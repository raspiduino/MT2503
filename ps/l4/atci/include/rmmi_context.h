/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * rmmi_context.h
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ï¿½K.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#ifndef _RMMI_CONTEXT_H
#define _RMMI_CONTEXT_H

//#include "Kal_release.h"        /* in dir. Kal */

//#include "stacklib.h"
//#include "event_shed.h"
//#include "fat_fs.h"     //BT_DEBUG

//#include "rmmi_gati.h" 
#include "l4c_common_enum.h"


#include "ps2sat_struct.h"
//#include "l4c2phb_enums.h"
#include "mcd_l4_common.h"

//#include "l3_inc_enums.h"
#include "as2l4c_struct.h"
#include "rmmi_common_enum.h"
//#include "kal_non_specific_general_types.h"
#include "fs_type.h"

#include "kal_general_types.h"
#include "cmux_vp_num.h"
#include "ps_public_enum.h"
#include "kal_public_api.h"

#include "l4c2phb_struct.h"
#include "l4c_aux_struct.h"

#include "med_struct.h"

#include "sim_public_enum.h"
#ifdef __GPS_AT_SUPPORT__
#include "gps_struct.h"
#endif
/* CONSTANTS */

#define NULL_TERM '\0'  /* string termination */
#define INVALID_ENUM 255        /* invalid enum value */

#define RMMI_PTR     rmmi_ptr_g
#define RMMI_COMM_PTR rmmi_common_ptr_g

#define rmmi_skip_spaces(source_string_ptr)                                  \
      while( source_string_ptr->string_ptr[ source_string_ptr->index ]       \
                                 == RMMI_SPACE )                             \
      {                                                                      \
        source_string_ptr->index++;                                          \
      }
//030617 mtk00468 add for skip unused character before character a 
#define rmmi_skip_none_a(source_string_ptr, length)                                                                                \
      while( (source_string_ptr->index < length) && !((source_string_ptr->string_ptr[ source_string_ptr->index ] == RMMI_CHAR_A) ||\
             (source_string_ptr->string_ptr[ source_string_ptr->index ] == rmmi_char_a)) )                                         \
      {                                                                                                                            \
        source_string_ptr->index++;                                                                                                \
      }

#define RMMI_IS_LOWER( alpha_char )   \
  ( ( (alpha_char >= rmmi_char_a) && (alpha_char <= rmmi_char_z) ) ?  1 : 0 )

#define RMMI_IS_UPPER( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_A) && (alpha_char <= RMMI_CHAR_Z) ) ? 1 : 0 )

#define RMMI_IS_HEX_ALPHA( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_A) && (alpha_char <= RMMI_CHAR_F) ) ? 1 : 0 )

#define RMMI_IS_NUMBER( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_0) && (alpha_char <= RMMI_CHAR_9) ) ? 1 : 0 )

#define RMMI_IS_ALPHA( alpha_char )   \
   ( ( RMMI_IS_UPPER(alpha_char) || RMMI_IS_LOWER(alpha_char) ) ? 1 : 0 )

#define RMMI_IS_SYMBOL( alpha_char )                                          \
   ( ( (alpha_char == RMMI_CHAR_PLUS) || (alpha_char == RMMI_CHAR_STAR) ||    \
       (alpha_char == RMMI_CHAR_POUND) || (alpha_char == RMMI_COMMA) ||       \
       (alpha_char == RMMI_CHAR_DOT) || (alpha_char == RMMI_FORWARD_SLASH) || \
       (alpha_char == RMMI_COLON) || (alpha_char == RMMI_HAT) ||              \
       (alpha_char == RMMI_CHAR_MINUS) ||                                     \
       (alpha_char == RMMI_L_SQ_BRACKET) ||                                   \
       (alpha_char == RMMI_R_SQ_BRACKET) ||                                   \
       (alpha_char == RMMI_L_ANGLE_BRACKET) ||                                \
        (alpha_char == RMMI_CHAR_ULINE) ||                                    \
         (alpha_char == RMMI_SPACE) ||                                        \
           (alpha_char == RMMI_SEMICOLON) ||                                  \
       (alpha_char == RMMI_R_ANGLE_BRACKET)                                   \
     ) ? 1 : 0 )

#define RMMI_IS_EXT_CHAR( alpha_char )                                                  \
   ( ( (alpha_char == RMMI_HAT) || (alpha_char == RMMI_CHAR_TILDE) ||                   \
   (alpha_char == RMMI_L_SQ_BRACKET) || (alpha_char == RMMI_R_SQ_BRACKET) ||            \
   (alpha_char == RMMI_L_CURLY_BRACKET) || (alpha_char == RMMI_R_CURLY_BRACKET) ||      \
   (alpha_char == RMMI_CHAR_REVERSE_SOLIDUS) ||(alpha_char == RMMI_CHAR_VERTICAL_LINE)  \
   ) ? 1 : 0 )

//#if !defined(__MTK_TARGET__) && defined(__RMMI_UT__)
//#define RMMI_UART_GetOwnerID(port) rmmi_current_mod_id
//#endif


typedef kal_bool(*UART_TRANS_FUNC_PTR) (kal_uint8);

typedef kal_uint32  RMMI_UART_FLAG;

#ifdef __GAS_SUPPORT__
#define  GAS_MAX_MODULE_COUNT   2

/* Structure */
typedef struct
{
    module_type mod_id;         /* The module id which uses this interface. */
} gas_mod_src_struct;

#endif  /*__GAS_SUPPORT__*/


typedef struct rmmi_report_mode_struct
{
    kal_uint32 einfo;         /* proprietary +ECPI: call progress information */	
    kal_uint32 ecpi;         /* proprietary +ECPI: call progress information */
    kal_uint32 eind;         /* proprietary +EIND: general indication */
    kal_uint8 ccm;          /* rmmi_report_mode_enum */
    kal_uint8 acm_warning;  /* rmmi_report_mode_enum */
    kal_uint8 call_wait;    /* rmmi_report_mode_enum */
    kal_uint8 cdip;         /* rmmi_report_mode_enum */
    kal_uint8 clip;         /* rmmi_report_mode_enum */
    kal_uint8 clir;         /* rmmi_report_mode_enum */
    kal_uint8 cnap;         /* rmmi_report_mode_enum */
    kal_uint8 colp;         /* rmmi_report_mode_enum */
    kal_uint8 ss_mo;        /* rmmi_report_mode_enum */
    kal_uint8 ss_mt;        /* rmmi_report_mode_enum */
    kal_uint8 ussd;         /* rmmi_report_mode_enum */
    kal_uint8 compression;  /* rmmi_report_mode_enum */
    kal_uint8 ps_reg;       /* rmmi_nw_reg_report_mode_enum */
    kal_uint8 cs_reg;       /* rmmi_nw_reg_report_mode_enum */
    kal_uint8 timezone;     /* rmmi_report_mode_enum */
    kal_uint8 crc;          /* rmmi_report_mode_enum, for +CRC */
    kal_uint8 cr;           /* rmmi_report_mode_enum, for +CR */
    kal_uint8 ecsq;
    kal_uint8 ecsq_count;
    kal_uint8 cgerep;
    kal_uint8 cmer_mode;
    kal_uint8 cmer_keyp;
    kal_uint8 cmer_ind;
    kal_uint8 cmer_bfr;
#if defined(__MMI_FMI__)
    kal_uint8 cmer_tscrn;
#else
    kal_uint8 esims;
#endif
    /* Bit 0(SMS ready), Bit 1(PHB ready), Bit 7(AT ready), others reserved */
} rmmi_report_mode_struct;

#ifdef __OP01__
typedef struct rmmi_op01_report_mode_struct
{
    kal_uint8 dsci;
    kal_uint8 rfsw;
    kal_uint8 cardmode;
} rmmi_op01_report_mode_struct;
#endif

typedef struct rmmi_rsp_mode_struct
{
    kal_uint32 echo_flag;        /* rmmi_cmd_echo_enum */
    kal_uint8 suppress_flag;    /* rmmi_result_code_suppress_enum */
    kal_uint8 format;           /* rmmi_result_code_format */
    kal_uint8 ext_result_code;
} rmmi_rsp_mode_struct;

typedef struct rmmi_single_cmd_struct
{
    kal_uint16 cmd_code;    /* rmmi_extended_cmd_id_enum */
    kal_uint8 cmd_mode;     /* rmmi_cmd_mode_enum */
} rmmi_single_cmd_struct;

typedef struct basic_cmd_struct
{
    kal_uint8 cmd_code; /* rmmi_basic_cmd_id_enum */
    kal_uint8 cmd_mode; /* rmmi_cmd_mode_enum */

    kal_bool is_this_node_used;
    kal_uint8 value;

    struct basic_cmd_struct *next_ptr;
} rmmi_multiple_basic_cmd_struct;

typedef struct rmmi_cmd_struct
{
    kal_uint8 which_present;    /* rmmi_cmd_type_enum */

    rmmi_single_cmd_struct single_cmd;
    rmmi_multiple_basic_cmd_struct multiple_cmd;        //not used now
} rmmi_cmd_struct;

typedef struct
{
    kal_uint8 s0;   /* auto answer */
    kal_uint8 s2;   /* escape character (+++) */
    kal_uint8 s3;   /* CR */
    kal_uint8 s4;   /* LF */
    kal_uint8 s5;   /* backspace */
    kal_uint8 s6;   /* pause before dialing */
    kal_uint8 s7;   /* connect timeout */
    kal_uint8 s8;   /* , pause time */
    kal_uint8 s10;  /* disconnect timeout */
    kal_uint8 s32;  /* XON character */
    kal_uint8 s33;  /* XOFF character */
    kal_uint8 s95;

} rmmi_s_register_struct;

typedef struct uart_queue_struct
{
    kal_uint16 head;
    kal_uint16 length;
    kal_uint8 data[MAX_DATA_QUEUE_LENGTH];

} rmmi_uart_queue_struct;

typedef struct
{
    kal_uint16 head;
    kal_uint16 length;
    kal_uint8 data[MAX_DATA_QUEUE_LENGTH];

} rmmi_uart_output_queue_struct;

typedef struct
{

    kal_bool sat_in_menu;
    kal_bool sat_in_process;
    kal_bool sat_normal_standby;
    kal_bool sat_ready;
    kal_uint8 sat_input_type;
    kal_uint8 sat_input_reveal;
    kal_uint8 sat_input_min_len;
    kal_uint8 sat_input_max_len;
    kal_bool sat_redial;
    kal_bool sat_redial_count;
    kal_uint32 sat_duration;

} rmmi_SAT_info_struct;

typedef struct rmmi_cind_struct
{
    kal_uint8 battchg;
    kal_uint8 signal;
    kal_uint8 service;
    kal_uint8 message;
    kal_uint8 call;
    kal_uint8 roam;
    kal_uint8 smsfull;
    kal_uint8 callsetup;
    kal_uint8 callheld; //for BT HF 1.5
} rmmi_cind_struct;

typedef struct rmmi_reg_state_struct
{
    kal_uint32 cell_id; // for +CREG, +CGREG, high 16 bits for RNC id, low 16 bits for cell_id
    kal_uint16 lac_value;       // for +CREG, +CGREG
    kal_uint8 act;	// [MAUI_01360129]
    kal_uint8 gsm_state;        // for +CREG
    kal_uint8 gprs_state;       //for +CGREG
} rmmi_reg_state_struct;

/* init by l4cphb_start_cnf_hdlr */
typedef struct rmmi_phb_info_struct
{
    kal_uint8 sim_phb_len;      //max length of name in SIM EFadn
    kal_uint8 sim_fdn_len;      //max length of name in EFfdn    
    kal_uint8 msisdn_alpha_length; //max length of EFmsisdn    
    kal_uint8 sim_email_len;       // max length of email in EF_EMAIL
} rmmi_phb_info_struct;

typedef struct 
{
    l4c_phb_entry_struct entry;
    l4c_number_struct num[3];
    phb_email_struct email;
} rmmi_phb_cpbw_struct;

typedef struct rmmi_clip_info_struct
{
    kal_uint8 number[41];       //MAX_CC_ADDR_LEN
    kal_uint8 type;
    kal_uint8 subaddr[41];      //MAX_CC_ADDR_LEN
    kal_uint8 satype;
    kal_uint8 cli_validity;
} rmmi_clip_info_struct;

typedef struct rmmi_cbst_struct
{
    kal_uint8 speed;
    kal_uint8 name;
    kal_uint8 ce;
} rmmi_cbst_struct;

typedef struct rmmi_crlp_strnct
{
    kal_uint8 iws;
    kal_uint8 mws;
    kal_uint8 T1;
    kal_uint8 N2;
} rmmi_crlp_strnct;

typedef struct rmmi_profile_struct
{
    rmmi_s_register_struct s_reg;
    rmmi_cbst_struct rmmi_cbst;
    rmmi_crlp_strnct rmmi_crlp;
    kal_uint8 rmmi_ciwf;
    kal_uint8 rmmi_atv;
    kal_uint8 rmmi_ate;
    kal_uint8 rmmi_atq;
    kal_uint8 rmmi_atx;
    kal_uint8 rmmi_atw;
    kal_uint8 rmmi_atampC;
    kal_uint8 rmmi_atampD;
    kal_uint8 rmmi_atampS;/* Add for UART 8 wire */
    kal_uint8 rmmi_atampK;
} rmmi_profile_struct;

#if defined(__M2M_CSGT_SUPPORT__)
typedef struct rmmi_m2m_csgt_struct
{    
    kal_bool mode; //0: turn off greeting text, 1: trun on greeting text
    kal_uint8 text[UEM_MAX_GREETING_LEN+1];//greeting text, maximum of length is 30
} rmmi_m2m_csgt_struct;
#endif /* __M2M_CSGT_SUPPORT__ */
typedef struct
{
   kal_uint8	reason;
   kal_uint8	mode;
   kal_uint8	timer;
   kal_uint8    dest_buffer[50];           
   kal_uint8    sub_dest_buffer[50];
   kal_bool     sub_addr_flag;
} ccfc_req_param_struct; /* for remembering params of AT+CFCC */

typedef struct
{
   kal_uint8	mode;
} ccwa_req_param_struct; /* for remembering params of AT+CCWA */

typedef struct
{
   kal_uint8	reason;
   kal_uint8	mode;
   kal_uint8 passwd[9];
} clck_ss_req_param_struct; /* for remembering params of AT+CLCK */

typedef struct rmmi_transfer_struct
{
    module_type dest_mod; 
    UART_PORT port; 
} rmmi_transfer_struct;

#if defined(__GPS_AT_SUPPORT__) || defined(__GPS_ALL_IN_ONE_AT_SUPPORT__)
typedef struct
{
#ifdef __GPS_ADAPTOR_SUPPORT__
    kal_bool power_state;
    kal_bool gps_urc_state;  //0 turn off GPS URC, 1 turn on
    kal_uint32 tracking_period; // n seconds per time
    kal_uint16 gps_sentence_bit_map;
    kal_uint32 time_period;
    kal_uint32 gps_urc_counter;
    gps_type_enum gps_type;
    gps_start_mode_enum start_mode;   
    gps_set_param_enum param_type[GPS_CMD_SET_END-1];
    kal_uint32 api_value[GPS_CMD_SET_END-1];
 #endif
 #ifdef __GPS_ALL_IN_ONE_AT_SUPPORT__
    kal_bool gps_control_state;
    kal_bool gps_epo_state;
    kal_int32 gps_epo_data_account;
    kal_bool gps_time_sync_state;
    kal_int32 gps_time_sync_data_account;
 #endif
} rmmi_gps_context_struct;
#endif
#ifdef __BCM_AT_CMD__
#define RMMI_MAX_BT_SPP_PORT 3
#endif
typedef struct rmmi_common_context_struct
{
#ifdef __CMUX_SUPPORT__
    kal_uint8   physical_port;
    kal_bool    cmux_enable;
#endif /* __CMUX_SUPPORT__ */

#ifdef __BT_SUPPORT__
    kal_uint8 rmmi_hf_src;
    kal_bool hf_urc_report_flag;
#endif

    kal_bool cmd_from_tst;      //command is from Catcher

#if defined(__PHB_STORAGE_BY_MMI__)
    /***********************************************
    * It is more appropriate to use a structure to contain the info. 
    * for different PHB type. But, we only need to remember the info of ME PHB currently,
    * So we can do this in the future if needed.
    ************************************************/
    kal_uint16 phb_me_total;
    kal_uint16 phb_me_used;
    kal_uint16 phb_me_free;
    kal_uint16 phb_me_max_name_len;
    kal_uint16 phb_me_max_num_len;
    kal_uint16 phb_me_max_email_len;
#endif 


    RMMI_UART_FLAG isAtdAction_flag; /* mtk00714 20040412 : remember ATD this action after setup_cnf */
    RMMI_UART_FLAG isAtdAbort_flag;  /* mtk01616 070323 to know it's a Atd abort by any character  */

#if defined(__CMUX_MODEM_STATUS_SUPPORT__)	 
    RMMI_UART_FLAG isDSRAbort_flag;
#endif  

#ifdef SYNCML_DM_SUPPORT
    kal_bool lock_atci; 
#endif
#ifdef __GEMINI__
    rmmi_sim_uart_setting_enum sim_uart_setting;
    sim_interface_enum rmmi_uart_owner[RMMI_MAX_CHANNEL_NUMBER];
#endif
    RMMI_UART_FLAG uart_plugout;
    RMMI_UART_FLAG uart_stop_send_flag;
    RMMI_UART_FLAG is_multi_cmd;
    RMMI_UART_FLAG multi_cmd_error;  // this flag using to verify if error occur , we should abort command processor
    RMMI_UART_FLAG is_sms_cmd;       //using to cehck string is sms command and send " > " to DTE

    kal_uint8 source[RMMI_MAX_CHANNEL_NUMBER]; 
    kal_uint8 port[RMMI_MAX_CHANNEL_NUMBER]; 
    kal_uint8 uart_port_value; /* this value store the default value form NVRAM */    
    rmmi_transfer_struct transfer; 


    rmmi_uart_queue_struct uart_input_queue[RMMI_MAX_CHANNEL_NUMBER];
    rmmi_uart_queue_struct uart_output_queue[RMMI_MAX_CHANNEL_NUMBER];
    kal_uint8 multi_cmd_string[RMMI_MAX_CHANNEL_NUMBER][MAX_MULTIPLE_CMD_INFO_LEN];

#ifdef __TC01__    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 

#if defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__)
    kal_uint8 etstlp_port[2]; //for tst_port_ps and tst_port_l1
#endif
#ifdef __BCM_AT_CMD__
    kal_uint8 bt_spp_port[RMMI_MAX_BT_SPP_PORT];
    kal_uint8 bt_spp_srcid[RMMI_MAX_BT_SPP_PORT];
#endif
} rmmi_common_context_struct;

typedef struct rmmi_context_struct
{
/*************************************************************************/
/* Below context are placed in the front of RMMI context                 */
/* to increase immediate offset access , to reduce ROM size              */
/* Please KEEP the position for the following frequent used variables    */
/*************************************************************************/
    kal_uint8 current_src;
    kal_uint8 char_set; //+CSCS
    rmmi_phb_type_enum phb_storage_type;  
    kal_bool is_ucm_action;        
    kal_uint16 cmee_err;        // error value for +CME:<err>
    kal_bool uart_in_data_mode;
    kal_uint8 online_cmd_state;


    kal_uint8 response_type;

    kal_bool ats0_auto_answer;  //mtk01616_070707 add this to prevent print OK for auto answer 
#ifdef __UCM_SUPPORT__
    kal_bool is_ata_action;     //mtk01616_070707 add this to handle ATA result code
    kal_bool is_compound_action; //MAUI_02016224
#endif

    /* use to check if sim verified */
    kal_bool command_allow;     // using to keep if password required, only some AT command can access when pin puk or ph_sim pending
    kal_uint16 cmd_error_cause; // SMU saves command not allow cause for +cme error value to TA 
    
    rmmi_s_register_struct s_reg;
    void *arg_list[RMMI_MAX_ARG_NUM];

    rmmi_rsp_mode_struct rsp_mode;
    rmmi_cind_struct indicators;        // for +CIND and +CMER 
    rmmi_report_mode_struct report_mode;
    rmmi_reg_state_struct register_status;      //registration status for +CREG, +CGREG
    

/***********************************************************************/
/* Above context are placed in the front of L4C context                */
/* to increase immediate offset access , to reduce ROM size            */
/* Please try to KEEP the position for these frequent used variables   */
/***********************************************************************/

    /* settings */
    kal_uint8 em_enable;        //mtk00468 add for using to keep the em enable or disable engineer mode information
    kal_uint8 date_aux_mode;    // this variable using for +CSDF to keep in local
    kal_uint8 cring_type;       //mtk00714 add for +CRC (remember cring_type for rmmi_ring_repeat_hdlr)
    kal_uint8 error_report_mode;        //  /* +CMEE <mode>: rmmi_error_report_mode_enum */
    kal_uint8 plmn_format;
    kal_uint8 cops_mode;
    kal_uint8 CPOL_plmn_format;
    kal_uint8 smsal_bfr;                    /* +CNMI : <bfr> */
    kal_uint8 CNMI_mode;        // +CNMI: <mode>: result code mode 
    //kal_uint16 max_plmn_list_len;       //+CPOL ?
    kal_bool cb_mode;
    kal_bool csdh_show; //mtk00714: for +CSDH , hide/show detail Text mode parameters.
    kal_bool clae_mode; // we save clae mode in rmmi context
    kal_bool cmut_mode; // we save clae mode in rmmi context
    kal_uint8 preferred_lang;
    kal_uint8 ring_count;       // for ATS0
    rmmi_phb_info_struct phb_info;
    rmmi_clip_info_struct clip_info;
    kal_uint8 casp_soundID;     //for +CASP proprietary command , timeout hdlr parameter.
    //kal_bool is_gprs_data_dialing;  /* ATH is not allowed to hangup existed voice call after dialup failed */ //mtk02285, 201003, 6251_ram
#ifdef __MOD_TCM__
    kal_uint8 cgatt_last_action;    /* mtk00714 20040611 add to avoid continuos at+cgatt=0 or at+cgatt=1 */
#endif //mtk02285, 201003, 6251_ram
    kal_uint16 cpbr_range[2];
    kal_uint16 phb_del_index;
    kal_uint8 phb_del_storage;
    kal_uint8 cpbr_ln_base_index; 
    #ifdef __OP01__
    kal_uint8 scpbr_num_index;   
    kal_uint8 scpbr_entry_found;
    l4_name_struct scpbr_alphaId;
    rmmi_phb_cpbw_struct *scpbw_entry_ptr;
    rmmi_op01_report_mode_struct op01_report_mode;
    #endif

    kal_bool is_cpbw_phb_fdn; 
#if defined(__AT_EPBW_SUPPORT__)
    kal_bool phb_is_epbw;
#endif
	l4c_source_id_enum online_cmd_state_src_id; //MAUI_01652672, mtk02285, 20090324

#ifdef __IRDA_SUPPORT__
    //kal_uint8 ppp_nsapi; //mtk02285, 201003, 6251_ram
#endif 

#ifdef __RSAT__
    kal_bool sat_icon_displayed;        //mtk00924: display icon for STK SMS, SS, USSD, DTMF
#endif /* __RSAT__ */ 


    kal_uint8 except_src;       //for unsolicited code, but don't send it to this src. ex. MT data call, don't send RING to bt hs
    kal_uint8 imei_action;      //rmmi_imei_action_enum
    kal_bool invalid_sim;       //mtk00924 2005_0418 : when sim invalid there are some cmd not allowed
    kal_uint8 rmmi_atd_mem;      //mtk01616_090116 :rmmi_mem_dial_enum
    #if defined(__MMI_FMI__)    
    kal_bool MMI_string_enable;
    kal_bool screenshot_pending;
    FS_HANDLE screenshot_fd;
    kal_uint16 screenshot_index;
    #endif
    kal_uint16 action_cmd;      //rmmi_extended_cmd_id_enum
    kal_uint8 ws46;
#ifdef __BT_SUPPORT__
    kal_uint8 last_reported_ciev_signal; //hong_rx_level
    kal_bool send_ciev_callheld; //mtk01616_090923: explictly to send +CIEV:<callheld> even the status is not changed
#endif
    kal_uint8 ath_for_dialup;   //mtk01616_080923: ATH is for dialup failure, we use this to  prevent ATH to disconnect call
    kal_uint8 last_number_dialed[MAX_CC_ADDR_LEN];//atdL last number dialed 

#if 0 //__CTM_SUPPORT__
/* under construction !*/
#endif 

    kal_uint8 em_volume_level;
    kal_uint8 em_volume_type;
    kal_uint8 em_audio_type;
    kal_uint8 em_audio_gain;
    kal_uint8 em_audio_mode;
    kal_uint8 em_eadp_action;

    /* Context for AT+EAPS */
    kal_uint8 eaps_action;
    kal_uint8 eaps_para1;
    kal_uint8 eaps_para2;
    kal_uint8 eaps_para3;
    void* eaps_audio_param;

#ifdef __VOIP__
    kal_bool cm_cmd_approve;    //Send Call Management command to MMI to get approval 
    void *string_ptr;
    void *node_ptr;
    void *id;
#endif /* __VOIP__ */ 
#if !defined(__MMI_FMI__)
    kal_uint8 poweroff_src_id;
    kal_uint8 is_spn_valid;
    kal_uint8 spn[17];
#endif 

    kal_uint32 eind_ready_flag;
    kal_uint8 vgr_gain;
    kal_uint8 vgt_gain;

    kal_uint16 last_executed_P2_fail; //[MAUI_01292349] mtk02480l 27.007: +CPIN? return  PIN2/PUK2 if previous command execured authentication failure, i.e. cmee_err= 17/18    	

#if defined(__MODEM_EM_MODE__)
    kal_uint8 em_src_id;  // used to remember EM request src_id
#endif 

#if defined(__ENABLE_MYBCCH__)
    kal_uint8 mybcch_src_id;
#endif

    #ifdef __GATI_ENABLE__
    gati_mod_src_struct gati_mod_src_table[GATI_MAX_MODULE_COUNT];	/* The table which record the relation of module to src_id and its control status */
    kal_uint8 gati_binary_mode_module[MAX_SOURCE_NUM];	/* The module id that active the binary mode for specific source id */
    kal_uint32 gati_stop_read_data_from_uart;						/* The bit map to specify which src_id is now stop receiving data from the UART */
    kal_uint32 gati_pending_rtr_ind;								/* The bit map to specify if there are rtr indication from the UART during the ATCI stop receiving data from the UART */
    gati_buffer_struct	gati_buffer;										/* The buffer will be used when the mode is in the binary mode and there is some data from other module which does not active the binary mode. */
    kal_uint8 gati_buffer_count;
    /* The following variables are temp ones used to transmit informations between functions */
    kal_bool	gati_write_allow_flag;					/* This flag is used to allow the writing action for the owner of the binary mode */
    kal_uint16 gati_actual_write;						/* This variable is used to get the actual write size to the output queue in the rmmi_uart_write_data */
    kal_uint8 gati_data_type;							/* This variable is used to know if the data type is integrity or not */
    #endif 

#ifdef __GAS_SUPPORT__
    gas_mod_src_struct gas_mod_src_table[GAS_MAX_MODULE_COUNT];
#endif 

#ifdef __SMS_STORAGE_BY_MMI__
    kal_uint8 usm_src_id;
#endif
#if defined(__SMS_STORAGE_BY_MMI__) 
    kal_bool cpms_query;
    kal_bool cpms_set;
    kal_uint8 esmss_mode;
#endif

#ifdef __AT_EPBUM_SUPPORT__
    kal_uint8 phb_anr_occurrence;
    kal_uint8 phb_email_occurrence;
    kal_uint8 phb_sne_occurrence;
    kal_uint8 phb_anr_length;
    kal_uint8 phb_email_length;
    kal_uint8 phb_sne_length;
    kal_uint8 phb_grp_length;
#endif 

#if defined(__CLOG_STORAGE_BY_MMI__)
    kal_uint8 phb_ln_total[PHB_LN_MAX];
    kal_uint8 phb_ln_used[PHB_LN_MAX];
    kal_uint8 phb_ln_free[PHB_LN_MAX];
#endif

#if defined(__SMS_STORAGE_BY_MMI__) && !defined(WISDOM_MMI) 
    kal_uint8 cmss_da_tag;
    l4_addr_bcd_struct cmss_da;
#endif 

    kal_uint8 cmec_keyp; 
    kal_uint8 cmec_disp;
    kal_uint8 cmec_ind;

#if defined(__NBR_CELL_INFO__)
    l4c_nbr_cell_info_ind_struct nbr_info;
#endif

    kal_uint8 is_emgr; 
#if defined(PLUTO_MMI) && (defined(__OP11_ATK__) || defined(__AUTO_ATK__))
    kal_uint8 *appName;
    kal_uint16 appName_len;
#endif

   kal_uint8   ccfc_combi_classx; //original <classx> given by AT+CFCC 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   ccfc_current_class; //the class of current req 
   ccfc_req_param_struct ccfc_req_param;  //stores other req parameter information
   kal_bool	ccfc_result;

#if !defined(__SLIM_AT__) 
   kal_uint8   clck_ss_combi_classx; //original <classx> given by AT+CLCK 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   clck_ss_current_class; //the class of current req 
   clck_ss_req_param_struct clck_ss_req_param;  //stores other req parameter information
   kal_bool	clck_ss_result;
   smu_security_type_enum clck_sml_type; //for at+clck to query SML status
#endif

   kal_uint8   ccwa_combi_classx; //original <classx> given by AT+CCWA 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   ccwa_current_class; //the class of current req 
   ccwa_req_param_struct ccwa_req_param;  //stores other req parameter information
   kal_bool	ccwa_result;
   kal_uint8 cvhu_mode; //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH

#if !defined(__ULC_AT__)
    rmmi_profile_struct rmmi_default_profile;
    rmmi_profile_struct rmmi_user_profile;
    rmmi_profile_struct rmmi_current_profile;
#endif 	

    rmmi_uart_queue_struct CNMI_ResultCodeBuffer;       //for +CNMI, SMSAL_ONE_MSG_LEN = 160
    kal_uint8 cmd_mode;
#ifndef __MMI_FMI__ 
    kal_uint8 cpbf_findtext[30];
#endif

#ifdef __SAT__
#ifdef __SATCB__
    rmmi_uart_queue_struct sat_output_queue;    //mtk00714 add for SAT using
    kal_bool IsSATcommand;      //check if SATCommand 
    kal_bool IsSATresponse;     //use to check if SAT response
    void *SAT_rsp_ptr;
#endif	
#endif /* __SAT__ */ 

#ifdef __CMUX_SUPPORT__
    kal_uint8 rmmi_data_channel_src;
    kal_uint8 rmmi_urc_channel_src;
#endif 

#if defined(__AT_IPR_WRITE_FS_SUPPORT__)
   kal_uint32 atipr_rate;
#endif

#ifdef __MODEM_CARD__
    kal_uint8 csp_plmn_mode;
#endif
#if defined(__MESSAGE_BASED_AT_SUPPORT__) 
    kal_bool msg_based_at_enable;
#endif

    kal_uint8 ats0_src_id; //MAUI_02743662 for saving ATS0 auto answer source id

    kal_uint8 cpls_selected;

#if defined(__DUAL_TALK_MODEM_SUPPORT__)
    kal_bool wake_up_ap;
#endif

#if defined(__PLMN_LIST_WITH_CELL_INFO__)
#ifndef __DISABLE_CUSTOM_POSI_STRING__
    kal_uint8 posi_string[34];
#endif
    kal_bool  is_posi_action;
    kal_uint8 atiposi_src_id;
#endif

    kal_bool skip_cust_at_rsp_response;   /* bypass custom_at_response_result_generator if true */
    kal_bool force_cust_at_rsp_reponse;

#if defined(__GPS_AT_SUPPORT__) || defined(__GPS_ALL_IN_ONE_AT_SUPPORT__)
    rmmi_gps_context_struct rmmi_gps_context;
#endif
    kal_uint8 atcpwc_src_id;
#if defined(__JAMMING_DETECTION__)
    kal_uint8 em_rrm_feature_cmd_status;
#endif /*__JAMMING_DETECTION__ */
    kal_bool deactivate_all;
    kal_uint8 cid_num;
#ifdef __UICC_CHANNEL_SUPPORT__
    kal_uint32 is_crla;
#endif /* __UICC_CHANNEL_SUPPORT__ */
#ifdef __DISCONNECT_PS_CALLS_FOR_ATH__
    kal_bool no_response;
    kal_uint8 ath_src_id;
#endif /* __DISCONNECT_PS_CALLS_FOR_ATH__ */
} rmmi_context_struct;

typedef struct rmmi_string_struct
{
    kal_uint16 index;
    kal_uint8 *string_ptr;
    kal_uint8 *ip_string;
    l4c_source_id_enum src_id;  // DEREK
    kal_uint8 cmd_mode;
    kal_uint8 cmd_class;  
    kal_uint16 cmd_index;       //rmmi_extended_cmd_id_enum
    kal_uint16 cmd_row_index;    
    rmmi_extend_symbol_hash_enum symbol_hash;
} rmmi_string_struct;

#ifdef __SAT__

typedef enum
{
    RMMI_TIM_MOD_NONE,
    RMMI_TIM_MOD_SAT_DSPL_TEXT,
    RMMI_TIM_MOD_SAT_PLAY_TONE,
    RMMI_TIM_MOD_SAT_REDIAL,
    RMMI_TIM_MOD_SAT_NOTICE,
    RMMI_TIM_MOD_SAT_MMI_INFO,
    RMMI_NUM_OF_TIMER_MOD
}
rmmi_timer_mod_enum;

typedef struct
{
    eventid timer_id;
    kal_uint8 time;
    kal_bool timer_on;
} rmmi_sat_timer_struct;

/* SAT */
#define SAT_SIG_SETUP_MENU_SHOW          70
#define SAT_SIG_SELECT_ITEM_SHOW          71
#define SAT_SIG_DSPL_TXT_SHOW             72
#define SAT_SIG_GET_INKEY_SHOW            73
#define SAT_SIG_GET_INPUT_SHOW            74
#define SAT_SIG_PLAY_TONE_SHOW            75
#define SAT_SIG_SETUP_CALL_SHOW           76
//#define SAT_SIG_SETUP_CALL_REQ_SHOW      77
//#define SAT_SIG_SETUP_CALL_RES_SHOW      78
//#define SAT_SIG_REDIAL_SHOW                79
#define SAT_SIG_SEND_SMS_SHOW            80
#define SAT_SIG_SEND_SS_SHOW              81
#define SAT_SIG_SEND_USSD_SHOW           82
#define SAT_SIG_MMI_INFO_SHOW             83
//#define SAT_SIG_NOTICE_SHOW                85

#define RMMI_SAT_SIG_SETUP_CALL_REQ          16
#define RMMI_SAT_SIG_SEND_SS_REQ             17
#define RMMI_SAT_SIG_SEND_USSD_REQ           18
#define RMMI_SAT_SIG_SEND_SMS_REQ            19
#define RMMI_SAT_SIG_PLAY_TONE_RES           32
#define RMMI_SAT_SIG_DSPL_TEXT_RES           33
#define RMMI_SAT_SIG_GET_INKEY_RES           34
#define RMMI_SAT_SIG_GET_INPUT_RES           35
#define RMMI_SAT_SIG_SELECT_ITEM_RES         36
#define RMMI_SAT_SIG_MENU_SELECT_REQ         37
#define RMMI_SAT_SIG_START_SAT               80
#define RMMI_SAT_SIG_SETUP_CALL_REDIAL       88

typedef struct
{
    kal_uint8 item_len;
    kal_uint8 item_dcs;
    kal_uint8 item_id;
    kal_uint8 *item_data;
}
rmmi_sat_menu_item_struct;

typedef struct
{
    kal_uint8 is_help_info_available;
    kal_uint8 cmd_detail[5];
    kal_uint8 alpha_id_len;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 num_of_item;
    rmmi_sat_menu_item_struct *menu_items;
}
rmmi_sat_main_menu_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 is_item_id_available;
    kal_uint8 item_id;
    kal_uint8 alpha_id_len;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 num_of_item;
    rmmi_sat_menu_item_struct *menu_items;
}
rmmi_sat_sub_menu_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 priority;
    kal_uint8 clear_text_type;
    kal_uint8 immediate_res;
    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
}
rmmi_sat_dspl_text_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 type_of_input;
    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
}
rmmi_sat_get_inkey_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 type_of_input;
    kal_uint8 is_input_revealed_to_user;
    kal_uint8 len_of_min_input;
    kal_uint8 len_of_max_input;

    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
    kal_uint16 no_default_text;
    kal_uint8 *default_text;
    kal_uint8 dcs_of_default_text;
}
rmmi_sat_get_input_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 tone_id;
    kal_uint32 duration;
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;

}
rmmi_sat_play_tone_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 mmi_info_type;
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
}
rmmi_sat_mmi_info_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 condition;
    kal_uint32 duration;

    kal_uint8 no_alpha_id1;
    kal_uint8 *alpha_id1;
    kal_uint8 dcs_of_alpha_id1;
    kal_uint8 no_alpha_id2;
    kal_uint8 *alpha_id2;
    kal_uint8 dcs_of_alpha_id2;

    kal_uint8 size_of_ccp;
    kal_uint8 ccp[MAX_SAT_SIZE_OF_CCP];
    kal_uint8 size_of_subaddr;
    kal_uint8 subaddr[MAX_SIM_SUB_ADDR_BCD_LEN];	

    kal_uint8 no_addr;
    kal_uint8 *addr;
}
rmmi_sat_setup_call_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_sms_packed_required;
    kal_uint8 size_of_addr;
    kal_uint8 addr[MAX_SIM_ADDR_LEN];		//mtk02514_081216
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_sms_tpdu;
    kal_uint8 *sms_tpdu;
}
rmmi_sat_send_sms_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_ss_string;
    kal_uint8 *ss_string;
}
rmmi_sat_send_ss_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_ussd_string;
    kal_uint8 *ussd_string;
    kal_uint8 dcs_of_ussd_string;
}
rmmi_sat_send_ussd_struct;

/* TYPES */

typedef enum
{
    RMMI_VTS_SPEECH_IN = 0,
    RMMI_VTS_SPEECH_OUT = 1,
    RMMI_VTS_KEY_BEEP = 2,
    RMMI_VTS_DTMF_TONE = 3,
    RMMI_VTS_RINGER = 4,
    RMMI_VTS_MEDIA = 5,
    RMMI_NUM_OF_VTS_TYPE
}
rmmi_vts_type_enum;

typedef enum
{
    RMMI_VTS_PLAY_CRESCENDO = 0,    /* Play sound for crescendo. */
    RMMI_VTS_PLAY_INFINITE = 1,     /* Play sound for infinite. */
    RMMI_VTS_PLAY_ONCE = 2,         /* Play sound for once. */
    RMMI_VTS_PLAY_DESCENDO = 3,     /* Play sound for descendo. */
    RMMI_VTS_PLAY_OFF = 4,          /* stop sound */
    RMMI_NUM_OF_VTS_PLAY_MODE
}
rmmi_vts_play_mode_enum;

#endif /* __SAT__ */ 

typedef struct
{
    kal_uint8 err_string[RMMI_MAX_ERR_STR_LEN];
} rmmi_error_msg_struct;

//RMMI_UT ---
#define ATCI_MAX_UT_IO_LENGTH 1024

typedef struct
{
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    kal_uint8 src_id;
	kal_uint8 port;
    kal_uint8 string[ATCI_MAX_UT_IO_LENGTH];
	kal_bool stuff;
} atci_ut_rmmi_input_string_struct; // MSG_ID_ATCI_UT_RMMI_INPUT_STRING

typedef struct
{
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    kal_uint8 src_id;
	kal_uint8 port;
    kal_uint8 string[ATCI_MAX_UT_IO_LENGTH];
	kal_bool stuff;
} atci_ut_rmmi_output_string_struct; // MSG_ID_ATCI_UT_RMMI_OUTPUT_STRING
//--- RMMI_UT	

typedef void (*RMMI_EXT_CMD_FUNCTION) (rmmi_string_struct *source_string_ptr);

typedef kal_bool(*RMMI_BASIC_CMD_FUNCTION)
    (rmmi_string_struct *source_string_ptr, rmmi_multiple_basic_cmd_struct *head_node_ptr, rmmi_err_id_enum *err_id);

typedef void (*RMMI_IND_FUNCTION) ();

extern rmmi_context_struct *rmmi_ptr_g;
extern rmmi_common_context_struct *rmmi_common_ptr_g;
extern module_type rmmi_current_mod_id;
extern	rmmi_context_struct rmmi_cntxt_g[RMMI_MAX_SIM_NUM];
#if defined(__ATCMD_ONOFF_CHECK__)
extern kal_bool rmmi_check_at_enable;
#endif

#if defined(__DUAL_TALK_MODEM_SUPPORT__)
typedef struct
{
    kal_uint8 speech_mode;
    kal_uint8 rat_mode;
} rmmi_spc_espeech_param_struct;

typedef struct
{
    kal_uint8 sidetone;
} rmmi_spc_esstv_param_struct;

typedef struct
{
    kal_uint8 tone_id;
} rmmi_spc_edtp_param_struct;

typedef struct
{
    kal_uint8 esetdev_mode;
    kal_uint8 src_dev;
} rmmi_spc_esetdev_param_struct;

typedef struct
{
    kal_uint8 volume;
    kal_uint8 gain_id;
} rmmi_spc_esov_param_struct;

typedef struct
{
    kal_uint8 mic_volume;
} rmmi_spc_esmv_param_struct;

typedef struct
{
    kal_uint8 mode;
} rmmi_spc_essma_param_struct;

typedef union
{
    rmmi_spc_espeech_param_struct *espeech_param;
    rmmi_spc_esstv_param_struct *esstv_param;
    rmmi_spc_edtp_param_struct *edtp_param;
    rmmi_spc_esetdev_param_struct *esetdev_param;
    rmmi_spc_esov_param_struct *esov_param;
    rmmi_spc_esmv_param_struct *esmv_param;
    rmmi_spc_essma_param_struct *essma_param;
} rmmi_spc_param_union;
#endif /* __DUAL_TALK_MODEM_SUPPORT__ */

typedef struct l4c_minilog_struct
{
    kal_bool invalid_sim; 
    kal_bool mmrr_ready_flag;
    kal_bool auto_attach;
    kal_bool sub_modules_ready;
    kal_uint8  uart_port_value;
    kal_uint8 csm_state; 
    kal_uint8 cfun_state;
    kal_uint8 ps_conf_test_mode;
    smu_sim_status_enum sim_status;
#ifdef __GEMINI__
    kal_uint8  dual_sim_mode_setting;
#endif 
#ifdef __ECC_RETRY_ENHANCEMENT__ 
    kal_uint8 enhanced_ecc_id;
#endif 
#ifdef __SP_GEMINI_3G_SWITCH__
    kal_uint8 cur_3g_capability;
#endif  

#ifdef __MOD_TCM__
#if defined(__PS_DIALUP__)
    kal_uint16 ps_dialup_port[MAX_EXT_PDP_CONTEXT+1];
#endif
#if defined(__INT_PDP_CONTEXT_ON__)
#ifndef __APP_SECONDARY_PDP_SUPPORT__
    kal_uint8 pdp_context_id[MAX_INT_PDP_CONTEXT];
#else 
    kal_uint16 pdp_context_id[MAX_INT_PDP_CONTEXT];
#endif /* __APP_SECONDARY_PDP_SUPPORT__ */
#endif /* __INT_PDP_CONTEXT_ON__ */
#endif /* __MOD_TCM__ */

    //csmcc_mscap_struct mscap;
    UART_PORT ps_uart_port;
    kal_uint16 sim_error_cause;
    kal_uint32 ps_conf_test_profile;
    kal_uint32 flags; 
}l4c_minilog_struct;


#endif /* _RMMI_CONTEXT_H */


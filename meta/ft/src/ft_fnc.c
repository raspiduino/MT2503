/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
*  Modification Notice:
*  --------------------------
*  This software is modified by MediaTek Inc. and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*******************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *   ft_fnc_r.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Factory testing function library
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *              HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
/*************************************************************************
* Include Statements for KAL
 *************************************************************************/
#include "stack_common.h"
#include "stack_msgs.h"
#include "app_ltlcom.h"
#include "task_config.h"
#include "stack_ltlcom.h"

/*************************************************************************
* Include Statements for MAUI
 *************************************************************************/
/**************************************************************************
 * System Service header
 *************************************************************************/
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_public_defs.h"
#include "string.h"
#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "stack_config.h"
#include "init.h"
/**************************************************************************
 * HAL header
 *************************************************************************/
#include "dcl.h"
#include "drv_comm.h"
#include "l1audio.h"
// include the device.h for the GPIO_DEV_LED_KEY definition
// (Baseband tool LED, vibrator definitions)
#include "device.h"
#include "tst_hal_internal_wrapper_defs.h"
/**************************************************************************
 * FT header
 *************************************************************************/
#include "ft_msg.h"
#include "ft_public.h"
#include "ft_private.h"
#include "ft_fnc_cct.h"
#include "ft_fnc_misc.h"
#include "ft_fnc_l1rf.h"
#include "ft_fnc_wcdma.h"
/**************************************************************************
 * custom header
 *************************************************************************/
#include "meta_customize.h"
#include "custom_em.h"
#include "usb_custom.h"
#include "custom_equipment.h"
/**************************************************************************
 * L1 RF header
 *************************************************************************/
#include "mph_types.h"
#include "m12190.h"
#include "l1cal.h"
#include "l1d_cid.h"
#include "l1tst_public.h"
#include "l1_types_public.h"
/**************************************************************************
 * UL1 RF header
 *************************************************************************/
#if defined(__UMTS_RAT__) && defined(__MTK_UL1_FDD__)
/* under construction !*/
/* under construction !*/
#endif // #if defined(__UMTS_RAT__) && defined(__MTK_UL1_FDD__)
#include "fctycomp_config.h"
/**************************************************************************
 * NVRAM header
 *************************************************************************/
#include "nvram_data_items.h"
/**************************************************************************
 * audio (MED) header
 *************************************************************************/
#ifndef MED_NOT_PRESENT
#include "aud_defs.h"
#include "med_struct.h"
#endif // MED_NOT_PRESENT
#include "tst_def.h"
/**************************************************************************
 * Wifi header
 *************************************************************************/
#if defined(__WIFI_SUPPORT__)
extern void wndrv_cal_tx_ALC_power_2400M( wndrv_cal_tx_ALC_2400M_struct *tx_alc );
extern void wndrv_cal_ALC_Slope_2400M( wndrv_cal_ALC_Slope_2400M_struct *t);
extern kal_bool wndrv_chip_isOK(void);
extern kal_bool wndrv_get_ALC_enable( void );
#endif // #if defined(__WIFI_SUPPORT__)

kal_uint32 ft_event_group_ptr; /**< \brief ft event group pointer */
kal_bool  g_b_ft_assert_check_enable;
kal_bool  g_b_ver_Incorrect;
kal_uint8 g_u1_msg_recv_times = 0;  // will be reset to 0 in FT_TestAlive()

extern bool Drv_ReadReg(uint32 addr, uint16 *data);
extern bool Drv_WriteReg(uint32 addr, uint16 data);
extern void tst_log_primitive_without_filter_check(ilm_struct*,
        kal_uint8,
        kal_uint32);

extern void Media_SetMelodyFilter( uint16 len, const int16 *filter );

L1RF_DATA_T ft_rfDATA;
RuntimeUpdate_T ft_rf_data_pt;
/*******************************************************************************
 *
 *  Utility Functions
 *
 *******************************************************************************/
ilm_struct * _FT_ALLOC_MSG(kal_uint16 size, kal_bool  IsFtMsg)
{
    ilm_struct          *ilm_ptr = NULL;

    if( NULL == (ilm_ptr=allocate_ilm(MOD_FT)) ) {
        ASSERT(0); // assert it!
        //return NULL;
    }

    ilm_ptr->local_para_ptr = NULL;
    ilm_ptr->peer_buff_ptr = NULL;

    if( 0 < size ) {
        if( NULL == (ilm_ptr->local_para_ptr=construct_local_para(size, TD_CTRL)) ) {
            cancel_ilm(MOD_FT);
            ASSERT(0); // assert it!
            //return NULL;
        }
    }

    if( KAL_TRUE == IsFtMsg ) {
        // reset content of FT primitive first
        kal_mem_set(((char *)ilm_ptr->local_para_ptr)+sizeof(FT_H), 0, size-sizeof(FT_H));
    }

    return ilm_ptr;
}

void _FT_SendFtMsgByToken(module_type  src_mod, module_type  dest_mod, sap_type  sap, msg_type  msg, ilm_struct  *ilm_ptr, kal_uint16  token)
{
    ilm_ptr->src_mod_id  = src_mod;
    ilm_ptr->dest_mod_id = dest_mod;
    ilm_ptr->msg_id = msg;
    ilm_ptr->sap_id = sap;
    if (dest_mod == MOD_TST) {
        ((FT_H *)(ilm_ptr->local_para_ptr))->token=token;
        ilm_ptr->src_mod_id  = (module_type)0xA1;
        ilm_ptr->dest_mod_id = (module_type)0;
        ilm_ptr->sap_id      = (sap_type)0xA3;
        ilm_ptr->msg_id      = (msg_type)2;
        // directly copy primitive to TST ring buffer
        tst_log_primitive_without_filter_check(
                ilm_ptr,
                RS232_LOGGED_PRIMITIVE_TYPE,
                MSG_ID_LOGGED_PRIMITIVE);
        // cancel ilm, because we directly access TST ring buffer, no need to send primitive to TST
        cancel_ilm(MOD_FT);
        return;
    }

    // FT task does not have internal queue(can be replaced by external queue)
    //if(src_mod == dest_mod)
    //{
    //    msg_send_int_queue(ilm_ptr);
    //}
    //else
    {
        msg_send_ext_queue(ilm_ptr);
    }
}
/*******************************************************************************
 *
 *  FT Module Initialization Functions
 *
 *******************************************************************************/
/*******************************************************************************
 * FUNCTION
 *   FT_InitFtData
 *
 * DESCRIPTION
 *
 * CALLS
 *
 * PARAMETERS
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *******************************************************************************/
extern kal_int8 FT_FAT_Handle_Clear(void);
void FT_InitFtData()
{
    FT_FAT_Handle_Clear();
    FT_L1RfDataInit();
    //g_META_DLL_Version_Incorrect = KAL_FALSE;
    g_b_ver_Incorrect = KAL_FALSE;
    g_b_ft_assert_check_enable = KAL_FALSE; //default value: don't check!
    // activate in 3G proejcts (FDD/TDD)
#if defined(__UMTS_RAT__)
/* under construction !*/
#endif
    // init event group
    ft_event_group_ptr = (kal_uint32) kal_create_event_group("FtEvent");
}
/**
 * This function calls Dcl PMU interface to read PMIC register
 * @register_index the index of the register to be written
 */
kal_bool ft_pmic_reg_read(kal_uint16 *data, kal_uint16 register_index)
{
    kal_bool status;
    DCL_HANDLE handle;
    PMU_CTRL_MISC_GET_REGISTER_VALUE val;
    val.offset=register_index;
    handle=DclPMU_Open(DCL_PMU, FLAGS_NONE);
    if(DclPMU_Control(handle, MISC_GET_REGISTER_VALUE, (DCL_CTRL_DATA_T *)&val) != STATUS_OK)
    {
        // in this case, there might be not supported (if the driver did not support yet, usually in development phase)
        status = KAL_FALSE;
    }
    else
    {
        status = KAL_TRUE;
    }
    DclPMU_Close(handle);
    *data = val.value;
    return status;
}
/**
 * This function calls Dcl PMU interface to read PMIC register
 * @param data the register value to be written to PMIC
 * @param register_index the index of the register to be written
 */
kal_bool ft_pmic_reg_write(kal_uint16 data, kal_uint16 register_index)
{
    kal_bool status;
    DCL_HANDLE handle;
    PMU_CTRL_MISC_SET_REGISTER_VALUE val;
    val.offset=register_index;
    val.value=data;
    handle=DclPMU_Open(DCL_PMU, FLAGS_NONE);
    if(DclPMU_Control(handle, MISC_SET_REGISTER_VALUE, (DCL_CTRL_DATA_T *)&val) != STATUS_OK)
    {
        // in this case, there might be not supported (if the driver did not support yet, usually in development phase)
        status = KAL_FALSE;
    }
    else
    {
        status = KAL_TRUE;
    }
    DclPMU_Close(handle);
    return status;
}
/**
 * This function handles the PMIC register read operation
 * @param req FT task PMIC register read request
 * @param Regtype register type
 */
void FT_FtPMICRegisterRead(ft_PMICRegisterRead_req_T* req,unsigned char RegType) // for build warning
{
    ilm_struct* ptr_ilm;
    ft_PMICRegisterRead_cnf_T* ptrMsg;
    ptr_ilm = FT_ALLOC_MSG( sizeof(ft_PMICRegisterRead_cnf_T) );
    ptrMsg = (ft_PMICRegisterRead_cnf_T *)ptr_ilm->local_para_ptr;
    ptrMsg->status = KAL_FALSE;
    if(RegType ==FT_PMICReg)
    {
        ptrMsg->header.ft_msg_id = FT_PMIC_REG_READ_CNF_ID;
        /*
         * Note: The custom_pmic_reg_read interface is changed due to HAL,
         * the reference is changed to ft_pmic_reg_read
         */
        ptrMsg->status = ft_pmic_reg_read(&(ptrMsg->value), (kal_uint16)req->addr);
    }
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ptr_ilm);
}
/**
 * This function handles the PMIC register write operation
 * @param req FT task PMIC register write request
 * @param Regtype register type
 */
void FT_FtPMICRegisterWrite(ft_PMICRegisterWrite_req_T* req,unsigned char RegType)
{
    ilm_struct* ptr_ilm;
    ft_PMICRegisterWrite_cnf_T *ptrMsg ;
    ptr_ilm = FT_ALLOC_MSG( sizeof(ft_PMICRegisterWrite_cnf_T) );
    ptrMsg = (ft_PMICRegisterWrite_cnf_T *)ptr_ilm->local_para_ptr;
    ptrMsg->status = KAL_FALSE;
    if(RegType ==FT_PMICReg)
    {
        ptrMsg->header.ft_msg_id = FT_PMIC_REG_WRITE_CNF_ID;
        /*
         * Note: The custom_pmic_reg_write interface is changed due to HAL,
         * the reference is changed to ft_pmic_reg_write
         */
        ptrMsg->status = ft_pmic_reg_write(req->value, (kal_uint16)req->addr);
    }
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ptr_ilm);
}

/*******************************************************************************
 * FUNCTION
 *   FT_FtRegisterRead()
 *
 * DESCRIPTION
 *   Handle the request of reading Register Req
 *
 * CALLS
 *   Drv_ReadReg(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void FT_FtRegisterRead(ft_RegisterRead_req_T* req,unsigned char RegType)
{
    kal_uint8 status;
    ilm_struct* ptr_ilm;
    ft_RegisterRead_cnf_T* ptrMsg;

    ptr_ilm = FT_ALLOC_MSG( sizeof(ft_RegisterRead_cnf_T) );
    /* if ptrMsg != NULL*/
    ptrMsg = (ft_RegisterRead_cnf_T *)ptr_ilm->local_para_ptr;
    status = KAL_FALSE; // for build warning
    if(RegType ==FT_BaseBandReg)
    {
        ptrMsg->header.ft_msg_id = FT_REG_READ_CNF_ID;
        status=Drv_ReadReg(req->addr,&ptrMsg->value);
    }
    if(status==KAL_TRUE)
    { status=FT_CNF_OK; }
    else
    { status=FT_CNF_FAIL; }
    ptrMsg->status = status;
    /* FT_SEND_MSG(src_mod, dest_mod, sap_id, msg_id, ilm_ptr) */
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ptr_ilm);
}


/*******************************************************************************
 * FUNCTION
 *   FT_FtRegisterWrite()
 *
 * DESCRIPTION
 *   Handle the request of Writing Register Req
 *
 * CALLS
 *   Drv_WriteReg(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void FT_FtRegisterWrite(ft_RegisterWrite_req_T* req,unsigned char RegType)
{
    kal_uint8 status;
    ilm_struct* ptr_ilm;
    ft_RegisterWrite_cnf_T *ptrMsg ;
    ptr_ilm = FT_ALLOC_MSG( sizeof(ft_RegisterWrite_cnf_T) );

    status = KAL_FALSE; // for build warning

    /* if ptrMsg != NULL*/
    ptrMsg = (ft_RegisterWrite_cnf_T *)ptr_ilm->local_para_ptr;
    if(RegType ==FT_BaseBandReg)
    {
        ptrMsg->header.ft_msg_id = FT_REG_WRITE_CNF_ID;
        status=Drv_WriteReg(req->addr,req->value);
    }
    if(status==KAL_TRUE)
    { status=FT_CNF_OK; }
    else
    { status=FT_CNF_FAIL; }
    ptrMsg->status = status;
    /* FT_SEND_MSG(src_mod, dest_mod, sap_id, msg_id, ilm_ptr) */
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ptr_ilm);

}

/*******************************************************************************
 * FUNCTION
 *   FT_FtADC_GetMeaData()
 *
 * DESCRIPTION
 *   Handle the request of Getting MeaData
 *
 * CALLS
 *   ADC_GetData2Meta(.)
 *
 * PARAMETERS
 *   *req
 *
 * RETURNS
 *   None
 *
 * GLOBALS AFFECTED
 *   None
 *******************************************************************************/
void  FT_FtADC_GetMeaData(ft_FtADC_GetMeaData_req_T* req)
{
    //extern uint32 ADC_GetData2Meta(uint8 sel, uint16 meacount);
    ilm_struct* ptr_ilm;
    ft_FtADC_GetMeaData_cnf_T *ptrMsg ;
    ADC_CTRL_GET_DATA_2_META_T data2meta;
    DCL_HANDLE adc_handle;
    ptr_ilm = FT_ALLOC_MSG( sizeof(ft_FtADC_GetMeaData_cnf_T) );
    ptrMsg = (ft_FtADC_GetMeaData_cnf_T *)ptr_ilm->local_para_ptr;
    ASSERT(ptrMsg);
    ptrMsg->status=FT_CNF_OK;
    ptrMsg->header.ft_msg_id = FT_ADC_GETMEADATA_CNF_ID;
    adc_handle = DclHADC_Open(DCL_ADC, FLAGS_NONE);
    data2meta.u1Channel = req->Sel;
    data2meta.u2MeaCount = req->Meacount;
    if(DclHADC_Control(adc_handle, ADC_CMD_GET_DATA_2_META, (DCL_CTRL_DATA_T *)& data2meta) != STATUS_OK)
    {
        ptrMsg->status = FT_CNF_FAIL;
    }
    ptrMsg->value = data2meta.u4ADCData;
    if(DclHADC_Close(adc_handle) != STATUS_OK)
    {
        ptrMsg->status = FT_CNF_FAIL;
    }

    //ptrMsg->value =ADC_GetData2Meta(req->Sel,req->Meacount)  ;
    /* FT_SEND_MSG(src_mod, dest_mod, sap_id, msg_id, ilm_ptr) */
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ptr_ilm);

}
/*******************************************************************************
 *
 *  Version Info functionality
 *
 *******************************************************************************/
void FT_GetVersionInfo(void) {

    ilm_struct          *ilm_ptr;
    FT_VER_INFO_CNF     *ptrMsg;
    version_struct      ver_struct;

    ilm_ptr = FT_ALLOC_MSG(sizeof(FT_VER_INFO_CNF));

    // if ptrMsg != NULL
    ptrMsg = (FT_VER_INFO_CNF *)ilm_ptr->local_para_ptr;

    // assign primitive id
    ptrMsg->header.ft_msg_id = FT_VER_INFO_CNF_ID;

    // get version info
    INT_VersionNumbers(&ver_struct);

    // check
    if( NULL == ver_struct.bb_chip ) {
        ver_struct.bb_chip = "Unknown";
    }
    if( NULL == ver_struct.dsp_fw ) {
        ver_struct.dsp_fw = "Unknown";
    }
    if( NULL == ver_struct.dsp_ptch ) {
        ver_struct.dsp_ptch = "Unknown";
    }
    if( NULL == ver_struct.mcu_sw ) {
        ver_struct.mcu_sw = "Unknown";
    }
    if( NULL == ver_struct.bb_board ) {
        ver_struct.bb_board = "Unknown";
    }

    // assign BaseBand chip version string
    strcpy((kal_char *)ptrMsg->bb_chip, ver_struct.bb_chip);
    // assign ECO version
    kal_mem_set(ptrMsg->eco_ver, 0, 4);
    // assign DSP firmware version string
    strcpy((kal_char *)ptrMsg->dsp_fw, ver_struct.dsp_fw);
    // assign DSP patch version string
    strcpy((kal_char *)ptrMsg->dsp_patch, ver_struct.dsp_ptch);
    // assign S/W version string
    strcpy((kal_char *)ptrMsg->sw_ver, ver_struct.mcu_sw);
    // assign H/W version string
    strcpy((kal_char *)ptrMsg->hw_ver, ver_struct.bb_board);
    // assign Melody version string
    strcpy((kal_char *)ptrMsg->melody_ver, "Unknown");
    // FT_SEND_MSG(src_mod, dest_mod, sap_id, msg_id, ilm_ptr)
    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ilm_ptr);
}

/*******************************************************************************
 *
 *  FT task test alive
 *
 *******************************************************************************/
void FT_TestAlive(void) {

    FT_IS_ALIVE_CNF *pMsg;
    ilm_struct      *ilm_ptr;

    ilm_ptr = FT_ALLOC_MSG( sizeof(FT_IS_ALIVE_CNF));

    pMsg=(FT_IS_ALIVE_CNF *)ilm_ptr->local_para_ptr;
    pMsg->header.ft_msg_id = FT_IS_ALIVE_CNF_ID;

    g_u1_msg_recv_times = 0;

    FT_SEND_MSG(MOD_FT, MOD_TST, FT_TST_SAP, MSG_ID_FT_TO_TST, ilm_ptr);
}
/**
 * This api calls the DCL interface to check and clear the PDN1 bit 7 set by flashtool
 * and scrambles theh powerkey1
 */
static kal_bool FT_ClearPowerKey(void)
{
    /// Driver RTC FT Power Off request
    RTC_CTRL_FT_POWEROFF_T ft_cmd_data;
    DCL_HANDLE rtc_handle = DclRTC_Open(DCL_RTC, FLAGS_NONE);
    DclRTC_Control(rtc_handle, RTC_CMD_FT_POWEROFF, (DCL_CTRL_DATA_T *) &ft_cmd_data);
    DclRTC_Close(rtc_handle);
    return (kal_bool)ft_cmd_data.fgMetaReset;
}
/*******************************************************************************
 *
 * FUNCTION
 *   FT_PowerOff
 *
 * DESCRIPTION
 *   Power off sequence in META mode
 *
 * CALLS
 *   custom_ft_util_check_if_usb_enable_support for check the USB_ENABLE compile option
 *   USB_PowerControl
 *   DclRTC_Open/DclRTC_Control (RTC_CMD_FT_POWEROFF command)/DclRTC_Close for RTC power off sequence (scramble PDN1 bit 7 for flashtool entering META mode)
 *   DclPW_Open/DclPW_Control (PW_CMD_POWEROFF command)/DclPW_Close for Driver power off sequence
 *   DclWDT_Open/DclWDT_Control (WDT_CMD_DRV_RESET command)/DclWDT_Close for Driver reset sequence
 *
 * PARAMETERS
 *   void
 *
 * RETURNS
 *   void
 *
 * GLOBALS AFFECTED
 *   N/A
 *
 *******************************************************************************/
void FT_PowerOff(void)
{
#if (!defined(__SMART_PHONE_MODEM__))
    kal_bool toolUsbReset = KAL_FALSE;
    if(true == custom_ft_util_check_if_usb_enable_support())
    {
        // shutdown USB module
        USB_PowerControl(KAL_FALSE);
    }
    Custom_META_USBVirtualComDisconnect();
    // Turn off backlight
    custom_cfg_gpio_set_level(GPIO_DEV_LED_MAINLCD, LED_LIGHT_LEVEL0);    
    toolUsbReset = FT_ClearPowerKey();
    if(tst_hal_USBDL_Is_USB_Download_Mode() == KAL_TRUE ||
            /* Note: FEATURE compile option and references should be checked before patch-back */
            tst_hal_USBDL_Is_USB_Fast_Meta_Mode() == KAL_TRUE)
    {
        // Driver power off sequence
        {
            DCL_HANDLE dcl_pmu_handle;
            dcl_pmu_handle=DclPW_Open(DCL_PW, FLAGS_NONE);
            DclPW_Control(dcl_pmu_handle,PW_CMD_POWEROFF,NULL);
            DclPW_Close(dcl_pmu_handle);
        }
        // really turn off the target because USB will provide power automatically to target side
        if(toolUsbReset == KAL_FALSE)
        {
            DCL_HANDLE dcl_wdt_handle;
            dcl_wdt_handle = DclWDT_Open(DCL_WDT, FLAGS_NONE);
            DclWDT_Control(dcl_wdt_handle, WDT_CMD_DRV_RESET, FLAGS_NONE);
            DclWDT_Close(dcl_wdt_handle);
        }
        else
        {
            while(1);
        }
    }
#endif // #if (!defined(__SMART_PHONE_MODEM__))
}
/***********************************************
 * FT task self message API
 * This API is called in other task context
 * or HISR conext!
 **********************************************/
#pragma arm section code = "SECONDARY_ROCODE", rodata = "SECONDARY_RODATA"
void ft_send_in_proc_call_req(ft_in_proc_call_type func, kal_uint32 func_arg1, void *func_arg2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ilm_struct* ptr_ilm = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if( NULL == (ptr_ilm=allocate_ilm(kal_get_active_module_id())) )
    {
        ASSERT(0);
    }
    else
    {
        ptr_ilm->local_para_ptr = NULL;
        ptr_ilm->peer_buff_ptr = NULL;
        if( NULL == (ptr_ilm->local_para_ptr=construct_local_para(sizeof(ft_in_proc_call_req_struct), TD_CTRL)) )
        {
            cancel_ilm(kal_get_active_module_id());
            ASSERT(0);
        }
        else
        {
            ft_in_proc_call_req_struct *msg_p = (ft_in_proc_call_req_struct *)ptr_ilm->local_para_ptr;
            msg_p->func = func;
            msg_p->func_arg1 = func_arg1;
            msg_p->func_arg2 = func_arg2;
            FT_SEND_MSG(kal_get_active_module_id(), MOD_FT, FT_TST_SAP, (msg_type)MSG_ID_FT_IN_PROC_CALL_REQ, ptr_ilm);
        }
    }
}
/***********************************************
 * FT task self message (In Proc Call handler)
 **********************************************/
void ft_in_proc_call_handler(ilm_struct *ilm_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ft_in_proc_call_req_struct *msg_p = (ft_in_proc_call_req_struct*) ilm_ptr->local_para_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(msg_p->func != NULL);
    msg_p->func(msg_p->func_arg1, msg_p->func_arg2);
}
#pragma arm section code, rodata

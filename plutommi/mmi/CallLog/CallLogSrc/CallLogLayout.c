/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
*
* Filename:
* ---------
*  CallLogLayout.c
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  
*
* Author:
* -------
 * -------
*                      
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
*
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/

/*----------------------------------------------------------------------------*/
/* Comments                                                                   */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Include                                                                    */
/*----------------------------------------------------------------------------*/
#include "MMI_features.h"
#include "wgui_touch_screen.h"  /* mmi_tap_type_enum */
#include "UcmGprot.h"

#include "gui_typedef.h"
#include "wgui_categories_list.h"
#include "MMIDataType.h"

#if defined(__MMI_TELEPHONY_SUPPORT__) || defined(__MMI_BT_PBAP_CLIENT__)


#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_history_gprot.h"
#include "gui_data_types.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "GlobalResDef.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "string.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "MMI_common_app_trc.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_util.h"
#include "wgui_categories_list.h"

#include "CustDataRes.h"
#include "Unicodexdcl.h"
#include "GlobalConstants.h"
#include "app_datetime.h"
#include "wgui.h"
#include "wgui_include.h"
#include "wgui_categories.h"
#include "CommonScreensResDef.h"
#include "Menucuigprot.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_rp_app_uiframework_def.h"

#include "custom_calllog.h"
#include "CallLogSrvGprot.h"
#include "CallLogSrvIprot.h"
#include "CallLogConfig.h"
#include "CallLogGprot.h"
#include "CallLogProt.h"
#include "CallLogLayout.h"
#include "CallLogViewer.h"
#include "mmi_rp_app_calllog_def.h"

#include "PbapSrvGprot.h"
#ifdef __MMI_BT_PBAP_CLIENT__
#include "gui_typedef.h"
#include "wgui_categories_CM.h"

#include"custom_mmi_default_value.h"
#include "DateTimeType.h"
#include "app_datetime.h"
#include "PbapSrvGprot.h"
#include "CallLogAdpProt.h"
#include "mmi_rp_app_bluetooth_def.h"
#include "phbpbapsrvGprot.h"
#include "CallLogAdpprot.h"
#include "BtcmSrvGprot.h"
#include "calllogAdppbapc.h"
#include "mmi_rp_app_phonebook_def.h"
#endif

#ifdef __MMI_NCENTER_SUPPORT__
#include "Vsrv_ncenter.h"
#endif

#ifndef __MMI_UNIFIED_COMPOSER__
#ifdef __MMI_MMS__
#include "mms_api.h"
#endif 
#endif /* __MMI_UNIFIED_COMPOSER__ */ 
#include "MMI_common_app_trc.h"
#include "BTMMIScrGprots.h"
#include "pbapSrvgprot.h"
/*----------------------------------------------------------------------------*/
/* Constant                                                                   */
/*----------------------------------------------------------------------------*/
#define  MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED       (0x0004)

#define  MMI_CLOG_LT_BIT_PER_BYTE      (8)
#define  MMI_CLOG_LT_BIT_SHIFT         (3)
#define  MMI_CLOG_LT_BIT_MASK_BYTE     ((SRV_CLOG_LOG_MAX_NUM + MMI_CLOG_LT_BIT_PER_BYTE - 1) / MMI_CLOG_LT_BIT_PER_BYTE)
/*----------------------------------------------------------------------------*/
/* Macro                                                                      */
/*----------------------------------------------------------------------------*/
#if defined (__MMI_BTD_BOX_UI_STYLE__) && defined (__MMI_BT_PBAP_CLIENT__)
#ifndef __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
#define __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
#endif /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__ */ 
#endif /* */ 



/*----------------------------------------------------------------------------*/
/* typedef                                                                    */
/*----------------------------------------------------------------------------*/

typedef FuncPtr MMI_CLOG_LT_TAB_HDLR;

#ifdef __MMI_FTE_SUPPORT__
typedef GUIIconbarItemCallback MMI_CLOG_LT_TB_HDLR;
#endif /* __MMI_FTE_SUPPORT__ */ 


#if defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)
typedef void (*MMI_CLOG_LT_TAP_HDLR) (mmi_tap_type_enum tap_type, S32 index);
#endif /*defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)*/


/*----------------------------------------------------------------------------*/
/* Enum                                                                       */
/*----------------------------------------------------------------------------*/
#if defined(__MMI_ICON_BAR_SUPPORT__)

typedef enum
{
    MMI_CLOG_LT_TB_ID_MAKE_CALL = 0x01,
    MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL = 0x02,
    MMI_CLOG_LT_TB_ID_SEND_MSG = 0x04,
    MMI_CLOG_LT_TB_ID_SEND_SMS = 0x08,
    MMI_CLOG_LT_TB_ID_SEND_MMS = 0x10,
    MMI_CLOG_LT_TB_ID_ALL_MSG = MMI_CLOG_LT_TB_ID_SEND_MSG | MMI_CLOG_LT_TB_ID_SEND_SMS | MMI_CLOG_LT_TB_ID_SEND_SMS,
    MMI_CLOG_LT_TB_ID_ALL = 0xFF,
    MMI_CLOG_LT_TB_ID_MAX_ITEM = 10
} mmi_clog_lt_tb_id_enum;
#endif /* defined(__MMI_ICON_BAR_SUPPORT__)*/

/*----------------------------------------------------------------------------*/
/* Structure                                                                  */
/*----------------------------------------------------------------------------*/

typedef struct
{
    mmi_clog_lt_id_enum lt_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_title_struct;

typedef struct
{
    const mmi_clog_lt_title_struct *title[MMI_CLOG_LT_ID_MAX_NUM];
} mmi_clog_lt_title_tbl_struct;

typedef struct
{
    mmi_clog_lt_id_enum lt_id;
    U16 scrn_id;
    MMI_STR_ID str_id;
    MMI_IMG_ID img_id;
} mmi_clog_lt_tab_page_struct;

#ifdef __MMI_BT_PBAP_CLIENT__
typedef struct
{
    mmi_clog_lt_bt_id_enum lt_id;
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    mmi_clog_lt_id_enum lt_type;
#endif
    U16 scrn_id;
    MMI_STR_ID str_id;
    MMI_IMG_ID img_id;
} mmi_clog_lt_bt_tab_page_struct;
#endif

typedef struct
{
    U32 total_num;
    const mmi_clog_lt_tab_page_struct *page[MMI_CLOG_LT_ID_MAX_NUM];
    MMI_CLOG_LT_TAB_HDLR page_hdlr;
} mmi_clog_lt_tab_struct;

#ifdef __MMI_BT_PBAP_CLIENT__

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
typedef struct 
{
   const mmi_clog_lt_bt_tab_page_struct *image[MMI_CLOG_LT_ID_MAX_NUM];
}mmi_clog_lt_bt_tab_page_add_struct;
#endif

typedef struct
{
    U32 total_num;
#if SRV_PBAPC_LINK_NUM >= 2
#ifndef __MMI_TELEPHONY_SUPPORT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[SRV_PBAPC_LINK_NUM];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[SRV_PBAPC_LINK_NUM];
#endif

#else
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[SRV_PBAPC_LINK_NUM+1];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[SRV_PBAPC_LINK_NUM +1];
#endif
#endif
#else
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[2];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[2];
#endif
#endif

    MMI_CLOG_LT_TAB_HDLR page_hdlr;
} mmi_clog_lt_bt_tab_struct;
#endif

#if defined(__MMI_ICON_BAR_SUPPORT__)
typedef struct
{
    mmi_clog_lt_tb_id_enum tb_id;
    MMI_IMG_ID enb_img_id;
    MMI_IMG_ID dis_img_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_tb_item_struct;

typedef struct
{
    U32 total_num;
    const mmi_clog_lt_tb_item_struct *items;
    MMI_CLOG_LT_TB_HDLR tb_hdlr;
} mmi_clog_lt_tb_struct;
#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/

#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
typedef struct
{
    #if defined(__MMI_ICON_BAR_SUPPORT__)
    const mmi_clog_lt_tb_struct *tb;
    #endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/
	
	#if defined (__MMI_TOUCH_SCREEN__)
    MMI_CLOG_LT_TAP_HDLR tap_hdlr;
	#endif /*defined (__MMI_TOUCH_SCREEN__)*/
	
} mmi_clog_lt_fte_struct;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__)) */ 

typedef struct
{
    MMI_MENU_ID root_menu_id;
    const mmi_clog_lt_title_tbl_struct *title_tbl;
    const mmi_clog_key_tbl_struct *key_tbl;
    const mmi_clog_lt_img_tbl_struct *img_tbl;
    const mmi_clog_lt_tab_struct *tab;
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
    const mmi_clog_lt_fte_struct *fte;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__)) */ 
} mmi_clog_lt_scrn_data_struct;

#ifdef __MMI_BT_PBAP_CLIENT__
typedef struct
{
    MMI_MENU_ID root_menu_id;
    const mmi_clog_lt_title_tbl_struct *title_tbl;
    const mmi_clog_key_tbl_struct *key_tbl;
    const mmi_clog_lt_img_tbl_struct *img_tbl;
    const mmi_clog_lt_bt_tab_struct *tab;
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
    const mmi_clog_lt_fte_struct *fte;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__)) */ 
} mmi_clog_lt_bt_scrn_data_struct;
#endif

typedef struct
{
    U32 total_num; /* total log count in current screen */
    SRV_CLOG_HANDLE handle;
} mmi_clog_lt_log_data_struct;

typedef struct
{
    U16 flags;
    mmi_clog_lt_type_enum lt_type;
    mmi_clog_lt_id_enum sel_lt_id;
#ifdef __MMI_BT_PBAP_CLIENT__
    mmi_clog_lt_bt_id_enum tab_id;
    S32 bt_index;
#endif
    U16 sel_log_idx;
    SRV_CLOG_ID sel_log_id;
    MMI_ID self_gid;
    mmi_clog_lt_log_data_struct log_data;    
    mmi_clog_lt_style_enum style;
#ifdef __MMI_CLOG_MARK_SEVERAL__
    U8 bit_mask[MMI_CLOG_LT_BIT_MASK_BYTE];
    SRV_CLOG_ID log_ids[SRV_CLOG_LOG_MAX_NUM];
    MMI_ID progress_popup_gid;
#endif   
} mmi_clog_lt_inst_struct;


typedef struct
{
    mmi_clog_lt_inst_struct inst_list[MMI_CLOG_LT_INST_MAX_NUM];
} mmi_clog_lt_cntx_struct;


#ifdef __MMI_BT_PBAP_CLIENT__
S32 g_local_index;
#if SRV_PBAPC_LINK_NUM >= 2 
#ifdef __MMI_TELEPHONY_SUPPORT__
    S32 g_high_index[SRV_PBAPC_LINK_NUM][4] = {1,1,1,1};
#else

    S32 g_high_index[SRV_PBAPC_LINK_NUM][4] = {0,0,0,0};

#endif
#else
#ifdef __MMI_TELEPHONY_SUPPORT__
    S32 g_high_index[4] = {1,1,1,1};
#endif
#endif

U32 g_exist_flag;
#ifdef __MMI_BT_NOTI_SRV__
extern  NMGR_HANDLE bt_nmgr_handle ;
#endif /*__MMI_BT_NOTI_SRV__*/

extern mmi_clog_pbapc_cntx_struct g_mmi_clog_pbapc_cntx;
extern mmi_clog_pbapc_ex_inst_struct* mmi_clog_get_pbapc_cntx_ex();

extern mmi_clog_pbapc_processing_inst_struct g_mmi_clog_pbapc_processing_inst;
mmi_clog_get_last_num_struct g_mmi_clog_get_last_info;

mmi_clog_rsp_missed_call g_is_missed_call;
#endif

/*----------------------------------------------------------------------------*/
/* Static Function Declaration                                                */
/*----------------------------------------------------------------------------*/
/* Instance operations */
static mmi_clog_lt_cntx_struct *mmi_clog_lt_get_cntx(void);
static void mmi_clog_lt_reset_inst(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_destroy_inst(mmi_clog_lt_inst_struct *inst);
static mmi_clog_lt_inst_struct *mmi_clog_lt_alloc_inst(mmi_clog_lt_cntx_struct *cntx);

static MMI_STR_ID mmi_clog_lt_get_title_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id);
static void mmi_clog_lt_update_sel_log_id(mmi_clog_lt_inst_struct *inst);

/* Screen showing */
static MMI_RET mmi_clog_lt_group_proc(mmi_event_struct *evt);
static void mmi_clog_lt_show_list(mmi_clog_lt_inst_struct *inst);

#ifdef __MMI_CLOG_TAB_SUPPORT__
static void mmi_clog_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_lt_enter_tab(mmi_clog_lt_inst_struct * inst);//CHANGE
#else
static void mmi_clog_lt_enter_tab(mmi_scrn_essential_struct *grp_data);
#endif

static void mmi_clog_lt_exit_tab(mmi_scrn_essential_struct *grp_data);
static void mmi_clog_lt_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num);
static void mmi_clog_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data);
static void mmi_clog_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info);
static void mmi_clog_lt_show_tab_page(mmi_clog_lt_inst_struct *inst);
static const mmi_clog_lt_tab_page_struct *mmi_clog_lt_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_id_enum lt_id);
static S32 mmi_clog_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id);
#endif /* __MMI_CLOG_TAB_SUPPORT__ */ 

/*for bt dialer start */
#ifdef __MMI_BT_PBAP_CLIENT__
void mmi_clog_bt_get_last_log(U8 index, mmi_clog_get_last_number_async_cb cb, srv_phb_pbap_storage_enum storage);

static MMI_MENU_ID mmi_clog_bt_get_menu_id(mmi_clog_lt_id_enum lt_id);
static void mmi_clog_bt_link_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_bt_link_lt_enter_tab(mmi_clog_lt_inst_struct *inst);//CHANGE
#else
static void mmi_clog_bt_link_lt_enter_tab(mmi_scrn_essential_struct *scr_info);
#endif

static void mmi_clog_bt_link_lt_exit_tab(mmi_scrn_essential_struct *grp_data);
static const mmi_clog_lt_bt_tab_page_struct *mmi_clog_lt_bt_link_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_bt_id_enum lt_id);
static void mmi_clog_bt_link_fill_tab_info(mmi_clog_lt_inst_struct *inst,
                                                mmi_frm_tab_struct *page_info, 
                                                U32 page_num);
static void mmi_clog_bt_link_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data);
static S32 mmi_clog_bt_pbap_set_index_cb(srv_pbapc_query_req_struct *req);

#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
static MMI_RET mmi_clog_lt_bt_scrn_proc(mmi_event_struct *evt);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
static void mmi_clog_bt_link_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info);
MMI_RET mmi_clog_update_list_by_status(mmi_event_struct*evt);
void mmi_clog_set_bt_status();
static void mmi_clog_bt_link_lsk_hdlr(void);
static void mmi_clog_bt_link_conn_profile_lsk_hdlr();
static void mmi_clog_bt_link_conn_profile_cb(srv_bt_cm_bt_addr *dev_addr, srv_bt_cm_connection_type conn_type, MMI_BOOL result, MMI_BOOL is_connect, MMI_BOOL is_indicate);
void mmi_clog_bt_link_no_conn_show_list(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_tab_page_struct *page);
static void mmi_clog_bt_dialer_show(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_bt_dialer_pre_show(mmi_clog_lt_inst_struct *inst);

//static mmi_ret mmi_clog_pbapc_notify_evt_hdlr(mmi_event_struct *evt);
//extern void mmi_clog_pbapc_processing_show_ex(MMI_ID parent_id, mmi_clog_pbapc_op_type_enum type, srv_phb_pbap_storage_enum sel_lt_storage);
#if 0
/* under construction !*/
#endif
#endif
/*for BT dialer end*/
static void mmi_clog_lt_pre_enter(mmi_clog_lt_inst_struct *inst);
static pBOOL mmi_clog_lt_get_log_item(S32 item_index, UI_string_type str_buff, U8 **img_buff_p, U8 str_img_mask);
static void mmi_clog_lt_get_string(mmi_clog_lt_inst_struct *inst, srv_clog_log_struct *log, WCHAR *str_buff);
#ifndef __MMI_CLOG_FPBW__
static S32 mmi_clog_lt_get_log_hint(S32 item_index, UI_string_type *hint_array);
#endif /*__MMI_CLOG_FPBW__*/
static S32 mmi_clog_lt_get_multi_log_items(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count);

/* Screen handlers */
static void mmi_clog_lt_item_hlt_hdlr(S32 sel);
static void mmi_clog_lt_set_key_hdlr(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_set_csk_key(S32 is_predef);
static void mmi_clog_lt_csk_hdlr(void);

static void mmi_clog_lt_lsk_hdlr(void);
static void mmi_clog_lt_rsk_hdlr(void);

static void mmi_clog_lt_send_key_hdlr(void);
#ifdef __MMI_IP_KEY__
/* under construction !*/
#endif

/* FTE operations */
#if defined(__MMI_ICON_BAR_SUPPORT__)
static void mmi_clog_lt_tb_create(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_tb_refresh(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_tb_action_hdlr(S32 index);
static const mmi_clog_lt_tb_item_struct *mmi_clog_lt_get_tb_item_by_index(mmi_clog_lt_inst_struct *inst, S32 index);
static U32 mmi_clog_lt_tb_get_enb_items(mmi_clog_lt_inst_struct *inst);

static void mmi_clog_lt_tb_set_enb_state(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_tb_id_enum ids, S32 enable);
#endif /* __MMI_ICON_BAR_SUPPORT__*/ 

#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
static void mmi_clog_lt_tap_action_hdlr(mmi_tap_type_enum tap_type, S32 index);
static void mmi_clog_lt_set_tap_hdlr(mmi_clog_lt_inst_struct *inst);
#endif /*defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)*/

static void mmi_clog_lt_op_enter(void);
static void mmi_clog_lt_viewer_enter(void);
static MMI_ID mmi_clog_lt_act_proc(mmi_clog_op_mid_enum op_mid, U32 flags);

/* Service access */
static void mmi_clog_lt_log_start(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_data(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_update_read_status(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_sel_index(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_load_log_ids(mmi_clog_lt_inst_struct *inst);

#ifdef __MMI_CLOG_EVENT_REFRESH_SUPPORT__
static void mmi_clog_lt_inst_srv_evt_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt);
static void mmi_clog_lt_inst_srv_evt_add_log_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt);
static void mmi_clog_lt_refresh_int(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_lt_is_scrn_in_active(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_screen(mmi_clog_lt_inst_struct *inst);
#endif /* __MMI_CLOG_EVENT_REFRESH_SUPPORT__ */
#ifdef __MMI_CLOG_MARK_SEVERAL__
static void mmi_clog_mark_several_hlt_hdlr(S32 sel);
static S32 mmi_clog_mark_several_get_state(S32 item_index, PU8 *checkbox_image);
static S32 mmi_clog_mark_several_set_state(S32 item_index);
static U16 mmi_clog_mark_several_has_marked(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_set_key_hdlr(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_change_status(void);
static void mmi_clog_mark_several_op_enter(void);
static MMI_RET mmi_clog_mark_several_op_group_proc(mmi_event_struct *evt);
static void mmi_clog_mark_several_op_hide_menu(mmi_id cui_id, mmi_clog_lt_inst_struct *inst);

static U8 mmi_clog_bitmask_get_state(U8* bit_mask, U16 index);
static void mmi_clog_mark_several_delete_confirm(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_delete(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_mark_several_delete_common(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_mark_several_delete_result(
            SRV_CLOG_HANDLE handle,
            S32 pid,
            void *req_data,
            void *cnf_data,
            MMI_BOOL more,
            srv_clog_ret_enum ret);

#endif /* __MMI_CLOG_MARK_SEVERAL__ */

/*----------------------------------------------------------------------------*/
/* Static Global Variable                                                     */
/*----------------------------------------------------------------------------*/
#ifdef __MMI_BT_PBAP_CLIENT__
typedef struct
{
    mmi_clog_lt_bt_id_enum lt_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_bt_title_struct;
#endif
static const mmi_clog_lt_title_struct g_mmi_clog_lt_dialed_call = 
{
    MMI_CLOG_LT_ID_DIALED_CALL,
    STR_GLOBAL_DIALLED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_missed_call = 
{
    MMI_CLOG_LT_ID_MISSED_CALL,
    STR_GLOBAL_MISSED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_recved_call = 
{
    MMI_CLOG_LT_ID_RECVED_CALL,
    STR_GLOBAL_RECEIVED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_all_call = 
{
    MMI_CLOG_LT_ID_ALL_CALL,
    STR_ID_CLOG_ALL_CALL
};
#ifdef __MMI_BT_PBAP_CLIENT__

#ifdef __MMI_TELEPHONY_SUPPORT__
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    STR_ID_CLOG_SUB_LOCAL
};
#endif
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_bt_call = 
{
    MMI_CLOG_LT_ID_BT,
    STR_ID_PHB_PBAPC_BT1
};


#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_bt_call_v3 = 
{
    MMI_CLOG_LT_ID_BT_V3,
    STR_ID_PHB_PBAPC_BT2
};
#endif

#endif

static const mmi_clog_lt_title_tbl_struct g_mmi_clog_lt_title_tbl = 
{
    {
        &g_mmi_clog_lt_dialed_call,
        &g_mmi_clog_lt_missed_call,
        &g_mmi_clog_lt_recved_call,
        &g_mmi_clog_lt_all_call
    }
};

static const mmi_clog_key_tbl_struct g_mmi_clog_lt_key_tbl = 
{
    {
        &g_mmi_clog_lsk_option,
        &g_mmi_clog_csk_common,
        &g_mmi_clog_rsk_back
    },
    {
        mmi_clog_lt_lsk_hdlr,
        mmi_clog_lt_csk_hdlr,
        mmi_clog_lt_rsk_hdlr,
        mmi_clog_lt_send_key_hdlr,
#ifdef __MMI_IP_KEY__
/* under construction !*/
#endif
     }
};

#ifdef __MMI_CLOG_TAB_SUPPORT__
static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_call = 
{
    MMI_CLOG_LT_ID_DIALED_CALL,
    SCR_ID_CLOG_DIALED_CALL,
    STR_GLOBAL_DIALLED_CALLS,
    IMG_ID_CLOG_TAB_DIALED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_missed_call = 
{
    MMI_CLOG_LT_ID_MISSED_CALL,
    SCR_ID_CLOG_MISSED_CALL,
    STR_GLOBAL_MISSED_CALLS,
    IMG_ID_CLOG_TAB_MISSED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_recved_call = 
{
    MMI_CLOG_LT_ID_RECVED_CALL,
    SCR_ID_CLOG_RECVED_CALL,
    STR_GLOBAL_RECEIVED_CALLS,
    IMG_ID_CLOG_TAB_RECVED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_all_call = 
{
    MMI_CLOG_LT_ID_ALL_CALL,
    SCR_ID_CLOG_ALL_CALL,
    STR_ID_CLOG_ALL_CALL,
    IMG_ID_CLOG_TAB_ALL_CALL
};

static const mmi_clog_lt_tab_struct g_mmi_clog_lt_tab = 
{
    4,
    {
        &g_mmi_clog_lt_tab_page_dialed_call,
        &g_mmi_clog_lt_tab_page_missed_call,
        &g_mmi_clog_lt_tab_page_recved_call,
        &g_mmi_clog_lt_tab_page_all_call
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_lt_enter_tab_page
};

#endif /* __MMI_CLOG_TAB_SUPPORT__ */

#ifdef __MMI_BT_PBAP_CLIENT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
#ifdef __MMI_TELEPHONY_SUPPORT__
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_DIALED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_DIALED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_MISSED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_MISSED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recieve_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_RECVED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_RECEIVED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_ALL_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_ALL_LOCAL_CALL
};
#endif

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_DIALED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_DIALED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_MISSED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_MISSED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_ALL_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_ALL_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recved_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_RECVED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_RECEIVED_BT_CALL
};

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_DIALED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_DIALED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_MISSED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_MISSED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_ALL_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_ALL_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recved_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_RECVED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_RECEIVED_BT_CALL
};
#endif
#endif
#endif

#ifdef __MMI_BT_PBAP_CLIENT__
#ifdef __MMI_TELEPHONY_SUPPORT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_local_call = 
{
    &g_mmi_clog_lt_tab_page_dialed_local_call , 
    &g_mmi_clog_lt_tab_page_missed_local_call,
    &g_mmi_clog_lt_tab_page_recieve_local_call,
    &g_mmi_clog_lt_tab_page_all_local_call
};
#else

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_MAIN_ICON
};
#endif  /*#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)*/
#endif /*__MMI_TELEPHONY_SUPPORT__*/

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_bt_dialer_call = 
{ 
    &g_mmi_clog_lt_tab_page_dialed_bt_call, 
    &g_mmi_clog_lt_tab_page_missed_bt_call,
    &g_mmi_clog_lt_tab_page_all_bt_call, 
    &g_mmi_clog_lt_tab_page_recved_bt_call       
};
#else
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_bt_dialer_call = 
{
    MMI_CLOG_LT_ID_BT,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_MAIN_ICON
};
#endif

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_bt_dialer_call_v3 = 
{ 
    &g_mmi_clog_lt_tab_page_dialed_bt_call_v3, 
    &g_mmi_clog_lt_tab_page_missed_bt_call_v3,
    &g_mmi_clog_lt_tab_page_all_bt_call_v3, 
    &g_mmi_clog_lt_tab_page_recved_bt_call_v3       
};
#endif
#else

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_bt_dialer_call_v3 = 
{
    MMI_CLOG_LT_ID_BT_V3,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_MAIN_ICON
};
#endif
#endif

static const mmi_clog_lt_bt_tab_struct g_mmi_clog_bt_link_lt_tab = 
{
#if SRV_PBAPC_LINK_NUM >= 2

#ifndef __MMI_TELEPHONY_SUPPORT__
    SRV_PBAPC_LINK_NUM,
    {    
        &g_mmi_clog_lt_tab_page_bt_dialer_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call_v3
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page


#else/*__MMI_TELEPHONY_SUPPORT__*/

    SRV_PBAPC_LINK_NUM+1,
    {    
        &g_mmi_clog_lt_tab_page_local_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call_v3
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page
#endif /*__MMI_TELEPHONY_SUPPORT__*/
#else
    2,
    {    
#ifdef __MMI_TELEPHONY_SUPPORT__
        &g_mmi_clog_lt_tab_page_local_call,
#endif
        &g_mmi_clog_lt_tab_page_bt_dialer_call
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page
#endif
};
#endif

#if defined(__MMI_ICON_BAR_SUPPORT__)
/* The FTE toolbar show its items in the same order of the declarations in this array  */
static const mmi_clog_lt_tb_item_struct g_mmi_clog_lt_tb_item_list[] = 
{
    /* Make call */
    {
        MMI_CLOG_LT_TB_ID_MAKE_CALL,
        IMG_GLOBAL_TOOLBAR_CALL,
        IMG_GLOBAL_TOOLBAR_CALL_DISABLED,
        STR_GLOBAL_DIAL
    },

#if(defined(__OP01_3G__) && defined(__MMI_VIDEO_TELEPHONY__)) 
    /* Make video call */
    {
        MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL,
        IMG_GLOBAL_TOOLBAR_VIDEO_CALL,
        IMG_GLOBAL_TOOLBAR_VIDEO_CALL_DISABLED,
        STR_GLOBAL_DIAL_VIDEO_CALL
    },  

#endif /* __OP01_3G__ && __MMI_VIDEO_TELEPHONY__ */


#ifdef __MMI_UNIFIED_COMPOSER__
    /* Send message */
    {
        MMI_CLOG_LT_TB_ID_SEND_MSG,
        IMG_GLOBAL_TOOLBAR_SEND_MESSAGE,
        IMG_GLOBAL_TOOLBAR_SEND_MESSAGE_DISABLED,
        STR_GLOBAL_SEND_MESSAGE
    },
#else /* __MMI_UNIFIED_COMPOSER__ */ 
    /* Send SMS */
    {
        MMI_CLOG_LT_TB_ID_SEND_SMS,
        IMG_ID_CLOG_TB_SEND_SMS,
        IMG_ID_CLOG_TB_SEND_SMS_DISABLE,
        STR_GLOBAL_SEND_TEXT_MESSAGE
    },

#ifdef __MMI_MMS__
    /* Send MMS */
    {
        MMI_CLOG_LT_TB_ID_SEND_MMS,
        IMG_ID_CLOG_TB_SEND_MMS,
        IMG_ID_CLOG_TB_SEND_MMS_DISABLE,
        STR_GLOBAL_SEND_MULTIMEDIA_MESSAGE
    }
#endif /* __MMI_MMS__ */ 
#endif /* __MMI_UNIFIED_COMPOSER__ */ 
};

static const mmi_clog_lt_tb_struct g_mmi_clog_lt_tb = 
{
    sizeof(g_mmi_clog_lt_tb_item_list) / sizeof(mmi_clog_lt_tb_item_struct),
    g_mmi_clog_lt_tb_item_list,
    mmi_clog_lt_tb_action_hdlr
};
#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/

#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
static const mmi_clog_lt_fte_struct g_mmi_clog_lt_fte = 
{
#if defined(__MMI_ICON_BAR_SUPPORT__)
    &g_mmi_clog_lt_tb,
#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/

#if defined (__MMI_TOUCH_SCREEN__)
    mmi_clog_lt_tap_action_hdlr,
#endif /*defined (__MMI_TOUCH_SCREEN__)*/
};

#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__)) */ 

static const mmi_clog_lt_scrn_data_struct g_mmi_clog_lt_scrn_data = 
{
    MAIN_MENU_CALL_LOG,
    &g_mmi_clog_lt_title_tbl,
    &g_mmi_clog_lt_key_tbl,
    &g_mmi_clog_lt_img_tbl,
#ifdef __MMI_CLOG_TAB_SUPPORT__
    &g_mmi_clog_lt_tab,
#else /*__MMI_CLOG_TAB_SUPPORT__*/
    NULL,
#endif /*__MMI_CLOG_TAB_SUPPORT__*/
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
    &g_mmi_clog_lt_fte
#endif /*defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))*/
};

#ifdef __MMI_BT_PBAP_CLIENT__
static const mmi_clog_lt_bt_scrn_data_struct g_mmi_clog_bt_link_lt_scrn_data = 
{
    MAIN_MENU_CALL_LOG,
    &g_mmi_clog_lt_title_tbl,
    &g_mmi_clog_lt_key_tbl,
    &g_mmi_clog_lt_img_tbl,
//#ifdef __MMI_CLOG_TAB_SUPPORT__
    &g_mmi_clog_bt_link_lt_tab,
//#else /*__MMI_CLOG_TAB_SUPPORT__*/
   // NULL,
//#endif /*__MMI_CLOG_TAB_SUPPORT__*/
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))
    &g_mmi_clog_lt_fte
#endif /*defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_ICON_BAR_SUPPORT__))*/
};
#endif

static mmi_clog_lt_cntx_struct g_mmi_clog_lt_cntx;
WCHAR path[41];


extern U8 g_clog_sim_support;

#ifdef __MMI_NCENTER_SUPPORT__
extern vsrv_notification_handle g_ncenter_hdl;

#endif /*__MMI_NCENTER_SUPPORT__*/

extern NMGR_HANDLE nmgr_handle;


/*----------------------------------------------------------------------------*/
/* Extern Function Defines                                                    */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Function Definition                                                        */
/*----------------------------------------------------------------------------*/
static SRV_CLOG_ID mmi_clog_get_id_by_idx(mmi_clog_lt_id_enum lt_id, U16 sel_log_idx)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_get_list_log_req_struct req_data;
    srv_clog_get_list_log_cnf_struct cnf_data;
    const mmi_clog_lt_id_attr_struct *attr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_clog_init_para(SRV_CLOG_PARA_GET_LIST_LOG_CNF, &cnf_data);

    attr = mmi_clog_get_attr_by_lt_id(lt_id);
    SRV_CLOG_INIT_IDT(
        (srv_clog_log_identity_struct*) & req_data,
        attr->idt.cate,
        //attr->idt.sim_id,
        g_clog_sim_support,
        attr->idt.log_type,
        attr->idt.sub_type);
    
    req_data.get_by = SRV_CLOG_BY_IDX;
    req_data.get_elm = sel_log_idx;
    req_data.fields = SRV_CLOG_LOG_FIELD_LOG_ID;
#ifdef __MMI_TELEPHONY_SUPPORT__
    srv_clog_get_list_log(0,
        (const srv_clog_get_list_log_req_struct *) &req_data,
        &cnf_data);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    return cnf_data.log.data.call_log.log_id;
#else /* __MMI_TELEPHONY_SUPPORT__ */
    return 0;
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


#define MMI_CLOG_LT_INIT


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_cntx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static mmi_clog_lt_cntx_struct *mmi_clog_lt_get_cntx(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &g_mmi_clog_lt_cntx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_reset_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_reset_inst(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(inst, 0x0, sizeof(mmi_clog_lt_inst_struct));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_destroy_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_destroy_inst(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT))
        return;

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_DESTROY_INST,
        inst->self_gid,
        inst->flags,
        inst->lt_type,
        inst->sel_lt_id,
        inst->sel_log_idx,
        inst->sel_log_id));
#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
    if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE))
        srv_clog_destroy(inst->log_data.handle);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    mmi_clog_lt_reset_inst(inst);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_alloc_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cntx        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
mmi_clog_lt_inst_struct *mmi_clog_lt_alloc_inst(mmi_clog_lt_cntx_struct *cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_CLOG_LT_INST_MAX_NUM == 1) /* For slim */
    {
        MMI_CLOG_SET_BIT(cntx->inst_list[0].flags, MMI_CLOG_CMN_INST_FLAG_IS_USED | MMI_CLOG_INST_TYPE_LT);
        return &cntx->inst_list[0];
    }
    else
    {
        for (i = 0; i < MMI_CLOG_LT_INST_MAX_NUM; i++)
        {
            inst = &cntx->inst_list[i];
            if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_IS_USED))
            {
                MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_IS_USED | MMI_CLOG_INST_TYPE_LT);
                return inst;
            }
        }
        return NULL;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_title_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_STR_ID mmi_clog_lt_get_title_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_title_tbl_struct *title_tbl = g_mmi_clog_lt_scrn_data.title_tbl;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_CLOG_LT_ID_MAX_NUM; i++)
    {
        if (title_tbl->title[i] && title_tbl->title[i]->lt_id == lt_id)
            return title_tbl->title[i]->str_id;
    }
    
    MMI_CLOG_IT_ASSERT(0);
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_update_sel_log_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_update_sel_log_id(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst->sel_log_id = mmi_clog_get_id_by_idx(inst->sel_lt_id, inst->sel_log_idx);
}

#define MMI_CLOG_LT_IF

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_scrn_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 * evt       [IN]     
 * RETURNS
 *  MMI_RET
 *****************************************************************************/
static MMI_RET mmi_clog_lt_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
#ifdef __MMI_BT_PBAP_CLIENT__
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;

    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
#ifdef __MMI_BT_PBAP_CLIENT__
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_PHB_PBAPC_SYNC_CONTACT__ 
        {
            mmi_clog_bt_dialer_pre_show(inst);
        }
    #endif
#else /*SRV_PBAPC_LINK_NUM >= 2*/
    #ifndef __MMI_TELEPHONY_SUPPORT__
        {
            pbapc_cntx =  mmi_clog_get_pbapc_cntx_ex();
            pbapc_cntx->index = 0;
            mmi_clog_bt_dialer_pre_show(inst);
        }
    #endif/*__MMI_TELEPHONY_SUPPORT__*/
#endif/*SRV_PBAPC_LINK_NUM >= 2*/
#else /*__MMI_BT_PBAP_CLIENT__*/

        {
#ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_clog_lt_load_log_ids(inst);
            }
            else
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
            {
                mmi_clog_lt_refresh_data(inst);
            }
            mmi_clog_lt_show_list(inst);
        }
#endif /* __MMI_BT_PBAP_CLIENT__ */
        break;
#ifndef __MMI_TELEPHONY_SUPPORT__
#ifdef __MMI_BT_PBAP_CLIENT__  
      case EVT_ID_SCRN_INACTIVE:
            g_exist_flag = 0;
            break;
#endif
#endif
        default:
             break;
    }  

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_create_and_run
 * DESCRIPTION
 *  
 * PARAMETERS
 *  p_inst      [IN]        parent inst      
 * RETURNS
 *  
 *****************************************************************************/
MMI_ID mmi_clog_lt_create_and_run(mmi_clog_inst_struct *p_inst, mmi_clog_lt_style_enum style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_lt_cntx_struct *cntx = mmi_clog_lt_get_cntx();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
  #ifdef __MMI_CLOG_MARK_SEVERAL__
    if(style==MMI_CLOG_LT_STYLE_LIST)
        inst = &cntx->inst_list[0];     // for layout list
    else
        inst = &cntx->inst_list[1];     // for multiselection
  #else /* __MMI_CLOG_MARK_SEVERAL__ */
    inst = &cntx->inst_list[0];
  #endif /* __MMI_CLOG_MARK_SEVERAL__ */
    
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    inst = mmi_clog_lt_alloc_inst(cntx);
    if (!inst)
    {
        MMI_CLOG_ASSERT(0);
        return 0;
    }
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    MMI_CLOG_ASSERT(p_inst->sel_lt_id < MMI_CLOG_LT_ID_MAX_ITEM);
    inst->sel_lt_id = p_inst->sel_lt_id;
    inst->style = style;
    inst->lt_type = p_inst->lt_type;
#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
    inst->log_data.handle = p_inst->handle;

    if (!SRV_CLOG_IS_ELM_INVALID(p_inst->handle))
        MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE);
    mmi_clog_lt_log_start(inst);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    if(style==MMI_CLOG_LT_STYLE_LIST)
        gid = GRP_ID_CLOG_LAYOUT;
    else
        gid = GRP_ID_CLOG_LAYOUT_MARK;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_clog_alloc_gid(MMI_CLOG_GRP_TYPE_LT);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    inst->self_gid = mmi_frm_group_create_ex(p_inst->self_gid, gid, mmi_clog_lt_group_proc, inst, MMI_FRM_NODE_SMART_CLOSE_FLAG);

#ifdef __MMI_CLOG_MARK_SEVERAL__
    if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
    {
        inst->sel_log_idx = cntx->inst_list[0].sel_log_idx; /* use list highlight index, need revise */
    }
    else
#endif /* __MMI_CLOG_MARK_SEVERAL__ */
    {
        inst->sel_log_idx = 0;
    }
    mmi_clog_lt_update_sel_log_id(inst);
    
    g_clog_sim_support = MMI_SIM_ALL;  

#if !defined(__MMI_CLOG_TAB_SUPPORT__) || defined(__MMI_CLOG_MARK_SEVERAL__) 
    if(inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
    {
#ifdef __MMI_BT_PBAP_CLIENT__
        g_mmi_clog_pbapc_cntx.is_from_close_pop = MMI_FALSE;
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_PHB_PBAPC_SYNC_CONTACT__
    mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
    #else
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_bt_link_lt_enter_tab(inst);//CHANGE
    #else
        mmi_clog_bt_link_lt_first_enter_tab(inst);
    #endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    #endif /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
#else
    #ifndef __MMI_TELEPHONY_SUPPORT__
        mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
    #else /* __MMI_TELEPHONY_SUPPORT__ */
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_bt_link_lt_enter_tab(inst);//CHANGE
    #else
        mmi_clog_bt_link_lt_first_enter_tab(inst);
    #endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    #endif /*__MMI_TELEPHONY_SUPPORT__*/ 
#endif /*SRV_PBAPC_LINK_NUM >= 2*/
#endif 
    }
    else
#endif /*!defined(__MMI_CLOG_TAB_SUPPORT__) || defined(__MMI_CLOG_MARK_SEVERAL__)*/
#ifdef __MMI_CLOG_TAB_SUPPORT__
    if(inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
    { 
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_lt_enter_tab(inst);        
    #else
        mmi_clog_lt_first_enter_tab(inst);
    #endif
 
    }
#endif /* __MMI_CLOG_TAB_SUPPORT__ */

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_CREATE,
        p_inst->self_gid,
        inst->self_gid,
        inst->lt_type,
        inst->flags,
        inst->log_data.handle,
        inst->style));

    return inst->self_gid;
}


#define MMI_CLOG_LT_GRP


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_group_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_lt_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;

    if (evt->evt_id == EVT_ID_GROUP_DEINIT)
    {
        mmi_clog_lt_destroy_inst(inst);
#ifdef __MMI_BT_PBAP_CLIENT__
        mmi_clog_pbapc_deinit();
        g_exist_flag = 0;

        memset((void*)&g_is_missed_call, 0x0,sizeof (mmi_clog_rsp_missed_call));
#endif
    }
    else if (evt->evt_id == EVT_ID_GROUP_ENTER)
    {
       // mmi_frm_cb_reg_event(EVT_ID_DIALER_EVENT_ID, mmi_clog_update_list_by_status, inst);

    }
#ifdef __MMI_CLOG_MARK_SEVERAL__
    else if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        mmi_alert_result_evt_struct *alert = (mmi_alert_result_evt_struct*) evt;
        if (alert->result == MMI_ALERT_CNFM_YES)
            mmi_clog_mark_several_delete(inst);
    }
#endif    
    return MMI_RET_OK;
}


#define MMI_CLOG_LT_UI

#if defined(__MMI_CLOG_TAB_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_first_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_first_enter(inst->self_gid, SCR_ID_CLOG_LAYOUT, (FuncPtr) mmi_clog_lt_enter_tab, inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/ 
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    static void mmi_clog_lt_enter_tab(mmi_clog_lt_inst_struct * inst);//CHANGE
#else
    static void mmi_clog_lt_enter_tab(mmi_scrn_essential_struct *grp_data);
#endif
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    mmi_frm_tab_struct page_info[MMI_CLOG_LT_ID_MAX_NUM]; 
    mmi_clog_lt_inst_struct *inst;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__  
   inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;
#endif 
    mmi_clog_lt_fill_tab_info(inst, page_info, MMI_CLOG_LT_ID_MAX_NUM);

#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    cui_tab_create( inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page_info,
            (U8) g_mmi_clog_lt_enb_ids.total_num,
            cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT),
            inst);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    mmi_frm_scrn_tab_enter(
        inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        (FuncPtr) mmi_clog_lt_exit_tab,
        (FuncPtr) mmi_clog_lt_enter_tab,
        page_info,
        (U8) g_mmi_clog_lt_enb_ids.total_num,
        (U8) mmi_clog_lt_get_page_index_by_lt_id(inst, inst->sel_lt_id));
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_exit_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_exit_tab(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* mmi_frm_general_tab_exit(); */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_fill_tab_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst            [IN]         
 *  page_info       [OUT]         
 *  page_num        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tab_page_struct *page;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_mmi_clog_lt_enb_ids.total_num && i < page_num; i++)
    {
        page = mmi_clog_lt_get_page_by_lt_id(inst, g_mmi_clog_lt_enb_ids.lt_ids[i]);
        page_info[i].screen_id = page->scrn_id;
        page_info[i].tab_icon = (U8*) GetImage(page->img_id);
        page_info[i].tab_string = NULL;
        page_info[i].tab_entry_func = g_mmi_clog_lt_scrn_data.tab->page_hdlr;
        page_info[i].user_data = inst;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_enter_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  grp_data        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    U8 index;
    mmi_clog_lt_inst_struct *inst;
    const mmi_clog_lt_tab_page_struct *page;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) grp_data->user_data;
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    index = mmi_frm_scrn_tab_get_active_page_index();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    MMI_CLOG_ASSERT(index < g_mmi_clog_lt_enb_ids.total_num);
    inst->sel_lt_id = g_mmi_clog_lt_enb_ids.lt_ids[index];

    page = mmi_clog_lt_get_page_by_lt_id(inst, inst->sel_lt_id);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    ret = cui_tab_enter(
            inst->self_gid,
            page->scrn_id,
            (FuncPtr) mmi_clog_lt_exit_tab_page,
            (FuncPtr) mmi_clog_lt_enter_tab_page,
            MMI_FRM_FULL_SCRN);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    ret = mmi_frm_scrn_tab_page_enter(
            inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page->scrn_id,
            (FuncPtr) mmi_clog_lt_exit_tab_page,
            (FuncPtr) mmi_clog_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */

    if (!ret)
        return;

    /* Reload log data after change select lt_id */
    mmi_clog_lt_refresh_data(inst);

    mmi_clog_lt_show_tab_page(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_exit_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_show_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_show_tab_page(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buff;
    S32 category_error_flag;
    U32 has_lsk = MMI_TRUE;
    const mmi_clog_lt_tab_page_struct *page;
    U32 count = 0;

#ifdef __MMI_CLOG_SIM_FILTER__
    S32 ret;
    srv_clog_log_struct log;
    U32 i = 0;
#endif

    U32 log_number = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_pre_enter(inst);

    /* close nmgr */
    if (inst->sel_lt_id == MMI_CLOG_LT_ID_MISSED_CALL 
        || inst->sel_lt_id == MMI_CLOG_LT_ID_ALL_CALL)
    {
        if(nmgr_handle != NULL)
        {
            mmi_frm_nmgr_alert_cancel(nmgr_handle);
            nmgr_handle = NULL;
        }
#ifdef __MMI_NCENTER_SUPPORT__
        vsrv_ncenter_close_notification(g_ncenter_hdl);
#endif /*__MMI_NCENTER_SUPPORT__*/
    }

    page = mmi_clog_lt_get_page_by_lt_id(inst, inst->sel_lt_id);

#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    gui_buff = cui_tab_get_screen_gui_buf(SCR_ID_CLOG_LAYOUT,page->scrn_id);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    gui_buff = mmi_frm_scrn_tab_page_get_active_gui_buf();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */

    count = inst->log_data.total_num;

    if (MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED))
    {
        //gui_buff = NULL;
        MMI_CLOG_CLEAR_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);
    }

    RegisterHighlightHandler(mmi_clog_lt_item_hlt_hdlr);

#if (!defined(__MMI_CLOG_CALL_TIME__) && !defined(__MMI_CLOG_CALL_COST__) && !defined(__MMI_CLOG_SMS_COUNT__) && !defined(__MMI_CLOG_GPRS_COUNT__))
    {        
        if (!inst->log_data.total_num)
            has_lsk = MMI_FALSE;

    #ifdef __MMI_CLOG_SIM_FILTER__
        count = 0;

        for (i = 0; i<inst->log_data.total_num; i++)
        {
            ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, i),
                0, 
                &log);

            if (ret != SRV_CLOG_RET_OK)
            {
                break;
            }
            count ++; 
        }
    #endif /*__MMI_CLOG_SIM_FILTER__*/
       
        if (count == 0)
        {
            has_lsk = MMI_FALSE;
        }           
    }
#endif     

    log_number = count;

    wgui_cat1031_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(page->img_id),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        mmi_clog_lt_get_log_hint,
        NULL,//inst->sel_log_idx,
        mmi_clog_lt_get_page_index_by_lt_id(inst, inst->sel_lt_id),  
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1,
        gui_buff,
        &category_error_flag);

    mmi_clog_lt_set_key_hdlr(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_page_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_tab_page_struct *mmi_clog_lt_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tab_struct *tab = g_mmi_clog_lt_scrn_data.tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_CLOG_LT_ID_MAX_NUM; i++)
    {
        if (tab->page[i] && tab->page[i]->lt_id == lt_id)
            return tab->page[i];
    }
    MMI_CLOG_IT_ASSERT(0);
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_page_index_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0    
/* under construction !*/
/* under construction !*/
#endif

    for (i = 0; i < g_mmi_clog_lt_enb_ids.total_num; i++)
    {
        if (g_mmi_clog_lt_enb_ids.lt_ids[i] == lt_id)
            return i;
    }
    
    MMI_CLOG_IT_ASSERT(0);
    
    return 0;
}
#endif /*__MMI_CLOG_TAB_SUPPORT__*/


#ifdef __MMI_BT_PBAP_CLIENT__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_first_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_first_enter(inst->self_gid, SCR_ID_CLOG_LAYOUT, (FuncPtr) mmi_clog_bt_link_lt_enter_tab, inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_bt_link_lt_enter_tab(mmi_clog_lt_inst_struct *inst)//CHANGE
#else
static void mmi_clog_bt_link_lt_enter_tab(mmi_scrn_essential_struct *scr_info)
#endif
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
#if SRV_PBAPC_LINK_NUM >= 2
    S32 ret1;
#endif
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    mmi_clog_lt_inst_struct *inst;
#endif
#if defined (__MMI_BT_NOTI_SRV__)
   extern srv_bt_cm_bt_addr g_missed_bt_addr;
#endif
    srv_bt_cm_bt_addr bt_addr; 

    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
#ifndef __MMI_TELEPHONY_SUPPORT__
    mmi_frm_tab_struct page_info[SRV_PBAPC_LINK_NUM];
#else
    mmi_frm_tab_struct page_info[SRV_PBAPC_LINK_NUM + 1];
#endif
    U8 index;
    U16 i;
    #if 0
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
/* under construction !*/
#else
/* under construction !*/
#endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#ifdef __MMI_TELEPHONY_SUPPORT__
/* under construction !*/
#endif
#endif
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
#if SRV_PBAPC_LINK_NUM >= 2
    srv_phb_pbapc_get_btd_addr(&bt_addr,0);
    ret = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
    srv_phb_pbapc_get_btd_addr(&bt_addr,1);
    ret1 = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_V31, pbapc_cntx->index, ret, ret1, pbapc_cntx->flag[1]);
#else
    srv_phb_pbapc_get_btd_addr(&bt_addr, pbapc_cntx->index);
    ret = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;//CHANGE
#endif
#ifndef __MMI_TELEPHONY_SUPPORT__
    mmi_clog_bt_link_fill_tab_info(inst, page_info, (SRV_PBAPC_LINK_NUM));
#else
    mmi_clog_bt_link_fill_tab_info(inst, page_info, (SRV_PBAPC_LINK_NUM + 1));
#endif
#if SRV_PBAPC_LINK_NUM >= 2

    if ((!ret && !ret1)|| g_is_missed_call.is_from_local)
    {
        index = 0;
    }
    else if (!ret && ret1)
    {
        if (g_is_missed_call.is_from_bt)
        {
            index = 1;
        }
        else
        {
            if (!pbapc_cntx->flag[1])
            {
                index = 1;
                for (i = 0; i < 4; i++)
                {
                    g_high_index[0][i] = 1;
                    g_high_index[1][i] = 1;    
                }
            }
            else
            {
                switch (inst->sel_lt_id)
                {
                    case MMI_CLOG_LT_ID_DIALED_CALL:
                        index = g_high_index[pbapc_cntx->index][0];
                        break;
                    case MMI_CLOG_LT_ID_MISSED_CALL:
                        index = g_high_index[pbapc_cntx->index][1];
                        break;
                    case MMI_CLOG_LT_ID_RECVED_CALL:
                        index = g_high_index[pbapc_cntx->index][2];
                        break;
                    case  MMI_CLOG_LT_ID_ALL_CALL:
                        index = g_high_index[pbapc_cntx->index][3];
                        break;
                    default:
                        break;
               }

            }

        }

    }
    else
    {    
        if(g_is_missed_call.is_from_bt)
        {
#if defined (__MMI_BT_NOTI_SRV__)
            index =srv_pbapc_get_btd_index(&g_missed_bt_addr, SRV_PBAPC_FLAG_CONNECTED);
#endif           
        }
        else
        {
            switch (inst->sel_lt_id)
             {
                 case MMI_CLOG_LT_ID_DIALED_CALL:
                     index = g_high_index[pbapc_cntx->index][0];
                     break;
                 case MMI_CLOG_LT_ID_MISSED_CALL:
                     index = g_high_index[pbapc_cntx->index][1];
                     break;
                 case MMI_CLOG_LT_ID_RECVED_CALL:
                     index = g_high_index[pbapc_cntx->index][2];
                     break;
                 case  MMI_CLOG_LT_ID_ALL_CALL:
                     index = g_high_index[pbapc_cntx->index][3];
                     break;
                 default:
                     break;
            }
        }
    }
#else /*SRV_PBAPC_LINK_NUM >= 2*/
#ifdef __MMI_TELEPHONY_SUPPORT__
if (!ret|| g_is_missed_call.is_from_local)
    {
        index = 0;
    }
    else
    {    
        if(g_is_missed_call.is_from_bt)
        {
#if defined (__MMI_BT_NOTI_SRV__)
            index =srv_pbapc_get_btd_index(&g_missed_bt_addr, SRV_PBAPC_FLAG_CONNECTED);
 #endif   
        }
        else
        {
            switch (inst->sel_lt_id)
             {
                 case MMI_CLOG_LT_ID_DIALED_CALL:
                     index = g_high_index[0];
                     break;
                 case MMI_CLOG_LT_ID_MISSED_CALL:
                     index = g_high_index[1];
                     break;
                 case MMI_CLOG_LT_ID_RECVED_CALL:
                     index = g_high_index[2];
                     break;
                 case  MMI_CLOG_LT_ID_ALL_CALL:
                     index = g_high_index[3];
                     break;
                 default:
                     break;
            }

        }
    }

#endif /*__MMI_TELEPHONY_SUPPORT__*/

#endif

    
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_HIGH_LIGHT, index);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    cui_tab_create(inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        page_info,
        g_mmi_clog_bt_link_tab_id.tab_num,
        (U8) index,
        inst);
#else
    mmi_frm_scrn_tab_enter(
        inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        (FuncPtr) mmi_clog_bt_link_lt_exit_tab,
        (FuncPtr) mmi_clog_bt_link_lt_enter_tab,
        page_info,
        (U8) g_mmi_clog_bt_link_tab_id.tab_num,
        (U8) index);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_exit_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_exit_tab(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* mmi_frm_general_tab_exit(); */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_enter_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    S32 ret;
    U8 index;
    mmi_clog_lt_bt_tab_page_struct *page;
    U16 title_id;
    MMI_MENU_ID sel_menu_id;
    MMI_BOOL is_redraw;
    U8* gui_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) grp_data->user_data;
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else
    index = mmi_frm_scrn_tab_get_active_page_index();
#endif
    wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);

    page = (mmi_clog_lt_bt_tab_page_struct *)mmi_clog_lt_bt_link_get_page_by_lt_id(inst, g_mmi_clog_bt_link_tab_id.lt_ids[index]);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__    
    ret = cui_tab_enter(
            inst->self_gid,
            page->scrn_id,
            (FuncPtr) mmi_clog_bt_link_lt_exit_tab_page,
            (FuncPtr) mmi_clog_bt_link_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#else
    ret = mmi_frm_scrn_tab_page_enter(
            inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page->scrn_id,
            (FuncPtr) mmi_clog_bt_link_lt_exit_tab_page,
            (FuncPtr) mmi_clog_bt_link_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#endif
    if(!ret)
    {
        return;
    }
    
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_ENTER_TAB_PAGE,grp_data->scrn_id, inst->self_gid);

#ifdef __MMI_TELEPHONY_SUPPORT__
    if(grp_data->scrn_id == GRP_ID_CLOG_SUB_LOCAL)
    {
        g_exist_flag  = 0;
        mmi_clog_lt_refresh_data(inst);
        mmi_clog_lt_show_list(inst);
    }
    else
#endif
    {
        g_exist_flag = 1;
        is_redraw = mmi_frm_scenario_is_redrawing();
        kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_bt_link_lt_enter_tab_page:is_redraw = %d", is_redraw);
        if(is_redraw)
        {        
            gui_buffer = (U8*)mmi_frm_scrn_get_active_gui_buf();
            mmi_clog_pbapc_show_category(1, gui_buffer);
        }
        else
        {
            if(!g_mmi_clog_pbapc_cntx.is_from_close_pop)
            {
                mmi_clog_bt_dialer_show(inst);
            }
            else
            {
                g_mmi_clog_pbapc_cntx.is_from_close_pop = MMI_FALSE;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_no_conn_show_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
void mmi_clog_bt_link_no_conn_show_list(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_tab_page_struct *page)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 category_error_flag;
    U8 index;
    MMI_BOOL has_lsk;
    U8 *gui_buffer;
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_DIALER_NO_CONN_SHOW_LIST);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ 
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
    gui_buffer = (U8*)cui_tab_get_screen_gui_buf(inst->tab_id,page->scrn_id);
#else
    index = mmi_frm_scrn_tab_get_active_page_index();

    gui_buffer = (U8*)mmi_frm_scrn_tab_page_get_active_gui_buf();

#endif


    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();

    if (!srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &pbapc_cntx->addr[pbapc_cntx->index]))
    {
        has_lsk  = MMI_TRUE;
    }
    else
    {
        has_lsk = MMI_FALSE;
    }
    
    wgui_cat1031_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        has_lsk ? get_string(STR_GLOBAL_CONNECT): NULL,
        NULL,
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        0,
        NULL,
        NULL,
        inst->sel_log_idx,
        index,
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
    SetRightSoftkeyFunction(mmi_clog_lt_rsk_hdlr,KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id = mmi_frm_group_get_active_id();

    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx  = mmi_clog_get_pbapc_cntx_ex();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (srv_bt_cm_get_busy_dev() == NULL)
    {
        g_local_index =  pbapc_cntx->index;
        srv_pbapc_set_query_func(mmi_clog_bt_pbap_set_index_cb);
    }
    mmi_bt_dialer_show_popup(group_id);

}


static S32 mmi_clog_bt_pbap_set_index_cb(srv_pbapc_query_req_struct *req)
{
    req->bt_index = g_local_index;

    srv_pbapc_set_query_func(NULL);
    return 0;

}
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_conn_profile_lsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_conn_profile_lsk_hdlr()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_id cui_id;
    U8 index;
    srv_bt_cm_bt_addr addr;
    mmi_clog_pbapc_ex_inst_struct* pbapc_cntx = NULL;
    MMI_ID group_id = mmi_frm_group_get_active_id();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CLOG_TRC_INFO, TRC_MMI_CLOG_BT_DIALER_CONN_LSK_HDLR, group_id);
   // mmi_bt_dialer_conn_profile(NULL, group_id, SRV_BT_CM_PBAPC_CONNECTION, mmi_clog_bt_link_conn_profile_cb);
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    index = pbapc_cntx->index;
    addr = pbapc_cntx->addr[index];
    cui_id = cui_bt_dialer_connecting_create(group_id);
    if (cui_id != GRP_ID_INVALID)
    {
        pbapc_cntx->cui_id = cui_id;
        cui_bt_dialer_connecting_run(cui_id);
       pbapc_cntx->ret = srv_pbapc_connect(&addr, mmi_clog_bt_link_conn_profile_cb);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_conn_profile_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
//void mmi_clog_bt_link_conn_profile_cb(srv_bt_cm_connection_type conn_type,MMI_BOOL result,MMI_BOOL is_connect)
static void mmi_clog_bt_link_conn_profile_cb(srv_bt_cm_bt_addr *dev_addr, srv_bt_cm_connection_type conn_type, MMI_BOOL result, MMI_BOOL is_connect, MMI_BOOL is_indicate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    U16 str_id;
    mmi_clog_pbapc_ex_inst_struct* pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    MMI_TRACE(MMI_CLOG_TRC_INFO, TRC_MMI_CLOG_BT_DIALER_CONN_CB, result);
    //mmi_frm_scrn_close(GRP_ID_CLOG_LAYOUT,SCR_BT_CONNECTING);
    cui_bt_dialer_connecting_close(pbapc_cntx->cui_id);
    //mmi_bt_dialer_conn_profile_end(SRV_BT_CM_PBAPC_CONNECTION);// this is reset callback
    if (!result)
    {
        if (pbapc_cntx->ret != SRV_PBAPC_RET_OK)
        {
            str_id =  STR_GLOBAL_CURRENTLY_NOT_AVAILABLE;
        }
        else
        {
            str_id = STR_BT_CONN_FAILED;

        }
        mmi_frm_nmgr_popup(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_FAILURE,
        (WCHAR*)GetString(str_id));

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_get_menu_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static MMI_MENU_ID mmi_clog_bt_get_menu_id(mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(lt_id)
    {
        case MMI_CLOG_LT_ID_DIALED_CALL:
            return MENU_ID_CLOG_PBAPC_DIALED_CALL;
        case MMI_CLOG_LT_ID_MISSED_CALL:
            return MENU_ID_CLOG_PBAPC_MISSED_CALL;
        case MMI_CLOG_LT_ID_RECVED_CALL:
            return MENU_ID_CLOG_PBAPC_RECVED_CALL;
        case MMI_CLOG_LT_ID_ALL_CALL:
            return MENU_ID_CLOG_PBAPC_ALL_CALL;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_update_list_by_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
MMI_RET mmi_clog_update_list_by_status(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_set_bt_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
void mmi_clog_set_bt_status(U8 index)
{
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL;
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_SET_STATUS_0,pbapc_cntx->flag[index]);
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_TELEPHONY_SUPPORT__
    g_high_index[pbapc_cntx->index][0] = 1;
    g_high_index[pbapc_cntx->index][1] = 1;
    g_high_index[pbapc_cntx->index][2] = 1;
    g_high_index[pbapc_cntx->index][3] = 1;
    #else /*__MMI_TELEPHONY_SUPPORT__*/
    g_high_index[pbapc_cntx->index][0] = 0;
    g_high_index[pbapc_cntx->index][1] = 0;
    g_high_index[pbapc_cntx->index][2] = 0;
    g_high_index[pbapc_cntx->index][3] = 0; 
    #endif /*__MMI_TELEPHONY_SUPPORT__*/
#else
#ifdef __MMI_TELEPHONY_SUPPORT__

    g_high_index[0] = 1;
    g_high_index[1] = 1;
    g_high_index[2] = 1;
    g_high_index[3] = 1;
#endif
#endif 
    pbapc_cntx->flag[index] = 0;/*still need change .*/
    pbapc_cntx->only_update[index] = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_exit_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    U16 index = 0;
    //wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
    MMI_MENU_ID sel_menu_id;
    inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;
    sel_menu_id = mmi_clog_bt_get_menu_id(inst->sel_lt_id);
    //mmi_clog_pbapc_free_op_handle();
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    switch (sel_menu_id)
    {
        case MENU_ID_CLOG_PBAPC_DIALED_CALL:
            index = 0;
            break;
        case MENU_ID_CLOG_PBAPC_MISSED_CALL:
            index = 1;
            break;

        case MENU_ID_CLOG_PBAPC_RECVED_CALL:
            index = 2;
            break;
        case MENU_ID_CLOG_PBAPC_ALL_CALL:
            index = 3;
            break;
        default:
            break;
    }
#if SRV_PBAPC_LINK_NUM >= 2
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    g_high_index[pbapc_cntx->index][index] = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    g_high_index[pbapc_cntx->index][index] = mmi_frm_scrn_tab_get_active_page_index();  
#endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/

MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_PAGE_MENU,pbapc_cntx->index,g_high_index[pbapc_cntx->index][index]);

#else /*SRV_PBAPC_LINK_NUM >= 2*/
#ifdef __MMI_TELEPHONY_SUPPORT__
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    g_high_index[index] = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    g_high_index[index] = mmi_frm_scrn_tab_get_active_page_index();  
#endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#endif
#endif/*SRV_PBAPC_LINK_NUM >= 2*/
    g_mmi_clog_pbapc_cntx.is_from_close_pop = MMI_FALSE;

    wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_bt_scrn_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_lt_bt_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;
        
    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
        {
#ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_clog_lt_load_log_ids(inst);
            }
            else
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
            {
                mmi_clog_lt_refresh_data(inst);
            }
            mmi_clog_lt_show_list(inst);
        }
        break;

        default:
            break;
    }  

    return MMI_RET_OK;
}


#ifdef __MMI_BT_PBAP_CLIENT__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_get_page_index_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_bt_link_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < 2; i++)
    {
        if (g_mmi_clog_bt_link_tab_id.lt_ids[i] == lt_id)
            return i;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_bt_link_get_page_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_bt_tab_page_struct *mmi_clog_lt_bt_link_get_page_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_bt_tab_struct *tab = g_mmi_clog_bt_link_lt_scrn_data.tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    U32 j;
#ifdef __MMI_TELEPHONY_SUPPORT__
    for (i = 0; i < (SRV_PBAPC_LINK_NUM +1); i++)
#else
		for(i =0; i< SRV_PBAPC_LINK_NUM; i++)
#endif
        for(j = 0; j< 4; j++ )
    {
            if (tab->page[i] && tab->page[i]->image[j]->lt_id == lt_id && tab->page[i]->image[j]->lt_type == inst->sel_lt_id)
                return tab->page[i]->image[j];
    }
#else
#ifdef __MMI_TELEPHONY_SUPPORT__
    for (i = 0; i < (SRV_PBAPC_LINK_NUM +1); i++)
#else
		for(i =0; i< SRV_PBAPC_LINK_NUM; i++)
#endif
    {
        if (tab->page[i] && tab->page[i]->lt_id == lt_id)
            return tab->page[i];
    }
#endif
    MMI_CLOG_IT_ASSERT(0);
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_fill_tab_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num)
{
    U32 i;
    const mmi_clog_lt_bt_tab_page_struct *page;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_mmi_clog_bt_link_tab_id.tab_num && i < page_num; i++)
    {
        page = mmi_clog_lt_bt_link_get_page_by_lt_id(inst, g_mmi_clog_bt_link_tab_id.lt_ids[i]);
        page_info[i].screen_id = page->scrn_id;
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
        page_info[i].tab_string = NULL;
        page_info[i].tab_icon = GetImage(page->img_id);
#else
        page_info[i].tab_icon = NULL;//(U8*) GetImage(page->img_id);
        page_info[i].tab_string = GetString(page->str_id);
#endif
        page_info[i].tab_entry_func = g_mmi_clog_bt_link_lt_scrn_data.tab->page_hdlr;
        page_info[i].user_data = inst;
    }

}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_show_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_show_list(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    S32 has_lsk = MMI_FALSE;
    S32 category_error_flag;
    U32 log_number = 0;
    U32 count = 0;
#ifdef __MMI_CLOG_SIM_FILTER__
    srv_clog_log_struct log;
    S32 ret;
    U32 i = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_pre_enter(inst);

/* close nmgr */
    if (inst->sel_lt_id == MMI_CLOG_LT_ID_MISSED_CALL 
        || inst->sel_lt_id == MMI_CLOG_LT_ID_ALL_CALL)
    {
        if(nmgr_handle != NULL)
        {
            mmi_frm_nmgr_alert_cancel(nmgr_handle);
            nmgr_handle = NULL;
        }

#ifdef __MMI_NCENTER_SUPPORT__
        vsrv_ncenter_close_notification(g_ncenter_hdl);
#endif /*__MMI_NCENTER_SUPPORT__*/
    }

    count = inst->log_data.total_num;
    if (count)
        has_lsk = MMI_TRUE;

#ifdef __MMI_CLOG_SIM_FILTER__
    count = 0;

    for (i=0; i<inst->log_data.total_num; i++)
    {
        ret = srv_clog_get_log_by_id(inst->log_data.handle,
            mmi_clog_get_id_by_idx(inst->sel_lt_id, i), 0, &log);
        if (ret != SRV_CLOG_RET_OK)
        {
            break;
        }
        count++;
    }   
#endif /*__MMI_CLOG_SIM_FILTER__*/

    log_number = count;
    if (log_number == 0)
#ifndef __MMI_CLOG_FPBW__        
        has_lsk = MMI_FALSE;
#else /*__MMI_CLOG_FPBW__*/
    {
        mmi_clog_popup(STR_GLOBAL_EMPTY, MMI_EVENT_FAILURE, inst->self_gid, inst);
        mmi_frm_scrn_close_active_id();
        return ;
    }
#endif /*__MMI_CLOG_FPBW__*/

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();
    if (MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED))
    {
        gui_buffer = NULL;
        MMI_CLOG_CLEAR_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);
    }

#ifdef __MMI_CLOG_MARK_SEVERAL__
    if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
    {
        RegisterHighlightHandler(mmi_clog_mark_several_hlt_hdlr);
        
        wgui_cat1024_show(
            get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
            (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
            get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id),
            (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id),
            get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
            (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
            NULL,
            log_number,//(S32) inst->log_data.total_num,
            mmi_clog_lt_get_multi_log_items,
        #ifndef __MMI_CLOG_FPBW__
            mmi_clog_lt_get_log_hint,
        #else /*__MMI_CLOG_FPBW__*/
            NULL,
        #endif /*__MMI_CLOG_FPBW__*/
            mmi_clog_mark_several_get_state,
            mmi_clog_mark_several_set_state,
        #ifndef __MMI_CLOG_FPBW__
            IMG_ID_CLOG_MISSED_CALL,
            IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        #else /*__MMI_CLOG_FPBW__*/
            NULL,
            NULL,
        #endif /*__MMI_CLOG_FPBW__*/
            inst->sel_log_idx,
            gui_buffer);

        mmi_clog_mark_several_set_key_hdlr(inst);
        return;
    }
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
 
#if !defined(__MMI_CLOG_TAB_SUPPORT__)
    RegisterHighlightHandler(mmi_clog_lt_item_hlt_hdlr);

  #ifndef __MMI_CLOG_FPBW__
    wgui_cat1031_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        mmi_clog_lt_get_log_hint,
        inst->sel_log_idx,
        0,
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
  #else /*__MMI_CLOG_FPBW__*/
    wgui_cat1032_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        NULL,
        inst->sel_log_idx,
        0,
        NULL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
  #endif /**__MMI_CLOG_FPBW__*/
  
    mmi_clog_lt_set_key_hdlr(inst);
    
 #endif /*!defined(__MMI_CLOG_TAB_SUPPORT__)*/
} 


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_pre_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_pre_enter(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_ICON_BAR_SUPPORT__)
    mmi_clog_lt_tb_create(inst);
    mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_ICON_BAR_SUPPORT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_log_item
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item_index          [IN]        
 *  str_buff            [IN]        
 *  img_buff_p          [IN]        
 *  str_img_mask        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static pBOOL mmi_clog_lt_get_log_item(S32 item_index, UI_string_type str_buff, U8 **img_buff_p, U8 str_img_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    mmi_clog_lt_inst_struct *inst;
    srv_clog_log_struct log;
    U16 sim_image_id;
    U32 sim_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    if (item_index < 0 || item_index >= (S32) inst->log_data.total_num)
    {
        MMI_CLOG_ASSERT(item_index < (S32) inst->log_data.total_num);
        return MMI_FALSE;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, item_index),
                0, // default All fileds
                &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    if (ret != SRV_CLOG_RET_OK)
    {
        str_buff[0] = '\0';
        *img_buff_p = NULL;
        return MMI_FALSE;
    }
    mmi_clog_lt_get_string(inst, &log, str_buff);
    
#ifndef __MMI_CLOG_FPBW__

  #if (MMI_MAX_SIM_NUM >= 2)
    img_buff_p[0] =
        (U8*) GetImage(mmi_clog_get_image((const srv_clog_log_identity_struct*)&log.data.call_log));

  /* For list_icon2, as IMG_GLOBAL_SIMx is defined in number order, so we can use the rule to slim it,
   if unlickily this rule is changed, we can easy find this error in SQC stage, 
   better to provide a common API for this in a common module
  */

    sim_idx = MMI_CLOG_BIT2IDX(log.data.call_log.sim_id);
    sim_image_id = IMG_GLOBAL_SIM1 + sim_idx;

    img_buff_p[1] = (U8 *)GetImage(sim_image_id);
    
  #else /* MMI_MAX_SIM_NUM >= 2 */

    *img_buff_p =
        (U8*) GetImage(mmi_clog_get_image((const srv_clog_log_identity_struct*)&log.data.call_log));

  #endif /* MMI_MAX_SIM_NUM >= 2 */

#else /*__MMI_CLOG_FPBW__*/

  #if (MMI_MAX_SIM_NUM >= 2)
  /* For list_icon2, as IMG_GLOBAL_SIMx is defined in number order, so we can use the rule to slim it,
   if unlickily this rule is changed, we can easy find this error in SQC stage, 
   better to provide a common API for this in a common module
  */
    img_buff_p[0] = NULL;
    sim_idx = MMI_CLOG_BIT2IDX(log.data.call_log.sim_id);
    sim_image_id = IMG_GLOBAL_SIM1 + sim_idx; 
    img_buff_p[1] = (U8 *)GetImage(sim_image_id);
    
  #else /* MMI_MAX_SIM_NUM >= 2 */
  
    *img_buff_p = NULL;
  
  #endif /* MMI_MAX_SIM_NUM >= 2 */
    
#endif /*__MMI_CLOG_FPBW__*/
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst            [IN]     
 *  log             [IN]     
 *  str_buff        [OUT]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_get_string(mmi_clog_lt_inst_struct *inst, srv_clog_log_struct *log, WCHAR *str_buff)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CLOG_FPBW__
    WCHAR post[20];
#endif /*__MMI_CLOG_FPBW__*/
    U32 post_len = 0;   
    const WCHAR *unknown_cid;
    srv_clog_call_log_struct *call_log = &log->data.call_log;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CLOG_FPBW__
    if (call_log->total_num > 1)
    {
        kal_wsprintf(post, " (%d)", call_log->total_num);
        post_len = mmi_wcslen(post);
    }
#endif /*__MMI_CLOG_FPBW__*/
    if (mmi_clog_is_name_empty(log) && mmi_clog_is_cid_empty(log))
    {
        unknown_cid = (const WCHAR*)get_string(STR_ID_CLOG_UNKNOWN_NUMBER);	
        mmi_wcsncpy((WCHAR*) str_buff, unknown_cid, MAX_SUBMENU_CHARACTERS);
    }
    else if (mmi_clog_is_name_empty(log))
    {
        mmi_wcsncpy((WCHAR*) str_buff, (const WCHAR*)call_log->cid, MAX_SUBMENU_CHARACTERS - post_len);
    }
    else
    {
        mmi_wcsncpy((WCHAR*) str_buff, (const WCHAR*)call_log->name, MAX_SUBMENU_CHARACTERS - post_len);
    }
#ifndef __MMI_CLOG_FPBW__
    if (post_len)
        mmi_wcscat((WCHAR*) str_buff, (const WCHAR*)post);
#endif /*__MMI_CLOG_FPBW__*/
}


#ifndef __MMI_CLOG_FPBW__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_log_hint
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item_index      [IN]        
 *  hint_array      [OUT]         
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_get_log_hint(S32 item_index, UI_string_type *hint_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    mmi_clog_lt_inst_struct *inst;
    srv_clog_log_struct log;
    applib_time_struct app_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    if (item_index < 0 || item_index >= (S32) inst->log_data.total_num)
    {
        /* MMI_CLOG_ASSERT(item_index < (S32) inst->log_data.total_num); */
        return MMI_FALSE;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, item_index),
                0, // default All fileds
                &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    if (ret != SRV_CLOG_RET_OK)
    {
        hint_array[0][0] = 0;
        return MMI_FALSE;
    }
    if (log.data.call_log.timestamp[SRV_CLOG_LASTEST_TIME_IDX] == 0)
    {
        hint_array[0][0] = 0;
    }
    else
    {
        mmi_clog_time_utc2app(log.data.call_log.timestamp[SRV_CLOG_LASTEST_TIME_IDX], &app_time);
        date_string((UI_time*) & app_time, hint_array[0], DT_IDLE_SCREEN);
        mmi_wcscat(hint_array[0], L" ");
        time_string((UI_time*) & app_time, 
            (UI_string_type) (hint_array[0] + mmi_wcslen((const WCHAR*)hint_array[0])), 
            DT_IDLE_SCREEN);
    }
    return MMI_TRUE;
}

#endif /*__MMI_CLOG_FPBW__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_multi_log_items
 * DESCRIPTION
 *  Asyncdynamic list item load function
 * PARAMETERS
 *  start_index      :    [IN]     Start index of menu item
 *  menu_data        :    [OUT]    A pointer of parameter to store the menu data
 *  item_count        :    [IN]     The number of load menu items
 * RETURNS
 *  S32
 * RETURN VALUES
 *  Number of items can be retrieved
 *****************************************************************************/
static S32 mmi_clog_lt_get_multi_log_items(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count)
{
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    S32 total_count;
    S32 i, items = 0;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();
    
    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    total_count = (S32) inst->log_data.total_num;
    
    for (i = start_index; items < item_count && i < total_count; i++, items++)
    {
        mmi_clog_lt_get_log_item(i, 
            menu_data[items].item_list[0], 
            menu_data[items].image_list, 0);
    }
    return items;
}


#define MMI_CLOG_LT_HDLR


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_item_hlt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sel     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_item_hlt_hdlr(S32 sel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    inst->sel_log_idx = sel;
    mmi_clog_lt_update_sel_log_id(inst);

#if defined(__MMI_ICON_BAR_SUPPORT__)
    mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_key_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num)
    {
        mmi_ucm_handle_sendkeys_for_call(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_SEND], KEY_EVENT_DOWN);

    #ifdef __MMI_IP_KEY__
/* under construction !*/
    #endif 

        mmi_clog_lt_set_csk_key(MMI_TRUE);
        SetLeftSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_LSK], KEY_EVENT_UP);
    }
    else
    {
        /* only show LSK option if in tab style and has advanced menu items */
#if (defined(__MMI_CLOG_CALL_TIME__) || defined(__MMI_CLOG_CALL_COST__) || defined(__MMI_CLOG_SMS_COUNT__) || defined(__MMI_CLOG_GPRS_COUNT__))
        if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        {
            mmi_clog_lt_set_csk_key(MMI_FALSE);
            SetLeftSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_LSK], KEY_EVENT_UP);
        }
#endif /* __MMI_CLOG_CALL_TIME__ || __MMI_CLOG_CALL_COST__ || __MMI_CLOG_SMS_COUNT__ || __MMI_CLOG_GPRS_COUNT__ */

    }

    SetRightSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_RSK], KEY_EVENT_UP);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_set_horizontal_tab_bar_select_callback(mmi_frm_set_cur_sel_page);
#endif 

#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    mmi_clog_lt_set_tap_hdlr(inst);
#endif 

#ifdef __MMI_CLOG_SIM_SYNC_TEST__
    {
        extern void srv_clog_sim_pwon_test(void);
        extern void srv_clog_sim_pwoff_test(void);
        extern void srv_clog_sim_sat_refresh_test(void);

        SetKeyHandler(srv_clog_sim_pwon_test, KEY_VOL_UP, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_pwoff_test, KEY_VOL_DOWN, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_sat_refresh_test, KEY_CAMERA, KEY_EVENT_UP);

        SetKeyHandler(srv_clog_sim_pwon_test, KEY_STAR, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_pwoff_test, KEY_POUND, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_sat_refresh_test, KEY_0, KEY_EVENT_UP);
    }

#endif /* __MMI_CLOG_SIM_SYNC_TEST__ */ 

#ifdef __MMI_CLOG_REVISE_LOGS_TEST__
    {
        extern void srv_clog_revise_log_test(void);

        SetKeyHandler(srv_clog_revise_log_test, KEY_9, KEY_EVENT_UP);
    }
#endif /* __MMI_CLOG_REVISE_LOGS_TEST__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_csk_key
 * DESCRIPTION
 *  
 * PARAMETERS
 *  is_predef       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_csk_key(S32 is_predef)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_predef)
    {
        EnableCenterSoftkey(
            g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_CSK]->str_id,
            g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_CSK]->img_id);

        SetCenterSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_CSK], KEY_EVENT_UP);
    }
    else
    {
        EnableCenterSoftkey(0, IMG_GLOBAL_OPTION_CSK);
        SetCenterSoftkeyFunction(mmi_clog_lt_lsk_hdlr, KEY_EVENT_UP);
    }
    redraw_center_softkey();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_lsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_op_enter();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_rsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_rsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    mmi_frm_group_close(GRP_ID_CLOG_LAYOUT);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    mmi_frm_scrn_close_active_id();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_csk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_csk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_viewer_enter();
}

#ifdef __MMI_IP_KEY__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_IP_KEY__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_send_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_send_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_act_proc(MMI_CLOG_OP_MID_MAKE_CALL, MMI_CLOG_ACT_FLAG_CALL_BY_SEND_KEY);
}

#if defined(__MMI_ICON_BAR_SUPPORT__)

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_create
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_create(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U32 i;
    U32 j;
    U8 *enb_icons[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    U8 *dis_icons[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    U8 *strings[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    const mmi_clog_lt_tb_struct *tb;
    const mmi_clog_lt_tb_item_struct *item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return;
    tb = g_mmi_clog_lt_scrn_data.fte->tb;
    if (!tb || !tb->items || !tb->total_num)
        return;
    
    for (i = 0, j = 0; i < tb->total_num; i++)
    {
        item = &tb->items[i];
        if (!item)
            break;
        enb_icons[j] = (U8*) GetImage(item->enb_img_id);
        dis_icons[j] = (U8*) GetImage(item->dis_img_id);
        strings[j] = (U8*) get_string(item->str_id);
        j++;
    }
    wgui_icon_bar_setup(j++, enb_icons, dis_icons, strings, tb->tb_hdlr);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_refresh
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_refresh(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 enb_bits;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    enb_bits = mmi_clog_lt_tb_get_enb_items(inst);
    mmi_clog_lt_tb_set_enb_state(inst, (mmi_clog_lt_tb_id_enum)enb_bits, MMI_TRUE);
    wgui_icon_bar_update();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_get_enb_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static U32 mmi_clog_lt_tb_get_enb_items(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    U32 enb_bits = MMI_CLOG_LT_TB_ID_ALL;
    srv_clog_log_struct log;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num == 0)
    {
        enb_bits = 0;
        return enb_bits;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
            inst->log_data.handle,
            inst->sel_log_id,
            SRV_CLOG_LOG_FIELD_IDENTITY | SRV_CLOG_LOG_FIELD_CID,
            &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    if (ret != SRV_CLOG_RET_OK || mmi_clog_is_cid_empty(&log))
    {
        enb_bits = 0;
        return enb_bits;
    }

    if (log.data.call_log.sub_type == SRV_CLOG_CALL_TYPE_VOIP)
    {
        MMI_CLOG_CLEAR_BIT(enb_bits, MMI_CLOG_LT_TB_ID_ALL_MSG | MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL);
    }
    else
    {
    #ifndef __MMI_UNIFIED_COMPOSER__
    #ifdef __MMI_MMS__
        if (!mms_is_ready())
            MMI_CLOG_CLEAR_BIT(enb_bits, MMI_CLOG_LT_TB_ID_SEND_MMS);
    #endif /* __MMI_MMS__ */ 
    #endif /* __MMI_UNIFIED_COMPOSER__ */ 
    }

    return enb_bits;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_action_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_action_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;
    const mmi_clog_lt_tb_item_struct *item;
    mmi_clog_op_mid_enum op_mid = MMI_CLOG_OP_MID_MAKE_CALL;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    item = mmi_clog_lt_get_tb_item_by_index(inst, index);
    switch (item->tb_id)
    {
        case MMI_CLOG_LT_TB_ID_MAKE_CALL:
            op_mid = MMI_CLOG_OP_MID_MAKE_CALL;

#ifdef __OP01_3G__
           // flags = MMI_CLOG_ACT_FLAG_CALL_VOICE_ONLY;
#endif
            break;

#if(defined(__OP01_3G__) && defined(__MMI_VIDEO_TELEPHONY__)) 
        case MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL:
            op_mid = MMI_CLOG_OP_MID_MAKE_CALL;
            flags = MMI_CLOG_ACT_FLAG_CALL_VIDEO_ONLY;
            break;
#endif /* __OP01_3G__ && __MMI_VIDEO_TELEPHONY__ */

        case MMI_CLOG_LT_TB_ID_SEND_MSG:
            op_mid = MMI_CLOG_OP_MID_SEND_MSG;
            break;

        case MMI_CLOG_LT_TB_ID_SEND_SMS:
            op_mid = MMI_CLOG_OP_MID_SEND_SMS;
            break;

        case MMI_CLOG_LT_TB_ID_SEND_MMS:
            op_mid = MMI_CLOG_OP_MID_SEND_MMS;
            break;

        default:
            MMI_CLOG_IT_ASSERT(0);
            break;
    }

    mmi_clog_lt_act_proc(op_mid, flags);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_tb_item_by_index
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [?]         
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_tb_item_struct *mmi_clog_lt_get_tb_item_by_index(mmi_clog_lt_inst_struct *inst, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const mmi_clog_lt_tb_struct *tb;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return NULL;

    tb = g_mmi_clog_lt_scrn_data.fte->tb;

    if (!tb || !tb->items || !tb->total_num)
        return NULL;

    MMI_CLOG_ASSERT(index >= 0 && index < tb->total_num);

    return &tb->items[index];
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_set_enb_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [?]         
 *  ids         [IN]        
 *  enable      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_set_enb_state(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_tb_id_enum ids, S32 enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tb_item_struct *item;
    const mmi_clog_lt_tb_struct *tb;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return;

    tb = g_mmi_clog_lt_scrn_data.fte->tb;

    if (!tb || !tb->items || !tb->total_num)
        return;
    
    for (i = 0; i < tb->total_num; i++)
    {
        item = &tb->items[i];
        if (!item)
            break;
        if (MMI_CLOG_CHECK_BIT(ids, item->tb_id))
        {
            wgui_icon_bar_set_item_enable_state(i, (MMI_BOOL)enable);
        }
        else
        {
            wgui_icon_bar_set_item_enable_state(i, (MMI_BOOL)!enable);
        }
    }
}

#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/


#if defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_tap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_tap_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_register_tap_callback(mmi_clog_lt_tap_action_hdlr);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tap_action_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  tap_type        [IN]        
 *  index           [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tap_action_hdlr(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (tap_type == ENUM_TAP_ON_HIGHLIGHTED_ITEM)
    {
        mmi_clog_lt_viewer_enter();
    }
}

#endif /*defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)*/


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_op_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_op_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_op_para_struct para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    para.flags = 0;
    if (inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
        para.type = MMI_CLOG_OP_TYPE_LT_LIST;
    
#ifdef __MMI_CLOG_TAB_SUPPORT__
    else if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        para.type = MMI_CLOG_OP_TYPE_LT_TAB;
#endif /* __MMI_CLOG_TAB_SUPPORT__ */

    else
    {
        MMI_CLOG_IT_ASSERT(0);
    }
    para.sel_lt_id = inst->sel_lt_id;
    para.handle = inst->log_data.handle;
    para.log_id = inst->sel_log_id;
    mmi_clog_op_enter(inst->self_gid, &para);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_viewer_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_viewer_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    S32 ret;
//    U32 merge_style;

    mmi_clog_lt_inst_struct *inst;
    mmi_clog_vr_create_struct create;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    create.handle = inst->log_data.handle;
    create.log_id = inst->sel_log_id;

    create.mode = MMI_CLOG_VR_DEF_MODE;
    create.style = MMI_CLOG_VR_DEF_STYLE;
    if (inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
        MMI_CLOG_SET_BIT(create.style, MMI_CLOG_VR_STYLE_LT_LIST);
#ifdef __MMI_CLOG_TAB_SUPPORT__
    else if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        MMI_CLOG_SET_BIT(create.style, MMI_CLOG_VR_STYLE_LT_TAB);
#endif /* __MMI_CLOG_TAB_SUPPORT__ */
    else
    {
        MMI_CLOG_IT_ASSERT(0);
    }

    create.lt_type = inst->lt_type;
    create.sel_lt_id = inst->sel_lt_id;
    create.sup_merge = (MMI_CLOG_STYLE_MERGE == 0 ? MMI_FALSE : MMI_TRUE);

    mmi_clog_vr_create_and_run(inst->self_gid, &create);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_act_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  op_mid      [IN]        
 *  flags       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_ID mmi_clog_lt_act_proc(mmi_clog_op_mid_enum op_mid, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    mmi_clog_op_para_struct para;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    mmi_clog_act_para_struct para;
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    para.handle = inst->log_data.handle;
    para.log_id = inst->sel_log_id;
    para.op_mid = op_mid;
    para.sel_lt_id = inst->sel_lt_id;
    para.flags = flags;
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    return mmi_clog_op_run(inst->self_gid, &para);
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    return mmi_clog_act_proc(inst->self_gid, &para);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
}

#define MMI_CLOG_LT_LOG


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_log_start
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_log_start(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    U32 style;
    srv_clog_create_struct create;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE))
    {
        srv_clog_init_para(SRV_CLOG_PARA_CREATE, &create);
        create.user_data = inst;
        inst->log_data.handle = srv_clog_create(&create);
        MMI_CLOG_ASSERT(inst->log_data.handle);
    }
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_data
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_data(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_update_read_status(inst);
    mmi_clog_lt_load_log_ids(inst);
    /* Can only refresh current index of select lt_id */
    mmi_clog_lt_refresh_sel_index(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_update_read_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_update_read_status(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 ur_num;
    const mmi_clog_lt_id_attr_struct *attr;
    srv_clog_update_all_logs_req_struct req_data;

    MMI_ID gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //if (inst->sel_lt_id != MMI_CLOG_LT_ID_MISSED_CALL && inst->sel_lt_id != MMI_CLOG_LT_ID_ALL_CALL)
    //    return;

    gid = mmi_frm_scrn_get_active_id();

    if ((gid != SCR_ID_CLOG_LAYOUT
#ifdef __MMI_BT_PBAP_CLIENT__
      && gid != GRP_ID_CLOG_SUB_LOCAL
#endif /* __MMI_BT_PBAP_CLIENT__ */
        )
     || (inst->sel_lt_id != MMI_CLOG_LT_ID_MISSED_CALL && inst->sel_lt_id != MMI_CLOG_LT_ID_ALL_CALL))
        return;

    ur_num = srv_clog_get_unread_missed_call_num();
    if (ur_num == 0)
        return;

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_UPDATE_READ_STATUS,
        inst->self_gid,
        inst->sel_lt_id,
        inst->sel_log_idx,
        inst->sel_log_id));

    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);

    memcpy((srv_clog_log_identity_struct*) & req_data, &attr->idt, sizeof(srv_clog_log_identity_struct));
    req_data.req_fields = SRV_CLOG_LOG_FIELD_UNREAD_NUM;
    req_data.read = MMI_TRUE;
    srv_clog_update_all_logs(inst->log_data.handle, 0, &req_data, NULL);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_sel_index
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_sel_index(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    U32 j;
    U32 max_num;
    U16 old_sel_idx;
    SRV_CLOG_ID old_sel_log_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SRV_CLOG_IS_ELM_INVALID(inst->sel_log_id))
    {
        mmi_clog_lt_update_sel_log_id(inst);
        return;
    }

    if (inst->sel_log_id == mmi_clog_get_id_by_idx(inst->sel_lt_id, inst->sel_log_idx))
        return;

    old_sel_idx = inst->sel_log_idx;
    old_sel_log_id = inst->sel_log_id;
    max_num = inst->log_data.total_num;
    for (i = 0, j = inst->sel_log_idx; i < max_num; i++)
    {
        if (j >= max_num)
            j = 0;
        if (old_sel_log_id == mmi_clog_get_id_by_idx(inst->sel_lt_id, j))
        {
            inst->sel_log_idx = j;
            break;

        }
        j++;
    }

    if (i == max_num)   /* not found, must be deleted, try to highlight next one */
    {
        /* If some log before current selected one are deleted, should find the right index above,
           if current selected log or some log after this is deleted, just highlight next log,
           if current log is the last one, just highlight the previous one, 
           the rule is not to change user's view point except use make a call and merge it */
        if (inst->sel_log_idx > 0 && inst->sel_log_idx >= max_num)
        {
            inst->sel_log_idx--;
        }
        mmi_clog_lt_update_sel_log_id(inst);
    }
    if (inst->sel_log_idx != old_sel_idx)
        MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_REFRESH_SEL_INDEX,
        old_sel_log_id,
        inst->sel_log_id,
        old_sel_idx,
        inst->sel_log_idx,
        MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED)));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_load_log_ids
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_load_log_ids(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_log_identity_struct identity;
    srv_clog_num_info_struct num_info;
    const mmi_clog_lt_id_attr_struct *attr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_clog_init_para(SRV_CLOG_PARA_NUM_INFO, &num_info);
    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);
    SRV_CLOG_INIT_IDT(
        &identity,
        attr->idt.cate,
        attr->idt.sim_id,
        attr->idt.log_type,
        attr->idt.sub_type);
    
    srv_clog_get_list_num_info(inst->log_data.handle,
        (const srv_clog_log_identity_struct *) &identity, &num_info);
    inst->log_data.total_num = num_info.num[SRV_CLOG_LOG_NUM_TYPE_TOTAL_LOGS];
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


#ifdef __MMI_CLOG_EVENT_REFRESH_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_srv_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
MMI_RET mmi_clog_lt_srv_evt_hdlr(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_lt_cntx_struct *cntx = mmi_clog_lt_get_cntx();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_CLOG_LT_INST_MAX_NUM == 1)
    {
        inst = &cntx->inst_list[0];
        if (MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT) &&
            inst->log_data.handle != ((srv_clog_evt_log_op_struct*) evt)->handle)
        {
        #ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_frm_group_close(inst->self_gid);
            }
            else
        #endif
            {
                mmi_clog_lt_inst_srv_evt_hdlr(inst, evt);
            }
        }
    }
    else
    {
        for (i = 0; i < MMI_CLOG_LT_INST_MAX_NUM; i++)
        {
            inst = &cntx->inst_list[i];

            if (!MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT))
                continue;

            if (inst->log_data.handle == ((srv_clog_evt_log_op_struct*) evt)->handle)
                continue;
            
        #ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_frm_group_close(inst->self_gid);
            }
            else
        #endif
            {
                mmi_clog_lt_inst_srv_evt_hdlr(inst, evt);
            }
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_inst_srv_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 *  evt         [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_inst_srv_evt_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SRV_CLOG_ADD_LOG:
            mmi_clog_lt_inst_srv_evt_add_log_hdlr(inst, evt);
            break;

        case EVT_ID_SRV_CLOG_DEL_LOG:
        case EVT_ID_SRV_CLOG_DEL_ALL:
        case EVT_ID_SRV_CLOG_UPDATE_LOG:
        case EVT_ID_SRV_CLOG_UPDATE_ALL:
            mmi_clog_lt_refresh_int(inst);
            break;

        default:
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_inst_srv_evt_add_log_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 *  evt         [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_inst_srv_evt_add_log_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_evt_add_log_struct *srv_evt = (srv_clog_evt_add_log_struct*) evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_evt->add_ret == SRV_CLOG_ADD_LOG_RET_PURE_MERGE)
    {
        MMI_CLOG_ASSERT(!SRV_CLOG_IS_ELM_INVALID(srv_evt->old_idf.log_id));
        if (inst->sel_log_id == srv_evt->old_idf.log_id)
        {
            /* Set new log id here, and will update the sel_idx in mmi_clog_lt_refresh_int after reload the data */
            inst->sel_log_id = srv_evt->new_idf.log_id;

            MMI_CLOG_IT_TRACE((
                MMI_CLOG_TRC_INFO,
                TRC_MMI_CLOG_LT_INST_SRV_EVT_ADD_LOG_HDLR,
                srv_evt->add_ret,
                inst->sel_lt_id,
                inst->sel_log_idx,
                inst->sel_log_id,
                srv_evt->new_idf.log_id));

        }
    }
    mmi_clog_lt_refresh_int(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_int
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_int(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_refresh_data(inst);
    mmi_clog_lt_refresh_screen(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_is_scrn_in_active
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_is_scrn_in_active(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_LAYOUT) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_DIALED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_MISSED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_RECVED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_ALL_CALL))
        return MMI_TRUE;
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_screen(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_clog_lt_is_scrn_in_active(inst))
        return;
    mmi_frm_display_dummy_screen();
    mmi_frm_scrn_close_active_id();
}
#endif /* __MMI_CLOG_EVENT_REFRESH_SUPPORT__ */


#ifdef __MMI_CLOG_MARK_SEVERAL__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_hlt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sel     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_hlt_hdlr(S32 sel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    inst->sel_log_idx = sel;

#if defined(__MMI_ICON_BAR_SUPPORT__)
    //mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_get_state
 * DESCRIPTION
 *  category will call this function to get check box state for each item
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
static S32 mmi_clog_mark_several_get_state(S32 item_index, PU8 *checkbox_image)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    *checkbox_image = mmi_clog_bitmask_get_state(inst->bit_mask, item_index) ?
                      (PU8)GetImage(CHECKBOX_ON_IMAGE_ID) :
                      (PU8)GetImage(CHECKBOX_OFF_IMAGE_ID);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bitmask_get_state
 * DESCRIPTION
 *  get a bit state of bitmask
 * PARAMETERS
 *  bit_mask      [IN]
 *  index         [IN]
 * RETURNS
 *  0 is false, else is true
 *****************************************************************************/
static U8 mmi_clog_bitmask_get_state(U8* bit_mask, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return bit_mask[index >> 3] & (1 << (index % 8));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bitmask_set_state
 * DESCRIPTION
 *  change status
 * PARAMETERS
 *  bit_mask      [IN]
 *  index         [IN]
 * RETURNS
 *  0 is false, else is true
 *****************************************************************************/
static void mmi_clog_bitmask_set_state(U8* bit_mask, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bit_mask[index >> 3] ^= (1 << (index % 8));
}


static void mmi_clog_bitmask_mark_all(U8* bit_mask, U16 total_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, marked_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < total_count; i++)
    {
        bit_mask[i >> 3] |= (1 << (i % 8));
    }
}


static void mmi_clog_bitmask_unmark_all(U8* bit_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(bit_mask, 0, MMI_CLOG_LT_BIT_MASK_BYTE * sizeof(U8));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_set_state
 * DESCRIPTION
 *  set check box state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static S32 mmi_clog_mark_several_set_state(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    mmi_clog_bitmask_set_state(inst->bit_mask, item_index);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_has_marked
 * DESCRIPTION
 *  check if have marked items in mark several list, return total marked count
 * PARAMETERS
 *  void
 * RETURNS
 *  U16,  return total marked count
 *****************************************************************************/
static U16 mmi_clog_mark_several_has_marked(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, marked_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < inst->log_data.total_num; i++)
    {
        if (mmi_clog_bitmask_get_state(inst->bit_mask, i))
            marked_count++;
    }
    
    return marked_count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_set_key_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num != 0)
    {
        SetLeftSoftkeyFunction(mmi_clog_mark_several_op_enter, KEY_EVENT_UP);
        ChangeCenterSoftkey(0, IMG_GLOBAL_MARK_CSK);
        SetCenterSoftkeyFunction(mmi_clog_mark_several_change_status, KEY_EVENT_UP);
    }

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_set_horizontal_tab_bar_select_callback(mmi_frm_set_cur_sel_page);
#endif 

#ifdef __MMI_FTE_SUPPORT__
    //mmi_clog_lt_set_tap_hdlr(inst);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_change_status
 * DESCRIPTION
 *  change check box status, when press CSK "mark icon" in mark several list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_change_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    mmi_clog_bitmask_set_state(inst->bit_mask, inst->sel_log_idx);

    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_op_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    MMI_ID gid, cui_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    gid = GRP_ID_CLOG_OPTION;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_clog_alloc_gid(MMI_CLOG_GRP_TYPE_OP);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_frm_group_create_ex(inst->self_gid, gid, mmi_clog_mark_several_op_group_proc, inst, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    cui_id = cui_menu_create(
                    gid,
                    CUI_MENU_SRC_TYPE_RESOURCE,
                    CUI_MENU_TYPE_OPTION,
                    MENU_ID_CLOG_MARKOPTION,
                    MMI_TRUE,
                    inst);

    cui_menu_set_default_title_image_by_id(cui_id, GetRootTitleIcon(MAIN_MENU_CALL_LOG));
    cui_menu_run(cui_id);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_group_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_mark_several_op_group_proc(mmi_event_struct *cui_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct* evt = (cui_menu_event_struct*) cui_evt;
    mmi_clog_lt_inst_struct* inst = (mmi_clog_lt_inst_struct*)(evt->user_data);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_MENU_LIST_ENTRY:
            mmi_clog_mark_several_op_hide_menu(evt->sender_id, inst);
            break;
            
        case EVT_ID_CUI_MENU_ITEM_SELECT:
            if (MENU_ID_CLOG_MARK == evt->highlighted_menu_id ||
                MENU_ID_CLOG_UNMARK == evt->highlighted_menu_id)
                mmi_clog_bitmask_set_state(inst->bit_mask, inst->sel_log_idx);
            else if (MENU_ID_CLOG_UNMARK_ALL == evt->highlighted_menu_id)
                mmi_clog_bitmask_unmark_all(inst->bit_mask);
            else if (MENU_ID_CLOG_MARK_ALL == evt->highlighted_menu_id)
                mmi_clog_bitmask_mark_all(inst->bit_mask, inst->log_data.total_num);
            else if (MENU_ID_CLOG_MARK_DELETE == evt->highlighted_menu_id)
            {
                mmi_clog_mark_several_delete_confirm(inst);
                return MMI_RET_OK; // means Don't call mmi_frm_scrn_close_active_id
            }               

            mmi_frm_scrn_close_active_id();
            break;

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(evt->sender_id);
            break;

        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_hide_menu
 * DESCRIPTION
 *  hide option menu, when highlight diff item or if have mark items
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_op_hide_menu(mmi_id cui_id, mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 marked_count;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK_ALL, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_DELETE, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_ALL, MMI_FALSE);
    
    if (mmi_clog_bitmask_get_state(inst->bit_mask, inst->sel_log_idx))
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK, MMI_TRUE);
    }
    else
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK, MMI_TRUE);
    } 

    marked_count = mmi_clog_mark_several_has_marked(inst);
    if (0 == marked_count)
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK_ALL, MMI_TRUE);
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_DELETE, MMI_TRUE);
    }
    else if (inst->log_data.total_num == marked_count)
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_ALL, MMI_TRUE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_if_delete_log_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_delete_confirm(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_confirm(
        CNFM_TYPE_YESNO,
        STR_ID_CLOG_IF_DELETE_MARKED,
        MMI_EVENT_QUERY,
        inst->self_gid,
        inst,
        MMI_CLOG_ALERT_FLAG_AUTO_DISMISS | MMI_CLOG_ALERT_FLAG_HIDE_CSK);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_mark_several_delete(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < inst->log_data.total_num; i++)
    {
        if (mmi_clog_bitmask_get_state(inst->bit_mask, i))
        {
            inst->log_ids[j] = mmi_clog_get_id_by_idx(inst->sel_lt_id, (U16)i);
            j++;
        }
    }
    mmi_clog_mark_several_delete_common(inst);
    
    mmi_frm_display_dummy_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete_common
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_mark_several_delete_common(mmi_clog_lt_inst_struct *inst)
{
    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j = 0;
    const mmi_clog_lt_id_attr_struct *attr;
    srv_clog_del_multi_logs_req_struct req_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);
    memcpy((srv_clog_log_identity_struct*) & req_data, &attr->idt, sizeof(srv_clog_log_identity_struct));
    for (i = 0; i < inst->log_data.total_num && j < SRV_CLOG_DEL_MULTI_LOG_MAX_NUM; i++)
    {
        if (inst->log_ids[i] != 0)
        {
            req_data.log_ids[j] = inst->log_ids[i];
            j++;
            inst->log_ids[i] = 0; /* set it as invalid */
        }
    }
    if (j < SRV_CLOG_DEL_MULTI_LOG_MAX_NUM)
    {
        req_data.log_ids[j] = SRV_CLOG_INVALID_ELM;
    }

    if (j == 0) /* don't need to delete */
        return j;
    
    srv_clog_delete_multi_logs(
        inst->log_data.handle, 0, 
        (const srv_clog_del_multi_logs_req_struct *)&req_data, 
        mmi_clog_mark_several_delete_result);
    return j; /* log count of need to delete */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete_result
 * DESCRIPTION
 *  
 * PARAMETERS
 *  handle          [IN]        
 *  pid             [IN]        
 *  req_data        [IN]         
 *  cnf_data        [IN]         
 *  more            [IN]        
 *  ret             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_mark_several_delete_result(
            SRV_CLOG_HANDLE handle,
            S32 pid,
            void *req_data,
            void *cnf_data,
            MMI_BOOL more,
            srv_clog_ret_enum ret)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count; /* count of need to delete continue */
    mmi_clog_lt_inst_struct *mark_inst;    
    mmi_clog_lt_inst_struct *layout_inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mark_inst = (mmi_clog_lt_inst_struct*) mmi_frm_group_get_user_data(GRP_ID_CLOG_LAYOUT1); // mark list gruop id
    if (mark_inst != NULL)
    {
        count = mmi_clog_mark_several_delete_common(mark_inst);
        if (count != 0)
            return SRV_CLOG_RET_OK;
        else
            mmi_frm_group_close(mark_inst->self_gid); // this will auto close dummy screen
    }
    
    layout_inst = (mmi_clog_lt_inst_struct*) mmi_frm_group_get_user_data(GRP_ID_CLOG_LAYOUT); //list layout gruop id
    if (layout_inst != NULL && ret != SRV_CLOG_RET_OK)
        mmi_clog_popup(STR_GLOBAL_UNFINISHED, MMI_EVENT_FAILURE, layout_inst->self_gid, layout_inst);

    return SRV_CLOG_RET_OK;
}

#endif /* __MMI_CLOG_MARK_SEVERAL__ */


#ifdef __MMI_BT_PBAP_CLIENT__
void mmi_clog_view_from_idle_by_type(MMI_BOOL is_from_local)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_from_local)
    {
        g_is_missed_call.is_from_local = MMI_TRUE;
    }
    else
    {
        g_is_missed_call.is_from_bt= MMI_TRUE;
    }
}
#endif

/*
#if defined (__MMI_BT_PBAP_CLIENT__)
static mmi_ret mmi_clog_pbapc_notify_evt_hdlr(mmi_event_struct *evt)
{

    mmi_clog_pbapc_cntx_struct *pbapc_cntx;
    pbapc_cntx = mmi_clog_get_pbapc_cntx();
    kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_pbapc_notify_evt_hdlr:cb : exist = %d",g_exist_flag);
    if (evt->evt_id == EVT_ID_PHB_PBAPC_NOTIFY)
    {

        kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_pbapc_notify_evt_hdlr: flag =%d, is_read = %d, is_connect = %d",
        pbapc_cntx->flag,pbapc_cntx->is_read, srv_bt_cm_is_profile_connected(SRV_BT_CM_PBAPC_CONNECTION));
        if (srv_bt_cm_is_profile_connected(SRV_BT_CM_PBAPC_CONNECTION))
        {
            if (g_exist_flag)
            {
                if (pbapc_cntx->flag && pbapc_cntx->is_read )
                {
                    g_mmi_clog_pbapc_cntx.flag = 0;
                    g_mmi_clog_pbapc_cntx.is_read = 0;
                    kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_pbapc_notify_evt_hdlr:handle = %x, update = %d", pbapc_cntx->phapc_op_handle,pbapc_cntx->is_only_update);
                    if (pbapc_cntx->is_only_update)
                    {
                        mmi_clog_pbapc_select_hdlr(MENU_ID_CLOG_PBAPC_ALL_CALL,0);        
                    }
                    else
                    {
                        kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_pbapc_notify_evt_hdlr:parent = %d, menu_id = %d", g_mmi_clog_pbapc_processing_inst.parent_gid,g_mmi_clog_pbapc_processing_inst.sel_menu_id);
                        mmi_clog_pbapc_select_hdlr(g_mmi_clog_pbapc_processing_inst.sel_menu_id, g_mmi_clog_pbapc_processing_inst.parent_gid);
                    }
                
                }

            }
            else
            {
                g_mmi_clog_pbapc_cntx.flag = 0;
                g_mmi_clog_pbapc_cntx.is_read = 0;

            }
        }
        else
        {
            g_mmi_clog_pbapc_cntx.flag = 0;
            g_mmi_clog_pbapc_cntx.is_read = 0;
            mmi_frm_scrn_close(g_mmi_clog_pbapc_processing_inst.parent_gid,SCR_ID_CLOG_PBAPC_LT_PROCESSING);
        }

    }
#ifdef __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
    else if (evt->evt_id == EVT_ID_PBAP_NOTIFY)
    {
        if (g_exist_flag)
        {
            mmi_frm_display_dummy_screen();
            mmi_frm_scrn_close_active_id();
        }
    }
#endif

    return MMI_RET_OK;
}
#endif
*/


#ifdef __MMI_BT_PBAP_CLIENT__

static S32 mmi_clog_bt_dialer_get_file_exist()
{
    S32 ret;

    kal_wsprintf(path,"%s",SRV_PHB_PBAPC_FOLDER_PATH_FILE);
    ret = srv_fmgr_fs_path_exist(path);
    return ret;
}


static void mmi_clog_bt_dialer_pre_show(mmi_clog_lt_inst_struct *inst)
{
    MMI_BOOL is_redraw;
    U8 *gui_buffer;

    g_exist_flag = 1;
    is_redraw = mmi_frm_scenario_is_redrawing();
    kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_bt_dialer_pre_show: is_redraw = %d", is_redraw);
    if (is_redraw)
    {
        gui_buffer = (U8*)mmi_frm_scrn_get_active_gui_buf();
        mmi_clog_pbapc_show_category(1, gui_buffer);

    }
    else
    {
        if(!g_mmi_clog_pbapc_cntx.is_from_close_pop)
        {        
            mmi_clog_bt_dialer_show(inst);
        }
        else
        {
            g_mmi_clog_pbapc_cntx.is_from_close_pop = MMI_FALSE;
        }
    }

}


static void mmi_clog_bt_dialer_show(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_bt_tab_page_struct *page;
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
    srv_bt_cm_bt_addr bt_addr;
    MMI_MENU_ID sel_menu_id;
    srv_phb_pbap_storage_enum lt_storage;
    S32 ret;
    S32 get_ret;
    U8 index;
#ifndef __MMI_PHB_PBAPC_SYNC_CONTACT__
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
    #else
    index = mmi_frm_scrn_tab_get_active_page_index();
    #endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    #ifdef __MMI_TELEPHONY_SUPPORT__
    index = index -1;
    #endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    pbapc_cntx->index = index;
#else /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    if(g_is_missed_call.is_from_bt)
    {

        kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_bt_dialer_show: index = %d",  g_is_missed_call.bt_index);
        index = g_is_missed_call.bt_index;
    }
    else
    {
        index = pbapc_cntx->index;
    }

#endif /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
    get_ret = srv_phb_pbapc_get_btd_addr(&bt_addr,index);
    kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_bt_dialer_show: index = %d, get_ret = %d", index, get_ret);
    pbapc_cntx->addr[index] = bt_addr;
    MMI_TRACE(MMI_CLOG_TRC_INFO, TRC_MMI_CLOG_PBAPC_BT_DIALER_SHOW_V30,index, bt_addr);

    g_exist_flag = 1;
//#ifndef __MMI_PHB_PBAPC_SYNC_CONTACT__
    page = (mmi_clog_lt_bt_tab_page_struct *)mmi_clog_lt_bt_link_get_page_by_lt_id(inst, g_mmi_clog_bt_link_tab_id.lt_ids[index]);
//#endif

    sel_menu_id = mmi_clog_bt_get_menu_id(inst->sel_lt_id);
    kal_wsprintf(path,"%s%d%s",SRV_PHB_PBAPC_FOLDER_PATH_FIX, index, SRV_PHB_PBAPC_FILE);
    ret = srv_fmgr_fs_path_exist(path);

    MMI_TRACE(MMI_CLOG_TRC_INFO, TRC_MMI_CLOG_PATH_IS_EXIST, ret, sel_menu_id);
#ifdef __MTK_TARGET__
    if (get_ret < 0)
    {
        if (ret >=  0)/*sync before but now disconnect*/
        {
            mmi_clog_pbap_current_num = 0;
            pbapc_cntx->is_parse = 1;
            mmi_clog_prepare_data(sel_menu_id,inst->self_gid);

            mmi_clog_pbapc_parse_file(path);

        }
        else
        {
            wgui_set_menu_empty_string_by_id(STR_ID_PHB_PBAPC_NO_CONN);
            mmi_clog_bt_link_no_conn_show_list(inst, page);
            SetLeftSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
            SetCenterSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
        }

    }
    else
#endif
    {
#ifdef __MTK_TARGET__
        if(!srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr))// this API will change to srv_bt_cm_is_profile_connected_ex
        {
        MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_PAGE_IS_CONNECT,0);
    #ifndef __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
            if (srv_bt_cm_get_existed_conn_num_by_addr(&bt_addr))// this API will be change to srv_bt_cm_get_profile_connecting_state.
            {
                MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_DIALER_ONLY_AGREE,1);
                wgui_set_menu_empty_string_by_id(STR_ID_PHB_PBAPC_NO_CONN);
                mmi_clog_bt_link_no_conn_show_list(inst, page);
                SetLeftSoftkeyFunction(mmi_clog_bt_link_conn_profile_lsk_hdlr, KEY_EVENT_UP);
                SetCenterSoftkeyFunction(mmi_clog_bt_link_conn_profile_lsk_hdlr, KEY_EVENT_UP);
            }
            else
            {
                if(ret < 0)
                {
                    wgui_set_menu_empty_string_by_id(STR_ID_PHB_PBAPC_NO_CONN);
                    mmi_clog_bt_link_no_conn_show_list(inst, page);
                    SetLeftSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
                    SetCenterSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
                }
                else
                {
                    pbapc_cntx->is_parse = 1;
                    mmi_clog_prepare_data(sel_menu_id,inst->self_gid);
                    mmi_clog_pbap_current_num = 0;
                    mmi_clog_pbapc_parse_file(path);
                }
            }
    #else /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__*/
            MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_DIALER_ONLY_AGREE, -1);
            wgui_set_menu_empty_string_by_id(STR_ID_PHB_PBAPC_NO_CONN);

            mmi_clog_bt_link_no_conn_show_list(inst, page);

            if (srv_bt_cm_get_existed_conn_num_by_addr(&bt_addr))
            {
                SetLeftSoftkeyFunction(mmi_clog_bt_link_conn_profile_lsk_hdlr, KEY_EVENT_UP);
                SetCenterSoftkeyFunction(mmi_clog_bt_link_conn_profile_lsk_hdlr, KEY_EVENT_UP);
            }
            else
            {
                SetLeftSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
                SetCenterSoftkeyFunction(mmi_clog_bt_link_lsk_hdlr, KEY_EVENT_UP);
            }
    #endif /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__*/
        }/*is_connect*/
        else /*connect*/
#endif
        {
#ifdef __MTK_TARGET__
#else
        mmi_clog_pbap_current_num = 0;
#endif /*__MTK_TARGET__*/
        //extern int ixxx;
#ifdef __MMI_BT_NOTI_SRV__         
            kal_prompt_trace(MOD_MMI,"[TEST]mmi_clog_bt_dialer_show: lt_id = %d, is_from_bt = %d", inst->sel_lt_id,g_is_missed_call.is_from_bt);

            if (inst->sel_lt_id == MMI_CLOG_LT_ID_MISSED_CALL || inst->sel_lt_id == MMI_CLOG_LT_ID_ALL_CALL)
            {  
        #if SRV_PBAPC_LINK_NUM > 2
            kal_prompt_trace(MOD_MMI, "[TEST]mmi_clog_bt_dialer_show:lap =%0x, uap  =%0x", g_is_missed_call.missed_bt_addr[index].lap,g_is_missed_call.missed_bt_addr[index].uap);
                if (g_is_missed_call.is_from_bt)
                {
                    if(bt_nmgr_handle[index])
                    {
                        mmi_frm_nmgr_alert_cancel(bt_nmgr_handle[index]);
                    }

                }
                else
                {
                    srv_bt_noti_update_remote_missed_call(&g_is_missed_call.missed_bt_addr[index]);
                    if(bt_nmgr_handle[index])
                    {
                        mmi_frm_nmgr_alert_cancel(bt_nmgr_handle[index]);
                    }


                }
                

        #else
                srv_bt_noti_update_remote_missed_call(&pbapc_cntx->addr[0]);
                if(bt_nmgr_handle)
                {
                    mmi_frm_nmgr_alert_cancel(bt_nmgr_handle);
                }
        #endif

            }
#endif /*__MMI_BT_NOTI_SRV__*/
            MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_BT_DIALER_SHOW_V31,pbapc_cntx->flag[index], g_only_update_data,pbapc_cntx->only_update[index]);
            if (pbapc_cntx->flag[index] || pbapc_cntx->only_update[index])//for_calllog
            {
                if (pbapc_cntx->only_update[index]) // when enter again ,bg do some thing.
                {
                    lt_storage = mmi_clog_pbapc_menu_to_storage_path(sel_menu_id);
                    mmi_clog_pbapc_processing_show_ex(inst->self_gid,MMI_CLOG_PBAPC_OP_TYPE_LT_LIST, lt_storage);            
                }
                else  if(ret >= 0)// second enter, direactly parse file
                {
                    mmi_clog_pbap_current_num = 0;
                    pbapc_cntx->is_parse = 1;
                    mmi_clog_prepare_data(sel_menu_id,inst->self_gid);

                    mmi_clog_pbapc_parse_file(path);
                }
                else // file not exist, may be not exist this case .
                {
                    wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);
                    mmi_clog_bt_link_no_conn_show_list(inst, page);//how to show 
                }
            }
            else // first enter
            {
                g_folder_exist = MMI_FALSE;
                g_only_update_data = MMI_FALSE;
                pbapc_cntx->only_update[index] = MMI_FALSE;
                mmi_clog_pbapc_select_hdlr(sel_menu_id,inst->self_gid);
            }
        }
    }
}
#endif

#ifdef __MMI_BT_PBAP_CLIENT__

void mmi_clog_bt_get_last_log(U8 index, mmi_clog_get_last_number_async_cb cb, srv_phb_pbap_storage_enum storage)
{
    S32 ret;
    mmi_clog_pbapc_ex_inst_struct *clog_pbapc_cntx; 
    clog_pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    g_mmi_clog_pbapc_cntx.path = storage;
    g_mmi_clog_get_last_info.index = index;
    g_mmi_clog_get_last_info.is_get_num = MMI_TRUE;
    g_mmi_clog_get_last_info.cb = cb;
    kal_wsprintf(path,"%s%d%s",SRV_PHB_PBAPC_FOLDER_PATH_FIX, index, SRV_PHB_PBAPC_FILE);
    ret = srv_fmgr_fs_path_exist(path);
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_BT_GET_LAST,index,ret);
    if (ret >= 0)
    {
        mmi_clog_pbap_current_num = 0;
        g_mmi_clog_pbapc_cntx.is_canceled = MMI_FALSE;
        g_mmi_clog_pbapc_cntx.is_stoped = MMI_FALSE;
        mmi_clog_pbapc_parse_file(path);
    }
    else
    {
        clog_pbapc_cntx->only_update[index]= MMI_TRUE;
        mmi_clog_pbapc_select_hdlr(MENU_ID_CLOG_PBAPC_ALL_CALL, 0);
    }

}
#endif

#endif /* __MMI_TELEPHONY_SUPPORT__ || __MMI_BT_PBAP_CLIENT__ */


/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * ToDoListUtil.c
 *
 * Project:
 * --------
 * MAUI
 *
 * Description:
 * ------------
 * ToDoList utility APIs.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/
/*****************************************************************************
 * Include
 *****************************************************************************/
 
#ifndef MMI_TODOLIST_UTIL_C
#define MMI_TODOLIST_UTIL_C
#include "MMI_common_app_trc.h"
#include "DebugInitDef_Int.h"
#include "MMI_features.h"
#include "GlobalResDef.h"
#include "ImeGprot.h"
#include "MMIDataType.h"
#include "NetSetSrvGprot.h"
#ifdef __MMI_BIRTHDAY_REMINDER__
#include "BirthdayProt.h"
#endif 
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "mmi_common_app_trc.h"
#include "IndianCalendarDef.h"
#include "TodolistSrvGprot.h"
#include "Menucuigprot.h"
#include "string.h"
#include "gui_data_types.h"
#include "gui.h"
#include "DateTimeType.h"
#include "app_datetime.h"
#include "Unicodexdcl.h"
#include "CustDataRes.h"
#include "kal_trace.h"
#include "CommonScreensResDef.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_util.h"
#include "AlertScreen.h"
#include "wgui_datetime.h"
#include "mmi_frm_mem_gprot.h"
#include "PhoneBookGprot.h"
#include "gui_typedef.h"
#include "mmi_rp_app_alarm_def.h"
#include "CustMenuRes.h"
#include "wgui_categories_list.h"
#include "CustDataProts.h"
#include "GlobalConstants.h"
#include "CommonScreens.h"
#include "custom_mmi_default_value.h"  
#include "mmi_rp_app_todolist_def.h"
#include "mmi_rp_app_calendar_def.h"
#include "ToDoListGprot.h"
#include "ToDoListProt.h"
#ifdef __SYNCML_SUPPORT__
#include "Mmi_rp_srv_syncml_def.h" 
#endif
#include "CalendarProt.h"
#include "InlineCuiGprot.h" 
#include "Fseditorcuigprot.h" 
#include "syncmlgprot.h"  
#include "mmi_rp_app_organizer_def.h"
#include "AlarmDef.h"
#include "TimerEvents.h"
#include "ReminderSrvGprot.h"
#include "mmi_rp_srv_reminder_def.h"
#include "SecSetCuiGprot.h"
#include "NwUsabSrvGprot.h"
#include "PhbSrvGprot.h"
#include "GeneralSettingSrvGprot.h"


#if defined(__MMI_CALENDAR_EVENT__) || defined(__MMI_TODOLIST__)

/*****************************************************************************
 * Define
 *****************************************************************************/
#define MMI_TDL_UTIL_TRACE0(sub_grp) \
		MMI_TRACE(MMI_COMMON_TRC_G2_ORG, sub_grp)

#define MMI_TDL_UTIL_TRACE1(sub_grp, arg) \
		MMI_TRACE(MMI_COMMON_TRC_G2_ORG, sub_grp, arg)
		
#define MMI_TDL_UTIL_TRACE2(sub_grp, arg1, arg2) \
		MMI_TRACE(MMI_COMMON_TRC_G2_ORG, sub_grp, arg1, arg2)

#define MMI_TDL_UTIL_TRACE3(sub_grp, arg1, arg2, arg3) \
		MMI_TRACE(MMI_COMMON_TRC_G2_ORG, sub_grp, arg1, arg2, arg3)

		
/*****************************************************************************
 * Static Declaration
 *****************************************************************************/
#define STATIC_DECLARATION
static const cui_inline_item_fullscreen_edit_struct g_tdl_full_edit_subject = 
{
    0,
    0,
    STR_GLOBAL_SUBJECT,
    0,
    0,
    IMM_INPUT_TYPE_SENTENCE, /* Should check here */
    MAX_TODO_NOTE_LEN , /* Buffer size?? */
    NULL
};

static const cui_inline_item_fullscreen_edit_struct g_tdl_full_edit_detail = 
{
    0,
    0,
    STR_GLOBAL_DETAILS,
    0,
    0,
    IMM_INPUT_TYPE_SENTENCE, /* Should check here */
    MAX_TDL_DETAILS_SIZE , /* Buffer size?? */
    NULL
};

const mmi_tdl_alarm_type_struct g_tdl_alm_set[] = 
{
    {MMI_TDL_ALARM_OFF, STR_GLOBAL_OFF},
    {MMI_TDL_ALARM_ON, STR_GLOBAL_ON},
    {MMI_TDL_ALARM_BEFORE_5_MINS, STR_TODO_ALARM_BEFORE_5_MINS},
    {MMI_TDL_ALARM_BEFORE_10_MINS, STR_TODO_ALARM_BEFORE_10_MINS},
    {MMI_TDL_ALARM_BEFORE_15_MINS, STR_TODO_ALARM_BEFORE_15_MINS},
    {MMI_TDL_ALARM_BEFORE_30_MINS, STR_TODO_ALARM_BEFORE_30_MINS},
    {MMI_TDL_ALARM_CUSTOM, STR_GLOBAL_CUSTOM}
};

const mmi_tdl_repeat_type_struct g_tdl_freq_set[MMI_TDL_MAX_FREQ_ITEM] =
{
    {ALM_FREQ_ONCE, ALARM_ONCE_STRING},
    {ALM_FREQ_EVERYDAY, ALARM_EVREYDAY_STRING},
    {ALM_FREQ_DAYS, ALARM_DAYS_STRING},
    {ALM_FREQ_WEEKLY, ALARM_WEEKLY_STRING},
    {ALM_FREQ_MONTHLY, ALARM_MONTHLY_STRING},
    {ALM_FREQ_YEARLY, ALARM_YEARLY_STRING},
#ifdef __MMI_INDICAL__
    {ALM_FREQ_TITHI, ALARM_TITHI_STRING},
#endif
};

mmi_tdl_confirm_user_data_struct g_tdl_confirm_user_data;
mmi_tdl_edit_cntx_struct g_tdl_edit_cntx;
mmi_tdl_popup_user_data_struct g_tdl_popup_user_data;

U8 g_mmi_clndr_weekday_index[] = 
{
    0x01,   /* DAY_SUN */
    0x02,   /* DAY_MON */
    0x04,   /* DAY_TUE */
    0x08,   /* DAY_WED */
    0x10,   /* DAY_THU */
    0x20,   /* DAY_FRI */
    0x40    /* DAY_SAT */
};

#ifdef __MMI_CALENDAR_EVENT__
static const cui_inline_item_caption_struct g_tdl_event_1_caption[8] =
{
	{STR_GLOBAL_SUBJECT},
    {STR_TODO_START_TIME},
    {STR_TODO_END_TIME},
    {STR_ID_TDL_CATEGORY},
    {STR_GLOBAL_ALARM},
    {STR_TODO_REPEAT},
    {STR_TODO_LOCATION},
    {STR_GLOBAL_DETAILS}
};

static const cui_inline_item_caption_struct g_tdl_event_2_caption[5] =
{
    {STR_GLOBAL_SUBJECT},
    {STR_GLOBAL_TIME},
    {STR_ID_TDL_CATEGORY},
    {STR_GLOBAL_ALARM},
    {STR_GLOBAL_DETAILS}
};

static const cui_inline_item_caption_struct g_tdl_event_3_caption[1] =
{
    {STR_GLOBAL_ALARM}
};

static const cui_inline_item_fullscreen_edit_struct g_tdl_full_edit_location = 
{
    0,
    0,
    STR_TODO_LOCATION,
    0,
    0,
    IMM_INPUT_TYPE_SENTENCE, /* Should check here */
    MAX_TDL_LOCATION_SIZE,   /* Should change to location length */
    NULL
};


typedef enum
{
    CAL_EVENT_EDIT_INLINE_SUBJECT_CAPTION = CUI_INLINE_ITEM_ID_BASE,
    CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
    CAL_EVENT_EDIT_INLINE_STARTTIME_CAPTION,
    CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT,
    CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT,
    CAL_EVENT_EDIT_INLINE_ENDTIME_CAPTION,
    CAL_EVENT_EDIT_INLINE_ENDDATE_TEXT,
    CAL_EVENT_EDIT_INLINE_ENDTIME_TEXT,
    CAL_EVENT_EDIT_INLINE_TYPE_CAPTION,
    CAL_EVENT_EDIT_INLINE_TYPE_TEXT,
    CAL_EVENT_EDIT_INLINE_ALARM_CAPTION,
    CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
    CAL_EVENT_EDIT_INLINE_REPEAT_CAPTION,
    CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
    CAL_EVENT_EDIT_INLINE_LOCATION_CAPTION,
    CAL_EVENT_EDIT_INLINE_LOCATION_TEXT,
    CAL_EVENT_EDIT_INLINE_DETAILS_CAPTION,
    CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,   // don't edit
    CAL_EVENT_EDIT_INLINE_TOTAL = CAL_EVENT_EDIT_INLINE_DETAILS_TEXT - CUI_INLINE_ITEM_ID_BASE + 1,
}mmi_cal_cui_inline_item_enum1;


const cui_inline_set_item_struct g_tdl_event_cui_inline_item1[CAL_EVENT_EDIT_INLINE_TOTAL] = 
{
    {CAL_EVENT_EDIT_INLINE_SUBJECT_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_NOTE, &g_tdl_event_1_caption[0]},
    {CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_subject},
    {CAL_EVENT_EDIT_INLINE_STARTTIME_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_DATE, &g_tdl_event_1_caption[1]},
    {CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT, CUI_INLINE_ITEM_TYPE_DATE | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, CUI_INLINE_ITEM_TYPE_TIME | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_TIME, NULL},
    {CAL_EVENT_EDIT_INLINE_ENDTIME_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_DATE, &g_tdl_event_1_caption[2]},
    {CAL_EVENT_EDIT_INLINE_ENDDATE_TEXT, CUI_INLINE_ITEM_TYPE_DATE | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_ENDTIME_TEXT, CUI_INLINE_ITEM_TYPE_TIME | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_TIME, NULL},		
	{CAL_EVENT_EDIT_INLINE_TYPE_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ICON_COURSE, &g_tdl_event_1_caption[3]},
	{CAL_EVENT_EDIT_INLINE_TYPE_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_ALARM_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ALARM, &g_tdl_event_1_caption[4]},
    {CAL_EVENT_EDIT_INLINE_ALARM_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_REPEAT_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_REPEAT, &g_tdl_event_1_caption[5]},
    {CAL_EVENT_EDIT_INLINE_REPEAT_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},    
    {CAL_EVENT_EDIT_INLINE_LOCATION_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ICON_LOCATION, &g_tdl_event_1_caption[6]},
    {CAL_EVENT_EDIT_INLINE_LOCATION_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_location},
    {CAL_EVENT_EDIT_INLINE_DETAILS_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_DETAILS, &g_tdl_event_1_caption[7]},
    {CAL_EVENT_EDIT_INLINE_DETAILS_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_detail},
};

const cui_inline_set_item_struct g_tdl_event_cui_inline_item2[MMI_TDL_MAX_EVENT2_INLINE_ITEM] = 
{
    {CAL_EVENT_EDIT_INLINE_SUBJECT_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_NOTE, &g_tdl_event_2_caption[0]},
    {CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_subject},
    {CAL_EVENT_EDIT_INLINE_STARTTIME_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ICON_DATE, &g_tdl_event_2_caption[1]},
	{CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT, CUI_INLINE_ITEM_TYPE_DATE | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_DATE, NULL},
	{CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, CUI_INLINE_ITEM_TYPE_TIME | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_TIME, NULL},
    {CAL_EVENT_EDIT_INLINE_TYPE_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ICON_COURSE, &g_tdl_event_2_caption[2]},
    {CAL_EVENT_EDIT_INLINE_TYPE_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_ALARM_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ALARM, &g_tdl_event_2_caption[3]},
    {CAL_EVENT_EDIT_INLINE_ALARM_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CAL_EVENT_EDIT_INLINE_DETAILS_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_DETAILS, &g_tdl_event_2_caption[4]},
    {CAL_EVENT_EDIT_INLINE_DETAILS_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_detail},
};

const cui_inline_set_item_struct g_tdl_event_cui_inline_item3[MMI_TDL_MAX_EVENT3_INLINE_ITEM] = 
{
    {CAL_EVENT_EDIT_INLINE_ALARM_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ALARM, &g_tdl_event_3_caption[0]},
    {CAL_EVENT_EDIT_INLINE_ALARM_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
};

#endif /*__MMI_CALENDAR_EVENT__*/

#ifdef __MMI_TODOLIST__
static const cui_inline_item_caption_struct g_tdl_task_caption[7] =
{
	{STR_GLOBAL_SUBJECT},
	{STR_GLOBAL_PRIORITY},
	{STR_ID_TDL_DUETIME},
	{STR_GLOBAL_ALARM},
	{STR_TODO_REPEAT},
	{STR_GLOBAL_DETAILS},
	{STR_ID_TODO_STATUS}	
};

static const cui_inline_set_item_struct g_tdl_task_cui_inline_item[CUI_INLINE_ITEM_TOTAL] = 
{

    {CUI_INLINE_ITEM_SUBJECT_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_NOTE, &g_tdl_task_caption[0]},
    {CUI_INLINE_ITEM_SUBJECT_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_subject},  
    {CUI_INLINE_ITEM_PRIORITY_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ICON_PRIORITY, &g_tdl_task_caption[1]},
    {CUI_INLINE_ITEM_PRIORITY_TEXT, CUI_INLINE_ITEM_TYPE_SELECT, 0, NULL},       
    {CUI_INLINE_ITEM_DUETIME_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_NOTE, &g_tdl_task_caption[2]},
    {CUI_INLINE_ITEM_DUEDATE_TEXT, CUI_INLINE_ITEM_TYPE_DATE | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_DATE, NULL},
    {CUI_INLINE_ITEM_DUETIME_TEXT, CUI_INLINE_ITEM_TYPE_TIME | CUI_INLINE_ITEM_DISABLE_LIST_HIGHLIGHT, IMG_TODO_LIST_TIME, NULL},
    {CUI_INLINE_ITEM_ALARM_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_ALARM, &g_tdl_task_caption[3]},
    {CUI_INLINE_ITEM_ALARM_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CUI_INLINE_ITEM_REPEAT_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_REPEAT, &g_tdl_task_caption[4]},
    {CUI_INLINE_ITEM_REPEAT_TEXT, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CUI_INLINE_ITEM_DETAILS_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_TODO_LIST_DETAILS, &g_tdl_task_caption[5]},
    {CUI_INLINE_ITEM_DETAILS_TEXT, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, &g_tdl_full_edit_detail},
    {CUI_INLINE_ITEM_STATUS_CAPTION, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_STATUS, &g_tdl_task_caption[6]},
    {CUI_INLINE_ITEM_STATUS_TEXT, CUI_INLINE_ITEM_TYPE_SELECT, 0, NULL}    
};

#endif /*__MMI_TODOLIST__*/

 
/*****************************************************************************
 * Global Variable
 *****************************************************************************/
 
/*****************************************************************************
 * Local Function
 *****************************************************************************/ 
#define LOCAL_FUNCTION
static MMI_BOOL mmi_tdl_check_phone_lock(void);
static MMI_BOOL mmi_tdl_sg_mgr_sg_is_valid(mmi_id sg_id);
static void mmi_tdl_entry_select_repeat_type(void);
static void mmi_tdl_entry_select_repeat_type_tap_callnback(mmi_tap_type_enum tap_type, S32 index);
static void mmi_tdl_repeat_type_select_done(void);
static void mmi_tdl_repeat_select_highlight_hdlr(S32 index);
static void mmi_tdl_save_adjust_alarm_time(
                    srv_tdl_alarm_struct *alarm, 
                    const MYTIME *start_time);
static void mmi_tdl_init_app(void); /* currently static */
static void mmi_tdl_reminder_expriry_handler(void);
static void mmi_tdl_reminder_reinit_handler(void);
static U32 mmi_tdl_conv_vcal_to_rmd(U32 reference_type, MMI_BOOL method);
static mmi_ret mmi_tdl_expiry_cb_post_hdlr(mmi_event_struct *event);
static void mmi_tdl_entry_delete_all(mmi_id parent_id); 
static void mmi_tdl_delete_all_abort(void);
static void mmi_tdl_delete_overdue(mmi_id parent_id);
static void mmi_tdl_delete_all_searched(mmi_id parent_id);
static void mmi_tdl_entry_template_list(mmi_scrn_essential_struct* data); 
static void mmi_tdl_template_idx_highlight_hdlr(S32 idx); 
static void mmi_tdl_insert_template(void);  
static void mmi_tdl_insert_popup_callback(mmi_id parent_id);
void mmi_tdl_set_reminder(
                    const srv_tdl_vcal_enum vcal_type, 
                    const void *data,
                    const U16 index);
static U8 mmi_tdl_is_overdue_todo_exist(void);
static void mmi_tdl_send_del_notify_msg(void);
static void mmi_tdl_delete_all_notify_rsp(void *info);
static S32 mmi_tdl_reminder_compare(U32 exist, U32 curr);
srv_reminder_repeat_enum mmi_tdl_repeat_conv2reminder(mmi_tdl_repeat_rule_enum repeat);
void mmi_tdl_compute_pre_reminder_time(
                        U8 alarm_type,
                        MYTIME *alarm_time,
                        MYTIME *start_time,
                        MYTIME *pre_reminder);
static void mmi_tdl_send_vcal_menu_check(mmi_id group_id);
static void mmi_tdl_delete_curr_task(mmi_id parent_id);

#ifdef __MMI_CALENDAR_EVENT__
static mmi_ret cui_cal_save_group_proc(mmi_event_struct *evt);
static void cui_cal_save_back_to_inline(mmi_id sg_id);
static void cui_cal_save_set_inline_data(mmi_id sg_id);
static void cui_cal_save_proc_submit(mmi_event_struct *evt);
static void cui_cal_save_csk_press(mmi_event_struct *evt);
static void cui_cal_save_proc_notify(mmi_event_struct *evt);
static void cui_cal_save_create_context(mmi_tdl_save_cntx_struct *save_cntx);
static void mmi_cal_entry_select_category(void);
static void mmi_cal_entry_select_category_tap_callback(mmi_tap_type_enum tap_type, S32 index);
static void mmi_cal_category_select_highlight_hdlr(S32 index);
static void mmi_cal_category_select_done(void);
static void cui_cal_save_release_context(mmi_tdl_save_cntx_struct *save_cntx);
static void mmi_tdl_event_save_prepare(
                    srv_tdl_event_struct* buff, 
                    const U16 buff_size);
static void mmi_tdl_entry_event_edit_screen(void);


#endif

#ifdef __MMI_TODOLIST__
static mmi_ret cui_tdl_save_group_proc(mmi_event_struct *evt);
static void cui_tdl_save_create_context(mmi_tdl_save_cntx_struct *save_cntx);
static void cui_tdl_save_release_context(mmi_tdl_save_cntx_struct *save_cntx);
static void cui_tdl_save_proc_submit(mmi_event_struct *evt);
static void cui_tdl_save_csk_press(mmi_event_struct *evt);
static void cui_tdl_save_proc_notify(mmi_event_struct *evt);
static void mmi_tdl_task_save_prepare(srv_tdl_task_struct* buff, const U16 buff_size);

#endif

//static void mmi_tdl_entry_save_confirm(void);

/*****************************************************************************
 * Global Function
 *****************************************************************************/ 
extern U8 mmi_clndr_get_week_first_day(void);
void mmi_tdl_get_dow_repeat_str(WCHAR *buf, U8 dows);

void mmi_tdl_at_handler_init(void);
extern void mmi_clndr_reset_event_search_state(void);

void mmi_frm_group_post_event_ex (MMI_ID sender_gid, MMI_ID receiver_gid, mmi_event_struct *evt, U32 flag);
extern int mms_is_ready(void);
extern MMI_BOOL mmi_bt_is_to_display_bt_menu(void);
extern MMI_BOOL srv_sms_is_hide_send_sms_menu_item(void);
#define GLOBAL_FUNCTION
/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_init_app
 * DESCRIPTION
 *  Set highlight handlers and retrieve data from NVRAM.
 *  Register key handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef SUPPORT_JSR_75_PIM
    mmi_tdl_evtdb_handler_init();
#endif

#ifdef __MMI_VCALENDAR__
    mmi_tdl_at_handler_init();
#endif 
    srv_tdl_init();

}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_reminder_notify_proc
 * DESCRIPTION
 *  todolist repeat
 * PARAMETERS
 *  void
 * RETURNS
 *  todolist reminder handler
 *****************************************************************************/
mmi_ret mmi_tdl_reminder_notify_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_reminder_evt_struct *remdr_evt = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id != EVT_ID_SRV_REMINDER_NOTIFY)
    {
        return MMI_RET_OK;
    }
    remdr_evt = (srv_reminder_evt_struct *)evt;
    
	if (remdr_evt->reminder_type != SRV_REMINDER_TYPE_CAL 
	    && remdr_evt->reminder_type != SRV_REMINDER_TYPE_TASK
	    && remdr_evt->reminder_type != SRV_REMINDER_TYPE_TOTAL
	    && remdr_evt->reminder_type != SRV_REMINDER_TYPE_SNS)
	{
		return MMI_RET_OK;
	}
	else if (remdr_evt->reminder_type == SRV_REMINDER_TYPE_TOTAL)
	{
        if (remdr_evt->notify == SRV_REMINDER_NOTIFY_EXPIRY || 
            remdr_evt->notify == SRV_REMINDER_NOTIFY_DEINIT)
        {
            return MMI_RET_OK;
        }
	}
    g_tdl_cntx.reminder_type = (U16)mmi_tdl_conv_vcal_to_rmd((U32)remdr_evt->reminder_type, MMI_FALSE);    
    g_tdl_cntx.reminder_id = remdr_evt->usr_data;
    g_tdl_cntx.reminder_pow_off = remdr_evt->pwr_off;

    // if SNS reminder, get event source
	if(remdr_evt->reminder_type == SRV_REMINDER_TYPE_SNS &&
		g_tdl_cntx.reminder_type == SRV_TDL_VCAL_EVENT)
	{
		srv_tdl_get_sns_reminder_source(g_tdl_cntx.reminder_id ,(srv_tdl_event_source_enum*)&g_tdl_cntx.reminder_sns_source);
	}
	else
	{
        g_tdl_cntx.reminder_sns_source = 0;
	}
    switch(remdr_evt->notify)
    {
        case SRV_REMINDER_NOTIFY_INIT:
            mmi_tdl_init_app();
            break;
        case SRV_REMINDER_NOTIFY_EXPIRY:
            mmi_tdl_reminder_expriry_handler();
            break;
        case SRV_REMINDER_NOTIFY_REINIT:
            mmi_tdl_reminder_reinit_handler();
            break;
        case SRV_REMINDER_NOTIFY_DEINIT:
            mmi_tdl_reminder_snooze_handler();
            break;
        default:
            break;
    }
    
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_reminder_expriry_handler
 * DESCRIPTION
 *  CallBack handler to execute todolist expiry.
 * PARAMETERS
 *  index           [IN]        
 *  period          [?]         
 *  power_on        [IN]        
 *  BOOL(?)         [IN]        Power status
 *  U8(?)           [IN]        Index of alarm item
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_reminder_expriry_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_struct evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_tdl_check_phone_lock())
    {
    	MMI_FRM_INIT_EVENT(&evt, 0xFFFE);
        
        mmi_frm_post_event(&evt, mmi_tdl_expiry_cb_post_hdlr, NULL);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_check_phone_lock
 * DESCRIPTION
 *  Check phone lock
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_tdl_check_phone_lock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __DM_LAWMO_SUPPORT__
    if(mmi_dmui_is_phone_lock())
    {
        return MMI_TRUE;
    }
#endif

    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_reminder_reinit_handler
 * DESCRIPTION
 *  Reinit todolist to alarm queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_reminder_reinit_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_short_struct *pevent = NULL;
    srv_tdl_task_short_struct *ptask = NULL;
    MYTIME currTime;
    U8 i, ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DTGetRTCTime(&currTime);
#ifdef __MMI_CALENDAR_EVENT__
    for (i = 0; i < NUM_OF_CAL; i++)
    {
        ret = srv_tdl_get_cache(
                    (void*)&pevent, 
                    sizeof(srv_tdl_event_short_struct), 
                    SRV_TDL_VCAL_EVENT,
                    i);
        if ((ret == SRV_TDL_RESULT_OK) && (pevent->alarm.type >= MMI_TDL_ALARM_ON))
        {
            pevent->alarm.snooze = 0;
            if (pevent->repeat.rule == MMI_TDL_RULE_ONCE)
            {             
                if (MMI_TDL_SUCCESS == mmi_tdl_is_valid_alarm(
                                         pevent->category,
                                         &pevent->alarm,
                                         &pevent->start_time,
                                         pevent->repeat.rule))
                {
                    mmi_tdl_set_reminder(SRV_TDL_VCAL_EVENT, (void*)pevent, i);
                    
                    MMI_TDL_UTIL_TRACE1(MMI_CAL_ENTRY_REINIT_QUEUE_INSERT, i);
                }
                else
                {
                    srv_tdl_get(
                        (void*)&g_tdl_cntx.curr_event, 
                        sizeof(srv_tdl_event_struct), 
                        SRV_TDL_VCAL_EVENT,
                        i);
                    memset(&g_tdl_cntx.curr_event.alarm, 0, sizeof(srv_tdl_alarm_struct));
                    srv_tdl_update(
                            &g_tdl_cntx.curr_event, 
                            SRV_TDL_VCAL_EVENT, 
                            i);
                            
                    MMI_TDL_UTIL_TRACE1(MMI_CAL_ENTRY_REINIT_QUEUE_OFF, i);                            
                }
            }
            else
            {
                mmi_tdl_set_reminder(SRV_TDL_VCAL_EVENT, (void*)pevent, i);
            }
        }
    }
#endif
#ifdef __MMI_TODOLIST__
    for (i = 0; i < NUM_OF_TASK; i++)
    {
        ret = srv_tdl_get_cache(
                    (void*)&ptask, 
                    sizeof(srv_tdl_task_short_struct), 
                    SRV_TDL_VCAL_TASK,
                    i);
        if ((ret == SRV_TDL_RESULT_OK) && (ptask->alarm.type >= MMI_TDL_ALARM_ON))
        {
            ptask->alarm.snooze = 0;
            if (ptask->repeat.rule == MMI_TDL_RULE_ONCE)
            {             
                if (MMI_TDL_SUCCESS == mmi_tdl_is_valid_alarm(
                                            0xff,
                                            &ptask->alarm,
                                            &ptask->due_time,
                                            ptask->repeat.rule))
                {
                    mmi_tdl_set_reminder(SRV_TDL_VCAL_TASK, (void*)ptask, i);
                    MMI_TDL_UTIL_TRACE1(MMI_TDL_ENTRY_REINIT_QUEUE_INSERT, i);                    
                }
                else
                {
                    srv_tdl_get(
                        (void*)&g_tdl_cntx.curr_task, 
                        sizeof(srv_tdl_task_struct), 
                        SRV_TDL_VCAL_TASK,
                        i);
                    memset(&g_tdl_cntx.curr_task.alarm, 0, sizeof(srv_tdl_alarm_struct));
                    srv_tdl_update(
                            &g_tdl_cntx.curr_task, 
                            SRV_TDL_VCAL_TASK, 
                            i);
                    MMI_TDL_UTIL_TRACE1(MMI_TDL_ENTRY_REINIT_QUEUE_OFF, i); 
                }
            }
            else
            {
                mmi_tdl_set_reminder(SRV_TDL_VCAL_TASK, (void*)ptask, i);
            }
        }
    }
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_reminder_snooze_handler
 * DESCRIPTION
 *  Snooze from To Do List Reminder Screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_reminder_snooze_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //U16 error_code;
	MYTIME curr_time, inc_time;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_nmgr_unblock_sound_vid_stop(MMI_FRM_NMGR_SOUND | MMI_FRM_NMGR_VIB);
#ifndef __MMI_PROF_BEEP_WHEN_BGPLAYING__
    mdi_audio_resume_background_play();
#endif
    mmi_frm_nmgr_control_end(); /* 
                                 * When not press key and no tough, shoult use it to tell
                                 * Framework the scenario is end
                                 */
    
    StopTimer(ALARM_ALERT_NOTIFYDURATION_TIMER);

    if (g_tdl_cntx.reminder_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
        srv_tdl_event_get(
                &g_tdl_cntx.event_reminder, 
                sizeof(srv_tdl_event_struct), 
                (srv_tdl_event_source_enum)g_tdl_cntx.reminder_sns_source, 
                g_tdl_cntx.reminder_id);

        g_tdl_cntx.event_reminder.alarm.snooze++;
        MMI_TDL_UTIL_TRACE1(MMI_TDL_SNOOZE_COUNT, g_tdl_cntx.task_reminder.alarm.snooze);        
        if (g_tdl_cntx.event_reminder.alarm.snooze <= MAX_SNOOZE_CHANCES &&
			g_tdl_cntx.event_reminder.src_id == SRV_TDL_EVENT_SOURCE_LOCAL)
        {			
			g_tdl_cntx.event_reminder.alarm.snooze_interval = MMI_TDL_REMINDER_INTERVAL;
			
            srv_tdl_event_update(
                &g_tdl_cntx.event_reminder, 
                (srv_tdl_event_source_enum)g_tdl_cntx.reminder_sns_source, 
                g_tdl_cntx.reminder_id);
        }
        else
        {
            g_tdl_cntx.event_reminder.alarm.snooze = 0;
            //error_code = mmi_tdl_save_adjust_field(
            mmi_tdl_save_adjust_field(
                    &g_tdl_cntx.event_reminder,                    
                    sizeof(srv_tdl_event_struct), 
                    SRV_TDL_VCAL_EVENT);
			
			// modify SNS birthday reminder time to next year			
	        if(g_tdl_cntx.event_reminder.src_id != SRV_TDL_EVENT_SOURCE_LOCAL && 
			g_tdl_cntx.event_reminder.category == MMI_TDL_CATEGORY_BIRTHDAY &&
			g_tdl_cntx.event_reminder.alarm.type != MMI_TDL_ALARM_OFF)
	        {
				DTGetRTCTime(&curr_time);
				if (CompareTime(g_tdl_cntx.event_reminder.start_time, curr_time, NULL) <= 0)
				{
					memset(&inc_time, 0, sizeof(MYTIME));
					inc_time.nYear = 1;
					IncrementTime(g_tdl_cntx.event_reminder.alarm.first_launch, inc_time, &curr_time);
					memcpy(&g_tdl_cntx.event_reminder.alarm.first_launch, &curr_time, sizeof(MYTIME));
				}
	        }
            srv_tdl_event_update(
                    &g_tdl_cntx.event_reminder, 
                    (srv_tdl_event_source_enum)g_tdl_cntx.reminder_sns_source, 
                    g_tdl_cntx.reminder_id);
        
        #ifdef __MMI_SYNCML_SYNC_CALENDAR_SUPPORT__
			if(g_tdl_cntx.reminder_sns_source == SRV_TDL_VCAL_EVENT)
			{
	            mmi_syncml_calendar_data_changed_notification(
	                    SYNCML_RECORD_MODIFY, 
	                    (U16)(g_tdl_cntx.reminder_id));
			}
        #endif
        }
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        srv_tdl_get(
                &g_tdl_cntx.task_reminder, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK, 
                g_tdl_cntx.reminder_id);
        
        g_tdl_cntx.task_reminder.alarm.snooze++;
        if (g_tdl_cntx.task_reminder.alarm.snooze <= MAX_SNOOZE_CHANCES)
        {
            srv_tdl_update(
                    &g_tdl_cntx.task_reminder, 
                    SRV_TDL_VCAL_TASK, 
                    g_tdl_cntx.reminder_id);
        }
        else
        {
            g_tdl_cntx.task_reminder.alarm.snooze = 0;
            //error_code = mmi_tdl_save_adjust_field(
            mmi_tdl_save_adjust_field(
                    &g_tdl_cntx.task_reminder,                    
                    sizeof(srv_tdl_task_struct), 
                    SRV_TDL_VCAL_TASK);
            srv_tdl_update(
                    &g_tdl_cntx.task_reminder, 
                    SRV_TDL_VCAL_TASK, 
                    (U16)(g_tdl_cntx.reminder_id));
        
        #ifdef __MMI_SYNCML_SYNC_TASK_SUPPORT__
            mmi_syncml_task_data_changed_notification(
                    SYNCML_RECORD_MODIFY, 
                    (U16)(g_tdl_cntx.reminder_id));
        #endif
        }
 #endif
    }
    
    srv_reminder_notify_finish(MMI_TRUE);
	mmi_frm_group_close(GRP_ID_TDL_REMINDER);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_reminder
 * DESCRIPTION
 *  set a reminder and expiry time
 * PARAMETERS
 *  remdr_type : [IN] remider type
 *  start_time : [IN] start time of data
 *  repeat :     [IN] calendar repeat type
 *  week_days :  [IN] week days
 *  index :      [IN] tdl index
 * RETURNS
 *  reminder repeat type
 * RETURN VALUES
 *  void
 *****************************************************************************/
void mmi_tdl_set_reminder(
                    const srv_tdl_vcal_enum vcal_type, 
                    const void *data,
                    const U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_short_struct *pevent = NULL;
    srv_tdl_task_short_struct *ptask = NULL;
    MYTIME incTime, currTime, preTime;
    MYTIME expiryTime;
    MYTIME startTime;
    srv_reminder_type reminder_type = SRV_REMINDER_TYPE_SPON;
    U16 snooze = 0;
    mmi_tdl_repeat_rule_enum repeat = MMI_TDL_RULE_ONCE;
    srv_reminder_repeat_enum new_freq;
    U8 dows = 0;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SRV_TDL_VCAL_EVENT == vcal_type)
    {
#ifdef __MMI_CALENDAR_EVENT__
        pevent = (srv_tdl_event_short_struct*)data;
        snooze = pevent->alarm.snooze;
        reminder_type = SRV_REMINDER_TYPE_CAL;
        repeat = (mmi_tdl_repeat_rule_enum)pevent->repeat.rule;
        dows = pevent->repeat.dows;
        startTime = pevent->start_time;
            
        MMI_TDL_UTIL_TRACE3(
                MMI_CAL_EXPIRY_TIME_CB_ENTRY, 
                index,
                pevent->category,
                pevent->alarm.type);

        
#ifdef __MMI_BIRTHDAY_REMINDER__
        if (pevent->category == MMI_TDL_CATEGORY_BIRTHDAY)
        {
            memset(&preTime, 0, sizeof(MYTIME));
            switch(pevent->alarm.type)
            {
                case MMI_TDL_ALARM_CUSTOM:
                    preTime.nDay = 1;
                    break;
                default:
                    break;
            }
        }
        else
#endif /* __MMI_BIRTHDAY_REMINDER__ */
        {
            mmi_tdl_compute_pre_reminder_time(
                                        pevent->alarm.type, 
                                        &(pevent->alarm.first_launch),
                                        &startTime,
                                        &preTime);
        }
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        ptask = (srv_tdl_task_short_struct*)data;
        snooze = ptask->alarm.snooze;
        reminder_type = SRV_REMINDER_TYPE_TASK;
        repeat = (mmi_tdl_repeat_rule_enum)ptask->repeat.rule;
        dows = ptask->repeat.dows;
        startTime = ptask->due_time;
        
        MMI_TDL_UTIL_TRACE3(
                MMI_CAL_EXPIRY_TIME_CB_ENTRY, 
                index,
                0,
                ptask->alarm.type);

        mmi_tdl_compute_pre_reminder_time(
                                    ptask->alarm.type, 
                                    &(ptask->alarm.first_launch),
                                    &startTime,
                                    &preTime);
#endif
    }
        
    if (snooze)
    {
        DTGetRTCTime(&currTime);
        memset(&incTime, 0, sizeof(MYTIME));
        incTime.nMin = MMI_TDL_REMINDER_INTERVAL;
        IncrementTime(currTime, incTime, &expiryTime);
    }
    else
    {
        new_freq = mmi_tdl_repeat_conv2reminder(repeat);        
        DecrementTime(startTime, preTime, &startTime);
        expiryTime = srv_reminder_calc_time(&startTime, new_freq, dows);
    }

    MMI_TDL_UTIL_TRACE3(MMI_CAL_SET_DATE_DATE, expiryTime.nYear, expiryTime.nMonth, expiryTime.nDay);
    MMI_TDL_UTIL_TRACE2(MMI_CAL_SET_DATE_TIME, expiryTime.nHour, expiryTime.nMin);
    MMI_TDL_UTIL_TRACE1(MMI_CAL_EXPIRY_TIME_CB_LEAVE, snooze);

    srv_reminder_set_with_callback(reminder_type, &expiryTime, NULL, mmi_tdl_reminder_compare, index);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_expiry_cb_post_hdlr
 * DESCRIPTION
 *  CallBack handler to execute todolist expiry.
 * PARAMETERS
 *  index           [IN]        
 *  period          [?]         
 *  power_on        [IN]        
 *  BOOL(?)         [IN]        Power status
 *  U8(?)           [IN]        Index of alarm item
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_tdl_expiry_cb_post_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_REMINDER_OTHER,
                            MMI_EVENT_REMINDER_OTHER,
                            mmi_tdl_entry_reminder,
                            NULL);
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_conv_vcal_to_rmd
 * DESCRIPTION
 *  set a reminder and expiry time
 * PARAMETERS
 *  reference_type : [IN] remider type or vcal type
 *  method : [IN] vcal to reminder or reminder to vcal
 * RETURNS
 *  reminder and vcal type convertion
 * RETURN VALUES
 *  U32
 *****************************************************************************/
static U32 mmi_tdl_conv_vcal_to_rmd(U32 reference_type, MMI_BOOL method)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_vcal_enum vcal_type;
    srv_reminder_type reminder_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //method == TRUE: vcal_type --> reminder_type
    if (method)
    {
        vcal_type = (srv_tdl_vcal_enum)reference_type;
        if (SRV_TDL_VCAL_EVENT == vcal_type)
        {
            reminder_type = SRV_REMINDER_TYPE_CAL;
        }
        else if (SRV_TDL_VCAL_TASK == vcal_type)
        {
            reminder_type = SRV_REMINDER_TYPE_TASK;
        }
        else
        {
            reminder_type = SRV_REMINDER_TYPE_TOTAL;
        }
        return (U32)reminder_type;
    }
    else // method == FALSE: reminder_type --> vcal_type
    {
        reminder_type = (srv_reminder_type)reference_type;
        if (SRV_REMINDER_TYPE_CAL == reminder_type ||
			SRV_REMINDER_TYPE_SNS == reminder_type)
        {
            vcal_type = SRV_TDL_VCAL_EVENT;
        }
        else if (SRV_REMINDER_TYPE_TASK == reminder_type)
        {
            vcal_type = SRV_TDL_VCAL_TASK;
        }
        else
        {
            vcal_type = SRV_TDL_VCAL_END_OF_ENUM;
        }
        return (U32)vcal_type;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_reminder_proc
 * DESCRIPTION
 *  todolist repeat
 * PARAMETERS
 *  void
 * RETURNS
 *  todolist reminder handler
 *****************************************************************************/
mmi_ret mmi_tdl_set_reminder_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_tdl_op_evt_struct *op_evt = NULL;
    srv_tdl_event_short_struct *pevent = NULL;
    srv_tdl_task_short_struct *ptask = NULL;
    void *data = NULL;
    mmi_tdl_alarm_enum alarm_type = MMI_TDL_ALARM_OFF;
    //U16 ret;
    
    if (evt->evt_id != EVT_ID_SRV_TDL_OP)
    {
        return MMI_RET_OK;
    }
    
    op_evt = (srv_tdl_op_evt_struct *)evt;

    if (SRV_TDL_VCAL_EVENT == op_evt->vcal_type)
    {
#ifdef __MMI_CALENDAR_EVENT__
        //ret = srv_tdl_get_cache(
        srv_tdl_get_cache(
                    (void*)&pevent, 
                    sizeof(srv_tdl_event_short_struct), 
                    SRV_TDL_VCAL_EVENT,
                    op_evt->store_idx);
        //MMI_ASSERT(ret == SRV_TDL_RESULT_OK);        
        alarm_type = (mmi_tdl_alarm_enum)pevent->alarm.type;
        data = (void*)pevent;
		mmi_clndr_reset_event_search_state();

		//update the current content if necessary
		if(g_tdl_cntx.curr_event.event_id == op_evt->store_idx)
		{
			srv_tdl_event_get(
				 &g_tdl_cntx.curr_event, 
				 sizeof(srv_tdl_event_struct),
				 (srv_tdl_event_source_enum)SRV_TDL_VCAL_EVENT,
				 op_evt->store_idx); 
		}
#endif
    }
    else if (SRV_TDL_VCAL_TASK == op_evt->vcal_type)
    {
#ifdef __MMI_TODOLIST__
         //ret = srv_tdl_get_cache(
         srv_tdl_get_cache(
                    (void*)&ptask, 
                    sizeof(srv_tdl_task_short_struct), 
                    SRV_TDL_VCAL_TASK,
                    op_evt->store_idx);
         //MMI_ASSERT(ret == SRV_TDL_RESULT_OK);
         alarm_type = (mmi_tdl_alarm_enum)ptask->alarm.type;
         data = (void*)ptask;
#endif
    }
    else
    {
        return MMI_RET_OK;
    }

    switch(op_evt->op_type)
    {
        case SRV_TDL_OP_ADD:
            if(alarm_type > MMI_TDL_ALARM_OFF)
            {
                mmi_tdl_set_reminder(
                    op_evt->vcal_type, 
                    data, 
                    op_evt->store_idx);
            }
            break;
            
        case SRV_TDL_OP_UPDATE:
            srv_reminder_cancel(
                (srv_reminder_type)mmi_tdl_conv_vcal_to_rmd(op_evt->vcal_type, MMI_TRUE), 
                op_evt->store_idx);
            if(alarm_type > MMI_TDL_ALARM_OFF)
            {
                mmi_tdl_set_reminder(
                    op_evt->vcal_type, 
                    data, 
                    op_evt->store_idx);
            }
            break;
            
        case SRV_TDL_OP_DELETE:  
            srv_reminder_cancel(
                    (srv_reminder_type)mmi_tdl_conv_vcal_to_rmd(op_evt->vcal_type, MMI_TRUE), 
                    op_evt->store_idx);
            break;
            
        default:
            break;
    }
     return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_sg_mgr_get_current_sg_id
 * DESCRIPTION
 *  Get current running sg id
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
mmi_id mmi_tdl_sg_mgr_get_current_sg_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 grp_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    grp_id = mmi_frm_group_get_active_id();
    if (mmi_tdl_sg_mgr_sg_is_valid(grp_id))
    {
        return grp_id;
    }

    // TODO: Add trace
    return GRP_ID_INVALID;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_alarm_select_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_alarm_select_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_edit_cntx.selected_alm = (U8)index;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_alarm_type_select_done
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_alarm_type_select_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;      
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                            g_tdl_edit_cntx.save_sg_id); 
    save_cntx->alarm_index = g_tdl_edit_cntx.selected_alm;

    if (MMI_TDL_ALARM_CUSTOM == save_cntx->alarm_index)
    {
        // menu cui launch.
        g_tdl_edit_cntx.menu_gid = cui_menu_create(
                                            g_tdl_edit_cntx.save_sg_id,
                                            CUI_MENU_SRC_TYPE_APPCREATE,
                                            CUI_MENU_TYPE_APPSUB,
                                            MITEM_TDL_LIST_DAYS,
                                            MMI_FALSE,
                                            NULL);
        
        cui_menu_set_default_title_image(g_tdl_edit_cntx.menu_gid, (UI_image_type)get_image(GetRootTitleIcon(ORGANIZER_CALENDER_MENU)));
        cui_menu_run(g_tdl_edit_cntx.menu_gid);
    }
    else
    {
        mmi_frm_scrn_close_active_id();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_select_alarm_type
 * DESCRIPTION
 *  Highlight handler of edit task screen.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_entry_select_alarm_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_ALARM_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_ALARM_SELECT_TYPE,
                    NULL,
                    mmi_tdl_entry_select_alarm_type,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_tdl_alarm_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_ALARM_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_ALARM_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_GLOBAL_ALARM,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->alarm_index,
        gui_buffer);
        
    SetLeftSoftkeyFunction(mmi_tdl_alarm_type_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_tdl_alarm_type_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}

static void mmi_tdl_entry_select_alarm_type_tap_callback(mmi_tap_type_enum tap_type, S32 index)	
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_ALARM_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_ALARM_SELECT_TYPE,
                    NULL,
                    mmi_tdl_entry_select_alarm_type,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_tdl_alarm_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_ALARM_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_ALARM_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_GLOBAL_ALARM,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->alarm_index,
        gui_buffer);
        
    SetLeftSoftkeyFunction(mmi_tdl_alarm_type_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_tdl_alarm_type_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}
/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_select_repeat_type
 * DESCRIPTION
 *  Highlight handler of edit task screen.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_entry_select_repeat_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_RULE_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_REPEAT_SELECT_TYPE,
                    NULL,
                    mmi_tdl_entry_select_repeat_type,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_tdl_repeat_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_REPEAT_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_REPEAT_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_TODO_REPEAT,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->repeat_index,
        gui_buffer);
        
    SetLeftSoftkeyFunction(mmi_tdl_repeat_type_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_tdl_repeat_type_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}

static void mmi_tdl_entry_select_repeat_type_tap_callnback(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_RULE_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_REPEAT_SELECT_TYPE,
                    NULL,
                    mmi_tdl_entry_select_repeat_type,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_tdl_repeat_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_REPEAT_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_REPEAT_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_TODO_REPEAT,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->repeat_index,
        gui_buffer);
        
    SetLeftSoftkeyFunction(mmi_tdl_repeat_type_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_tdl_repeat_type_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}
/*****************************************************************************
 * FUNCTION
 *  mmi_cal_category_select_done
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_repeat_type_select_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;      
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                            g_tdl_edit_cntx.save_sg_id); 
    save_cntx->repeat_index = g_tdl_edit_cntx.selected_repeat;

    if (MMI_TDL_RULE_DAYS == save_cntx->repeat_index)
    {
        // menu cui launch.
        g_tdl_edit_cntx.menu_gid = cui_menu_create(
                                            g_tdl_edit_cntx.save_sg_id,
                                            CUI_MENU_SRC_TYPE_APPCREATE,
                                            CUI_MENU_TYPE_APPSUB,
                                            MITEM_TDL_LIST_DAYS,
                                            MMI_FALSE,
                                            NULL);
        
        cui_menu_set_default_title_image(g_tdl_edit_cntx.menu_gid, (UI_image_type)get_image(GetRootTitleIcon(ORGANIZER_CALENDER_MENU)));
        cui_menu_run(g_tdl_edit_cntx.menu_gid);
    }
    else
    {
        mmi_frm_scrn_close_active_id();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_repeat_select_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_repeat_select_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_edit_cntx.selected_repeat = (U8)index;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_save_adjust_alarm_time
 * DESCRIPTION
 *  To sort the task list in decending time order.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_save_adjust_alarm_time(
                    srv_tdl_alarm_struct *alarm, 
                    const MYTIME *start_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME inc_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TDL_ALARM_CUSTOM == alarm->type)
    {
        return;
    }
    if (MMI_TDL_ALARM_OFF == alarm->type)
    {
        memset(&alarm->first_launch, 0, sizeof(MYTIME));
        return;
    }
    
    memset(&inc_time, 0, sizeof(MYTIME));
    switch(alarm->type)
    {
        case MMI_TDL_ALARM_ON:
            break;
            
        case MMI_TDL_ALARM_BEFORE_5_MINS:
            inc_time.nMin= 5;
            break;
            
        case MMI_TDL_ALARM_BEFORE_10_MINS:
            inc_time.nMin = 10;
            break;
            
        case MMI_TDL_ALARM_BEFORE_15_MINS:
            inc_time.nMin = 15;
            break;
            
        case MMI_TDL_ALARM_BEFORE_30_MINS:
            inc_time.nMin = 30;
            break;

        default:
            break;
    }
    applib_dt_decrease_time(
            (applib_time_struct*)start_time,
            (applib_time_struct*)&inc_time,
            (applib_time_struct*)&alarm->first_launch);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_sg_mgr_sg_is_valid
 * DESCRIPTION
 *  Check if tdl sg id
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_tdl_sg_mgr_sg_is_valid(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TODOLIST__
    if (sg_id >= GRP_ID_TDL_BEGIN && sg_id < GRP_ID_TDL_END)
    {
        return MMI_TRUE;
    }
#endif /* __MMI_TODOLIST__ */

#ifdef __MMI_CALENDAR_EVENT__
    if (sg_id >= GRP_ID_CAL_BEGIN && sg_id < GRP_ID_CAL_END)
    {
        return MMI_TRUE;
    }
#endif /* __MMI_CALENDAR__ */   

    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_validated_delete_all
 * DESCRIPTION
 *	Delete all with passcode
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/ 
//void mmi_tdl_validated_delete_all(void)
void mmi_tdl_validated_delete_all(MMI_ID app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_tdl_get_all_index(
            g_tdl_cntx.sorted_list, 
            NUM_OF_TDL, 
            g_tdl_cntx.vcal_filter, 
            &g_tdl_cntx.total);    

    if (SRV_TDL_VCAL_TASK == g_tdl_cntx.vcal_filter)
    {
#ifdef __MMI_TODOLIST__
        mmi_tdl_entry_delete_all(GRP_ID_TDL_MAIN);
#endif
    }
    else
    {
#ifdef __MMI_CALENDAR_EVENT__
        mmi_tdl_entry_delete_all(GRP_ID_CAL_MAIN);
#endif
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_delete_all
 * DESCRIPTION
 *  Delete all tasks from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_delete_all(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                parent_id,
                SCR_ID_TDL_DELETE_ALL,
                NULL,
                NULL,
                MMI_FRM_FULL_SCRN))
    {
        return;
    }
                
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    ShowCategory66Screen(
        STR_GLOBAL_DELETE_ALL,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        0,
        0,
        STR_GLOBAL_CANCEL,
        0,
        (PU8)GetString(STR_GLOBAL_DELETING),
        mmi_get_event_based_image(MMI_EVENT_PROGRESS),
        NULL);
    
    if (gui_buffer == NULL)
    {   /* delete from 0 */
        g_tdl_cntx.delete_process = MMI_TRUE;
        g_tdl_cntx.delete_marker = 0;
        g_tdl_cntx.count_deleted = 0;
        mmi_tdl_send_del_notify_msg();
    }
    
    ClearInputEventHandler(MMI_DEVICE_KEY);
    SetKeyHandler(mmi_tdl_delete_all_abort, KEY_END, KEY_EVENT_DOWN);
    SetRightSoftkeyFunction(mmi_tdl_delete_all_abort, KEY_EVENT_UP);  
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_abort
 * DESCRIPTION
 *  Delete all tasks from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_delete_all_abort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                mmi_tdl_sg_mgr_get_current_sg_id(),
                SCR_ID_TDL_DELETE_ALL_ABORT,
                NULL,
                NULL,
                MMI_FRM_FULL_SCRN))
    {
        return;
    }                
    
//    EntryNewScreen(SCR_ID_TDL_DELETE_ALL_ABORT, NULL, NULL, NULL);

    ShowCategory66Screen(
        STR_GLOBAL_CANCELLING,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        0,
        0,
        0,
        0,
        (PU8) GetString(STR_GLOBAL_CANCELLING),
        mmi_get_event_based_image(MMI_EVENT_PROGRESS),
        NULL);

    ClearInputEventHandler(MMI_DEVICE_ALL);

    /* stop delete process */
    g_tdl_cntx.delete_marker = MMI_TDL_INVALID_INDEX;    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_overdue_confirm
 * DESCRIPTION
 *  Confirm if delete all overdue events.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_delete_overdue_confirm(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 string_id = 0;
    mmi_confirm_property_struct arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_tdl_is_overdue_todo_exist())
    {
        if (g_tdl_cntx.vcal_filter == SRV_TDL_VCAL_EVENT)
        {
#ifdef __MMI_CALENDAR_EVENT__
            string_id = STR_ID_TDL_NO_EVENTS;
#endif
        }
        else
        {
#ifdef __MMI_TODOLIST__
            string_id = STR_ID_TDL_NO_TASKS;
#endif
        }
        mmi_popup_display_simple((WCHAR*)(get_string(string_id)), MMI_EVENT_FAILURE, parent_id, NULL);
        return;
    }
    
    if (g_tdl_cntx.vcal_filter == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
        string_id = STR_ID_CLNDR_DELETE_ALL_OVERDUE_QUERY;
#endif
    }
    else if (g_tdl_cntx.vcal_filter == SRV_TDL_VCAL_TASK)
    { 
#ifdef __MMI_TODOLIST__
        string_id = STR_TODO_LIST_DELETE_OVERDUE_QUERY;
#endif
    }
    else
    {
        string_id = STR_TODO_LIST_DELETE_ALL_TASK_QUERY;
    }
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = parent_id;
    arg.callback = (mmi_proc_func)mmi_tdl_comfirm_proc;
    
    mmi_tdl_confirm_user_data_init(&g_tdl_confirm_user_data);
    g_tdl_confirm_user_data.sg_id = parent_id;
    g_tdl_confirm_user_data.LSK_function = mmi_tdl_delete_overdue;
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    arg.user_tag = (void*)&g_tdl_confirm_user_data;
    mmi_confirm_display(
        (WCHAR*)get_string(string_id),
        MMI_EVENT_QUERY,
        &arg);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_overdue
 * DESCRIPTION
 *  Delete all overdue events.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_delete_overdue(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_search_filter_struct search_filter;
    U16 error_code;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    search_filter.type = SRV_TDL_SEARCH_TYPE_BEFORE;
    GetDateTime(&search_filter.u.date_time);
    
    error_code = srv_tdl_search(
                        g_tdl_cntx.sorted_list,
                        NUM_OF_TDL,
                        (srv_tdl_vcal_enum)g_tdl_cntx.vcal_filter,
                        search_filter,
                        &g_tdl_cntx.total);
                        
    if (error_code != SRV_TDL_RESULT_OK)                        
    {
        return;
    }

    for (i = 0; i < g_tdl_cntx.total; i++)
    {
        mmi_tdl_delete_record(
                        g_tdl_cntx.sorted_list[i].index, 
                        g_tdl_cntx.sorted_list[i].type);
    }

    return;     
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_template_list
 * DESCRIPTION
 *  Display list of template
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_template_list(mmi_scrn_essential_struct* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 menu_list[MMI_TDL_MAX_NOTE_TEMPLATE_ITEM];   /* Stores the strings id */
    U8 *gui_buffer;                              /* Buffer holding history data */
    S32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
             data->group_id,
             SCR_TDL_LIST_TEMPLATE,
             NULL,
             (FunctionPtr)mmi_tdl_entry_template_list,
             MMI_FRM_FULL_SCRN))
    {
        return;
    }
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();
    for (j = 0; j < MMI_TDL_MAX_NOTE_TEMPLATE_ITEM; j++)
    {
        menu_list[j] = (U16)(STR_TODO_TEMPLATE_1 + j);
    }
    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    ShowCategory159Screen(
        STR_TODO_LIST_USE_TEMPLATE,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MMI_TDL_MAX_NOTE_TEMPLATE_ITEM,
        menu_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        0,
        gui_buffer,
        mmi_tdl_template_idx_highlight_hdlr,
        mmi_frm_scrn_close_active_id);

    if (wgui_inputs_menu_index_in_editor_range() == MMI_FALSE)
    {
        SetLeftSoftkeyFunction(mmi_tdl_insert_template, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_tdl_insert_template, KEY_EVENT_UP);                
        SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_template_idx_highlight_hdlr
 * DESCRIPTION
 *  Store index of selected template
 * PARAMETERS
 *  nIndex      [IN]        Index of selected template.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_template_idx_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_edit_cntx.template_idx = (U8) index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_insert_template
 * DESCRIPTION
 *  Inssert selected template into buffer and go back to editor screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_insert_template(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR template_buff[MAX_TODO_LIST_NOTE];
    S32 curr_len;
	S32 remain_len;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    curr_len = mmi_ucs2strlen(
                    GetString((U16)(STR_TODO_TEMPLATE_1 + g_tdl_edit_cntx.template_idx)));
                    
    remain_len = MAX_TODO_NOTE_LEN - 1 - mmi_ucs2strlen((CHAR*)g_tdl_edit_cntx.edit_buff);
    
    mmi_ucs2ncpy(
        template_buff, 
        GetString((U16)(STR_TODO_TEMPLATE_1 + g_tdl_edit_cntx.template_idx)), 
        curr_len);

	if (curr_len > remain_len)
	{
        mmi_popup_property_struct arg;  
        mmi_popup_property_init(&arg);  
        arg.parent_id = g_tdl_edit_cntx.save_sg_id; 
        arg.callback = (mmi_proc_func)mmi_tdl_popup_proc; 

        mmi_tdl_popup_user_data_init(&g_tdl_popup_user_data);
        g_tdl_popup_user_data.sg_id = g_tdl_edit_cntx.save_sg_id;
        g_tdl_popup_user_data.callback_function = mmi_tdl_insert_popup_callback;
        arg.user_tag = (void*)&g_tdl_popup_user_data;
        mmi_popup_display((WCHAR*)(get_string(STR_TODO_TEMPLATE_NOT_ENOUGH_SPACE)), MMI_EVENT_FAILURE, &arg);
 		return;
	}

    mmi_wcsncat((WCHAR*)g_tdl_edit_cntx.edit_buff, (WCHAR*)template_buff, MAX_TODO_NOTE_LEN - 1);
    mmi_frm_scrn_close_active_id();    
    cui_fseditor_close(g_tdl_edit_cntx.fseditor_gid);
    g_tdl_edit_cntx.fseditor_gid = cui_fseditor_create(g_tdl_edit_cntx.save_sg_id);
    
    if (0 == g_tdl_edit_cntx.fseditor_gid)
    {
        return;
    }

    cui_fseditor_set_title(
            g_tdl_edit_cntx.fseditor_gid, 
            STR_GLOBAL_SUBJECT, 
            GetRootTitleIcon(ORGANIZER_CALENDER_MENU));
    cui_fseditor_set_buffer(
                        g_tdl_edit_cntx.fseditor_gid, 
                        (U8*)g_tdl_edit_cntx.edit_buff, 
                        MMI_TDL_MAX_TEXT_EDIT_BUFF_EN_SIZE, 
                        MAX_TODO_NOTE_LEN - 1);
    cui_fseditor_set_input_method(
                        g_tdl_edit_cntx.fseditor_gid, 
                        IMM_INPUT_TYPE_SENTENCE, 
                        NULL, 
                        0);

    g_tdl_edit_cntx.fseditor_option_menu[0] = MITEM_TODO_LIST_USE_TEMPLATE;
    cui_fseditor_set_custom_options_menu(
                        g_tdl_edit_cntx.fseditor_gid,
                        MMI_FALSE,
                        g_tdl_edit_cntx.fseditor_option_menu,
                        1);
    cui_fseditor_run(g_tdl_edit_cntx.fseditor_gid);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_insert_popup_callback
 * DESCRIPTION
 *  Show task type list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_insert_popup_callback(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_close(parent_id, SCR_TDL_LIST_TEMPLATE);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_is_overdue_todo_exist
 * DESCRIPTION
 *  Check if overdue event presents.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static U8 mmi_tdl_is_overdue_todo_exist(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_search_filter_struct search_filter;
    U16 total;
    U16 error_code;
    U8 result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    search_filter.type = SRV_TDL_SEARCH_TYPE_BEFORE;
    GetDateTime(&search_filter.u.date_time);
    
    error_code = srv_tdl_search(
                        NULL,
                        NUM_OF_TDL,
                        (srv_tdl_vcal_enum)g_tdl_cntx.vcal_filter,
                        search_filter,
                        &total);
                        
    if (error_code != SRV_TDL_RESULT_OK)                        
    {
        return result;
    }

    if (total > 0)
    {
        result = MMI_TRUE;
    }
        
    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_send_del_notify_msg
 * DESCRIPTION
 *  Delete all tasks from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_send_del_notify_msg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetProtocolEventHandler(mmi_tdl_delete_all_notify_rsp, MSG_ID_MMI_MMI_TDL_DEL_NOTIFY);
    /* Just a notify */
    mmi_frm_send_ilm(MOD_MMI, MSG_ID_MMI_MMI_TDL_DEL_NOTIFY, NULL, NULL);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_notify
 * DESCRIPTION
 *  Protocol event handler
 * PARAMETERS
 *  info        [IN]            message content
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_delete_all_notify_rsp(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL del_flag = MMI_FALSE;   
    mmi_id parent_id;
    CHAR *out_buf;
    U8 count = 0;
    CHAR count_str[10];    
    U8 i;
    U16 j;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (SRV_TDL_VCAL_TASK == g_tdl_cntx.vcal_filter)
    {
        parent_id = GRP_ID_TDL_MAIN;
    }
    else
    {
        parent_id = GRP_ID_CAL_MAIN;
    }
    
    SetProtocolEventHandler(NULL, MSG_ID_MMI_MMI_TDL_DEL_NOTIFY);

    if (g_tdl_cntx.delete_marker == MMI_TDL_INVALID_INDEX)
    {    
        out_buf = (CHAR*)OslMalloc(MMI_TDL_MAX_OUT_PUT_MSG_SIZE * ENCODING_LENGTH);
        memset(out_buf, 0x00, MMI_TDL_MAX_OUT_PUT_MSG_SIZE * ENCODING_LENGTH);
        sprintf(count_str, "%d", g_tdl_cntx.count_deleted);
        mmi_asc_to_ucs2(out_buf, count_str);

        /* out_buf */
        if (g_tdl_cntx.vcal_filter == SRV_TDL_VCAL_EVENT)
        {
#ifdef __MMI_CALENDAR_EVENT__
            if (g_tdl_cntx.count_deleted <= 1)
            {
                mmi_ucs2cat(out_buf, GetString(STR_ID_TDL_EVENT_DELETED));
            }
            else
            {
                mmi_ucs2cat(out_buf, GetString(STR_ID_TDL_EVENTS_DELETED));
            }
#endif
        }
        else
        {
#ifdef __MMI_TODOLIST__
            if (g_tdl_cntx.count_deleted <= 1)
            {
                mmi_ucs2cat(out_buf, GetString(STR_ID_TDL_TASK_DELETED));
            }
            else
            {
                mmi_ucs2cat(out_buf, GetString(STR_ID_TDL_TASKS_DELETED));
            }
#endif
        }

        g_tdl_cntx.delete_marker = 0;
        g_tdl_cntx.delete_process = MMI_FALSE;
        mmi_popup_display_simple((WCHAR*)((UI_string_type)out_buf), MMI_EVENT_SUCCESS, mmi_tdl_sg_mgr_get_current_sg_id(), NULL);
        mmi_frm_scrn_close(parent_id, SCR_ID_TDL_DELETE_ALL_ABORT);
        OslMfree(out_buf);
        return;
    }

    for (i = g_tdl_cntx.delete_marker; i < g_tdl_cntx.total; i++)
    {
        if (g_tdl_cntx.sorted_list[i].type == SRV_TDL_VCAL_TASK)
        {
			j = g_tdl_cntx.sorted_list[i].index;
#ifdef __MMI_TODOLIST__
            g_tdl_cntx.delete_marker = i;
            mmi_tdl_delete_record(
                j, 
                SRV_TDL_VCAL_TASK);
            g_tdl_cntx.count_deleted++;
#endif
        }
        else if(g_tdl_cntx.sorted_list[i].type == SRV_TDL_VCAL_EVENT)
        {
			j = g_tdl_cntx.sorted_list[i].index;
#ifdef __MMI_CALENDAR_EVENT__
            g_tdl_cntx.delete_marker = i;
       //     srv_tdl_delete(j, SRV_TDL_VCAL_EVENT);
           mmi_tdl_delete_record(
                j, 
                SRV_TDL_VCAL_EVENT);
            g_tdl_cntx.count_deleted++;
#endif
        }
        count++;
        if (count >= MMI_TDL_MAX_DEL_NUM)
        {
            del_flag = MMI_TRUE;
            mmi_tdl_send_del_notify_msg();
            break;
        }
    }

    /* Finish deletion */
    if (!del_flag)
    {
        g_tdl_cntx.delete_marker = 0;
        g_tdl_cntx.delete_process = MMI_FALSE;
        g_tdl_cntx.count_deleted = 0;
        mmi_frm_scrn_close(parent_id, SCR_ID_TDL_DELETE_ALL);
        mmi_frm_scrn_close(GRP_ID_TDL_SEARCH, SCR_ID_TDL_DELETE_ALL);
    }
}

static S32 mmi_tdl_reminder_compare(U32 exist, U32 curr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 exist_priority;
    U32 curr_priority;
    S32 value;
    srv_tdl_task_struct *ptask;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ptask = OslMalloc(sizeof(srv_tdl_task_struct));
	srv_tdl_get(
			ptask, 
			sizeof(srv_tdl_task_struct), 
			SRV_TDL_VCAL_TASK, 
			exist); 

	exist_priority = ptask->priority;

	srv_tdl_get(
			ptask, 
			sizeof(srv_tdl_task_struct), 
			SRV_TDL_VCAL_TASK, 
			curr); 
        
	curr_priority = ptask->priority;
	
	if (curr_priority > exist_priority)
	{
		value = 1;
	}
	else
	{
		value = -1;
    }
    
    OslMfree(ptask);

	return value;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_repeat_conv2reminder
 * DESCRIPTION
 *  convert calendar repeat type to reminder repeat type
 * PARAMETERS
 *  repeat : [IN]
 * RETURNS
 *  reminder repeat type
 * RETURN VALUES
 *  void
 *****************************************************************************/
srv_reminder_repeat_enum mmi_tdl_repeat_conv2reminder(mmi_tdl_repeat_rule_enum repeat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_reminder_repeat_enum new_repeat;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_repeat = SRV_REMINDER_REPEAT_ONCE;
    switch(repeat)
    {
        case MMI_TDL_RULE_ONCE:
            new_repeat = SRV_REMINDER_REPEAT_ONCE;
            break;
        case MMI_TDL_RULE_DAILY:
            new_repeat = SRV_REMINDER_REPEAT_EVERYDAY;
            break;
        case MMI_TDL_RULE_DAYS:
            new_repeat = SRV_REMINDER_REPEAT_DAYS;
            break;
        case MMI_TDL_RULE_WEEKLY:
            new_repeat = SRV_REMINDER_REPEAT_WEEKLY;
            break;
        case MMI_TDL_RULE_MONTHLY:
            new_repeat = SRV_REMINDER_REPEAT_MONTHLY;
            break;
        case MMI_TDL_RULE_YEARLY:
            new_repeat = SRV_REMINDER_REPEAT_YEARLY;
            break;
        default:
            break;
    }
    return new_repeat;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_load_by_store_index()
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_tdl_load_by_store_index(U16 store_index, U16 vcal_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result = SRV_TDL_RESULT_INVALID_PARAMETER;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (vcal_type > SRV_TDL_VCAL_TASK)
    {
        result = SRV_TDL_RESULT_INVALID_PARAMETER;
        goto MMI_TDL_ERROR_CLEAN;
    }
    
    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
        result = srv_tdl_get(
                    (void*)&g_tdl_cntx.curr_event, 
                    sizeof(srv_tdl_event_struct), 
                    SRV_TDL_VCAL_EVENT,
                    store_index);
                    
        if (result != SRV_TDL_RESULT_OK)
        {
            memset(&g_tdl_cntx.curr_event, 0, sizeof(srv_tdl_event_struct));
            goto MMI_TDL_ERROR_CLEAN;
        }
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        result = srv_tdl_get(
                    (void*)&g_tdl_cntx.curr_task, 
                    sizeof(srv_tdl_task_struct), 
                    SRV_TDL_VCAL_TASK,
                    store_index);
                    
        if (result != SRV_TDL_RESULT_OK)
        {
            memset(&g_tdl_cntx.curr_task, 0, sizeof(srv_tdl_task_struct));
            goto MMI_TDL_ERROR_CLEAN;
        }
#endif
    }
    
MMI_TDL_ERROR_CLEAN:
    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_searched_confirm
 * DESCRIPTION
 *  Confirm of delete all menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_delete_all_searched_confirm(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 str_id = 0;
    mmi_confirm_property_struct arg;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (SRV_TDL_VCAL_EVENT == g_tdl_cntx.vcal_filter)
    {
#ifdef __MMI_CALENDAR_EVENT__
        str_id = STR_ID_CLNDR_DELETE_ALL_QUERY;
#endif
    }
    else if (SRV_TDL_VCAL_TASK == g_tdl_cntx.vcal_filter)
    {
#ifdef __MMI_TODOLIST__
        str_id = STR_TODO_LIST_DELETE_ALL_QUERY;
#endif
    }
    else
    {
        str_id = STR_TODO_LIST_DELETE_ALL_TASK_QUERY;
    }
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = parent_id;
    arg.callback = (mmi_proc_func)mmi_tdl_comfirm_proc;

    mmi_tdl_confirm_user_data_init(&g_tdl_confirm_user_data);
    g_tdl_confirm_user_data.sg_id = parent_id;
    g_tdl_confirm_user_data.LSK_function = mmi_tdl_delete_all_searched;
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    arg.user_tag = (void*)&g_tdl_confirm_user_data;
    mmi_confirm_display(
        (WCHAR*)get_string(str_id),
        MMI_EVENT_QUERY,
        &arg);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_searched
 * DESCRIPTION
 *  Delete all searched task/events.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_delete_all_searched(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //srv_tdl_search_filter_struct search_filter;
    U16 error_code;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    error_code = srv_tdl_search(
                        g_tdl_cntx.sorted_list,
                        NUM_OF_TDL,
                        (srv_tdl_vcal_enum)g_tdl_cntx.vcal_filter,
                        g_tdl_cntx.search,
                        &g_tdl_cntx.total);
                        
    if (error_code != SRV_TDL_RESULT_OK)                        
    {
        return;
    }

    for (i = 0; i < g_tdl_cntx.total; i++)
    {
        mmi_tdl_delete_record(
                        g_tdl_cntx.sorted_list[i].index, 
                        g_tdl_cntx.sorted_list[i].type);
    }

    return;     
}

/*****************************************************************************
* FUNCTION
*  mmi_tdl_dismiss_reminder
* DESCRIPTION
*  Exit from To Do List Reminder Screen.
*  only handle alarm part without update tdl data.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_tdl_dismiss_reminder(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	mmi_frm_nmgr_unblock_sound_vid_stop(MMI_FRM_NMGR_SOUND | MMI_FRM_NMGR_VIB);
#ifndef __MMI_PROF_BEEP_WHEN_BGPLAYING__
	mdi_audio_resume_background_play();
#endif
	mmi_frm_nmgr_control_end(); /* 
								* When not press key and no tough, shoult use it to tell
								* Framework the scenario is end
								*/


	StopTimer(ALARM_ALERT_NOTIFYDURATION_TIMER);

	mmi_frm_group_close(GRP_ID_TDL_REMINDER);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_event_task_content
 * DESCRIPTION
 *  End key handler of todolist reminder screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_get_event_task_content(CHAR *buffer, U16 reminder_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_string_type time_buff = NULL;
    UI_string_type date_buff = NULL;        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (reminder_type > SRV_TDL_VCAL_TASK)
    {
        return;
    }    
    time_buff = (UI_string_type)OslMalloc(MMI_TDL_MAX_TIME_FORMAT_BUFF_EN_SIZE);
    date_buff = (UI_string_type)OslMalloc(MMI_TDL_MAX_DATE_FORMAT_BUFF_EN_SIZE);  
    
    if (SRV_TDL_VCAL_TASK == reminder_type)
    {
#ifdef __MMI_TODOLIST__
        //subject
        mmi_ucs2cpy(buffer, GetString(STR_GLOBAL_SUBJECT));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
        mmi_ucs2cat(buffer, (CHAR*)L" ");
        mmi_ucs2cat(buffer, (CHAR*)g_tdl_cntx.curr_task.subject);
		mmi_ucs2cat(buffer, (CHAR*)L"\n");
		//priority
        mmi_ucs2cat(buffer, GetString(STR_GLOBAL_PRIORITY));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
        mmi_ucs2cat(buffer, (CHAR*)L" ");
        if(g_tdl_cntx.curr_task.priority == 0)
        {
            mmi_ucs2cat(buffer, GetString(STR_GLOBAL_LOW));
        }
        else if(g_tdl_cntx.curr_task.priority == 1)
        {
            mmi_ucs2cat(buffer, GetString(STR_GLOBAL_MEDIUM));
        }
        else
        {
            mmi_ucs2cat(buffer, GetString(STR_GLOBAL_HIGH));
        }
		mmi_ucs2cat(buffer, (CHAR*)L"\n");
        //due time
        mmi_ucs2cat(buffer, GetString(STR_GLOBAL_TIME));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));  
        date_string(&g_tdl_cntx.curr_task.due_time, date_buff, DT_IDLE_SCREEN);
        time_string(&g_tdl_cntx.curr_task.due_time, time_buff, DT_IDLE_SCREEN);
        mmi_ucs2cat(buffer, (CHAR*)date_buff);
        mmi_ucs2cat(buffer, (CHAR*)L"  ");
        mmi_ucs2cat(buffer, (CHAR*)time_buff);    
        mmi_ucs2cat(buffer, (CHAR*)L"\n");

        //alarm
		mmi_ucs2cat(buffer, GetString(STR_GLOBAL_ALARM));
		mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
		mmi_ucs2cat(buffer, (CHAR*)L" ");
		mmi_ucs2cat(buffer, GetString(g_tdl_alm_set[g_tdl_cntx.curr_task.alarm.type].str_id ));
		mmi_ucs2cat(buffer, (CHAR*)L"\n");

		//repeat
		mmi_ucs2cat(buffer, GetString(STR_TODO_REPEAT));
		mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
		mmi_ucs2cat(buffer, (CHAR*)L" ");
		if(g_tdl_cntx.curr_task.repeat.rule != MMI_TDL_RULE_DAYS)
		{
		    mmi_ucs2cat(buffer, GetString(g_tdl_freq_set[g_tdl_cntx.curr_task.repeat.rule].str_id));
		}
		else
		{   
			memset(g_tdl_edit_cntx.repeat_str, 0, sizeof(g_tdl_edit_cntx.repeat_str));
			mmi_tdl_get_dow_repeat_str(g_tdl_edit_cntx.repeat_str, g_tdl_cntx.curr_task.repeat.dows);
		    mmi_ucs2cat(buffer, (CHAR*)g_tdl_edit_cntx.repeat_str);
		}
		mmi_ucs2cat(buffer, (CHAR*)L"\n");
		
        //details
	    if(0 != mmi_ucs2strlen((CHAR*)g_tdl_cntx.curr_task.details))
	    {
			mmi_ucs2cat(buffer, GetString(STR_GLOBAL_DETAILS));
	        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
	        mmi_ucs2cat(buffer, (CHAR*)L" ");
	        mmi_ucs2cat(buffer, (CHAR*)g_tdl_cntx.curr_task.details);
			mmi_ucs2cat(buffer, (CHAR*)L"\n");
	    }
		// status
		mmi_ucs2cat(buffer, GetString(STR_ID_TODO_STATUS));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
        mmi_ucs2cat(buffer, (CHAR*)L" ");
        if(g_tdl_cntx.curr_task.status == 0)
        {
            mmi_ucs2cat(buffer, GetString(STR_ID_TODO_STATUS_UNDONE));
        }
        else if(g_tdl_cntx.curr_task.status == 1)
        {
            mmi_ucs2cat(buffer, GetString(STR_GLOBAL_DONE));
        }
#endif
    }
    else
    {
#ifdef __MMI_CALENDAR_EVENT__

        //subject
        mmi_ucs2cpy(buffer, GetString(STR_GLOBAL_SUBJECT));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
        mmi_ucs2cat(buffer, (CHAR*)L" ");
        mmi_ucs2ncat(buffer, (CHAR*)g_tdl_cntx.curr_event.subject, MAX_TODO_NOTE_LEN);  
        mmi_ucs2cat(buffer, (CHAR*)L"\n");
        // category
        mmi_ucs2cat(buffer, GetString(STR_ID_TDL_CATEGORY));
        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
        mmi_ucs2cat(buffer, (CHAR*)L" ");
        mmi_ucs2cat(buffer, GetString(g_tdl_cntx.curr_event.category + STR_TODO_REMINDER)); 
        mmi_ucs2cat(buffer, (CHAR*)L"\n");
        
        if(g_tdl_cntx.curr_event.category != MMI_TDL_CATEGORY_ANNIVERSARY &&
		   g_tdl_cntx.curr_event.category != MMI_TDL_CATEGORY_BIRTHDAY)
        {
	        //start time
	        mmi_ucs2cat(buffer, GetString(STR_TODO_START_TIME));
	        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
	        mmi_ucs2cat(buffer, (CHAR*)L" ");
	        date_string(&g_tdl_cntx.curr_event.start_time, date_buff, DT_IDLE_SCREEN);
	        time_string(&g_tdl_cntx.curr_event.start_time, time_buff, DT_IDLE_SCREEN);
	        mmi_ucs2cat(buffer, (CHAR*)date_buff);
	        mmi_ucs2cat(buffer, (CHAR*)L"  ");
	        mmi_ucs2cat(buffer, (CHAR*)time_buff); 
	        mmi_ucs2cat(buffer, (CHAR*)L"\n");
	        //end time
	        mmi_ucs2cat(buffer, GetString(STR_TODO_END_TIME));
	        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
	        mmi_ucs2cat(buffer, (CHAR*)L" ");
	        date_string(&g_tdl_cntx.curr_event.end_time, (UI_string_type)date_buff, DT_IDLE_SCREEN);
	        time_string(&g_tdl_cntx.curr_event.end_time, (UI_string_type)time_buff, DT_IDLE_SCREEN);        
	        mmi_ucs2cat(buffer, (CHAR*)date_buff);
	        mmi_ucs2cat(buffer, (CHAR*)L"  ");
	        mmi_ucs2cat(buffer, (CHAR*)time_buff);  
	        mmi_ucs2cat(buffer, (CHAR*)L"\n");
        }
        else
        {
        	//date time
	        mmi_ucs2cat(buffer, GetString(STR_GLOBAL_TIME));
	        mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
	        mmi_ucs2cat(buffer, (CHAR*)L" ");
	        date_string(&g_tdl_cntx.curr_event.start_time, date_buff, DT_IDLE_SCREEN);
	        time_string(&g_tdl_cntx.curr_event.start_time, time_buff, DT_IDLE_SCREEN);
	        mmi_ucs2cat(buffer, (CHAR*)date_buff);
	        mmi_ucs2cat(buffer, (CHAR*)L"  ");
	        mmi_ucs2cat(buffer, (CHAR*)time_buff); 
	        mmi_ucs2cat(buffer, (CHAR*)L"\n");
        }
        
        //alarm
		mmi_ucs2cat(buffer, GetString(STR_GLOBAL_ALARM));
		mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
		mmi_ucs2cat(buffer, (CHAR*)L" ");
		mmi_ucs2cat(buffer, GetString(g_tdl_alm_set[g_tdl_cntx.curr_event.alarm.type].str_id ));

        if(g_tdl_cntx.curr_event.category != MMI_TDL_CATEGORY_ANNIVERSARY &&
		   g_tdl_cntx.curr_event.category != MMI_TDL_CATEGORY_BIRTHDAY)
        {
			//repeat
			mmi_ucs2cat(buffer, (CHAR*)L"\n");
			mmi_ucs2cat(buffer, GetString(STR_TODO_REPEAT));
			mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
			mmi_ucs2cat(buffer, (CHAR*)L" ");
			if(g_tdl_cntx.curr_event.repeat.rule != MMI_TDL_RULE_DAYS)
			{
			    mmi_ucs2cat(buffer, GetString(g_tdl_freq_set[g_tdl_cntx.curr_event.repeat.rule].str_id));
			}
			else
			{
				memset(g_tdl_edit_cntx.repeat_str, 0, sizeof(g_tdl_edit_cntx.repeat_str));
				mmi_tdl_get_dow_repeat_str(g_tdl_edit_cntx.repeat_str, g_tdl_cntx.curr_event.repeat.dows);
			    mmi_ucs2cat(buffer, (CHAR*)g_tdl_edit_cntx.repeat_str);
			}
		
	        //location
            if(0 != mmi_ucs2strlen((CHAR*)g_tdl_cntx.curr_event.location))
            {
			    mmi_ucs2cat(buffer, (CHAR*)L"\n");
			    mmi_ucs2cat(buffer, GetString(STR_TODO_LOCATION));
			    mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
			    mmi_ucs2cat(buffer, (CHAR*)L" ");
			    mmi_ucs2cat(buffer, (CHAR*) g_tdl_cntx.curr_event.location);
            }
		}
		
        //details
        if(0 != mmi_ucs2strlen((CHAR*)g_tdl_cntx.curr_event.details))
	    {
            mmi_ucs2cat(buffer, (CHAR*)L"\n");
	        mmi_ucs2cat(buffer, GetString(STR_GLOBAL_DETAILS));
            mmi_ucs2cat(buffer, GetString(STR_ID_CAL_COLON));
            mmi_ucs2cat(buffer, (CHAR*)L" ");
            mmi_ucs2cat(buffer, (CHAR*) g_tdl_cntx.curr_event.details);
        }
#endif
    }
    
    if (time_buff != NULL)
    { 
        OslMfree(time_buff);
    }
    if (date_buff != NULL)
    { 
        OslMfree(date_buff);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_view_int
 * DESCRIPTION
 *  End key handler of todolist reminder screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_view_int(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 note_len;
    U8 *gui_buffer;
    UI_string_type title;
	srv_tdl_vcal_enum vcal_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                GRP_ID_TDL_VIEW, 
                SCR_TDL_VIEW, 
                NULL, 
                mmi_tdl_entry_view_int, 
                MMI_FRM_FULL_SCRN))
    {
        return;
    }
    vcal_type = g_tdl_cntx.vcal_filter; 
	
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();
    mmi_tdl_get_event_task_content(g_tdl_edit_cntx.view_buff, vcal_type);
    note_len = mmi_ucs2strlen(g_tdl_edit_cntx.view_buff);
    
    if (SRV_TDL_VCAL_EVENT == vcal_type)
    {
#ifdef __MMI_CALENDAR_EVENT__
        title = (UI_string_type)g_tdl_cntx.curr_event.subject;  
#endif

    }
    else
    {
#ifdef __MMI_TODOLIST__
         title = (UI_string_type)g_tdl_cntx.curr_task.subject;
#endif
    }
    
    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);   
	ShowCategory79Screen(
	   title,
	   (U8*) GetImage(GetRootTitleIcon(ORGANIZER_CALENDER_MENU)),
	   (UI_string_type) (GetString(STR_GLOBAL_EDIT)),
	   (U8*) GetImage(IMG_GLOBAL_OK),
	   (UI_string_type) (GetString(STR_GLOBAL_BACK)),
	   (U8*) GetImage(IMG_GLOBAL_BACK),
	   MMI_TRUE,
	   MMI_FALSE,
	   (UI_buffer_type) g_tdl_edit_cntx.view_buff,
	   note_len,
	   gui_buffer);

	if (SRV_TDL_VCAL_EVENT == vcal_type)
	{
#ifdef __MMI_CALENDAR_EVENT__
	    SetCenterSoftkeyFunction(mmi_tdl_entry_event_edit_screen, KEY_EVENT_UP);
		SetLeftSoftkeyFunction(mmi_tdl_entry_event_edit_screen, KEY_EVENT_UP);
#endif		
	}
	else
	{
#ifdef __MMI_TODOLIST__	
	    SetCenterSoftkeyFunction(mmi_tdl_entry_task_edit_screen, KEY_EVENT_UP);
		SetLeftSoftkeyFunction(mmi_tdl_entry_task_edit_screen, KEY_EVENT_UP);
#endif		
	}
	SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_view_with_sg
 * DESCRIPTION
 *  Execute View option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_view_with_sg(mmi_id parent_id, srv_tdl_vcal_enum vcal_type, U32 source, U32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_view_group_data_struct *view_group_cntx;
	//srv_tdl_result_enum ret = SRV_TDL_RESULT_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.curr_store_idx = index;
    g_tdl_cntx.vcal_filter = vcal_type; 
    view_group_cntx = (mmi_tdl_view_group_data_struct*)
                            OslMalloc(sizeof(mmi_tdl_view_group_data_struct));
    view_group_cntx->parent_id = parent_id;
     
    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
		g_tdl_cntx.curr_source_id = (srv_tdl_event_source_enum)source;
		g_tdl_cntx.curr_event_id = index;

        view_group_cntx->group_id = mmi_frm_group_create(
                                            parent_id, 
                                            GRP_ID_TDL_VIEW, 
                                            mmi_tdl_event_view_group_proc, 
                                            view_group_cntx);
            
        mmi_frm_group_enter(GRP_ID_TDL_VIEW, MMI_FRM_NODE_SMART_CLOSE_FLAG);
	    srv_tdl_event_get(
			  (void*)&g_tdl_cntx.curr_event, 
			  sizeof(srv_tdl_event_struct), 
			  (srv_tdl_event_source_enum)source,
			  index);
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        view_group_cntx->group_id = mmi_frm_group_create(
                                            parent_id, 
                                            GRP_ID_TDL_VIEW, 
                                            mmi_tdl_task_view_group_proc, 
                                            view_group_cntx);
            
        mmi_frm_group_enter(GRP_ID_TDL_VIEW, MMI_FRM_NODE_SMART_CLOSE_FLAG);
        //ret = srv_tdl_get(
        srv_tdl_get(
            (void*)&g_tdl_cntx.curr_task, 
            sizeof(srv_tdl_task_struct), 
            SRV_TDL_VCAL_TASK,
            index);
#endif
    }

#ifdef __MMI_BIRTHDAY_REMINDER__
    if (vcal_type == SRV_TDL_VCAL_EVENT && 
        g_tdl_cntx.curr_event.category == MMI_TDL_CATEGORY_BIRTHDAY)
    {
        mmi_tdl_br_entry_bday_view_from_org(GRP_ID_TDL_VIEW);
    }
    else
#endif    
    {
        mmi_tdl_entry_view_int();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_task_main_leave_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  start_index     [IN]        
 *  menuData        [?]         
 *  num_item        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
mmi_ret mmi_tdl_task_main_leave_proc(mmi_event_struct *parm)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (parm->evt_id)
    {
        case EVT_ID_SCRN_DEINIT:
        {
            g_tdl_cntx.curr_option = TODO_LIST_OPTION_TOTAL;
	    #if 0
        #ifdef __MMI_OP11_HOMESCREEN__
/* under construction !*/
        #endif
        #endif
            {
                g_tdl_cntx.vcal_filter = SRV_TDL_VCAL_BOTH;
            }
            break;
        }
        default:
            break;
    }

    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_view_hdlr
 * DESCRIPTION
 *  Execute View option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_view_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id parent_id;
    U16 index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    parent_id = mmi_tdl_sg_mgr_get_current_sg_id();
    index = mmi_tdl_get_curr_store_idx();
    mmi_tdl_view_with_sg(parent_id, g_tdl_cntx.vcal_filter, 0, index);
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_delete_confirm
 * DESCRIPTION
 *  Display confirmation screen for deleting one task.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_delete_confirm(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = parent_id;
    arg.callback = (mmi_proc_func)mmi_tdl_comfirm_proc;

    mmi_tdl_confirm_user_data_init(&g_tdl_confirm_user_data);
    g_tdl_confirm_user_data.sg_id = parent_id;
    g_tdl_confirm_user_data.LSK_function = mmi_tdl_delete_curr_task;
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    arg.user_tag = (void*)&g_tdl_confirm_user_data;
    mmi_confirm_display(
        (WCHAR*)get_string(STR_TODO_LIST_DELETE_ONE_TASK_QUERY),
        MMI_EVENT_QUERY,
        &arg);
        
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_confirm
 * DESCRIPTION
 *  Confirm of delete all menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_delete_all_confirm(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_tdl_check_no_event_popup())
    {
        return;
    }
    
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = parent_id;
    arg.callback = (mmi_proc_func)mmi_tdl_comfirm_proc;

    mmi_tdl_confirm_user_data_init(&g_tdl_confirm_user_data);
    g_tdl_confirm_user_data.sg_id = parent_id;
    g_tdl_confirm_user_data.LSK_function = mmi_tdl_validated_delete_all;
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    arg.user_tag = (void*)&g_tdl_confirm_user_data;
    mmi_confirm_display(
        (WCHAR*)get_string(STR_TODO_LIST_DELETE_ALL_TASK_QUERY),
        MMI_EVENT_QUERY,
        &arg);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_check_no_event_popup
 * DESCRIPTION
 *  Confirm of delete all menu.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_tdl_check_no_event_popup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 str_id = 0; 
    U16 total;
    srv_tdl_vcal_enum vcal_type = g_tdl_cntx.vcal_filter;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_tdl_get_all_index(NULL, NUM_OF_TDL, vcal_type, &total);
        
    /* check if task/event list is empty */
    if (0 == total)
    {
        if (vcal_type == SRV_TDL_VCAL_EVENT)
        {
#ifdef __MMI_CALENDAR_EVENT__
            str_id = STR_ID_TDL_NO_EVENTS;
#endif
        }
        else
        {
#ifdef __MMI_TODOLIST__
            str_id = STR_ID_TDL_NO_TASKS;
#endif
        }
        mmi_popup_display_simple((WCHAR*)(get_string(str_id)), MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);

        return MMI_TRUE;
    }
    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_curr_store_idx
 * DESCRIPTION
 *  Get current selected item's store index
 * PARAMETERS
 * 
 * RETURNS
 * The store index of the item.
 *****************************************************************************/
U16 mmi_tdl_get_curr_store_idx(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_tdl_cntx.sorted_list[g_tdl_cntx.curr_selected].index;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_list_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_list_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_tdl_cntx.curr_selected = (U8)index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_async_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  start_index     [IN]        
 *  menuData        [?]         
 *  num_item        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_tdl_get_async_items(
                S32 start_index, 
                gui_iconlist_menu_item *menu_data, 
                S32 num_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_get_async_items(start_index, menu_data, num_item, &(g_tdl_cntx.date));
    return num_item;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_get_async_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  start_index     [IN]        
 *  menuData        [?]         
 *  num_item        [IN]   
 *  data            [IN]
 * RETURNS
 *  
 *****************************************************************************/
void mmi_get_async_items(
                S32 start_index, 
                gui_iconlist_menu_item *menu_data, 
                S32 num_item,
                MYTIME* date)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, count = 0;
    srv_tdl_task_short_struct *ptask = NULL;
    //U16 ret;
	CHAR str[(MMI_TDL_MAX_DATE_STRING_LEN + 1) * ENCODING_LENGTH] = {0};
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE3(MMI_TDL_DATA_ALL_ASYNC_ITEM, start_index, num_item, g_tdl_cntx.total);
        
    /* Construct task list */
    for (i = start_index; count < num_item; i++, count++)
    {
#ifdef __MMI_TODOLIST__		
		//ret = srv_tdl_get_cache(
		srv_tdl_get_cache(
				(void*)&ptask, 
				sizeof(srv_tdl_task_short_struct), 
				SRV_TDL_VCAL_TASK,
				g_tdl_cntx.sorted_list[i].index);

        mmi_tdl_get_date_string(
                        &ptask->due_time, 
                        (CHAR*)menu_data[count].item_list[1], 
                        (MMI_TDL_MAX_DATE_STRING_LEN + 1) * ENCODING_LENGTH);

        mmi_tdl_get_time_string(
                            ptask,
                            SRV_TDL_VCAL_TASK,
                            date,
                            str,
                            (MMI_TDL_MAX_TIME_STRING_LEN + 1) * 2);   

		mmi_ucs2cat((CHAR*)menu_data[count].item_list[1], (CHAR*)L"  ");
        mmi_ucs2cat((CHAR*)menu_data[count].item_list[1], str);
        
        /* Subject */
        mmi_ucs2ncpy(
            (CHAR*)menu_data[count].item_list[0], 
            (CHAR*)ptask->subject, 
            SRV_TDL_SUBJECT_SIZE);
                
        /* Alarm */
        if (ptask->alarm.type >= MMI_TDL_ALARM_ON)
        {
            menu_data[count].image_list[0] = 
                        (PU8)GetImage(IMG_TODO_LIST_ICON_ALARM);
        }
        else
        {
            menu_data[count].image_list[0] = 0;
        }
    
        /* Type */
        menu_data[count].image_list[1] =
                (PU8)GetImage((U16)(ORGANIZER_MENU_TODOLIST_IMAGEID));

        /* status */
#ifdef __MMI_FTE_SUPPORT__		
		if(ptask->status == 0)
		{
            menu_data[count].image_list[2] = (PU8)GetImage((U16)(IMG_TODO_LIST_ICON_UNDONE));
		}
		else
		{
            menu_data[count].image_list[2] = (PU8)GetImage((U16)(IMG_TODO_LIST_ICON_DONE));
		}
#endif
#endif
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_entry_list_option
 * DESCRIPTION
 *  Show option list
 * PARAMETERS
 *  parent_id  [IN]
 *  root_id    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_entry_list_option(MMI_ID parent_id, mmi_menu_id root_id, mmi_proc_func proc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_common_group_data_struct *opt_user_data;     
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    opt_user_data = (mmi_tdl_common_group_data_struct*)OslMalloc(sizeof(mmi_tdl_common_group_data_struct));
    memset(opt_user_data, 0, sizeof(mmi_tdl_common_group_data_struct));
    opt_user_data->parent_id = parent_id;

    opt_user_data->group_id = mmi_frm_group_create(
                                                parent_id,
                                                GRP_ID_AUTO_GEN,
                                                proc,
                                                opt_user_data);
    mmi_frm_group_enter(opt_user_data->group_id, MMI_FRM_NODE_NONE_FLAG);

    opt_user_data->child_id = cui_menu_create(
                                        opt_user_data->group_id,
                                        CUI_MENU_SRC_TYPE_RESOURCE,
                                        CUI_MENU_TYPE_OPTION,
                                        root_id,
                                        MMI_TRUE,
                                        NULL);
    cui_menu_set_default_title(
                            opt_user_data->child_id, 
                            get_string(STR_GLOBAL_OPTIONS),
                            get_image(ORGANIZER_TITLE_IMAGEID));
    mmi_tdl_send_vcal_menu_check(opt_user_data->child_id);
    //search result listDelete All;
    if(parent_id == GRP_ID_TDL_SEARCH)
	 cui_menu_set_item_hidden(opt_user_data->child_id, MITEM_TODO_LIST_DELETE_ALL, MMI_TRUE); 
    cui_menu_run(opt_user_data->child_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_edit_opt_menu_select_hdlr
 * DESCRIPTION
 *  Generate the menus.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_edit_opt_menu_select_hdlr(mmi_id parent_id, mmi_id highlight_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    cui_tdl_save_result_struct send_evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    switch (highlight_item)
    {
        case MITEM_TDL_EDIT_OPTIONS_SELECT:
        {
            switch (parent_id)
            {
#ifdef __MMI_CALENDAR_EVENT__
                case CAL_EVENT_EDIT_INLINE_TYPE_TEXT:
                {
                    mmi_cal_entry_select_category();
                    break;
                }         
                case CAL_EVENT_EDIT_INLINE_REPEAT_TEXT:
                {
                    mmi_tdl_entry_select_repeat_type();
                    break;
                }
                case CAL_EVENT_EDIT_INLINE_ALARM_TEXT:
                {
                    mmi_tdl_entry_select_alarm_type();
                    break;
                }    
#endif    
#ifdef __MMI_TODOLIST__		  
				case CUI_INLINE_ITEM_REPEAT_TEXT:
				{
					mmi_tdl_entry_select_repeat_type();
					break;
				}
				case CUI_INLINE_ITEM_ALARM_TEXT:
				{
					mmi_tdl_entry_select_alarm_type();
					break;
				}	 
#endif 
                default:
                    break;
            }
            break;
        }   
        case MITEM_TDL_EDIT_OPTIONS_SAVE:
        {		
		    send_evt.evt_id = EVT_ID_CUI_INLINE_SUBMIT;
            send_evt.size = sizeof(cui_tdl_save_result_struct);
            send_evt.user_data = NULL;
            send_evt.sender_id = GRP_ID_TDL_EDIT_OPTIONS;
            send_evt.result = 0;
            send_evt.store_index = g_tdl_cntx.curr_store_idx;
	        //mmi_frm_group_post_event_ex(GRP_ID_TDL_EDIT_OPTIONS, g_tdl_edit_cntx.save_sg_id, (mmi_group_event_struct*)&send_evt, 0);
	        mmi_frm_group_post_event_ex(GRP_ID_TDL_EDIT_OPTIONS, g_tdl_edit_cntx.save_sg_id, (mmi_event_struct*)&send_evt, 0);
            break;
        }          
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_search_option_group_proc
 * DESCRIPTION
 *  Generate the menus.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_tdl_edit_option_group_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*)evt;
    mmi_tdl_common_group_data_struct *opt_user_data;     
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    opt_user_data = (mmi_tdl_common_group_data_struct*)evt->user_data;
    switch(menu_evt->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            OslMfree(opt_user_data);
            break;
        }  
        case EVT_ID_CUI_MENU_LIST_ENTRY:
            break;
            
        case EVT_ID_CUI_MENU_ITEM_SELECT:
            mmi_tdl_edit_opt_menu_select_hdlr(opt_user_data->parent_id, menu_evt->highlighted_menu_id);
            break;

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(opt_user_data->child_id);
            mmi_frm_group_close(opt_user_data->group_id);
            break;
    }
    return MMI_RET_OK;        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_edit_option
 * DESCRIPTION
 *  Show option list
 * PARAMETERS
 *  parent_id  [IN]
 *  root_id    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_edit_option(MMI_ID parent_id, mmi_menu_id root_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_common_group_data_struct *opt_user_data;     
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    opt_user_data = (mmi_tdl_common_group_data_struct*)OslMalloc(sizeof(mmi_tdl_common_group_data_struct));
    memset(opt_user_data, 0, sizeof(mmi_tdl_common_group_data_struct));
    opt_user_data->parent_id = root_id;

    opt_user_data->group_id = mmi_frm_group_create(
                                                parent_id,
                                                GRP_ID_TDL_EDIT_OPTIONS,
                                                mmi_tdl_edit_option_group_proc,
                                                opt_user_data);
    mmi_frm_group_enter(opt_user_data->group_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    opt_user_data->child_id = cui_menu_create(
                                        opt_user_data->group_id,
                                        CUI_MENU_SRC_TYPE_RESOURCE,
                                        CUI_MENU_TYPE_OPTION,
                                        MITEM_TDL_EDIT_OPTIONS,
                                        MMI_TRUE,
                                        NULL);
    cui_menu_set_default_title(
                            opt_user_data->child_id, 
                            get_string(STR_GLOBAL_OPTIONS),
                            get_image(ORGANIZER_TITLE_IMAGEID));
    cui_menu_run(opt_user_data->child_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clndr_search_daily_check
 * DESCRIPTION
 *  Check if the event is in the search list.
 * PARAMETERS
 *  data : [IN] The data to be checked.
 *  filter : [IN] The check criterin.
 * RETURNS
 *  The error code of the operation.
 * RETURN VALUES
 *  MMI_TRUE : Sort successfully.
 *  MMI_FALSE : Sort failed with unknow reasons.
 *****************************************************************************/ 
static MMI_BOOL mmi_clndr_search_daily_check(
                                 const void *data, 
                                 const srv_tdl_vcal_enum vcal_type,
                                 const srv_tdl_search_filter_struct search_filter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_short_struct *pevent = (srv_tdl_event_short_struct*)data;
    MMI_BOOL result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (pevent->repeat.rule)
    {
	#if defined(__MMI_INDICAL__) && defined(__MMI_TODOLIST__)
        case MMI_TDL_RULE_TITHI:
            result = (MMI_BOOL)srv_tdl_event_search_tithi_daily(
                                                    data, 
                                                    vcal_type,
                                                    search_filter.u.date_time);
            
            break;
    #endif /* __MMI_INDICAL__ */

        default:
            result = srv_tdl_event_search_check_daily(
                                                    pevent, 
                                                    search_filter.u.date_time);
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clndr_search_daily_check
 * DESCRIPTION
 *  Check if the event is in the search list.
 * PARAMETERS
 *  data : [IN] The data to be checked.
 *  filter : [IN] The check criterin.
 * RETURNS
 *  The error code of the operation.
 * RETURN VALUES
 *  MMI_TRUE : Sort successfully.
 *  MMI_FALSE : Sort failed with unknow reasons.
 *****************************************************************************/ 
static MMI_BOOL mmi_tdl_search_daily_check(
                                 const void *data, 
                                 const srv_tdl_vcal_enum vcal_type,
                                 const srv_tdl_search_filter_struct search_filter)

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_task_short_struct *ptask = (srv_tdl_task_short_struct*)data;
    MMI_BOOL result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (ptask->repeat.rule)
    {
	#if defined(__MMI_INDICAL__) && defined(__MMI_TODOLIST__)
        case MMI_TDL_RULE_TITHI:
            result = srv_tdl_event_search_tithi_daily(
                                                    data, 
                                                    vcal_type,
                                                    search_filter.u.date_time);
            
            break;
    #endif /* __MMI_INDICAL__ */

        default:
            result = srv_tdl_task_search_check_daily(
                                                    ptask, 
                                                    search_filter.u.date_time);
    }
    return result;
}


 /*****************************************************************************
 * FUNCTION
 *  mmi_tdl_make_daily_list_ext
 * DESCRIPTION
 *  To initialize task list of selected date from calendar application.
 * PARAMETERS
 *  sorted_list   [OUT]   sorted_list array.
 *  total         [OUT]   buffer to store the total num.
 *  size          [IN]    size of "sorted_list".
 *  selected_time [IN]    time to filter the tasks.
 *  vcal_type     [IN]    filter of vcal.
 * RETURNS
 *  S32  the error code
 *****************************************************************************/
U16 mmi_tdl_make_daily_list_ext(
                    srv_tdl_event_task_struct *sorted_list, 
                    U16 *total,
                    U8 size, 
                    MYTIME seleted_time, 
                    U16 vcal_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_search_filter_struct search_info;
    U16 result = MMI_TDL_ERROR_UNKNOW;
    U16 error_code = MMI_TDL_ERROR_UNKNOW;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE0(MMI_TDL_DATA_MAKE_DAILY_LIST);
    if (seleted_time.nYear == 0 || 
        seleted_time.nMonth == 0 || 
        seleted_time.nDay == 0)
    {
        goto MMI_TDL_ERROR_CLEAN;
    }

    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_MAKE_DAILY_LIST_FILTER, vcal_type);
    
    search_info.type = SRV_TDL_SEARCH_TYPE_DAILY;
    memcpy(&search_info.u.date_time, &seleted_time, sizeof(MYTIME));

    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
        error_code = srv_tdl_search_ext(
                            sorted_list,
                            NUM_OF_TDL,
                            (srv_tdl_vcal_enum)vcal_type,
                            search_info,
                            total,
                            mmi_clndr_search_daily_check);
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        error_code = srv_tdl_search_ext(
                            sorted_list,
                            NUM_OF_TDL,
                            (srv_tdl_vcal_enum)vcal_type,
                            search_info,
                            total,
                            mmi_tdl_search_daily_check);

		g_tdl_cntx.search.type = search_info.type;
		memcpy(&g_tdl_cntx.search.u.date_time, &seleted_time, sizeof(MYTIME));
#endif
    }
    if (error_code != SRV_TDL_RESULT_OK)
    {
        goto MMI_TDL_ERROR_CLEAN;
    }
    
    error_code = srv_tdl_sort(
                        sorted_list, 
                        *total, 
                        SRV_TDL_SORT_TYPE_ENTRY_TIME);

    if (error_code != SRV_TDL_RESULT_OK)
    {
        goto MMI_TDL_ERROR_CLEAN;
    }

    result = MMI_TDL_SUCCESS;
    
MMI_TDL_ERROR_CLEAN:
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_MAKE_DAILY_LIST_TOTAL, *total);
    MMI_TDL_UTIL_TRACE2(MMI_TDL_DATA_MAKE_DAILY_LIST_LEAVE, error_code, result);
    return result;    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_make_all_list
 * DESCRIPTION
 *  To make the list of all tasks to be displayed.
 * PARAMETERS
 *  list : [OUT] the sorted list result, if list == NULL, searched result
 *               will be stored in g_tdl_cntx.sorted_list, and total will 
 *               be stored in g_tdl_cntx.total_listed_num.
 *  total : [OUT] searched total.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_make_all_list(
                        srv_tdl_event_task_struct *list, 
                        U16 size,
                        U16 *total, 
                        U16 vcal_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE0(MMI_TDL_DATA_MAKE_ALL_LIST);
    srv_tdl_get_all_index(list, size, (srv_tdl_vcal_enum)vcal_type, total);
    srv_tdl_sort(list, *total, SRV_TDL_SORT_TYPE_ENTRY_TIME);
}

/*****************************************************************************
* FUNCTION
*  mmi_tdl_save_adjust_field
* DESCRIPTION
*   This function update tdl record
*
* PARAMETERS
*  void
* RETURNS
*  void
* GLOBALS AFFECTED
*   none
*****************************************************************************/
U16 mmi_tdl_save_adjust_field(
                        void *data,
                        const U16 buff_size,
                        const U16 vcal_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_struct *pevent;
    srv_tdl_task_struct *ptask;
    U16 error_code;
    U16 result = MMI_TDL_SUCCESS;
    MYTIME incTime, expiryTime;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_SAVE_ADJUST_FIELD_ENTRY, vcal_type);
    
    if (SRV_TDL_VCAL_EVENT == vcal_type)
    {
#ifdef __MMI_CALENDAR_EVENT__
        pevent = (srv_tdl_event_struct*)data;

        /* Check end time. */
        if (CompareTime(pevent->end_time, pevent->start_time, NULL) < 0)
        {
            memcpy(&pevent->end_time, &pevent->start_time, sizeof(MYTIME));
            result = MMI_TDL_INVALID_END_TIME;
        }
        
        /* Check repeat rule. */
		if((pevent->repeat.rule != MMI_TDL_RULE_ONCE) //&&
//		   (pevent->category != MMI_TDL_CATEGORY_ANNIVERSARY) &&
//           (pevent->category != MMI_TDL_CATEGORY_BIRTHDAY)
#ifdef __MMI_INDICAL__
           && (pevent->repeat.rule == MMI_TDL_RULE_TITHI &&
           pevent->start_time.nYear < 2000)
#endif /* __MMI_INDICAL__ */
           )
		{
			DTGetRTCTime(&incTime);
            memset(&incTime, 0, sizeof(MYTIME));
			
			if(pevent->repeat.rule == MMI_TDL_RULE_DAILY || pevent->repeat.rule == MMI_TDL_RULE_DAYS)
			{
				incTime.nDay = 1;
			}
			else if(pevent->repeat.rule == MMI_TDL_RULE_WEEKLY)
			{
				incTime.nDay = 7;
			}
			else if(pevent->repeat.rule == MMI_TDL_RULE_MONTHLY)
			{
				incTime.nMonth = 1;
			}
			else if(pevent->repeat.rule == MMI_TDL_RULE_YEARLY)
			{
				incTime.nYear = 1;
			}
			
			IncrementTime(pevent->start_time, incTime, &expiryTime);
			if (CompareTime(pevent->end_time, expiryTime, NULL) >= 0)
			{
				pevent->repeat.rule = MMI_TDL_RULE_ONCE;
                result = MMI_TDL_INVALID_REPEAT;
			}
			if(pevent->repeat.rule == MMI_TDL_RULE_DAYS)
			{
				if((pevent->repeat.dows & (0x1 << pevent->start_time.DayIndex)) == 0)
				{
					pevent->repeat.rule = MMI_TDL_RULE_ONCE;
                    result = MMI_TDL_INVALID_REPEAT;
				}
			}
        }

        /* Check anniversary repeat rule. */

        if (pevent->repeat.rule != MMI_TDL_RULE_YEARLY &&
            (pevent->category == MMI_TDL_CATEGORY_ANNIVERSARY ||
             pevent->category == MMI_TDL_CATEGORY_BIRTHDAY))
        {
            pevent->repeat.rule = MMI_TDL_RULE_YEARLY;
        }

        /* Check alarm time. */
        error_code = (mmi_tdl_error_enum)mmi_tdl_is_valid_alarm(pevent->category,
                                &pevent->alarm, &pevent->start_time, pevent->repeat.rule);

        if (error_code == MMI_TDL_EXPIRED_ALARM ||
            error_code == MMI_TDL_INVALID_ALARM ||
            error_code == MMI_TDL_ALARM_TOO_LATE ||
            error_code == MMI_TDL_ALARM_OVERRUN)
        {
            pevent->alarm.type = MMI_TDL_ALARM_OFF;
            pevent->alarm.snooze = 0;
            result = MMI_TDL_INVALID_ALARM;            
        }
        
        mmi_tdl_save_adjust_alarm_time(&pevent->alarm, &pevent->start_time);
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        ptask = (srv_tdl_task_struct*)data;
        error_code = (mmi_tdl_error_enum)mmi_tdl_is_valid_alarm(0xff,
                        &ptask->alarm, &ptask->due_time, ptask->repeat.rule);

        /* Check alarm time. */
        if (error_code == MMI_TDL_EXPIRED_ALARM ||
            error_code == MMI_TDL_INVALID_ALARM ||
            error_code == MMI_TDL_ALARM_TOO_LATE ||
            error_code == MMI_TDL_ALARM_OVERRUN)
        {
            ptask->alarm.type = MMI_TDL_ALARM_OFF;
            ptask->alarm.snooze = 0;
            result = MMI_TDL_INVALID_ALARM;            
        }
        mmi_tdl_save_adjust_alarm_time(&ptask->alarm, &ptask->due_time);
#endif
    }

    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_SAVE_ADJUST_FIELD_LEAVE, result);
    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_is_valid_alarm
 * DESCRIPTION
 *  Retrieve user input from inline editor screen and save to global context.
 * PARAMETERS
 *  MYTIME alarm_time
 *  MYTIME *start_time
 *  U8 alarm_type
 *  U8 repeat
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_tdl_is_valid_alarm(U8 category, srv_tdl_alarm_struct *alarm, MYTIME *start_time, U8 repeat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    TIME_EQUALITY equality;
    MYTIME curr_time;
    mmi_tdl_error_enum result = MMI_TDL_SUCCESS;
    MYTIME temp_alarm_time;
    U32 diff_sec;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_IS_VALID_ALARM_RESULT, alarm->type);

    /* Check alarm */
    if (alarm->type >= MMI_TDL_ALARM_TOTAL)
    {
        result = MMI_TDL_INVALID_ALARM;
        goto MMI_ERROR_CLEAN;            
    }

    if (alarm->type == MMI_TDL_ALARM_OFF)
    {
        goto MMI_ERROR_CLEAN;
    }

    memcpy(&temp_alarm_time, &alarm->first_launch, sizeof(MYTIME));
    
    MMI_TDL_UTIL_TRACE3(
        MMI_TDL_DATA_IS_VALID_ALARM_CURR_DATE, 
        temp_alarm_time.nYear, 
        temp_alarm_time.nMonth, 
        temp_alarm_time.nDay);
    MMI_TDL_UTIL_TRACE2(
        MMI_TDL_DATA_IS_VALID_ALARM_CURR_DATE, 
        temp_alarm_time.nHour, 
        temp_alarm_time.nMin);

    if (repeat == MMI_TDL_RULE_ONCE && temp_alarm_time.nYear < MMI_TDL_START_YEAR_SUPPORT)
    {
        result = MMI_TDL_INVALID_ALARM;
        goto MMI_ERROR_CLEAN;            
    }
    
    GetDateTime(&curr_time);
    
    MMI_TDL_UTIL_TRACE3(
        MMI_TDL_DATA_IS_VALID_ALARM_CURR_DATE, 
        curr_time.nYear, 
        curr_time.nMonth, 
        curr_time.nDay);
    MMI_TDL_UTIL_TRACE2(
        MMI_TDL_DATA_IS_VALID_ALARM_CURR_DATE, 
        curr_time.nHour, 
        curr_time.nMin);

    equality = (TIME_EQUALITY)CompareTime(temp_alarm_time, curr_time, NULL);

    /* if current time > alarm_time */
    if (repeat == MMI_TDL_RULE_ONCE && equality != TIME_GREATER)
    {
        if (alarm->type >= MMI_TDL_ALARM_ON)
        {
            result = MMI_TDL_EXPIRED_ALARM; 
            goto MMI_ERROR_CLEAN;
        }
    }
    
    /* If custom, should check if alarm time later than start time */
    if (alarm->type == MMI_TDL_ALARM_CUSTOM)
    {
        /* should alarm_time < start time */
        equality = (TIME_EQUALITY)CompareTime(temp_alarm_time, *start_time, NULL);
        if (equality == TIME_GREATER)
        {
            result = MMI_TDL_ALARM_TOO_LATE;
            goto MMI_ERROR_CLEAN;
        }
        else
        {
            diff_sec = applib_get_time_difference_ext_in_second(
                                            (applib_time_struct*)start_time,
                                            (applib_time_struct*)&temp_alarm_time);

        #ifdef __MMI_BIRTHDAY_REMINDER__
            if (category != MMI_TDL_CATEGORY_BIRTHDAY)
        #endif
            {
                if (diff_sec > MMI_TDL_MAX_PRE_REMINDER_SEC) 
                {
                    result = MMI_TDL_ALARM_OVERRUN;
                    goto MMI_ERROR_CLEAN;
                }
            }
        }
    }
    
MMI_ERROR_CLEAN:
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_IS_VALID_ALARM_RESULT, result);
    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_save_adjust_alarm_type
 * DESCRIPTION
 *  To sort the task list in decending time order.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_save_adjust_alarm_type(
                    srv_tdl_alarm_struct *alarm, 
                    const MYTIME *start_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME pre_reminder;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (alarm->type != MMI_TDL_ALARM_CUSTOM || 
        applib_dt_compare_time(
            (applib_time_struct*)start_time, 
            (applib_time_struct*)&alarm->first_launch, 
            NULL) < 0)
    {
        return;
    }
    
    applib_get_time_difference(
            (applib_time_struct*)start_time, 
            (applib_time_struct*)&alarm->first_launch,
            (applib_time_struct*)&pre_reminder);

    if (pre_reminder.nYear == 0 &&
        pre_reminder.nMonth == 0 &&
        pre_reminder.nDay == 0 &&
        pre_reminder.nHour == 0 &&
        pre_reminder.nSec == 0)
    {
        switch (pre_reminder.nMin)
        {
            case 0:
                alarm->type = MMI_TDL_ALARM_ON;
                break;
                
            case 5:
                alarm->type = MMI_TDL_ALARM_BEFORE_5_MINS;
                break;
                
            case 10:
                alarm->type = MMI_TDL_ALARM_BEFORE_10_MINS;
                break;
                
            case 15:
                alarm->type = MMI_TDL_ALARM_BEFORE_15_MINS;
                break;
                
            case 30:
                alarm->type = MMI_TDL_ALARM_BEFORE_30_MINS;
                break;
                
            default:
                break;
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_record
 * DESCRIPTION
 *  Delete one task from To Do List
 * PARAMETERS
 *  index       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_tdl_delete_record(U16 index, U16 vcal_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (vcal_type > SRV_TDL_VCAL_TASK)
    {
        return MMI_FALSE;
    }

    if(vcal_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__		
		if(g_tdl_cntx.curr_event_id != index)
		{
			srv_tdl_delete(index, (srv_tdl_vcal_enum)vcal_type);  // delete all: monthly weekly view
		}
        else
        {
            srv_tdl_event_delete(g_tdl_cntx.curr_source_id, g_tdl_cntx.curr_event_id);
        }
#endif		
    }
    else
    {
	    srv_tdl_delete(index, (srv_tdl_vcal_enum)vcal_type);
	}

#ifdef __SYNCML_SUPPORT__
    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
    #ifdef __MMI_SYNCML_SYNC_CALENDAR_SUPPORT__
        mmi_syncml_calendar_data_changed_notification(SYNCML_RECORD_DELETE, index);
    #endif
    }
    else
    {
    #ifdef __MMI_SYNCML_SYNC_TASK_SUPPORT__
        mmi_syncml_task_data_changed_notification(SYNCML_RECORD_DELETE, index);    
    #endif
    }
#endif
    return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_short
 * DESCRIPTION
 *  Delete events in spec time.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void* mmi_tdl_get_short(srv_tdl_vcal_enum vcal_type, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_short_struct *pevent = NULL;
    srv_tdl_task_short_struct *ptask = NULL;
    //U16 ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/     
    if (vcal_type > SRV_TDL_VCAL_TASK)
    {
        return NULL;
    }

    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
#ifdef __MMI_CALENDAR_EVENT__
        //ret = srv_tdl_get_cache(
        srv_tdl_get_cache(
                    (void*)&pevent, 
                    sizeof(srv_tdl_event_short_struct), 
                    SRV_TDL_VCAL_EVENT,
                    index);
        //MMI_ASSERT(ret == SRV_TDL_RESULT_OK);        
        return pevent;
#endif
    }
    else
    {
#ifdef __MMI_TODOLIST__
        //ret = srv_tdl_get_cache(
        srv_tdl_get_cache(
                    (void*)&ptask, 
                    sizeof(srv_tdl_task_short_struct), 
                    SRV_TDL_VCAL_TASK,
                    index);
        //MMI_ASSERT(ret == SRV_TDL_RESULT_OK);        
        return ptask;
#endif
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_date_string
 * DESCRIPTION
 *  Construct date string, used in title or task list menu date displaying
 * PARAMETERS
 *  year            [IN]        
 *  month           [IN]        
 *  day             [IN]        
 *  timeString      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_date_string(const MYTIME *date, CHAR *date_buff, const U16 buff_size)

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	srv_setting_date_format_enum date_format;
	srv_setting_date_seperator_enum date_seperator;
    char sper = '/';
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buff_size < (MMI_TDL_MAX_DATE_STRING_LEN + 1) * ENCODING_LENGTH)
    {
        return;
    }
    
	date_format = srv_setting_get_date_format();
	date_seperator = srv_setting_get_date_seperator();
	switch (date_seperator)
	{
		case  SETTING_DATE_SEPERATOR_DOT:
			sper = '.';
			break;
		case  SETTING_DATE_SEPERATOR_COLON:
			sper = ':';
			break;
		case  SETTING_DATE_SEPERATOR_SLOPE: 
			sper = '/';
			break;
		case  SETTING_DATE_SEPERATOR_LINE:
			sper = '-';
			break;
		default:
			break;
	}
	switch (date_format)
	{
		case SETTING_DATE_FORMAT_DD_MM_YYYY:
		    kal_wsprintf((kal_wchar*)date_buff, "%02d%c%02d%c%04d", date->nDay, sper, date->nMonth, sper, date->nYear);
			break;
		case SETTING_DATE_FORMAT_MM_DD_YYYY:
			kal_wsprintf((kal_wchar*)date_buff, "%02d%c%02d%c%04d", date->nMonth, sper, date->nDay, sper, date->nYear);
			break;
		case SETTING_DATE_FORMAT_YYYY_MM_DD:
			kal_wsprintf((kal_wchar*)date_buff, "%04d%c%02d%c%02d", date->nYear, sper, date->nMonth, sper, date->nDay);
			break;
		default:
			break;
	}
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_context_date
 * DESCRIPTION
 *  
 * PARAMETERS
 *  CalTime     [?]         
 *  Type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_set_context_date(MYTIME *CalTime)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE3(MMI_TDL_UTIL_SET_DATE_DATE, CalTime->nYear, CalTime->nMonth, CalTime->nDay);
    MMI_TDL_UTIL_TRACE3(MMI_TDL_UTIL_SET_DATE_TIME, CalTime->nHour, CalTime->nMin, CalTime->nSec);

    g_tdl_cntx.date.nYear = CalTime->nYear;
    g_tdl_cntx.date.nMonth = CalTime->nMonth;
    g_tdl_cntx.date.nDay = CalTime->nDay;
    g_tdl_cntx.date.nHour = CalTime->nHour;
    g_tdl_cntx.date.nMin = CalTime->nMin;
    g_tdl_cntx.date.nSec = CalTime->nSec;
    g_tdl_cntx.date.DayIndex = CalTime->DayIndex;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_compute_pre_reminder_time
 * DESCRIPTION
 *  compute the reminder time according to user's setting
 * PARAMETERS
 *  alarm_type   [IN]
 *  alarm_time   [IN]
 *  start_time   [IN]
 *  pre_reminder [OUT]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_compute_pre_reminder_time(
                    U8 alarm_type,
                    MYTIME *alarm_time, 
                    MYTIME *start_time,
                    MYTIME *pre_reminder)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result = DT_TIME_EQUAL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    memset(pre_reminder, 0, sizeof(MYTIME));
    
    switch (alarm_type)
    {
        case MMI_TDL_ALARM_BEFORE_5_MINS:
            pre_reminder->nMin = 5;
            break;

		case MMI_TDL_ALARM_BEFORE_10_MINS:
			pre_reminder->nMin = 10;
			break;

        case MMI_TDL_ALARM_BEFORE_15_MINS:
            pre_reminder->nMin = 15;
            break;

        case MMI_TDL_ALARM_BEFORE_30_MINS:
            pre_reminder->nMin = 30;
            break;
    
        case MMI_TDL_ALARM_CUSTOM:
            result = applib_dt_compare_time(
                         (applib_time_struct*)start_time,
                         (applib_time_struct*)alarm_time,
                         NULL);
            if (result == DT_TIME_GREATER)
            {
                applib_get_time_difference(
                        (applib_time_struct*)start_time, 
                        (applib_time_struct*)alarm_time, 
                        (applib_time_struct*)pre_reminder);
            }
            break;
        default:
            break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_compute_alarm_time
 * DESCRIPTION
 *  compute the reminder time according to user's setting
 * PARAMETERS
 * U8 alarm_type  :          [IN] ON, OFF, 5 MIN BEFORE...
 * MYTIME *start_time :      [IN] Start time of task or event
 * MYTIME *alarm_time :      [OUT] Alarm time computed according to alarm type 
 *                               and start_time
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_compute_alarm_time(
                        const U8 alarm_type,
                        const MYTIME *start_time, 
                        MYTIME *alarm_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME pre_reminder;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&pre_reminder, 0, sizeof(MYTIME));
    switch (alarm_type)
    {
        case MMI_TDL_ALARM_OFF:
            break;
        case MMI_TDL_ALARM_ON:
            memcpy(alarm_time, start_time, sizeof(MYTIME));
            break;
        case MMI_TDL_ALARM_BEFORE_5_MINS:
            pre_reminder.nMin = 5;
            applib_dt_decrease_time(
                    (applib_time_struct *)start_time, 
                    (applib_time_struct *)&pre_reminder, 
                    (applib_time_struct *)alarm_time);
            break;
        case MMI_TDL_ALARM_BEFORE_10_MINS:
            pre_reminder.nMin = 10;
            applib_dt_decrease_time(
                    (applib_time_struct *)start_time, 
                    (applib_time_struct *)&pre_reminder, 
                    (applib_time_struct *)alarm_time);
            break;
        case MMI_TDL_ALARM_BEFORE_15_MINS:
            pre_reminder.nMin = 15;
            applib_dt_decrease_time(
                    (applib_time_struct *)start_time, 
                    (applib_time_struct *)&pre_reminder, 
                    (applib_time_struct *)alarm_time);
            break;
        case MMI_TDL_ALARM_BEFORE_30_MINS:
            pre_reminder.nMin = 30;
            applib_dt_decrease_time(
                    (applib_time_struct *)start_time, 
                    (applib_time_struct *)&pre_reminder, 
                    (applib_time_struct *)alarm_time);
            break;
        default:
            break;
    }    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_send_vcal_menu_check
 * DESCRIPTION
 *  type  [IN]  :
 *  index [IN]  :
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_send_vcal_menu_check(mmi_id group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL sim_check = MMI_TRUE;
    U16 item_num;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if sim is invalid, hide SMS, MMS, Email, else unhide them. */
    /* if it is in flight mode, hide BT, irda, else unhide them. */
#if defined(__MMI_VCALENDAR__) && defined(MMI_ON_HARDWARE_P)
    #if defined(__MMI_MMS__)
    if(mms_is_ready())
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_MMS, MMI_FALSE);
    }
    else
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_MMS, MMI_TRUE);
    }
    #endif
    if (!srv_nw_usab_any_sim_is_usable())
    {
        sim_check = MMI_FALSE;
    } 
    
#if 0    
#ifdef __MMI_WLAN_FEATURES__ 
/* under construction !*/
#endif /* __MMI_WLAN_FEATURES__ */
#endif

    if (sim_check == MMI_FALSE)
    {
    #if !defined(__MMI_MESSAGES_NO_SEND_BY_SMS_OPTION__)	
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_SMS, MMI_TRUE);
    #endif
    #if  defined(__MMI_EMAIL__)
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_EMAIL, MMI_TRUE);
    #endif
    }
    else
    {
    #if !defined(__MMI_MESSAGES_NO_SEND_BY_SMS_OPTION__)	
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_SMS, MMI_FALSE);
    #endif
    #if  defined(__MMI_EMAIL__)
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_EMAIL, MMI_FALSE);
    #endif
    }
    
#ifdef __MMI_OPP_SUPPORT__
//#ifdef __MMI_BT_SUPPORT__
    if (!mmi_bt_is_to_display_bt_menu())
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_BT, MMI_TRUE);    
     }
    else
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_BT, MMI_FALSE);        
    }
//#endif /* __MMI_BT_SUPPORT__   */
#endif /* __MMI_OPP_SUPPORT__ */

#if  defined(__MMI_EMAIL__)
    if (!mmi_email_is_email_can_forward())
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_EMAIL, MMI_TRUE);    
    }
    else
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_EMAIL, MMI_FALSE);        
    }
#endif /* __MMI_EMAIL__ */

//#if (defined(__MMI_DUAL_SIM_MASTER__)) && (!defined(__MMI_MESSAGES_NO_SEND_BY_SMS_OPTION__))	
#if (!defined(__MMI_MESSAGES_NO_SEND_BY_SMS_OPTION__))	
    if (srv_sms_is_hide_send_sms_menu_item() == MMI_TRUE)
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_SMS, MMI_TRUE);        
    }
    else
    {      
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_SEND_BY_SMS, MMI_FALSE);        
    }
#endif /* __MMI_DUAL_SIM_MASTER__ */
    item_num = GetNumOfChild_Ext(MENU_VCLNDR_FORWARD);
    if (item_num == 0)
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_FORWARD, MMI_TRUE);            
    }
    else
    {
        cui_menu_set_item_hidden(group_id, MENU_VCLNDR_FORWARD, MMI_FALSE);                
    }
#endif /* defined(__MMI_VCALENDAR__) && defined(MMI_ON_HARDWARE_P) */    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_confirm_user_data_init
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_confirm_user_data_init(mmi_tdl_confirm_user_data_struct* arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    arg->sg_id = GRP_ID_INVALID;
    arg->LSK_function = NULL;
    arg->CSK_function = NULL;
    arg->RSK_function = NULL;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_comfirm_proc
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_tdl_comfirm_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_ALERT_QUIT:
        {
            mmi_alert_result_evt_struct *alert = (mmi_alert_result_evt_struct*)evt;
            mmi_tdl_confirm_user_data_struct* confirm_data = 
                (mmi_tdl_confirm_user_data_struct*)alert->user_tag;

            switch (alert->result)
            {
                case MMI_ALERT_NORMAL_EXIT:
                {
                    mmi_frm_group_close(alert->alert_id);
                    break;
                }
                case MMI_ALERT_CNFM_YES:
                {
                    if (confirm_data->LSK_function != NULL)
                    {
                        confirm_data->LSK_function(confirm_data->sg_id);
                    }
                    break;
                }
                case MMI_ALERT_CNFM_NO:
                {
                    if (confirm_data->RSK_function != NULL)
                    {
                        confirm_data->RSK_function(confirm_data->sg_id);
                    }
                    break;
                }
                default:
                    break;
            }
        }
        default:
        {
            break;
        }        
    }
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_popup_user_data_init
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_popup_user_data_init(mmi_tdl_popup_user_data_struct* arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    arg->sg_id = GRP_ID_INVALID;
    arg->callback_function = NULL;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_popup_proc
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_tdl_popup_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_POPUP_QUIT:
        {        
            mmi_event_popoupcallback_result_struct *popup_evt = (mmi_event_popoupcallback_result_struct*)evt;
            mmi_tdl_popup_user_data_struct *popup_data = popup_evt->user_tag;
            popup_data->callback_function(popup_data->sg_id);
            break;
        }
        default:
        {
            break;
        }
    }
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_all_history
 * DESCRIPTION
 *  
 * PARAMETERS
 *  task            [?]         
 *  year            [IN]        
 *  month           [IN]        
 *  day             [IN]        
 *  timeString      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_delete_all_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id gid;
           
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (gid = GRP_ID_TDL_BEGIN; gid < GRP_ID_TDL_END; gid++)
    {
        if (mmi_frm_group_is_present(gid) && (GRP_ID_TDL_REMINDER != gid) && (GRP_ID_TDL_EDIT != gid))
        {
            mmi_frm_group_close(gid);
        }
    }

    for (gid = GRP_ID_CAL_BEGIN; gid < GRP_ID_CAL_END; gid++)
    {
        if (mmi_frm_group_is_present(gid) && (GRP_ID_CAL_SAVE != gid))
        {
            mmi_frm_group_close(gid);
        }    
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_curr_task
 * DESCRIPTION
 *  Delete one task from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_delete_curr_task(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 result = 0;
    U16 string_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_tdl_cntx.vcal_filter == SRV_TDL_VCAL_EVENT)
	{
#ifdef	__MMI_CALENDAR_EVENT__
		    result = mmi_tdl_delete_record(g_tdl_cntx.sorted_event[g_tdl_cntx.curr_selected].event_id,
	                                      g_tdl_cntx.sorted_event[g_tdl_cntx.curr_selected].source_id);	
#endif
	}
	else
	{
	    result = mmi_tdl_delete_record(
	                        g_tdl_cntx.sorted_list[g_tdl_cntx.curr_selected].index, 
	                        g_tdl_cntx.sorted_list[g_tdl_cntx.curr_selected].type);
	}
    if (result)
    {
        string_id = STR_GLOBAL_DELETED;    
    }
    else
    {
        string_id = STR_GLOBAL_UNFINISHED;
        mmi_popup_display_simple((WCHAR*)(get_string(string_id)), MMI_EVENT_SUCCESS, parent_id, NULL);
	}
}

void mmi_tdl_get_dow_repeat_str(WCHAR *buf, U8 dows)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef	__MMI_CALENDAR_FDOW__	
	if(mmi_clndr_get_week_first_day())
	{
		for (i = 0; i < 7; i++)
		{
			if (dows & (0x1 << ((i+1)%7)))
			{
				if (buf[0] == 0)
				{
					mmi_wcscpy(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
				}
				else
				{
					mmi_wcscat(buf, (WCHAR*)L", ");
					mmi_wcscat(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
				}
			}
		}
	}
    else
	{	
		for (i = 0; i < 7; i++)
		{
			if (dows & (0x1 << i))
			{
				if (buf[0] == 0)
				{
					mmi_wcscpy(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
				}
				else
				{
					mmi_wcscat(buf, (WCHAR*)L", ");
					mmi_wcscat(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
				}
			}
		}
	}
#else
	for (i = 0; i < 7; i++)
	{
		if (dows & (0x1 << i))
		{
			if (buf[0] == 0)
			{
				mmi_wcscpy(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
			}
			else
			{
				mmi_wcscat(buf, (WCHAR*)L", ");
				mmi_wcscat(buf, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
			}
		}
	}
#endif
}

#ifdef __MMI_CALENDAR_EVENT__
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_create
 * DESCRIPTION
 *  Create calendar event save CUI.
 * PARAMETERS
 *  mmi_id : [IN] parent_id, parent group ID to add current group to.
 * RETURNS
 *  mmi_id
 *****************************************************************************/
mmi_id cui_cal_save_create(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;
    MYTIME curr_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SYNCML_SYNC_CALENDAR_SUPPORT__
    if (mmi_syncml_is_calendar_sync_now())
    {
        mmi_popup_display_simple((WCHAR*)(get_string(STR_ID_SYNC_CODE_FORBIDDEN)), MMI_EVENT_FAILURE, parent_id, NULL);
        return GRP_ID_INVALID;
    }
#endif /* __MMI_SYNCML_SYNC_CALENDAR_SUPPORT__ */
    
    if (mmi_frm_group_is_present(GRP_ID_CAL_SAVE))
    {
        mmi_frm_group_close(GRP_ID_CAL_SAVE);
    }
    
    set_inline_date_boundary(MMI_TDL_END_YEAR_SUPPORT, MMI_TDL_START_YEAR_SUPPORT, 12, 1);

    g_tdl_cntx.vcal_filter = SRV_TDL_VCAL_EVENT;
    save_cntx = (mmi_tdl_save_cntx_struct*)OslMalloc(sizeof(mmi_tdl_save_cntx_struct));
    memset(save_cntx, 0, sizeof(mmi_tdl_save_cntx_struct));
    save_cntx->highlight_item = CUI_INLINE_ITEM_ID_BASE;
    
    cui_cal_save_create_context(save_cntx);
    save_cntx->parent_id = parent_id;
    save_cntx->group_id = mmi_frm_group_create(
                                        parent_id,
                                        GRP_ID_CAL_SAVE,
                                        cui_cal_save_group_proc, 
                                        save_cntx);
    g_tdl_edit_cntx.save_sg_id = save_cntx->group_id;
    
    GetDateTime(&curr_time);
    curr_time.nMin = 0;
    curr_time.nSec = 0;
    memcpy(&save_cntx->start_time, &curr_time, sizeof(MYTIME));
    memcpy(&save_cntx->end_time, &curr_time, sizeof(MYTIME));
    memcpy(&save_cntx->alarm_time, &curr_time, sizeof(MYTIME));
    save_cntx->operation_type = MMI_TDL_OP_TYPE_ADD;
    save_cntx->title_id = STR_GLOBAL_ADD;
    
    return save_cntx->group_id;  
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_group_proc
 * DESCRIPTION
 *  Proc function of edit group.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret cui_cal_save_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_tdl_save_result_struct send_evt;
    mmi_tdl_save_cntx_struct *save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;  
    U8 *repeat_set[MMI_TDL_RULE_TOTAL];
    U8 *alarm_set[MMI_TDL_ALARM_TOTAL];
    U32 i;  
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    for (i = 0; i < MMI_TDL_RULE_TOTAL; i++)
    {
        repeat_set[i] = (U8*)get_string((U16)(g_tdl_freq_set[i].str_id));
    }
    for (i = 0; i < MMI_TDL_ALARM_TOTAL; i++)
    {
        alarm_set[i] = (U8*)get_string((U16)(g_tdl_alm_set[i].str_id));
    }
    
    switch(evt->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            cui_cal_save_release_context(save_cntx);
            OslMfree(save_cntx);
            break;
        }
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            cui_cal_save_proc_submit(evt);
            break;
        }
        case EVT_ID_CUI_INLINE_ABORT:
        {
            send_evt.evt_id = EVT_ID_TDL_SAVE_CANCEL;
            send_evt.size = sizeof(cui_tdl_save_result_struct);
            send_evt.user_data = NULL;
            send_evt.sender_id = g_tdl_edit_cntx.save_sg_id;
            send_evt.result = save_cntx->save_result;
            send_evt.store_index = g_tdl_cntx.curr_store_idx;
            mmi_frm_group_send_to_parent(g_tdl_edit_cntx.save_sg_id, (mmi_group_event_struct*)&send_evt); 
            break;
        }            
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_cal_save_proc_notify(evt);
            break;
        }
        case EVT_ID_CUI_INLINE_CSK_PRESS:
        {
            cui_cal_save_csk_press(evt);
            break;
        }
        case EVT_ID_CUI_FSEDITOR_ABORT:
            cui_fseditor_close(g_tdl_edit_cntx.fseditor_gid);
            break;

        case EVT_ID_CUI_FSEDITOR_CUSTOM_MENU_SELECTED:
        {
            cui_fseditor_custom_menu_select_evt_struct *event = (cui_fseditor_custom_menu_select_evt_struct*)evt;
            switch (event->menu_id)
            {
                case MITEM_TODO_LIST_USE_TEMPLATE:
                {
                    mmi_frm_scrn_first_enter(
                                    save_cntx->group_id,
                                    SCR_TDL_LIST_TEMPLATE,
                                    (FunctionPtr)mmi_tdl_entry_template_list,
                                    NULL);
                    
                    break;

                }
            }
            break;
        }                        
        case EVT_ID_CUI_FSEDITOR_CHANGED:
        {
            cui_fseditor_get_text(
                            g_tdl_edit_cntx.fseditor_gid, 
                            (WCHAR*)g_tdl_edit_cntx.edit_buff, 
                            MAX_TDL_DETAILS_SIZE);
            break;
        }        
        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
        {
            if (MMI_TDL_RULE_DAYS != save_cntx->repeat_index)
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                                repeat_set[save_cntx->repeat_index]);        
            }
            else
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                                g_tdl_edit_cntx.repeat_str);        
            }
  
            if (MMI_TDL_ALARM_CUSTOM != save_cntx->alarm_index)
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                                alarm_set[save_cntx->alarm_index]);        
            }
            else
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                                g_tdl_edit_cntx.alarm_date);        
            }
		#ifdef __MMI_TOUCH_SCREEN__
			if (save_cntx->highlight_item == CAL_EVENT_EDIT_INLINE_TYPE_TEXT)
            {
				//wgui_register_tap_callback(mmi_cal_entry_select_category);
				wgui_register_tap_callback(mmi_cal_entry_select_category_tap_callback);
            }
			else if(save_cntx->highlight_item == CAL_EVENT_EDIT_INLINE_REPEAT_TEXT)
            {
				//wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type);
				wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type_tap_callnback);
            }
			else if(save_cntx->highlight_item == CAL_EVENT_EDIT_INLINE_ALARM_TEXT)
            {
				//wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type);
				wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type_tap_callback);		
            }
		#endif /* __MMI_TOUCH_SCREEN__ */

            break;
        }
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
            mmi_menu_id list_of_ids[7];    
            U32 i;

            for (i = 0; i < 7; i++)
            {
                list_of_ids[i] = i;
            }
            
            cui_menu_set_currlist_flags(
                                    g_tdl_edit_cntx.menu_gid, 
                                    CUI_MENU_NORMAL_CHECK_BOX_LIST);
            cui_menu_set_default_title_image(
                                    g_tdl_edit_cntx.menu_gid, 
                                    (UI_image_type)get_image(GetRootTitleIcon(ORGANIZER_CALENDER_MENU)));  
            cui_menu_set_currlist_title(
                                    g_tdl_edit_cntx.menu_gid,
                                    get_string(STR_GLOBAL_CUSTOM),
                                    0);
            cui_menu_set_currlist(
                                    g_tdl_edit_cntx.menu_gid,
                                    7,
                                    list_of_ids);
            if(mmi_clndr_get_week_first_day())
            {
				for (i = 0; i < 7; i++)
				{
					cui_menu_set_item_string(
										g_tdl_edit_cntx.menu_gid, 
										(MMI_MENU_ID)i,
										(WCHAR*)GetString(STR_GLOBAL_SUNDAY + (i+1)%7));		
				}
            }
            else
            {
	            for (i = 0; i < 7; i++)
	            {
	                cui_menu_set_item_string(
	                                    g_tdl_edit_cntx.menu_gid, 
	                                    (MMI_MENU_ID)i,
	                                    (WCHAR*)GetString(STR_GLOBAL_SUNDAY + i));      
	            }
            }
            cui_menu_set_checkbox_state(g_tdl_edit_cntx.menu_gid, save_cntx->dow_state);
            break;
        }
        case EVT_ID_CUI_MENU_CHECKBOX_CHANGE_STATE:
        {
            cui_menu_get_checkbox_state(g_tdl_edit_cntx.menu_gid, save_cntx->dow_state);        
            break;
        }        
        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            memset(g_tdl_edit_cntx.repeat_str, 0, MMI_TDL_MAX_INLINE_STRING_LEN);
	        if(mmi_clndr_get_week_first_day())
	        {
				for (i = 0; i < 7; i++)
				{
					if (save_cntx->dow_state[i])
					{
						if (g_tdl_edit_cntx.repeat_str[0] == 0)
						{
							mmi_wcscpy(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
						}
						else
						{
							mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)L", ");
							mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
						}
					}
				}
			}
			else
			{	
	            for (i = 0; i < 7; i++)
	            {
	                if (save_cntx->dow_state[i])
	                {
	                    if (g_tdl_edit_cntx.repeat_str[0] == 0)
	                    {
	                        mmi_wcscpy(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
	                    }
	                    else
	                    {
	                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)L", ");
	                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
	                    }
	                }
	            }
			}		
            mmi_frm_scrn_close(g_tdl_edit_cntx.save_sg_id, SCR_TDL_REPEAT_SELECT_TYPE);
            cui_menu_close(g_tdl_edit_cntx.menu_gid);
            
            break;
        }
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
        {
            mmi_frm_scrn_close_active_id();
            break;
        }
        default:
            break;
    }
    return MMI_RET_OK;

}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_proc_submit
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_proc_submit(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_event_inline_submit_struct *event;    
    cui_inline_item_date_time_struct start_date, end_date;    
    cui_inline_item_time_struct start_time, end_time;  

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_submit_struct*)evt;        
    save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;
    
    if (event->item_id == CAL_EVENT_EDIT_INLINE_TYPE_TEXT)
    {
        mmi_tdl_entry_edit_option(save_cntx->group_id, CAL_EVENT_EDIT_INLINE_TYPE_TEXT);
        return;
    }
    
    if (event->item_id == CAL_EVENT_EDIT_INLINE_ALARM_TEXT)
    {
        mmi_tdl_entry_edit_option(save_cntx->group_id, CAL_EVENT_EDIT_INLINE_ALARM_TEXT);
        return;
    }
    
    if (event->item_id == CAL_EVENT_EDIT_INLINE_REPEAT_TEXT)
    {
        if (save_cntx->category_index != MMI_TDL_CATEGORY_ANNIVERSARY &&
			save_cntx->category_index != MMI_TDL_CATEGORY_BIRTHDAY)
        {   
            mmi_tdl_entry_edit_option(save_cntx->group_id, CAL_EVENT_EDIT_INLINE_REPEAT_TEXT);
            return;
        }
    }
    
    if (save_cntx->category_index == MMI_TDL_CATEGORY_ANNIVERSARY ||
		save_cntx->category_index == MMI_TDL_CATEGORY_BIRTHDAY)
    {                            
        cui_inline_get_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT,
                    &start_date);

        cui_inline_get_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT,
                    &start_time);

        save_cntx->start_time.nYear = start_date.year;
        save_cntx->start_time.nMonth = (U8)start_date.month;
        save_cntx->start_time.nDay = (U8)start_date.day;
        save_cntx->start_time.nHour = (U8)start_time.date_time.hour;
        save_cntx->start_time.nMin = (U8)start_time.date_time.minute;
        save_cntx->start_time.nSec = 0;
        save_cntx->start_time.DayIndex = DOW(
                                            save_cntx->start_time.nYear,
                                            save_cntx->start_time.nMonth,
                                            save_cntx->start_time.nDay);

                
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                save_cntx->subject);
   /*             
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                &save_cntx->alarm_index); */
                
        cui_inline_get_value(
                 save_cntx->child_id,
                 CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                 save_cntx->detail);
    }
    else
    {                            
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT,
                &start_date);
                                            
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, 
                &start_time);
                
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_ENDDATE_TEXT, 
                &end_date);
                
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_ENDTIME_TEXT, 
                &end_time);

        save_cntx->start_time.nYear = start_date.year;
        save_cntx->start_time.nMonth = (U8)start_date.month;
        save_cntx->start_time.nDay = (U8)start_date.day;
        save_cntx->start_time.nHour = (U8)start_time.date_time.hour;
        save_cntx->start_time.nMin = (U8)start_time.date_time.minute;
        save_cntx->start_time.nSec = 0;
        save_cntx->start_time.DayIndex = DOW(
                                            save_cntx->start_time.nYear,
                                            save_cntx->start_time.nMonth,
                                            save_cntx->start_time.nDay);
                                                    
        save_cntx->end_time.nYear = end_date.year;
        save_cntx->end_time.nMonth = (U8)end_date.month;
        save_cntx->end_time.nDay = (U8)end_date.day;
        save_cntx->end_time.nHour = (U8)end_time.date_time.hour;
        save_cntx->end_time.nMin = (U8)end_time.date_time.minute;
        save_cntx->end_time.nSec = 0;
        save_cntx->end_time.DayIndex = DOW(
                                            save_cntx->end_time.nYear,
                                            save_cntx->end_time.nMonth,
                                            save_cntx->end_time.nDay);
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                save_cntx->subject);
      /*          
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                &save_cntx->alarm_index);*/

        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_LOCATION_TEXT,
                save_cntx->location);
                        
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                save_cntx->detail);
                            
    }
    mmi_tdl_save_event(save_cntx->group_id, (mmi_tdl_operation_type_enum)(save_cntx->operation_type));
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_csk_press
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_csk_press(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_event_inline_submit_struct *event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_submit_struct*)evt;        
    save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;
    
    switch(event->item_id)
    {
        case CAL_EVENT_EDIT_INLINE_TYPE_TEXT:
        {
            mmi_cal_entry_select_category();
            break;
        }
        case CAL_EVENT_EDIT_INLINE_ALARM_TEXT:
        {
            mmi_tdl_entry_select_alarm_type();
            break;
        }
        case CAL_EVENT_EDIT_INLINE_REPEAT_TEXT:
        {
            if (save_cntx->category_index != MMI_TDL_CATEGORY_ANNIVERSARY &&
				save_cntx->category_index != MMI_TDL_CATEGORY_BIRTHDAY)
            {        
                mmi_tdl_entry_select_repeat_type();
            }
            break;
        }
        default:
            cui_cal_save_proc_submit(evt);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_proc_notify
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_proc_notify(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_event_inline_notify_struct *event;
    MMI_BOOL is_dow_set = MMI_FALSE;
    U32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_notify_struct*)evt;        
    save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;    
    switch(event->event_type)
    {
        case CUI_INLINE_NOTIFY_HIGHLIGHT_ITEM:
        {
            save_cntx->highlight_item = event->item_id;
            switch(event->item_id)
            {
                case CAL_EVENT_EDIT_INLINE_TYPE_TEXT:
                {
                    cui_inline_set_softkey_text(
                                    save_cntx->child_id,
                                    CAL_EVENT_EDIT_INLINE_TYPE_TEXT,
                                    MMI_LEFT_SOFTKEY,
                                    STR_GLOBAL_OPTIONS);
					cui_inline_set_softkey_icon(    
						            save_cntx->child_id,
                                    CAL_EVENT_EDIT_INLINE_TYPE_TEXT,
                                    MMI_CENTER_SOFTKEY,
                                    IMG_GLOBAL_COMMON_CSK);
				#ifdef __MMI_TOUCH_SCREEN__
					//wgui_register_tap_callback(mmi_cal_entry_select_category);
					wgui_register_tap_callback(mmi_cal_entry_select_category_tap_callback);
				#endif /* __MMI_TOUCH_SCREEN__ */
                    break;
                }
                case CAL_EVENT_EDIT_INLINE_REPEAT_TEXT:
                {
                    if (save_cntx->category_index != MMI_TDL_CATEGORY_ANNIVERSARY &&
						save_cntx->category_index != MMI_TDL_CATEGORY_BIRTHDAY)
                    {
                        cui_inline_set_softkey_text(
                                        save_cntx->child_id,
                                        CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                                        MMI_LEFT_SOFTKEY,
                                        STR_GLOBAL_OPTIONS);
						cui_inline_set_softkey_icon(    
							            save_cntx->child_id,
	                                    CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
	                                    MMI_CENTER_SOFTKEY,
	                                    IMG_GLOBAL_COMMON_CSK);
				#ifdef __MMI_TOUCH_SCREEN__
					//wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type);
					wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type_tap_callnback);
				#endif /* __MMI_TOUCH_SCREEN__ */
                    }
                    break;
                }
                case CAL_EVENT_EDIT_INLINE_ALARM_TEXT:
                {
                    cui_inline_set_softkey_text(
                                    save_cntx->child_id,
                                    CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                                    MMI_LEFT_SOFTKEY,
                                    STR_GLOBAL_OPTIONS);
					cui_inline_set_softkey_icon(    
						            save_cntx->child_id,
                                    CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                                    MMI_CENTER_SOFTKEY,
                                    IMG_GLOBAL_COMMON_CSK);
				#ifdef __MMI_TOUCH_SCREEN__
					//wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type);
					wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type_tap_callback);
				#endif /* __MMI_TOUCH_SCREEN__ */
                    break;
                }
                default:
                    break;
            }
            break;
        }
        case CUI_INLINE_NOTIFY_ITEM_CHANGED:
        {
            switch(event->item_id)
            {
                case CAL_EVENT_EDIT_INLINE_ALARM_TEXT:               
                {   
           /*         cui_inline_get_value(
                           save_cntx->child_id,
                           CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                           &save_cntx->alarm_index); */
                    break;
                }
                case CAL_EVENT_EDIT_INLINE_REPEAT_TEXT:               
                {             
                        cui_inline_get_value(
                                save_cntx->child_id,
                                CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                                &save_cntx->repeat_index);
                                        
                        if (MMI_TDL_RULE_DAYS != save_cntx->repeat_index)
                        {
                            cui_inline_set_item_attributes(
                                                    save_cntx->child_id,
                                                    CAL_EVENT_EDIT_INLINE_REPEAT_TEXT + 1,
                                                    CUI_INLINE_SET_ATTRIBUTE,
                                                    CUI_INLINE_ITEM_DISABLE);
                            memset(save_cntx->dow_state, 0, 7);                                                    
                        }
                        else
                        {
                            cui_inline_set_item_attributes(
                                                    save_cntx->child_id,
                                                    CAL_EVENT_EDIT_INLINE_REPEAT_TEXT + 1,
                                                    CUI_INLINE_RESET_ATTRIBUTE,
                                                    CUI_INLINE_ITEM_DISABLE);
                            for (i = 0; i < MMI_TDL_MAX_DAYS_PER_WEEK; i++)
                            {
                                if (save_cntx->dow_state[i] == 1)
                                {
                                    is_dow_set = MMI_TRUE;
                                    break;
                                }
                            }
                            if (is_dow_set == MMI_FALSE)
                            {
                                memset(save_cntx->dow_state, 1, 7);
                                save_cntx->dow_state[0] = 0;
                                save_cntx->dow_state[6] = 0;
                            }                                                    
                        }
                    break;
                }
            }
            break;
        }
        
        default:
            break;
    }    
}

/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_create_context
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_create_context(mmi_tdl_save_cntx_struct *save_cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    save_cntx->subject = OslMalloc(MAX_TODO_LIST_NOTE);
    memset(save_cntx->subject, 0, MAX_TODO_LIST_NOTE);
    
    save_cntx->location = OslMalloc(MAX_TDL_LOCATION_SIZE * ENCODING_LENGTH);
    memset(save_cntx->location, 0, MAX_TDL_LOCATION_SIZE * ENCODING_LENGTH);
    
    save_cntx->detail = OslMalloc(MAX_TDL_DETAILS_SIZE * ENCODING_LENGTH);
    memset(save_cntx->detail, 0, MAX_TDL_DETAILS_SIZE * ENCODING_LENGTH);    
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_run
 * DESCRIPTION
 *  Run tdl save CUI.
 * PARAMETERS
 *  mmi_id : [IN] sg_id, group ID to run group.
 * RETURNS
 *  mmi_id
 *****************************************************************************/
void cui_cal_save_run(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    mmi_frm_group_enter(sg_id, MMI_FRM_NODE_NONE_FLAG);
    cui_cal_save_set_inline_data(sg_id);
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_inline_data
 * DESCRIPTION
 *  Run tdl save CUI.
 * PARAMETERS
 *  mmi_id : [IN] sg_id, group ID to run group.
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_set_inline_data(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_inline_struct inline_data;
    cui_inline_item_date_time_struct start_date, end_date;
    cui_inline_item_time_struct start_time, end_time;    
    mmi_tdl_save_cntx_struct *save_cntx;  
    U8 *alarm_set[MMI_TDL_ALARM_TOTAL];
    U8 *repeat_set[MMI_TDL_RULE_TOTAL];   
    U8 *category_set[MMI_TDL_CATEGORY_TOTAL];    
    U32 i;
    cui_inline_item_softkey_struct softkey;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    for (i = 0; i < MMI_TDL_ALARM_TOTAL; i++)
    {
        alarm_set[i] = (U8*)get_string(g_tdl_alm_set[i].str_id);
    }

    for (i = 0; i < MMI_TDL_CATEGORY_TOTAL; i++)
    {
        category_set[i] = (U8*)get_string((U16)(i + STR_TODO_REMINDER));
    }

    for (i = 0; i < MMI_TDL_RULE_TOTAL; i++)
    {
        repeat_set[i] = (U8*)get_string((U16)(g_tdl_freq_set[i].str_id));
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    
    if (MMI_TDL_OP_TYPE_EDIT == save_cntx->operation_type)
    {
        save_cntx->title_id = STR_GLOBAL_EDIT;
    }
    else
    {
        save_cntx->title_id = STR_GLOBAL_ADD;
    }

    softkey.softkey[MMI_LEFT_SOFTKEY].string_id = STR_GLOBAL_SAVE;
    softkey.softkey[MMI_LEFT_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_RIGHT_SOFTKEY].string_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_RIGHT_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_CENTER_SOFTKEY].string_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_CENTER_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;

    if(save_cntx->source_id != SRV_TDL_EVENT_SOURCE_LOCAL)
    {
	   inline_data.items_count = MMI_TDL_MAX_EVENT3_INLINE_ITEM;
       inline_data.title = save_cntx->title_id;
       inline_data.title_icon = GetRootTitleIcon(ORGANIZER_CALENDER_MENU);
       inline_data.screen_flag = CUI_INLINE_SCREEN_DISABLE_DONE;
       inline_data.softkey = &softkey;
       inline_data.items = g_tdl_event_cui_inline_item3;
	   save_cntx->child_id = cui_inline_create(sg_id, &inline_data);
	   if (save_cntx->child_id != GRP_ID_INVALID)
       {
	   		cui_inline_set_value(
				   save_cntx->child_id,
				   CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
				   alarm_set[save_cntx->alarm_index]);
			
			cui_inline_set_highlight_item(
                   save_cntx->child_id, 
                   save_cntx->highlight_item);
			
		    cui_inline_run(save_cntx->child_id);
       }
       else
       {
           mmi_frm_group_close(save_cntx->child_id);
       }
    }
    else if (save_cntx->category_index == MMI_TDL_CATEGORY_ANNIVERSARY ||
		save_cntx->category_index == MMI_TDL_CATEGORY_BIRTHDAY)
    {
       inline_data.items_count = MMI_TDL_MAX_EVENT2_INLINE_ITEM;
       inline_data.title = save_cntx->title_id;
       inline_data.title_icon = GetRootTitleIcon(ORGANIZER_CALENDER_MENU);
       inline_data.screen_flag = CUI_INLINE_SCREEN_DISABLE_DONE;
       inline_data.softkey = &softkey;
       inline_data.items = g_tdl_event_cui_inline_item2;
    
       save_cntx->child_id = cui_inline_create(sg_id, &inline_data);
       if (save_cntx->child_id != GRP_ID_INVALID)
       {
           start_date.year = save_cntx->start_time.nYear;
           start_date.month = save_cntx->start_time.nMonth;
           start_date.day = save_cntx->start_time.nDay;
           start_time.date_time.hour = save_cntx->start_time.nHour;
           start_time.date_time.minute = save_cntx->start_time.nMin;
           start_time.date_time.second = 0;

           cui_inline_set_fullscreen_edit_title_icon(save_cntx->child_id, CAL_EVENT_EDIT_INLINE_DETAILS_TEXT, GetRootTitleIcon(ORGANIZER_CALENDER_MENU));

           cui_inline_set_value(
                   save_cntx->child_id,
                   CAL_EVENT_EDIT_INLINE_TYPE_TEXT,
                   category_set[save_cntx->category_index]);
                                     
           cui_inline_set_value(
                   save_cntx->child_id, 
                   CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT, 
                   &start_date);

           cui_inline_set_value(
                   save_cntx->child_id, 
                   CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, 
                   &start_time);

           cui_inline_set_value(
                   save_cntx->child_id,
                   CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                   save_cntx->subject);

		   cui_inline_set_value(
				   save_cntx->child_id,
				   CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
				   alarm_set[save_cntx->alarm_index]);

           cui_inline_set_value(
                   save_cntx->child_id,
                   CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                   save_cntx->detail);
                   
           cui_inline_set_highlight_item(
                   save_cntx->child_id, 
                   save_cntx->highlight_item);
		   
           cui_inline_run(save_cntx->child_id);
       }
       else
       {
           mmi_frm_group_close(save_cntx->child_id);
       }
    }
    else
    {
        inline_data.items_count = CAL_EVENT_EDIT_INLINE_TOTAL;
        inline_data.title = save_cntx->title_id;
        inline_data.title_icon = GetRootTitleIcon(ORGANIZER_CALENDER_MENU);
        inline_data.screen_flag = CUI_INLINE_SCREEN_DISABLE_DONE;
        inline_data.softkey = &softkey;
        inline_data.items = g_tdl_event_cui_inline_item1;
        
        save_cntx->child_id = cui_inline_create(
                                            sg_id,
                                            &inline_data);
        
        if (save_cntx->child_id != GRP_ID_INVALID)
        {
            start_date.year = save_cntx->start_time.nYear;
            start_date.month = save_cntx->start_time.nMonth;
            start_date.day = save_cntx->start_time.nDay;
            start_time.date_time.hour = save_cntx->start_time.nHour;
            start_time.date_time.minute = save_cntx->start_time.nMin;
            start_time.date_time.second = 0;   
            
            end_date.year = save_cntx->end_time.nYear;
            end_date.month = save_cntx->end_time.nMonth;
            end_date.day = save_cntx->end_time.nDay;
            end_time.date_time.hour = save_cntx->end_time.nHour;
            end_time.date_time.minute = save_cntx->end_time.nMin;
            end_time.date_time.second = 0;

            /* set fseditor in inline editor title icon for location and detail */
            cui_inline_set_fullscreen_edit_title_icon(save_cntx->child_id, CAL_EVENT_EDIT_INLINE_LOCATION_TEXT, GetRootTitleIcon(ORGANIZER_CALENDER_MENU));
            cui_inline_set_fullscreen_edit_title_icon(save_cntx->child_id, CAL_EVENT_EDIT_INLINE_DETAILS_TEXT, GetRootTitleIcon(ORGANIZER_CALENDER_MENU));

            cui_inline_set_value(
                    save_cntx->child_id,
                    CAL_EVENT_EDIT_INLINE_TYPE_TEXT,
                    category_set[save_cntx->category_index]);

            cui_inline_set_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT, 
                    &start_date);
        
            cui_inline_set_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, 
                    &start_time);

            cui_inline_set_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_ENDDATE_TEXT, 
                    &end_date);
        
            cui_inline_set_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_ENDTIME_TEXT, 
                    &end_time);

            cui_inline_set_value(
                    save_cntx->child_id,
                    CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                    save_cntx->subject);
            
            cui_inline_set_value(
				    save_cntx->child_id,
				    CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
				    alarm_set[save_cntx->alarm_index]);
  
            cui_inline_set_value(
                    save_cntx->child_id,
                    CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                    repeat_set[save_cntx->repeat_index]);
            
            cui_inline_set_value(
                    save_cntx->child_id,
                    CAL_EVENT_EDIT_INLINE_LOCATION_TEXT,
                    save_cntx->location);
                    
            cui_inline_set_value(
                    save_cntx->child_id,
                    CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                    save_cntx->detail);

            cui_inline_set_highlight_item(
                    save_cntx->child_id, 
                    save_cntx->highlight_item);
		   
            cui_inline_run(save_cntx->child_id);
        }
        else
        {
            mmi_frm_group_close(save_cntx->child_id);
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_title
 * DESCRIPTION
 *  Set the title of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * title : [IN] title to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_title(mmi_id sg_id, U16 title_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->title_id = title_id;
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_operation_type
 * DESCRIPTION
 *  Set the type of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * title : [IN] type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_operation_type(mmi_id sg_id, mmi_tdl_operation_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->operation_type = type;
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_event
 * DESCRIPTION
 *  Set the subject of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * subject : [IN] subject to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_event(mmi_id sg_id, srv_tdl_event_struct *pevent)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx; 
    U32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->subject)
    {
        mmi_wcsncpy(save_cntx->subject, (U16*)pevent->subject, MAX_TODO_NOTE_LEN - 1);
    }
    if (save_cntx->location)
    {
        mmi_wcsncpy(save_cntx->location, (U16*)pevent->location, MAX_TDL_LOCATION_SIZE - 1);
    }
    if (save_cntx->detail)
    {
        mmi_wcsncpy(save_cntx->detail, (U16*)pevent->details, MAX_TDL_DETAILS_LEN);
    }

    memcpy(&save_cntx->start_time, &pevent->start_time, sizeof(MYTIME));
    memcpy(&save_cntx->end_time, &pevent->end_time, sizeof(MYTIME));
    save_cntx->category_index = pevent->category;
    save_cntx->alarm_index = pevent->alarm.type;
	save_cntx->source_id = pevent->src_id;
    if (pevent->alarm.type != MMI_TDL_ALARM_OFF)
    {
        memcpy(&save_cntx->alarm_time, &pevent->alarm.first_launch, sizeof(MYTIME));
    }
    save_cntx->repeat_index = pevent->repeat.rule;
    
    if (MMI_TDL_RULE_DAYS == save_cntx->repeat_index)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (pevent->repeat.dows & g_mmi_clndr_weekday_index[j])
            {
				if(mmi_clndr_get_week_first_day())
				{
                    save_cntx->dow_state[(j+7-1)%7] = 1;
     			}
                else
                {
                    save_cntx->dow_state[j] = 1;
                }
            }
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_subject
 * DESCRIPTION
 *  Set the subject of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * subject : [IN] subject to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_subject(mmi_id sg_id, U16 *subject)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->subject)
    {
        mmi_wcsncpy(save_cntx->subject, subject, MAX_TODO_NOTE_LEN - 1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_start_time
 * DESCRIPTION
 *  Set the start_time of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * start_time : [IN] start_time to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_start_time(mmi_id sg_id, MYTIME *start_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    memcpy(&save_cntx->start_time, start_time, sizeof(MYTIME));
    save_cntx->start_time.nMin = 0;
    save_cntx->start_time.nSec = 0;
}




/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_end_time
 * DESCRIPTION
 *  Set the end_time of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * end_time : [IN] end_time to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_end_time(mmi_id sg_id, MYTIME *end_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    memcpy(&save_cntx->end_time, end_time, sizeof(MYTIME));
    save_cntx->end_time.nMin = 0;
    save_cntx->end_time.nSec = 0;
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_category
 * DESCRIPTION
 *  Set the category of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * category : [IN] category to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_category(mmi_id sg_id, U8 category)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->category_index = category;
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_alarm
 * DESCRIPTION
 *  Set the category of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * alarm_type : [IN] alarm type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_alarm(mmi_id sg_id, U8 alarm_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->alarm_index = alarm_type;
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_alarm_time
 * DESCRIPTION
 *  Set the category of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * alarm_time : [IN] alarm time to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_alarm_time(mmi_id sg_id, MYTIME *alarm_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    memcpy(&save_cntx->alarm_time, alarm_time, sizeof(MYTIME));
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_repeat
 * DESCRIPTION
 *  Set the repeat of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * repeat_type : [IN] repeat type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_repeat(mmi_id sg_id, srv_tdl_repeat_struct *repeat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    
    U32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->repeat_index = repeat->rule;
    
    if (MMI_TDL_RULE_DAYS == save_cntx->repeat_index)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (repeat->dows & g_mmi_clndr_weekday_index[j])
            {
				if(mmi_clndr_get_week_first_day())
				{
                    save_cntx->dow_state[(j+7-1)%7] = 1;
				}
				else
				{
                    save_cntx->dow_state[j] = 1;
				}
            }
        }
    }
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_location
 * DESCRIPTION
 *  Set the repeat of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * location : [IN] location to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_location(mmi_id sg_id, U16 *location)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->location)
    {
        mmi_wcsncpy(save_cntx->location, location, MAX_TDL_LOCATION_SIZE - 1);
    }
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_detail
 * DESCRIPTION
 *  Set the repeat of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * detail : [IN] detail to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_set_detail(mmi_id sg_id, U16 *detail)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->detail)
    {
        mmi_wcsncpy(save_cntx->detail, detail, MAX_TDL_DETAILS_LEN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_set_highlight_item
 * DESCRIPTION
 *  Set highlight item.
 * PARAMETERS
 *  sg_id      [IN]        Screen group.
 *  item_id    [IN]        item id.
 * RETURNS
 *  void
 *****************************************************************************/
void cui_cal_save_set_highlight_item(mmi_id sg_id, U16 item_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->highlight_item = item_id;
}


/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_back_to_inline
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void cui_cal_save_back_to_inline(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_inline_item_date_time_struct start_date, end_date;    
    cui_inline_item_time_struct start_time, end_time;
    U8 *repeat_set[MMI_TDL_RULE_TOTAL];
    U8 repeat[20];
    U32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id); 

    if (g_tdl_edit_cntx.old_category == MMI_TDL_CATEGORY_ANNIVERSARY ||
		g_tdl_edit_cntx.old_category == MMI_TDL_CATEGORY_BIRTHDAY)
    {                            
        cui_inline_get_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT,
                    &start_date);
    
        cui_inline_get_value(
                    save_cntx->child_id, 
                    CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT,
                    &start_time);
    
        save_cntx->start_time.nYear = start_date.year;
        save_cntx->start_time.nMonth = (U8)start_date.month;
        save_cntx->start_time.nDay = (U8)start_date.day;
        save_cntx->start_time.nHour = (U8)start_time.date_time.hour;
        save_cntx->start_time.nMin = (U8)start_time.date_time.minute;
        save_cntx->start_time.nSec = 0;
        save_cntx->start_time.DayIndex = DOW(
                                            save_cntx->start_time.nYear,
                                            save_cntx->start_time.nMonth,
                                            save_cntx->start_time.nDay);
    
        
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                save_cntx->subject);
    /*    
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                &save_cntx->alarm_index);*/
        
       /* 
        cui_inline_get_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_ID_BASE + 8, 
                &alarm_date);
        
        cui_inline_get_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_ID_BASE + 9, 
                &alarm_time);
    
        save_cntx->alarm_time.nYear = alarm_date.year;
        save_cntx->alarm_time.nMonth = (U8)alarm_date.month;
        save_cntx->alarm_time.nDay = (U8)alarm_date.day;
        save_cntx->alarm_time.nHour = (U8)alarm_time.date_time.hour;
        save_cntx->alarm_time.nMin = (U8)alarm_time.date_time.minute;
        save_cntx->alarm_time.nSec = 0;
        save_cntx->alarm_time.DayIndex = DOW(
                                            save_cntx->alarm_time.nYear,
                                            save_cntx->alarm_time.nMonth,
                                            save_cntx->alarm_time.nDay);*/
        
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                save_cntx->detail);
    }
    else
    {
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_STARTDATE_TEXT,
                &start_date);
                                    
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_STARTTIME_TEXT, 
                &start_time);
        
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_ENDDATE_TEXT, 
                &end_date);
        
        cui_inline_get_value(
                save_cntx->child_id, 
                CAL_EVENT_EDIT_INLINE_ENDTIME_TEXT, 
                &end_time);
    
        save_cntx->start_time.nYear = start_date.year;
        save_cntx->start_time.nMonth = (U8)start_date.month;
        save_cntx->start_time.nDay = (U8)start_date.day;
        save_cntx->start_time.nHour = (U8)start_time.date_time.hour;
        save_cntx->start_time.nMin = (U8)start_time.date_time.minute;
        save_cntx->start_time.nSec = 0;
        save_cntx->start_time.DayIndex = DOW(
                                            save_cntx->start_time.nYear,
                                            save_cntx->start_time.nMonth,
                                            save_cntx->start_time.nDay);
                                            
        save_cntx->end_time.nYear = end_date.year;
        save_cntx->end_time.nMonth = (U8)end_date.month;
        save_cntx->end_time.nDay = (U8)end_date.day;
        save_cntx->end_time.nHour = (U8)end_time.date_time.hour;
        save_cntx->end_time.nMin = (U8)end_time.date_time.minute;
        save_cntx->end_time.nSec = 0;
        save_cntx->end_time.DayIndex = DOW(
                                            save_cntx->end_time.nYear,
                                            save_cntx->end_time.nMonth,
                                            save_cntx->end_time.nDay);
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT,
                save_cntx->subject);
     /*   
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_ALARM_TEXT,
                &save_cntx->alarm_index);*/
 
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_REPEAT_TEXT,
                repeat);
                
        for (i = 0; i < MMI_TDL_RULE_TOTAL; i++)
        {
            repeat_set[i] = (U8*)get_string((U16)(g_tdl_freq_set[i].repeat_type + ALARM_ONCE_STRING - 1));
            if (!mmi_ucs2cmp((char*)repeat_set[i], (char*)repeat))
            {
                save_cntx->repeat_index = i;
                break;
            }
        }  
                            
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_LOCATION_TEXT,
                save_cntx->location);
                
        cui_inline_get_value(
                save_cntx->child_id,
                CAL_EVENT_EDIT_INLINE_DETAILS_TEXT,
                save_cntx->detail);
                    
    }
    
    cui_inline_close(save_cntx->child_id);
    cui_cal_save_set_inline_data(sg_id);
}

/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_close
 * DESCRIPTION
 *  Set the title of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_cal_save_close(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    mmi_frm_group_close(sg_id);    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cal_entry_select_category
 * DESCRIPTION
 *  Highlight handler of edit task screen.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cal_entry_select_category(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_CATEGORY_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_SELECT_CATEGORY,
                    NULL,
                    mmi_cal_entry_select_category,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_cal_category_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_CATEGORY_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_CATEGORY_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_ID_TDL_CATEGORY,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->category_index,
        gui_buffer);
    g_tdl_edit_cntx.old_category = save_cntx->category_index;
    SetLeftSoftkeyFunction(mmi_cal_category_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_cal_category_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}
static void mmi_cal_entry_select_category_tap_callback(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    U16 item_num;
    U16 item_list[MMI_TDL_CATEGORY_TOTAL];
    mmi_tdl_save_cntx_struct *save_cntx;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(
                    g_tdl_edit_cntx.save_sg_id,
                    SCR_TDL_SELECT_CATEGORY,
                    NULL,
                    mmi_cal_entry_select_category,
                    MMI_FRM_FULL_SCRN))
    {
        return;
    }

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                        g_tdl_edit_cntx.save_sg_id);    
    
    SetParentHandler(0);
    RegisterHighlightHandler(mmi_cal_category_select_highlight_hdlr);
	item_num = GetNumOfChild_Ext(MITEM_TDL_CATEGORY_TYPE);
    GetSequenceStringIds_Ext(MITEM_TDL_CATEGORY_TYPE, item_list);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory15Screen(
        STR_ID_TDL_CATEGORY,
        GetRootTitleIcon(ORGANIZER_CALENDER_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        item_num,
        item_list,
        (U16*)gIndexIconsImageList,
        LIST_MENU,
        save_cntx->category_index,
        gui_buffer);
    g_tdl_edit_cntx.old_category = save_cntx->category_index;
    SetLeftSoftkeyFunction(mmi_cal_category_select_done, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_cal_category_select_done, KEY_EVENT_UP);                    
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);        
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cal_category_select_done
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cal_category_select_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;      
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(
                                                g_tdl_edit_cntx.save_sg_id); 
    save_cntx->category_index = g_tdl_edit_cntx.hilited_category;
    
    if ((g_tdl_edit_cntx.old_category == MMI_TDL_CATEGORY_ANNIVERSARY &&
        save_cntx->category_index != MMI_TDL_CATEGORY_ANNIVERSARY)||
        (g_tdl_edit_cntx.old_category == MMI_TDL_CATEGORY_BIRTHDAY&&
        save_cntx->category_index != MMI_TDL_CATEGORY_BIRTHDAY))
    {
        memcpy(&save_cntx->end_time, &save_cntx->start_time, sizeof(MYTIME));
    }
	
	mmi_frm_scrn_close_active_id();
    cui_cal_save_back_to_inline(save_cntx->group_id);
}

/*****************************************************************************
 * FUNCTION
 *  cui_cal_save_release_context
 * DESCRIPTION
 *  Release tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_cal_save_release_context(mmi_tdl_save_cntx_struct *save_cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OslMfree(save_cntx->subject);
    OslMfree(save_cntx->location);
    OslMfree(save_cntx->detail);
}

void mmi_tdl_set_type(srv_tdl_vcal_enum type)
{
    g_tdl_cntx.vcal_filter = type;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_save_event
 * DESCRIPTION
 *  Save an event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_save_event(mmi_id parent_id, mmi_tdl_operation_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 popup_string = STR_GLOBAL_SAVED;
    mmi_event_notify_enum popup_type = MMI_EVENT_SUCCESS;
    U16 result, error_code;
    srv_tdl_event_struct *pevent = NULL;
    mmi_tdl_save_cntx_struct *save_cntx;    
    cui_tdl_save_result_struct send_evt;
    MYTIME end_time, curr_time, inc_time;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE0(MMI_TDL_DATA_SAVE_EVENT);
    /*
     * 1. Prepare for save: move variables from g_tdl_edit_cntx to local buffer.
     * 2. Save.
     */
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(parent_id);    
    pevent = (srv_tdl_event_struct*)OslMalloc(sizeof(srv_tdl_event_struct));
    mmi_tdl_event_save_prepare(pevent, sizeof(srv_tdl_event_struct));
    memcpy(&end_time, &pevent->end_time, sizeof(MYTIME));
    error_code = mmi_tdl_save_adjust_field(
                    pevent, 
                    sizeof(srv_tdl_event_struct), 
                    SRV_TDL_VCAL_EVENT);

    // local added birthday
    if(pevent->category == MMI_TDL_CATEGORY_BIRTHDAY)
    {
		pevent->extend = (kal_uint32)(-1);
    }
    if (error_code == MMI_TDL_INVALID_END_TIME)
    {
        memcpy(&pevent->end_time, &end_time, sizeof(MYTIME));
        popup_string = STR_ID_TDL_EVENT_INVALID_END_TIME;
        mmi_popup_display_simple((WCHAR*)(get_string(popup_string)), MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);
        if (pevent)
        {
            OslMfree(pevent);
            pevent = NULL;
        }
        return;
    }
	if (error_code == MMI_TDL_INVALID_ALARM)
	{
	    popup_string = STR_TODO_ALARM_OFF_DONE;
	}
	else if (error_code == MMI_TDL_INVALID_REPEAT)
	{
	    popup_string = STR_TODO_REPEAT_INVALID;
		mmi_popup_display_simple((WCHAR*)(get_string(popup_string)), MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);
        if (pevent)
        {
            OslMfree(pevent);
            pevent = NULL;
        }
        return;
	}
    if (type == MMI_TDL_OP_TYPE_EDIT)
    {
		// modify SNS birthday reminder time to next year
        if(pevent->src_id != SRV_TDL_EVENT_SOURCE_LOCAL && 
		pevent->category == MMI_TDL_CATEGORY_BIRTHDAY &&
		pevent->alarm.type != MMI_TDL_ALARM_OFF)
        {
			DTGetRTCTime(&curr_time);
			if (CompareTime(pevent->start_time, curr_time, NULL) < 0)
			{
				memset(&inc_time, 0, sizeof(MYTIME));
				inc_time.nYear = 1;
				IncrementTime(pevent->alarm.first_launch, inc_time, &curr_time);
				memcpy(&pevent->alarm.first_launch, &curr_time, sizeof(MYTIME));
			}
        }
        result = srv_tdl_event_update(
            (void*)pevent, 
            g_tdl_cntx.curr_source_id, 
            g_tdl_cntx.curr_event_id);  
    }                
    else
   {
        result = srv_tdl_event_add(
            (void*)pevent, 
            SRV_TDL_EVENT_SOURCE_LOCAL, 
            &g_tdl_cntx.curr_event_id); 
            
       g_tdl_cntx.curr_source_id = SRV_TDL_EVENT_SOURCE_LOCAL;  
       if(result == SRV_TDL_RESULT_OK)
       {
           g_tdl_cntx.add_finish_flag = MMI_TRUE;
       }
   }   
    
    if (result != SRV_TDL_RESULT_OK)
    {
        if (result == SRV_TDL_RESULT_ADD_NOT_ENOUGH_MEMORY)
        {
            popup_string = STR_ID_TDL_CAL_FULL;
        }
        else
        {
            popup_string = STR_GLOBAL_FAILED_TO_SAVE;
        }
        popup_type = MMI_EVENT_FAILURE;
        
    }
    if (popup_string != STR_GLOBAL_SAVED)
        mmi_popup_display_simple((WCHAR*)(get_string(popup_string)), popup_type, GRP_ID_ROOT, NULL);
    
#ifdef __MMI_SYNCML_SYNC_CALENDAR_SUPPORT__
	if(g_tdl_cntx.curr_source_id == SRV_TDL_EVENT_SOURCE_LOCAL)
	{
	    if (type == MMI_TDL_OP_TYPE_EDIT)
	        mmi_syncml_calendar_data_changed_notification(
	                                    SYNCML_RECORD_MODIFY, 
	                                    g_tdl_cntx.curr_event_id);
	    else
	        mmi_syncml_calendar_data_changed_notification(
	                                    SYNCML_RECORD_ADD, 
	                                    g_tdl_cntx.curr_event_id);
	}
#endif

    if (pevent)
    {
        OslMfree(pevent);
        pevent = NULL;
    }

    if (mmi_frm_group_is_present(GRP_ID_TDL_VIEW))
    {
        mmi_frm_group_close(GRP_ID_TDL_VIEW);
    }

    save_cntx->save_result = result;

    if (SRV_TDL_RESULT_OK == result)
    {
        send_evt.evt_id = EVT_ID_TDL_SAVE_SUCCESS;
    }
    else
    {
        send_evt.evt_id = EVT_ID_TDL_SAVE_FAIL;
    }

    send_evt.size = sizeof(cui_tdl_save_result_struct);
    send_evt.user_data = NULL;
    send_evt.sender_id = g_tdl_edit_cntx.save_sg_id;
    send_evt.result = save_cntx->save_result;
    send_evt.store_index = g_tdl_cntx.curr_event_id;
    mmi_frm_group_send_to_parent(g_tdl_edit_cntx.save_sg_id, (mmi_group_event_struct*)&send_evt); 

    MMI_TDL_UTIL_TRACE2(MMI_TDL_DATA_SAVE_EVENT, result, error_code);    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_event_save_prepare
 * DESCRIPTION
 *  Create an event/task according to user input.
 * PARAMETERS
 *  buff : [OUT] Buffer to store event/task.
 *  buff_size : [IN] Buffer size
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_event_save_prepare(
                    srv_tdl_event_struct* buff, 
                    const U16 buff_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_struct *pevent = buff;
    U16 result = MMI_TDL_SUCCESS;
    U32 j;
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    MMI_ASSERT(buff);

    if (buff_size < sizeof(srv_tdl_event_struct))
    {
        result = MMI_TDL_ERROR_UNKNOW;
        goto MMI_ERROR_CLEAN;
    }
    
    pevent = (srv_tdl_event_struct*)buff;
    memset(pevent, 0, sizeof(srv_tdl_event_struct));
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(g_tdl_edit_cntx.save_sg_id);

    /* Start and end date time */
	if(save_cntx->source_id == SRV_TDL_EVENT_SOURCE_LOCAL)
	{
	    memcpy(&pevent->start_time, &save_cntx->start_time, sizeof(MYTIME));
	    if (save_cntx->category_index == MMI_TDL_CATEGORY_ANNIVERSARY ||
			save_cntx->category_index == MMI_TDL_CATEGORY_BIRTHDAY)
	    {
	        memcpy(&pevent->end_time, &pevent->start_time, sizeof(MYTIME));
	    }
	    else
	    {
	        memcpy(&pevent->end_time, &save_cntx->end_time, sizeof(MYTIME));    
	    }

	    pevent->src_id = save_cntx->source_id;
	    pevent->present = MMI_TRUE;
	    pevent->category = save_cntx->category_index;
	    pevent->vcal = SRV_TDL_VCAL_EVENT;
	}
	else
	{
        memcpy(pevent, &g_tdl_cntx.curr_event, sizeof(srv_tdl_event_struct));
	}
	
    pevent->alarm.type = g_tdl_alm_set[save_cntx->alarm_index].alarm_type;

    if (pevent->alarm.type == MMI_TDL_ALARM_CUSTOM)
    {
        memcpy(&pevent->alarm.first_launch, &save_cntx->alarm_time, sizeof(MYTIME));
        mmi_tdl_save_adjust_alarm_type(&pevent->alarm, &pevent->start_time);
    }
    else
    {
        mmi_tdl_save_adjust_alarm_time(&pevent->alarm, &pevent->start_time);
    }
	// for sns event, only edit alarm item, return here
	if(save_cntx->source_id != SRV_TDL_EVENT_SOURCE_LOCAL)
    {	
		goto MMI_ERROR_CLEAN;
    }

    /* Repeat */
    pevent->repeat.rule = save_cntx->repeat_index;
    pevent->repeat.dows = 0;

    if (pevent->repeat.rule == MMI_TDL_RULE_DAYS)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (save_cntx->dow_state[j])
            {
				if(mmi_clndr_get_week_first_day())
				{
                    pevent->repeat.dows |= g_mmi_clndr_weekday_index[(j+1)%7];
				}
				else
				{
                    pevent->repeat.dows |= g_mmi_clndr_weekday_index[j];
				}
            }
        }

        /* Reset to once */
        if (pevent->repeat.dows == 0)
        {
            pevent->repeat.rule = MMI_TDL_RULE_ONCE;
        }
    }

    /* Subject */                
    if (mmi_ucs2strlen((CHAR*)save_cntx->subject) == 0)
    {
        memcpy(
            (CHAR*)(pevent->subject), 
            GetString(STR_ID_TDL_NO_CONTENT), 
            SRV_TDL_SUBJECT_SIZE - 1);
    }
    else
    {
        mmi_ucs2ncpy((CHAR*)(pevent->subject), (CHAR*)(save_cntx->subject), SRV_TDL_SUBJECT_SIZE - 1);
    }

    if (pevent->category != MMI_TDL_CATEGORY_ANNIVERSARY &&
        pevent->category != MMI_TDL_CATEGORY_BIRTHDAY)
    {
        mmi_ucs2ncpy((CHAR*)pevent->location, (CHAR*)save_cntx->location, MAX_TDL_LOCATION_SIZE - 1);
        mmi_ucs2ncpy((CHAR*)pevent->details, (CHAR*)save_cntx->detail, SRV_TDL_DETAILS_SIZE - 1);
    }
    
    /* Anniversary */
    if (pevent->category == MMI_TDL_CATEGORY_ANNIVERSARY ||
		pevent->category == MMI_TDL_CATEGORY_BIRTHDAY)
    {
       mmi_ucs2ncpy((CHAR*)pevent->details, (CHAR*)save_cntx->detail, SRV_TDL_DETAILS_SIZE - 1);
    }

MMI_ERROR_CLEAN:
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_EVENT_SAVE_PREPARE, result);
 }

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_time_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  task            [?]         
 *  year            [IN]        
 *  month           [IN]        
 *  day             [IN]        
 *  timeString      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_time_string(
                const void *data,
                const U16 vcal_type,
                const MYTIME* date, 
                CHAR *time_buff,
                const U16 buff_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_event_struct *pevent;
    srv_tdl_task_struct *ptask;
    U8 is_start_day = MMI_FALSE;
    U8 is_end_day = MMI_FALSE;
    MYTIME start_time;
    MYTIME end_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (vcal_type > SRV_TDL_VCAL_TASK || 
        buff_size < (MMI_TDL_MAX_TIME_STRING_LEN + 1) * ENCODING_LENGTH)
    {
        return;
    }
    
    if (vcal_type == SRV_TDL_VCAL_EVENT)
    {
        pevent = (srv_tdl_event_struct*)data;
        memcpy(&start_time, &(pevent->start_time), sizeof(MYTIME));
        memcpy(&end_time, &(pevent->end_time), sizeof(MYTIME));
    
        if (start_time.nYear == date->nYear && 
            start_time.nMonth == date->nMonth && 
            start_time.nDay == date->nDay)
        {
            is_start_day = MMI_TRUE;
        }
    
        if (end_time.nYear == date->nYear &&
            end_time.nMonth == date->nMonth &&
            end_time.nDay == date->nDay)
        {
            is_end_day = MMI_TRUE;
        }

        if (pevent->repeat.rule == MMI_TDL_RULE_ONCE && !is_start_day)
        {
            start_time.nHour = 0;
            start_time.nMin = 0;
        }

        if (pevent->repeat.rule == MMI_TDL_RULE_ONCE && !is_end_day)
        {
            end_time.nHour= 23;
            end_time.nMin = 59;
        }

        if (pevent->category == MMI_TDL_CATEGORY_ANNIVERSARY ||
			pevent->category == MMI_TDL_CATEGORY_BIRTHDAY)
        {
            end_time.nHour= 23;
            end_time.nMin = 59;
        }

        kal_wsprintf(
                (kal_wchar*)time_buff, 
                "%02d:%02d-%02d:%02d", 
                start_time.nHour, 
                start_time.nMin,
                end_time.nHour, 
                end_time.nMin);
            
    }
    else
    {
        ptask = (srv_tdl_task_struct*)data;
        memcpy(&start_time, &(ptask->due_time), sizeof(MYTIME));
        kal_wsprintf(
                (kal_wchar*)time_buff, 
                "%02d:%02d", 
                start_time.nHour, 
                start_time.nMin);
    }

    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cal_category_select_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cal_category_select_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_edit_cntx.hilited_category = (U8)index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_event_edit_screen
 * DESCRIPTION
 *  Display reminder screen when TDL alarm expires.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_event_edit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_view_group_data_struct *view_group_cntx;
    mmi_id sg_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    view_group_cntx = (mmi_tdl_view_group_data_struct*)mmi_frm_group_get_user_data(GRP_ID_TDL_VIEW);
        
    sg_id = cui_cal_save_create(view_group_cntx->parent_id);
	cui_cal_save_set_event(sg_id, &g_tdl_cntx.curr_event);
	cui_cal_save_set_operation_type(sg_id, MMI_TDL_OP_TYPE_EDIT);
	cui_cal_save_set_highlight_item(sg_id, CAL_EVENT_EDIT_INLINE_SUBJECT_TEXT); 			   
	cui_cal_save_run(sg_id);
	mmi_frm_group_close(view_group_cntx->group_id);
	
}


#endif

#ifdef __MMI_TODOLIST__
/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_create
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  mmi_id : [IN] parent_id, parent group ID to add current group to.
 * RETURNS
 *  mmi_id
 *****************************************************************************/
mmi_id cui_tdl_save_create(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    MYTIME curr_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SYNCML_SYNC_TASK_SUPPORT__
    if (mmi_syncml_is_task_sync_now())
    {
        mmi_popup_display_simple((WCHAR*)(get_string(STR_ID_SYNC_CODE_FORBIDDEN)), MMI_EVENT_FAILURE, parent_id, NULL);
        return GRP_ID_INVALID;
    }
#endif /* __MMI_SYNCML_SYNC_TASK_SUPPORT__ */
    
    if (mmi_frm_group_is_present(GRP_ID_TDL_EDIT))
    {
        mmi_frm_group_close(GRP_ID_TDL_EDIT);
    }
    
    set_inline_date_boundary(MMI_TDL_END_YEAR_SUPPORT, MMI_TDL_START_YEAR_SUPPORT, 12, 1);

    g_tdl_cntx.vcal_filter = SRV_TDL_VCAL_TASK;
    save_cntx = (mmi_tdl_save_cntx_struct*)OslMalloc(sizeof(mmi_tdl_save_cntx_struct));
    memset(save_cntx, 0, sizeof(mmi_tdl_save_cntx_struct));
    save_cntx->highlight_item = CUI_INLINE_ITEM_ID_BASE;

    cui_tdl_save_create_context(save_cntx);
    save_cntx->parent_id = parent_id;
    save_cntx->group_id = mmi_frm_group_create(
                                        parent_id,
                                        GRP_ID_TDL_EDIT,
                                        cui_tdl_save_group_proc, 
                                        save_cntx);
                                        
    g_tdl_edit_cntx.save_sg_id = save_cntx->group_id;
    
    GetDateTime(&curr_time);
    curr_time.nMin = 0;
    curr_time.nSec = 0;
    save_cntx->priority_index = MMI_TDL_PRIORITY_MEDIUM;
    memcpy(&save_cntx->start_time, &curr_time, sizeof(MYTIME));
    memcpy(&save_cntx->alarm_time, &curr_time, sizeof(MYTIME));
    save_cntx->operation_type = MMI_TDL_OP_TYPE_ADD;
    save_cntx->title_id = STR_GLOBAL_ADD;
    return save_cntx->group_id;  
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_group_proc
 * DESCRIPTION
 *  Proc function of edit group.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret cui_tdl_save_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_tdl_save_result_struct send_evt;
    mmi_tdl_save_cntx_struct *save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;
    U8 *repeat_set[MMI_TDL_RULE_TOTAL];
    U8 *alarm_set[MMI_TDL_ALARM_TOTAL];
    U32 i;  
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    for (i = 0; i < MMI_TDL_RULE_TOTAL; i++)
    {
        repeat_set[i] = (U8*)get_string((U16)(g_tdl_freq_set[i].repeat_type + ALARM_ONCE_STRING - 1));
    }
    for (i = 0; i < MMI_TDL_ALARM_TOTAL; i++)
    {
        alarm_set[i] = (U8*)get_string((U16)(g_tdl_alm_set[i].str_id));
    }
    
    switch(evt->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            cui_tdl_save_release_context(save_cntx);
            OslMfree(save_cntx);
            break;
        }
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            cui_tdl_save_proc_submit(evt);
            break;
        }
        case EVT_ID_CUI_INLINE_ABORT:
        {     
            send_evt.evt_id = EVT_ID_TDL_SAVE_CANCEL;
            send_evt.size = sizeof(cui_tdl_save_result_struct);
            send_evt.user_data = NULL;
            send_evt.sender_id = g_tdl_edit_cntx.save_sg_id;
            send_evt.result = save_cntx->save_result;
            send_evt.store_index = g_tdl_cntx.curr_store_idx;
            mmi_frm_group_send_to_parent(g_tdl_edit_cntx.save_sg_id, (mmi_group_event_struct*)&send_evt); 
            break;
        }            
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_tdl_save_proc_notify(evt);
            break;
        }
        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
        {
            if (MMI_TDL_RULE_DAYS != save_cntx->repeat_index)
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CUI_INLINE_ITEM_REPEAT_TEXT,
                                repeat_set[save_cntx->repeat_index]);        
            }
            else
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CUI_INLINE_ITEM_REPEAT_TEXT,
                                g_tdl_edit_cntx.repeat_str);        
            }

            if (MMI_TDL_ALARM_CUSTOM != save_cntx->alarm_index)
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CUI_INLINE_ITEM_ALARM_TEXT,
                                alarm_set[save_cntx->alarm_index]);        
            }
            else
            {
                cui_inline_set_value(
                                save_cntx->child_id,
                                CUI_INLINE_ITEM_ALARM_TEXT,
                                g_tdl_edit_cntx.alarm_date);        
            }
		#ifdef __MMI_TOUCH_SCREEN__
			if(save_cntx->highlight_item == CUI_INLINE_ITEM_REPEAT_TEXT)
            {
				//wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type);
				wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type_tap_callnback);
            }
			else if(save_cntx->highlight_item == CUI_INLINE_ITEM_ALARM_TEXT)
            {
				//wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type);
				wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type_tap_callback);
            }
		#endif /* __MMI_TOUCH_SCREEN__ */
            break;
        }
        case EVT_ID_CUI_INLINE_CSK_PRESS:
        {    
            cui_tdl_save_csk_press(evt);
            break;
        }
        case EVT_ID_CUI_FSEDITOR_ABORT:
        {
            cui_fseditor_close(g_tdl_edit_cntx.fseditor_gid);
            break;
        }   
        case EVT_ID_CUI_FSEDITOR_CUSTOM_MENU_SELECTED:
        {
            cui_fseditor_custom_menu_select_evt_struct *event = (cui_fseditor_custom_menu_select_evt_struct*)evt;
            switch (event->menu_id)
            {
                case MITEM_TODO_LIST_USE_TEMPLATE:
                {
                    mmi_frm_scrn_first_enter(
                                    save_cntx->group_id,
                                    SCR_TDL_LIST_TEMPLATE,
                                    (FunctionPtr)mmi_tdl_entry_template_list,
                                    NULL);
                    break;
                }
            }
            break;
        }                   
        case EVT_ID_CUI_FSEDITOR_CHANGED:
        {
            cui_fseditor_get_text(
                            g_tdl_edit_cntx.fseditor_gid, 
                            (WCHAR*)g_tdl_edit_cntx.edit_buff, 
                            MAX_TDL_DETAILS_SIZE);
            break;
        }
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
            mmi_menu_id list_of_ids[7];    
            U32 i;

            for (i = 0; i < 7; i++)
            {
                list_of_ids[i] = i;
            }
            
            cui_menu_set_currlist_flags(
                                    g_tdl_edit_cntx.menu_gid, 
                                    CUI_MENU_NORMAL_CHECK_BOX_LIST);
            cui_menu_set_default_title_image(
                                    g_tdl_edit_cntx.menu_gid, 
                                    (UI_image_type)get_image(GetRootTitleIcon(ORGANIZER_TODOLIST_MENU)));  
            cui_menu_set_currlist_title(
                                    g_tdl_edit_cntx.menu_gid,
                                    get_string(STR_GLOBAL_CUSTOM),
                                    0);
            cui_menu_set_currlist(
                                    g_tdl_edit_cntx.menu_gid,
                                    7,
                                    list_of_ids);
#ifdef	__MMI_CALENDAR_FDOW__
            if(mmi_clndr_get_week_first_day())
            {
				for (i = 0; i < 7; i++)
				{
					cui_menu_set_item_string(
										g_tdl_edit_cntx.menu_gid, 
										(MMI_MENU_ID)i,
										(WCHAR*)GetString(STR_GLOBAL_SUNDAY + (i+1)%7));		
				}
            }
			else
			{
				for (i = 0; i < 7; i++)
	            {
	                cui_menu_set_item_string(
	                                    g_tdl_edit_cntx.menu_gid, 
	                                    (MMI_MENU_ID)i,
	                                    (WCHAR*)GetString(STR_GLOBAL_SUNDAY + i));      
	            }
			}
#else
            for (i = 0; i < 7; i++)
            {
                cui_menu_set_item_string(
                                    g_tdl_edit_cntx.menu_gid, 
                                    (MMI_MENU_ID)i,
                                    (WCHAR*)GetString(STR_GLOBAL_SUNDAY + i));      
            }
#endif
            cui_menu_set_checkbox_state(g_tdl_edit_cntx.menu_gid, save_cntx->dow_state);
            break;
        }
        case EVT_ID_CUI_MENU_CHECKBOX_CHANGE_STATE:
        {
            cui_menu_get_checkbox_state(g_tdl_edit_cntx.menu_gid, save_cntx->dow_state);        
            break;
        }        
        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            memset(g_tdl_edit_cntx.repeat_str, 0, MMI_TDL_MAX_INLINE_STRING_LEN);
#ifdef	__MMI_CALENDAR_FDOW__
	        if(mmi_clndr_get_week_first_day())
	        {
				for (i = 0; i < 7; i++)
				{
					if (save_cntx->dow_state[i])
					{
						if (g_tdl_edit_cntx.repeat_str[0] == 0)
						{
							mmi_wcscpy(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
						}
						else
						{
							mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)L", ");
							mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + (i+1)%7));
						}
					}
				}
	        }
			else
			{
				for (i = 0; i < 7; i++)
	            {
	                if (save_cntx->dow_state[i])
	                {
	                    if (g_tdl_edit_cntx.repeat_str[0] == 0)
	                    {
	                        mmi_wcscpy(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
	                    }
	                    else
	                    {
	                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)L", ");
	                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
	                    }
	                }
	            }
			}
#else			
            for (i = 0; i < 7; i++)
            {
                if (save_cntx->dow_state[i])
                {
                    if (g_tdl_edit_cntx.repeat_str[0] == 0)
                    {
                        mmi_wcscpy(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
                    }
                    else
                    {
                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)L", ");
                        mmi_wcscat(g_tdl_edit_cntx.repeat_str, (WCHAR*)get_string(STR_GLOBAL_SUNDAY_SHORT + i));
                    }
                }
            }
#endif			
            mmi_frm_scrn_close(g_tdl_edit_cntx.save_sg_id, SCR_TDL_REPEAT_SELECT_TYPE);
            cui_menu_close(g_tdl_edit_cntx.menu_gid);
            
            break;
        }
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
        {
            mmi_frm_scrn_close_active_id();
            break;
        }
        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_proc_notify
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_tdl_save_proc_notify(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_event_inline_notify_struct *event;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_notify_struct*)evt;        
    save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;
  
    switch(event->event_type)
    {
        case CUI_INLINE_NOTIFY_HIGHLIGHT_ITEM:
        {
			save_cntx->highlight_item = event->item_id;
            switch(event->item_id)
            {
                case CUI_INLINE_ITEM_REPEAT_TEXT:
                    cui_inline_set_softkey_text(
                                    save_cntx->child_id,
                                    CUI_INLINE_ITEM_REPEAT_TEXT,
                                    MMI_LEFT_SOFTKEY,
                                    STR_GLOBAL_OPTIONS);
				#ifdef __MMI_TOUCH_SCREEN__
					//wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type);
					wgui_register_tap_callback(mmi_tdl_entry_select_repeat_type_tap_callnback);
				#endif /* __MMI_TOUCH_SCREEN__ */
                    break;
                case CUI_INLINE_ITEM_ALARM_TEXT:
                    cui_inline_set_softkey_text(
                                    save_cntx->child_id,
                                    CUI_INLINE_ITEM_ALARM_TEXT,
                                    MMI_LEFT_SOFTKEY,
                                    STR_GLOBAL_OPTIONS);
				#ifdef __MMI_TOUCH_SCREEN__
					//wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type);
					wgui_register_tap_callback(mmi_tdl_entry_select_alarm_type_tap_callback);
				#endif /* __MMI_TOUCH_SCREEN__ */
                    break;
                default:
                    break;
            }
            break;
        }
        case CUI_INLINE_NOTIFY_ITEM_CHANGED:
        {
            switch(event->item_id)
            {
               case CUI_INLINE_ITEM_ALARM_TEXT:
               {
          /*          cui_inline_get_value(
                                    save_cntx->child_id,
                                    CUI_INLINE_ITEM_ALARM_TEXT,
                                    &save_cntx->alarm_index); */
                    break;
                }
            }
            break;
        }
        default:
            break;
    }    
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_proc_submit
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_tdl_save_proc_submit(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;  
    cui_event_inline_submit_struct *event;    
    cui_inline_item_date_time_struct due_date;
    cui_inline_item_time_struct due_time;   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_submit_struct*)evt;        
    save_cntx = (mmi_tdl_save_cntx_struct*)evt->user_data;

    if (event->item_id == CUI_INLINE_ITEM_REPEAT_TEXT)
    {
        mmi_tdl_entry_edit_option(save_cntx->group_id, CUI_INLINE_ITEM_REPEAT_TEXT);
        return;
    }

    if (event->item_id == CUI_INLINE_ITEM_ALARM_TEXT)
    {
        mmi_tdl_entry_edit_option(save_cntx->group_id, CUI_INLINE_ITEM_ALARM_TEXT);
        return;
    }
    
    cui_inline_get_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_DUEDATE_TEXT,
                &due_date);
            
    cui_inline_get_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_DUETIME_TEXT,
                &due_time);
            
    save_cntx->start_time.nYear = due_date.year;
    save_cntx->start_time.nMonth = (U8)due_date.month;
    save_cntx->start_time.nDay = (U8)due_date.day;
    save_cntx->start_time.nHour = (U8)due_time.date_time.hour;
    save_cntx->start_time.nMin = (U8)due_time.date_time.minute;
    save_cntx->start_time.nSec = 0;
    save_cntx->start_time.DayIndex = DOW(
                                        save_cntx->start_time.nYear,
                                        save_cntx->start_time.nMonth,
                                         save_cntx->start_time.nDay);
    cui_inline_get_value(
            save_cntx->child_id,
            CUI_INLINE_ITEM_SUBJECT_TEXT,
            save_cntx->subject);
                
  /*          
    cui_inline_get_value(
            save_cntx->child_id,
            CUI_INLINE_ITEM_ALARM_TEXT,
            &save_cntx->alarm_index);*/

    cui_inline_get_value(
            save_cntx->child_id,
            CUI_INLINE_ITEM_PRIORITY_TEXT,
            &save_cntx->priority_index);
            
    cui_inline_get_value(
            save_cntx->child_id,
            CUI_INLINE_ITEM_DETAILS_TEXT,
            save_cntx->detail);
            
    cui_inline_get_value(
            save_cntx->child_id,
            CUI_INLINE_ITEM_STATUS_TEXT,
            &save_cntx->status_index);
            
    mmi_tdl_save_task(save_cntx->group_id, (mmi_tdl_operation_type_enum)(save_cntx->operation_type));
}

/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_csk_press
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_tdl_save_csk_press(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_event_inline_submit_struct *event;      

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    event = (cui_event_inline_submit_struct*)evt;        

    switch(event->item_id)
    {
        case CUI_INLINE_ITEM_REPEAT_TEXT:
        {
            mmi_tdl_entry_select_repeat_type();
            break;
        }
        case CUI_INLINE_ITEM_ALARM_TEXT:
        {
            mmi_tdl_entry_select_alarm_type();
            break;
        }
        default:
            cui_tdl_save_proc_submit(evt);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_create_context
 * DESCRIPTION
 *  Create tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_tdl_save_create_context(mmi_tdl_save_cntx_struct *save_cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    save_cntx->subject = OslMalloc(MAX_TODO_LIST_NOTE);
    memset(save_cntx->subject, 0, MAX_TODO_LIST_NOTE);
    save_cntx->detail = OslMalloc(MAX_TDL_DETAILS_SIZE * ENCODING_LENGTH);
    memset(save_cntx->detail, 0, MAX_TDL_DETAILS_SIZE * ENCODING_LENGTH);    
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_release_context
 * DESCRIPTION
 *  Release tdl save CUI.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_id
 *****************************************************************************/
static void cui_tdl_save_release_context(mmi_tdl_save_cntx_struct *save_cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OslMfree(save_cntx->subject);
    OslMfree(save_cntx->detail);
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_run
 * DESCRIPTION
 *  Run tdl save CUI.
 * PARAMETERS
 *  mmi_id : [IN] parent_id, parent group ID to add current group to.
 * RETURNS
 *  mmi_id
 *****************************************************************************/
void cui_tdl_save_run(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_inline_struct inline_data;
    cui_inline_item_date_time_struct due_date;
    cui_inline_item_time_struct due_time;
    mmi_tdl_save_cntx_struct *save_cntx;  
    U8 *alarm_set[MMI_TDL_ALARM_TOTAL];
    U8 *repeat_set[MMI_TDL_RULE_TOTAL];
    U8 *priority_set[MMI_TDL_MAX_PRIORITY];
    U8 *status_set[2];
    U32 i;
    cui_inline_item_softkey_struct softkey;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    for (i = 0; i < MMI_TDL_ALARM_TOTAL; i++)
    {
        alarm_set[i] = (U8*)get_string(g_tdl_alm_set[i].str_id);
    }
    for (i = 0; i < MMI_TDL_RULE_TOTAL; i++)
    {
        repeat_set[i] = (U8*)get_string((U16)(g_tdl_freq_set[i].str_id));
    }

    priority_set[0] = (U8*)get_string(STR_GLOBAL_LOW);
    priority_set[1] = (U8*)get_string(STR_GLOBAL_MEDIUM);
    priority_set[2] = (U8*)get_string(STR_GLOBAL_HIGH);

    status_set[0] = (U8*)get_string(STR_ID_TODO_STATUS_UNDONE);
    status_set[1] = (U8*)get_string(STR_GLOBAL_DONE);

    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    mmi_frm_group_enter(sg_id, MMI_FRM_NODE_NONE_FLAG);

    if (MMI_TDL_OP_TYPE_EDIT == save_cntx->operation_type)
    {
        save_cntx->title_id = STR_GLOBAL_EDIT;
    }
    else
    {
        save_cntx->title_id = STR_GLOBAL_ADD;
    }
    softkey.softkey[MMI_LEFT_SOFTKEY].string_id = STR_GLOBAL_SAVE;
    softkey.softkey[MMI_LEFT_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_RIGHT_SOFTKEY].string_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_RIGHT_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_CENTER_SOFTKEY].string_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;
    softkey.softkey[MMI_CENTER_SOFTKEY].image_id = CUI_INLINE_SOFTKEY_DEFAULT_VALUE;

    inline_data.items_count = MMI_TDL_MAX_TASK_INLINE_ITEM;
    inline_data.title = save_cntx->title_id;
    inline_data.title_icon = GetRootTitleIcon(ORGANIZER_TODOLIST_MENU);
    inline_data.screen_flag = CUI_INLINE_SCREEN_DISABLE_DONE;
    inline_data.softkey = &softkey;
    inline_data.items = g_tdl_task_cui_inline_item;
    
    save_cntx->child_id = cui_inline_create(sg_id, &inline_data);
    if (save_cntx->child_id != GRP_ID_INVALID)
    {
        due_date.year = save_cntx->start_time.nYear;
        due_date.month = save_cntx->start_time.nMonth;
        due_date.day = save_cntx->start_time.nDay;
        due_time.date_time.hour = save_cntx->start_time.nHour;
        due_time.date_time.minute = save_cntx->start_time.nMin;
        due_time.date_time.second = 0;

        cui_inline_set_fullscreen_edit_title_icon(save_cntx->child_id, CUI_INLINE_ITEM_STATUS_CAPTION, GetRootTitleIcon(ORGANIZER_TODOLIST_MENU));
      
        cui_inline_set_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_DUEDATE_TEXT, 
                &due_date);
    
        cui_inline_set_value(
                save_cntx->child_id, 
                CUI_INLINE_ITEM_DUETIME_TEXT, 
                &due_time);

        cui_inline_set_value(
                save_cntx->child_id,
                CUI_INLINE_ITEM_SUBJECT_TEXT,
                save_cntx->subject);
    
        cui_inline_set_value(
                save_cntx->child_id,
                CUI_INLINE_ITEM_ALARM_TEXT,
                alarm_set[save_cntx->alarm_index]);

        cui_inline_set_value(
                save_cntx->child_id,
                CUI_INLINE_ITEM_REPEAT_TEXT,
                repeat_set[save_cntx->repeat_index]);

        cui_inline_set_item_select(
                save_cntx->child_id,
                CUI_INLINE_ITEM_PRIORITY_TEXT,
                MMI_TDL_MAX_PRIORITY,
                priority_set,
                save_cntx->priority_index);

        cui_inline_set_value(
                save_cntx->child_id,
                CUI_INLINE_ITEM_DETAILS_TEXT,
                save_cntx->detail);

        cui_inline_set_item_select(
                save_cntx->child_id,
                CUI_INLINE_ITEM_STATUS_TEXT,
                MMI_TDL_MAX_STATUS_NUM,
                status_set,
                save_cntx->status_index);
                
        cui_inline_set_highlight_item(save_cntx->child_id, save_cntx->highlight_item);
        cui_inline_run(save_cntx->child_id);
    }
    else
    {
        mmi_frm_group_close(save_cntx->child_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_title
 * DESCRIPTION
 *  Set the title of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * title : [IN] title to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_title(mmi_id sg_id, U16 title_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->title_id = title_id;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_operation_type
 * DESCRIPTION
 *  Set the type of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * title : [IN] type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_operation_type(mmi_id sg_id, mmi_tdl_operation_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->operation_type = type;
}

/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_task
 * DESCRIPTION
 *  Set the subject of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * subject : [IN] subject to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_task(mmi_id sg_id, srv_tdl_task_struct *ptask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    
    U32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->subject)
    {
        mmi_wcsncpy(save_cntx->subject, (U16*)ptask->subject, MAX_TODO_NOTE_LEN - 1);
    }
    if (save_cntx->detail)
    {
        mmi_wcsncpy(save_cntx->detail, (U16*)ptask->details, MAX_TDL_DETAILS_LEN);
    }
    memcpy(&save_cntx->start_time, &ptask->due_time, sizeof(MYTIME));
    save_cntx->alarm_index = ptask->alarm.type;
    if (ptask->alarm.type != MMI_TDL_ALARM_OFF)
    {
        memcpy(&save_cntx->alarm_time, &ptask->alarm.first_launch, sizeof(MYTIME));
    }
    save_cntx->repeat_index = ptask->repeat.rule;
    if (MMI_TDL_RULE_DAYS == save_cntx->repeat_index)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (ptask->repeat.dows & g_mmi_clndr_weekday_index[j])
            {
#ifdef	__MMI_CALENDAR_FDOW__
                if(mmi_clndr_get_week_first_day())
                {
				    save_cntx->dow_state[(j+7-1)%7] = 1;
                }
				else
				{
					 save_cntx->dow_state[j] = 1;
				}
#else
                save_cntx->dow_state[j] = 1;
#endif
            }
        }
    }
    
    save_cntx->priority_index = ptask->priority;
    save_cntx->status_index = ptask->status;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_subject
 * DESCRIPTION
 *  Set the subject of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * subject : [IN] subject to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_subject(mmi_id sg_id, U16 *subject)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->title_id)
    {
        mmi_wcsncpy(save_cntx->subject, subject, MAX_TODO_NOTE_LEN - 1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_due_time
 * DESCRIPTION
 *  Set the due_time of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * due_time : [IN] due_time to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_due_time(mmi_id sg_id, MYTIME *due_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    memcpy(&save_cntx->start_time, due_time, sizeof(MYTIME));
    save_cntx->start_time.nMin = 0;
    save_cntx->start_time.nSec = 0;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_priority
 * DESCRIPTION
 *  Set the priority of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * priority : [IN] priority to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_priority(mmi_id sg_id, U8 priority)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->priority_index = priority;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_status
 * DESCRIPTION
 *  Set the status of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * status : [IN] status to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_status(mmi_id sg_id, U8 status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->status_index = status;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_alarm
 * DESCRIPTION
 *  Set the category of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * alarm_type : [IN] alarm type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_alarm(mmi_id sg_id, U8 alarm_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->alarm_index = alarm_type;
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_alarm_time
 * DESCRIPTION
 *  Set the category of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * alarm_time : [IN] alarm time to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_alarm_time(mmi_id sg_id, MYTIME *alarm_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    memcpy(&save_cntx->alarm_time, alarm_time, sizeof(MYTIME));
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_repeat
 * DESCRIPTION
 *  Set the repeat of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * repeat_type : [IN] repeat type to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_repeat(mmi_id sg_id, srv_tdl_repeat_struct *repeat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;   
    U32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    save_cntx->repeat_index = repeat->rule;

    if (MMI_TDL_RULE_DAYS == save_cntx->repeat_index)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (repeat->dows & g_mmi_clndr_weekday_index[j])
            {
#ifdef	__MMI_CALENDAR_FDOW__
                if(mmi_clndr_get_week_first_day())
                {
				    save_cntx->dow_state[(j+7-1)%7] = 1;
                }
				else
				{
					 save_cntx->dow_state[j] = 1;
				}
#else
                save_cntx->dow_state[j] = 1;
#endif
            }
        }
    }
}

    
/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_detail
 * DESCRIPTION
 *  Set the repeat of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * detail : [IN] detail to set to
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_set_detail(mmi_id sg_id, U16 *detail)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);    
    if (save_cntx->detail)
    {
        mmi_wcsncpy(save_cntx->detail, detail, MAX_TDL_DETAILS_LEN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_set_highlight_item
 * DESCRIPTION
 *  Set highlight item.
 * PARAMETERS
 *  sg_id      [IN]        Screen group.
 *  item_id    [IN]        item id.
 * RETURNS
 *  void
 *****************************************************************************/
void cui_tdl_save_set_highlight_item(mmi_id sg_id, U16 item_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_save_cntx_struct *save_cntx;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (sg_id == GRP_ID_INVALID)
    {
        return;
    }
    
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(sg_id);  
    save_cntx->highlight_item = item_id;
}


/*****************************************************************************
 * FUNCTION
 *  cui_tdl_save_close
 * DESCRIPTION
 *  Set the title of edit screen
 * PARAMETERS
 * sg_id : [IN] screen group ID
 * RETURNS
 * RETURN VALUES
 *****************************************************************************/
void cui_tdl_save_close(mmi_id sg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_close(sg_id);    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_save_task
 * DESCRIPTION
 *  Save task.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_save_task(mmi_id parent_id, mmi_tdl_operation_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 popup_string = STR_GLOBAL_SAVED;
    mmi_event_notify_enum popup_type = MMI_EVENT_SUCCESS;
    U16 result, error_code;
    srv_tdl_task_struct *ptask = NULL;
    mmi_tdl_save_cntx_struct *save_cntx;    
    cui_tdl_save_result_struct send_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TDL_UTIL_TRACE0(MMI_TDL_DATA_SAVE_TASK);
    /*
     * 1. Prepare for save: move variables from g_tdl_edit_cntx to local buffer.
     * 2. Save.
     */
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(g_tdl_edit_cntx.save_sg_id);    
    ptask = (srv_tdl_task_struct*)OslMalloc(sizeof(srv_tdl_task_struct));
    mmi_tdl_task_save_prepare(ptask, sizeof(srv_tdl_task_struct));    
    error_code = mmi_tdl_save_adjust_field(
                    (void*)ptask, 
                    sizeof(srv_tdl_task_struct), 
                    SRV_TDL_VCAL_TASK);

	if (error_code == MMI_TDL_INVALID_ALARM)
	{
	    popup_string = STR_TODO_ALARM_OFF_DONE;
    }
	else if (error_code == MMI_TDL_INVALID_REPEAT)
	{
	    popup_string = STR_TODO_REPEAT_INVALID;
		mmi_popup_display_simple((WCHAR*)(get_string(popup_string)), MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);
        if (ptask)
        {
            OslMfree(ptask);
            ptask = NULL;
        }
        return;
	}

    if (type == MMI_TDL_OP_TYPE_EDIT)
        result = srv_tdl_update(
                    (void*)ptask, 
                    SRV_TDL_VCAL_TASK, 
                    g_tdl_cntx.curr_store_idx);
    else
        result = srv_tdl_add(
                    (void*)ptask, 
                    SRV_TDL_VCAL_TASK, 
                    &g_tdl_cntx.curr_store_idx);

    if (result != SRV_TDL_RESULT_OK)
    {
        if (result == SRV_TDL_RESULT_ADD_NOT_ENOUGH_MEMORY)
        {
            popup_string = STR_TODO_LIST_LIST_FULL_MSG;
        }
        else
        {
            popup_string = STR_GLOBAL_FAILED_TO_SAVE;
        }
        popup_type = MMI_EVENT_FAILURE;
    }
    if (popup_string != STR_GLOBAL_SAVED)
        mmi_popup_display_simple((WCHAR*)(get_string(popup_string)), popup_type, GRP_ID_ROOT, NULL);
        
#ifdef __MMI_SYNCML_SYNC_TASK_SUPPORT__    
    if (type == MMI_TDL_OP_TYPE_EDIT)
        mmi_syncml_task_data_changed_notification(
                                    SYNCML_RECORD_MODIFY, 
                                    g_tdl_cntx.curr_store_idx);
    else
        mmi_syncml_task_data_changed_notification(
                                    SYNCML_RECORD_ADD, 
                                    g_tdl_cntx.curr_store_idx);
#endif

    if (ptask)
    {
        OslMfree(ptask);
        ptask = NULL;
    }
    
    if (mmi_frm_group_is_present(GRP_ID_TDL_VIEW))
    {
        mmi_frm_group_close(GRP_ID_TDL_VIEW);
    }
    
    save_cntx->save_result = result;
    
    if (SRV_TDL_RESULT_OK == result)
    {
        send_evt.evt_id = EVT_ID_TDL_SAVE_SUCCESS;
    }
    else
    {
        send_evt.evt_id = EVT_ID_TDL_SAVE_FAIL;
    }
    
    send_evt.size = sizeof(cui_tdl_save_result_struct);
    send_evt.user_data = NULL;
    send_evt.sender_id = g_tdl_edit_cntx.save_sg_id;
    send_evt.result = save_cntx->save_result;
    send_evt.store_index = g_tdl_cntx.curr_store_idx;
    mmi_frm_group_send_to_parent(g_tdl_edit_cntx.save_sg_id, (mmi_group_event_struct*)&send_evt); 

	if ((type == MMI_TDL_OP_TYPE_EDIT) && mmi_frm_group_is_present(GRP_ID_TDL_REMINDER))
    {
	    mmi_tdl_dismiss_reminder();
    }

    MMI_TDL_UTIL_TRACE2(MMI_TDL_DATA_SAVE_TASK, result, error_code); 
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_task_save_prepare
 * DESCRIPTION
 *  Create an event/task according to user input.
 * PARAMETERS
 *  buff : [OUT] Buffer to store event/task.
 *  buff_size : [IN] Buffer size
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_tdl_task_save_prepare(
                    srv_tdl_task_struct* buff, 
                    const U16 buff_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_tdl_task_struct *ptask = buff;    
    mmi_tdl_save_cntx_struct *save_cntx;    
    U16 result = MMI_TDL_SUCCESS;
    U8 temp_status;
    U32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(buff);

    if (buff_size < sizeof(srv_tdl_task_struct))
    {
        result = MMI_TDL_ERROR_UNKNOW;
        goto MMI_ERROR_CLEAN;
    }

    ptask = (srv_tdl_task_struct*)buff;
    memset(ptask, 0, sizeof(srv_tdl_task_struct));
    save_cntx = (mmi_tdl_save_cntx_struct*)mmi_frm_group_get_user_data(g_tdl_edit_cntx.save_sg_id);

    /* Due date time */
    memcpy(&ptask->due_time, &save_cntx->start_time, sizeof(MYTIME));

    /* Present */
    ptask->present = MMI_TRUE;

    /* Priority */
    ptask->priority = save_cntx->priority_index;

	/* Status */
    temp_status = ptask->status;
	ptask->status = save_cntx->status_index;
    if (ptask->status == MMI_TDL_STATUS_DONE && 
        temp_status == MMI_TDL_STATUS_UNDONE)
    {
        GetDateTime(&ptask->complete_time);
    }

    /* vcal */
    ptask->vcal = SRV_TDL_VCAL_TASK;
    
    /* Alarm */
    ptask->alarm.type = g_tdl_alm_set[save_cntx->alarm_index].alarm_type;

    if (ptask->alarm.type == MMI_TDL_ALARM_CUSTOM)
    {
        memcpy(&ptask->alarm.first_launch, &save_cntx->alarm_time, sizeof(MYTIME));
        mmi_tdl_save_adjust_alarm_type(&ptask->alarm, &ptask->due_time);
    }
    else
    {
        mmi_tdl_save_adjust_alarm_time(&ptask->alarm, &save_cntx->start_time);
    }

    /* Repeat */
    ptask->repeat.rule = save_cntx->repeat_index;
    ptask->repeat.dows = 0;

    if (ptask->repeat.rule == MMI_TDL_RULE_DAYS)
    {
        for (j = 0; j < MMI_TDL_MAX_DAYS_PER_WEEK; j++)
        {
            if (save_cntx->dow_state[j])
            {
#ifdef	__MMI_CALENDAR_FDOW__
                if(mmi_clndr_get_week_first_day())
                {
				    ptask->repeat.dows |= g_mmi_clndr_weekday_index[(j+1)%7];
                }
				else
				{
					 ptask->repeat.dows |= g_mmi_clndr_weekday_index[j];
				}
#else
                ptask->repeat.dows |= g_mmi_clndr_weekday_index[j];
#endif
            }
        }

        /* Reset to once */
        if (ptask->repeat.dows == 0)
        {
            ptask->repeat.rule = MMI_TDL_RULE_ONCE;
        }
    }

    if (mmi_ucs2strlen((CHAR*)save_cntx->subject) == 0)
    {
        memcpy((CHAR*)(ptask->subject), GetString(STR_ID_TDL_NO_CONTENT), SRV_TDL_SUBJECT_SIZE - 1);
    }
    else
    {
        /* Subject */                
        mmi_ucs2ncpy((CHAR*)ptask->subject, (CHAR*)save_cntx->subject, SRV_TDL_SUBJECT_SIZE - 1);
    }
    
    /* Details */                
    mmi_ucs2ncpy((CHAR*)ptask->details, (CHAR*)save_cntx->detail, SRV_TDL_DETAILS_SIZE - 1);
    
MMI_ERROR_CLEAN:
    MMI_TDL_UTIL_TRACE1(MMI_TDL_DATA_TASK_SAVE_PREPARE, result);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_task_edit_screen
 * DESCRIPTION
 *  Display task screen when TDL alarm expires.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_task_edit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_tdl_view_group_data_struct *view_group_cntx;
    mmi_id sg_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    view_group_cntx = (mmi_tdl_view_group_data_struct*)mmi_frm_group_get_user_data(GRP_ID_TDL_VIEW);
        
    sg_id = cui_tdl_save_create(view_group_cntx->parent_id);
    cui_tdl_save_set_task(sg_id, &g_tdl_cntx.curr_task);
    cui_tdl_save_set_operation_type(sg_id, MMI_TDL_OP_TYPE_EDIT);
    cui_tdl_save_set_highlight_item(sg_id, CUI_INLINE_ITEM_SUBJECT_TEXT);                
    cui_tdl_save_run(sg_id);
    mmi_frm_group_close(GRP_ID_TDL_VIEW);
}

#endif /* __MMI_TODOLIST__ */
#endif
#endif /* MMI_TODOLIST_UTIL_C */

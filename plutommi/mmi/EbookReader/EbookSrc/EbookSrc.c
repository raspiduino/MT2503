/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * EbookSrc.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
  * Mar 18 2010 mtk80176
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *============================================================================== 
 *******************************************************************************/
#include "MMI_features.h"

#ifdef __MMI_EBOOK_READER__
#ifndef __COSMOS_MMI_PACKAGE__

#ifndef __MMI_SLIM_IMG_RES__
#define __EBOOK_SEARCH_SUPPORT__
#endif
#endif

#include "CommonScreens.h"
#include "USBDeviceGprot.h"
#include "App_str.h"
#include "IndicEngineGprot.h"
#include "LangModuleGProt.h"
#include "Wgui_categories_util.h"
#include "FileMgrCuiGprot.h"
#include "Inlinecuigprot.h"
#include "Menucuigprot.h"
#include "Fseditorcuigprot.h"
//#include "EbookDefs.h"
#include "ebrsrvgprot.h"
#include "EbookSrc.h"
#include "EbookGprot.h"
#include "EbookProt.h"
#include "mmi_rp_app_ebook_def.h"
#include "MMIDataType.h"
#include "MMI_common_app_trc.h"
#include "mmi_common_app_trc.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "GlobalResDef.h"
#include "CommonScreensResDef.h"
#include "AlertScreen.h"
#include "kal_general_types.h"
#include "nvram_common_defs.h"
#include "mmi_frm_nvram_gprot.h"
#include "fs_type.h"
#include "fs_func.h"
#include "FileMgrSrvGProt.h"
#include "fs_errcode.h"
#include "mmi_frm_scenario_gprot.h"
#include "CustDataRes.h"
#include "mmi_frm_events_gprot.h"
#include "GlobalConstants.h"
#include "Unicodexdcl.h"
#include "wgui_categories_list.h"
#include "wgui_inputs.h"
#include "string.h"
#include "gui_data_types.h"
#include "Conversions.h"
#include "kal_public_api.h"
#include "wgui_categories_text_viewer.h"
#include "gui_effect_oem.h"
#include "wgui_categories_popup.h"
#include "custom_events_notify.h"
#include "stdlib.h"
#include "stack_msgs.h"
#include "UcmSrvGprot.h"
#include "ImeGprot.h"
#include "gpiosrvgprot.h"
#include "wgui_categories_inputs.h"
#include "mmi_frm_queue_gprot.h"
#include "app_ltlcom.h"
#include "stack_config.h"
#include "stack_ltlcom.h"
#include "mmi_frm_input_gprot.h"
#include "mmi_rp_file_type_def.h"
#include "gdi_include.h"
#include "NotificationGprot.h"
#include "gui_inputs.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_common_app_trc.h"
#include "TimerEvents.h"
#include "mmi_frm_timer_gprot.h"
#include "wgui_categories.h"
#include "wgui_touch_screen.h"
#include "fs_gprot.h"
#include "wgui_draw_manager.h"
#ifdef __COSMOS_MMI_PACKAGE__

#include "vapp_fmgr_cui_gprot.h"
#include "common_nvram_editor_data_item.h"
#include "ImeGprot.h"
#include "imc.h"
#endif


extern void mmi_ebr_app_entry_async_open_book(void);
extern void fs_async_msg_handler(local_para_struct *local_para);

mmi_ebr_app_book_info g_fmgr_highlight_book_info;
mmi_ebr_app_context *g_ebr_app_context_array_p = NULL ;
static S32 g_ebr_app_memory_malloc_count = 0;
S32 g_ebr_app_enter_from_fmgr = 0;
#ifdef __COSMOS_MMI_PACKAGE__
static mmi_id inline_id = GRP_ID_INVALID;
static MMI_BOOL ebook_app_flag = MMI_FALSE;
#endif

typedef enum
{
    MMI_EBR_SETTING_FONT_SIZE_CAPTION_ID = (CUI_INLINE_ITEM_ID_BASE + 0),
    MMI_EBR_SETTING_FONT_SIZE_SELECT_ID,
    MMI_EBR_SETTING_SCROLL_BY_CAPTION_ID,
    MMI_EBR_SETTING_SCROLL_BY_SELECT_ID,
    MMI_EBR_SETTING_SCROLL_SPEED_CAPTION_ID,
    MMI_EBR_SETTING_SCROLL_SPEED_SELECT_ID,
    MMI_EBR_SETTING_STORAGE_CAPTION_ID,
    MMI_EBR_SETTING_STORAGE_DISPLAY_ID,    
    MMI_EBR_SETTING_ITEMS_NUM_TOTAL = (MMI_EBR_SETTING_STORAGE_DISPLAY_ID + 1 - CUI_INLINE_ITEM_ID_BASE),
}mmi_ebr_bookshelf_setting_items_enum;

#define MMI_EBR_JUMP_TO_INPUT_LINE_CAPTION_ID    (CUI_INLINE_ITEM_ID_BASE + 16)
#define MMI_EBR_JUMP_TO_INPUT_LINE_EDITOR_ID     (CUI_INLINE_ITEM_ID_BASE + 17)
#define MMI_EBR_JUMP_TO_TOTAL_LINE_CAPTION_ID    (CUI_INLINE_ITEM_ID_BASE + 18)
#define MMI_EBR_JUMP_TO_TOTAL_LINE_DISPLAY_ID    (CUI_INLINE_ITEM_ID_BASE + 19)

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_bookshelf_proc
 * DESCRIPTION
 *  The procedure for entrying bookshelf screen
 * PARAMETERS
 *  p_event  [IN] The event sent by filemanager cui
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
#ifdef __COSMOS_MMI_PACKAGE__
MMI_BOOL EbookAppEnterFlag(void)
{
    return ebook_app_flag;

}
U8 flag_vk = 0;
void mmi_ebr_open_add_bmlistedit_proc(void)
{
    cui_fseditor_close(g_ebr_app_context_array_p->add_bookmark_fseditor_id);
}
static mmi_ret mmi_ebr_open_add_bmlist_proc_test(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    U8 key_code = key_evt->key_code;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((key_evt->evt_id == EVT_ID_PRE_KEY) 
          && (key_evt->key_type == KEY_EVENT_DOWN) 
          && (key_code == KEY_BACK))
    {
       if(mmi_imc_get_ui_style(MMI_IMC_UI_STYLE_VK_ON) && !mmi_imc_is_vk_disabled())
       {
         flag_vk = 1;
       }
       else
       {
         flag_vk = 0; 
       }

    }

    return MMI_RET_OK;

}

void mmi_ebr_open_add_bmlist_proc(void)
{

  // cui_fseditor_close(g_ebr_app_context_array_p->add_bookmark_fseditor_id);
	if(flag_vk)
    {
	    execute_softkey_function(1, MMI_RIGHT_SOFTKEY);
	    SetKeyHandler(mmi_ebr_open_add_bmlistedit_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
    }
    else
    {
        mmi_ebr_open_add_bmlistedit_proc();

    }
}
#endif 
mmi_ret mmi_ebr_entry_bookshelf_proc(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTR_BOOKSHELF_PROC, p_event->evt_id);
    switch (p_event->evt_id)
    {
    #ifdef __COSMOS_MMI_PACKAGE__
        case EVT_ID_VCUI_FOLDER_BROWSER_LAUNCH_QUIT:
        {
            mmi_frm_group_close(GRP_ID_EBOOK_BOOKSHELF);
                ebook_app_flag = MMI_FALSE;
            break;
        }
    #endif
        case EVT_ID_CUI_FOLDER_BROWSER_ON_ENTRY:
        {
            break;
        }
		case EVT_ID_CUI_FOLDER_BROWSER_ON_EXIT:
        {
            break;
        }
		case EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT:
        {
            mmi_ebr_app_bookshelf_handle_cui_folder_browser_on_quit_message((cui_folder_browser_on_quit_event_struct*)p_event);         
            break;
        }
		case EVT_ID_CUI_FOLDER_BROWSER_ON_EMPTY:
        {
            break;
        }
		case EVT_ID_CUI_FOLDER_BROWSER_ON_MENU:
        {
            break;
        }
        #ifdef __COSMOS_MMI_PACKAGE__
        case EVT_ID_VCUI_FILE_SELECTOR_RESULT:
        {
            /*user selected a file*/
            mmi_ebr_open_lsk_hdlr();
            break; 
        }
        #else
        case EVT_ID_CUI_STORAGE_SELECTOR_RESULT:
        {
            mmi_ebr_app_bookshelf_handle_cui_storage_selector_result_message((cui_storage_selector_result_event_struct*)p_event);
            break;
        }
        #endif
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            mmi_ebr_app_bookshelf_handle_cui_inline_submit_message((cui_event_inline_submit_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_ABORT:
        {
            mmi_ebr_app_bookshelf_handle_cui_inline_abort_message((cui_event_inline_abort_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_CSK_PRESS:
        {
			mmi_ebr_app_bookshelf_handle_cui_inline_submit_message((cui_event_inline_submit_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_SET_KEY:
        {
            break;
        }
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            mmi_ebr_app_bookshelf_handle_cui_inline_notify_message((cui_event_inline_notify_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
        {
            mmi_ebr_app_bookshelf_handle_cui_inline_screen_active_message((cui_event_inline_common_struct*)p_event);
            break;
        }
        case EVT_ID_GROUP_DEINIT:
        {
#ifdef __COSMOS_MMI_PACKAGE__
             ebook_app_flag = MMI_FALSE;
#endif
            mmi_ebr_app_bookshelf_handle_cui_group_deinit_message(p_event);
            break;
        }
        case EVT_ID_ALERT_QUIT:
        {
            mmi_ebr_app_bookshelf_handle_alert_quit_message((mmi_alert_result_evt_struct*)p_event);
            break;
        }
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_check_bookshelf_storage_status
 * DESCRIPTION
 *  Check whether the ebook bookshelf's storage's status is OK 
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ebr_app_check_bookshelf_storage_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    mmi_ebr_app_setting_struct setting;
    MMI_BOOL storage_status = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    
    /* Initialize the drive value in eBook nvram */
    if (0x01 == setting.bookshelf_setting.memory_type)
    {
        setting.bookshelf_setting.memory_type = (CHAR)SRV_FMGR_PUBLIC_DRV;
        WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    }
    if (!srv_fmgr_drv_is_valid(setting.bookshelf_setting.memory_type) || 
        (FS_GetDevStatus(setting.bookshelf_setting.memory_type, FS_MOUNT_STATE_ENUM) != FS_NO_ERROR) ||
        (FS_GetDevStatus(setting.bookshelf_setting.memory_type, FS_FEATURE_STATE_ENUM) == FS_DEVICE_BUSY))
    {
        storage_status = MMI_FALSE;
    }
    else
    {
        storage_status = MMI_TRUE;
    }

    return storage_status;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_folder_browser_on_quit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT
 * PARAMETERS
 *  p_quit_event  [IN] The EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_folder_browser_on_quit_message(cui_folder_browser_on_quit_event_struct *p_quit_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_FOLDER_BROWSER_QUIT);
    mmi_frm_scrn_close(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_BOOKSHELF_SCREENID);
    #ifdef __COSMOS_MMI_PACKAGE__    
    vcui_folder_browser_close_by_custom(p_quit_event->sender_id);
    #else
    cui_folder_browser_close(p_quit_event->sender_id);
    #endif
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_storage_selector_result_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_STORAGE_SELECTOR_RESULT
 * PARAMETERS
 *  p_select_result_event  [IN] The EVT_ID_CUI_STORAGE_SELECTOR_RESULT event structure
 * RETURNS
 *  void
 *****************************************************************************/
  #ifndef __COSMOS_MMI_PACKAGE__
void mmi_ebr_app_bookshelf_handle_cui_storage_selector_result_message(cui_storage_selector_result_event_struct *p_select_result_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_setting_struct nvram_setting;
    S16 error = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_STORAGE_SELECT_RESULT, p_select_result_event->result, g_ebr_app_context_array_p->bookshelf_setting_id);
    if (p_select_result_event->result > 0)
    {
        g_ebr_app_context_array_p->select_bookshelf_drive = (CHAR)p_select_result_event->result;
        
        /* it is not selected from bookshelf setting */
        if (GRP_ID_INVALID == g_ebr_app_context_array_p->bookshelf_setting_id)
        {
            ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)(&nvram_setting), NVRAM_EF_EBOOK_SETTING_SIZE, &error);
            nvram_setting.bookshelf_setting.memory_type = g_ebr_app_context_array_p->select_bookshelf_drive;
            WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)(&nvram_setting), NVRAM_EF_EBOOK_SETTING_SIZE, &error);     
            mmi_ebr_app_entry_bookshelf();
        }
    }
    cui_storage_selector_close(p_select_result_event->sender_id);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_inline_submit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_SUBMIT
 * PARAMETERS
 *  p_submit_event  [IN] The EVT_ID_CUI_INLINE_SUBMIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_inline_submit_message(cui_event_inline_submit_struct *p_submit_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_popup_property_struct popup_struct;
    mmi_confirm_property_struct confirm_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_INLINE_SUBMIT, p_submit_event->item_id);
    /* Process the global setting operation */
    if ((p_submit_event->item_id >= MMI_EBR_SETTING_FONT_SIZE_CAPTION_ID) &&
        (p_submit_event->item_id <= MMI_EBR_SETTING_STORAGE_DISPLAY_ID))
    {
		if (MMI_FALSE == mmi_ebr_app_check_drive_status(g_ebr_app_context_array_p->select_bookshelf_drive))
		{
			mmi_popup_property_init(&popup_struct);
            popup_struct.callback = mmi_ebr_app_bookshelf_list_storage_popup_callback;
            popup_struct.user_tag = (void*)MMI_EBR_POPUPCALLBACK_TAG_LIST_STORAGE;
	        mmi_popup_display(
                (WCHAR*)GetString(STR_GLOBAL_MC_REMOVED), 
                MMI_EVENT_FAILURE, 
                &popup_struct);
			return;
		}
		mmi_ebr_app_save_bookshelf_setting_confirm_lsk_handler();
/*
        mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
        confirm_struct.parent_id = GRP_ID_EBOOK_BOOKSHELF;
        confirm_struct.user_tag = (void*)MMI_EBR_BOOKSHELF_ALERT_TYPE_BOOKSHELF_SETTING;
        mmi_confirm_display(
            (WCHAR*)GetString(STR_CONFIRM_SAVE_SETTINGS), 
            MMI_EVENT_QUERY, 
            &confirm_struct); */
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_inline_abort_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_ABORT
 * PARAMETERS
 *  p_abort_event  [IN] The EVT_ID_CUI_INLINE_ABORT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_inline_abort_message(cui_event_inline_abort_struct *p_abort_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_INLINE_ABORT, p_abort_event->sender_id, g_ebr_app_context_array_p->bookshelf_setting_id);
    cui_inline_close(p_abort_event->sender_id);
    if (g_ebr_app_context_array_p->bookshelf_setting_id == p_abort_event->sender_id)
    {
        g_ebr_app_context_array_p->bookshelf_setting_id = GRP_ID_INVALID;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_inline_notify_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_NOTIFY
 * PARAMETERS
 *  p_quit_event  [IN] The EVT_ID_CUI_INLINE_NOTIFY event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_inline_notify_message(cui_event_inline_notify_struct *p_notify_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_INLINE_NOTIFY, p_notify_event->event_type, p_notify_event->item_id);
    if (CUI_INLINE_NOTIFY_HIGHLIGHT_ITEM == p_notify_event->event_type)
    {
        if (MMI_EBR_SETTING_STORAGE_DISPLAY_ID == p_notify_event->item_id)
        {
            cui_inline_set_softkey_text(p_notify_event->sender_id, 
                            MMI_EBR_SETTING_STORAGE_DISPLAY_ID, 
                            MMI_LEFT_SOFTKEY, 
                            STR_GLOBAL_SELECT);
			wgui_inline_set_lsk_function(mmi_ebr_entry_select_drive);
            EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
            SetCenterSoftkeyFunction(mmi_ebr_entry_select_drive, KEY_EVENT_UP);
        }
        else
        {
            EnableCenterSoftkey(0, 0);
        }
    }
    
    if (CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED == p_notify_event->event_type)
    {
        switch (p_notify_event->item_id)
        {
            case MMI_EBR_SETTING_FONT_SIZE_SELECT_ID:
            {
                g_ebr_app_context_array_p->select_setting_value.inlineHighligtItemFontSize = p_notify_event->param;
                break;
            }
            case MMI_EBR_SETTING_SCROLL_BY_SELECT_ID:
            {
                g_ebr_app_context_array_p->select_setting_value.inlineHighligtItemScrollBy = p_notify_event->param;
                break;
            }
            case MMI_EBR_SETTING_SCROLL_SPEED_SELECT_ID:
            {
                g_ebr_app_context_array_p->select_setting_value.inlineHighligtItemScrollSpeed = p_notify_event->param;
                break;
            }
            default:
            {
                break;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_inline_screen_active_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_inline_screen_active_message(cui_event_inline_common_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 drive_list[SRV_FMGR_DRV_TOTAL];
    S32 drive_count = 0;
    CHAR drive = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    drive_count = mmi_ebr_app_get_storage_number(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE, drive_list, SRV_FMGR_DRV_TOTAL);

    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_INLINE_SCREEN_ACTIVE, drive_count, g_ebr_app_context_array_p->select_bookshelf_drive, g_ebr_app_context_array_p->bookshelf_path[0]);
    if (drive_count > 1)
    { 
        drive = g_ebr_app_context_array_p->select_bookshelf_drive;
        
        cui_inline_set_value(p_event->sender_id, MMI_EBR_SETTING_STORAGE_DISPLAY_ID, GetString(srv_fmgr_drv_get_string((U8)drive)));
        if (g_ebr_app_context_array_p->bookshelf_path[0] != drive)
        {
            cui_inline_set_screen_attributes(p_event->sender_id, CUI_INLINE_SET_ATTRIBUTE, CUI_INLINE_SCREEN_CHANGED);
        }
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_mem_success_callback
 * DESCRIPTION
 *  ebook app mem callback function, it is called after
 *  succeed allocating memory
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void mmi_ebr_app_mem_success_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	srv_fmgr_fileinfo_struct file_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_ebr_app_enter_from_fmgr)
	{
		file_info.size = g_fmgr_highlight_book_info.book_size;
		if(sizeof(g_fmgr_highlight_book_info.book_name))
		{
		    mmi_fmgr_ebook_option_hdlr(MENU_ID_FMGR_EBOOK_OPTION_OPEN_NEW,
			                       g_fmgr_highlight_book_info.book_name,
			                       &file_info);
		}
		else
		{
			mmi_popup_display_simple(
	            (WCHAR*)GetString(STR_GLOBAL_ERROR), 
	            MMI_EVENT_FAILURE, 
	            GRP_ID_ROOT, 
	            0);
		}
	}
	else
	{
		mmi_ebr_pre_entry_book_shel_screen();
	}
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_alloc_buffer
 * DESCRIPTION
 *  alloc ASM buffer 40K for ebook to use
 * PARAMETERS
 *  MMI_TRUE: enter form FMGR
 *  MMI_FALSE: enter from ebook reader
 * RETURNS
 *  MMI_TRUE: alloc success
 *  MMI_FALSE: ASM buffer not enough, need release other app's mem 
 *****************************************************************************/

static MMI_BOOL mmi_ebr_alloc_buffer(MMI_BOOL enter_from_fmgr)
{
    /* allocate memory from App-Based ASM */
//	ASSERT(!g_ebr_app_context_array_p);
	
    if (g_ebr_app_context_array_p == NULL)
    {
        g_ebr_app_context_array_p
            = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_EBOOK, MMI_EBOOK_APP_MEM_SIZE);

        if (g_ebr_app_context_array_p == NULL)
        {
			
			if(!enter_from_fmgr) // enety from ebook reader
			{
				g_ebr_app_enter_from_fmgr = 0;
			}
			else                 // entry from fmgr
			{
				g_ebr_app_enter_from_fmgr = 1;
			}
            mmi_frm_appmem_prompt_to_release_mem(
	            APPLIB_MEM_AP_ID_EBOOK,
	            IMG_GLOBAL_OK,
	            MMI_EBOOK_APP_MEM_SIZE,
	            mmi_ebr_app_mem_success_callback);
            return MMI_FALSE;
        }
    }	
    mmi_ebr_app_init();
    srv_ebr_bookshelf_init();
	srv_ebr_book_init();
    return MMI_TRUE;
}


static void mmi_ebr_free_buffer(void)
{
	if(g_ebr_app_context_array_p != NULL)
	{
	    applib_mem_ap_free(g_ebr_app_context_array_p);
	    g_ebr_app_context_array_p = NULL;
	}
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_cui_group_deinit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_GROUP_DEINIT
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_GROUP_DEINIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_cui_group_deinit_message(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_BOOKSHELF_GROUP_DEINIT, g_ebr_app_context_array_p->bookshelf_id);
    if (g_ebr_app_context_array_p->bookshelf_id >= 0)
    {
        srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id);
        g_ebr_app_context_array_p->bookshelf_id = -1;
    }

	mmi_ebr_free_buffer();
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_handle_alert_quit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_ALERT_QUIT
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_ALERT_QUIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_bookshelf_handle_alert_quit_message(mmi_alert_result_evt_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 user_tag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/            
    user_tag = (U32)(p_event->user_tag);
    switch ((mmi_ebr_bookshelf_alert_type_enum)user_tag)
    {
        case MMI_EBR_BOOKSHELF_ALERT_TYPE_DELETE_BOOK:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_entry_delete_ebook();
            }
            break;
        }
        case MMI_EBR_BOOKSHELF_ALERT_TYPE_BOOKSHELF_SETTING:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_app_save_bookshelf_setting_confirm_lsk_handler();
            }
            else if (MMI_ALERT_CNFM_NO == p_event->result)
            {
                mmi_ebr_app_save_bookshelf_setting_confirm_rsk_handler();
            }
            break;
        }
        case MMI_EBR_BOOKSHELF_ALERT_TYPE_OPEN_CONVERTING_BOOK:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_entry_book_shelf_lsk_handler();
            }
            else if (MMI_ALERT_CNFM_NO == p_event->result)
            {
                mmi_ebr_entry_book_shelf_rsk_handler();
            }
            break;
        }
        case MMI_EBR_BOOKSHELF_ALERT_TYPE_MEMORY_CARD_REMOVE_USE_PHONE:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_change_storage_from_card_to_phone_lsk();
            }
            break;
        }
        default:
        {
            break;
        }
    }
    

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_group_deinit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_GROUP_DEINIT
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_GROUP_DEINIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_group_deinit_message(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_ebr_app_context_array_p->book_id >= 0)
    {
        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
        {
            g_ebr_app_context_array_p->book_id = -1;
            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
            memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
        }
    }
#ifndef __COSMOS_MMI_PACKAGE__   
    if(g_ebr_app_context_array_p->bookshelf_id < 0)
    {
	    mmi_ebr_free_buffer();
    }
#endif
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_menu_list_entry_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_MENU_LIST_ENTRY
 * PARAMETERS
 *  p_menu_event_list_entry  [IN] The EVT_ID_CUI_MENU_LIST_ENTRY event structure
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __COSMOS_MMI_PACKAGE__
void mmi_ebr_option_key_proc(void)//by min 12.19
{
     mmi_id current_gid = mmi_frm_group_get_active_id();
     mmi_frm_group_close(current_gid);
     
}

#endif  
void mmi_ebr_app_open_book_handle_cui_menu_list_entry_message(cui_menu_event_struct *p_menu_event_list_entry)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_MENU_ENTRY, p_menu_event_list_entry->parent_menu_id);
    if (MENU_ID_EBK_OPEN_OPTIONS == p_menu_event_list_entry->parent_menu_id)
    {
        mmi_menu_id option_menu_id_array[] = {                              
              //          MENU_ID_EBK_OPEN_EBOOK_STOP_CONVERTING,
                        MENU_ID_EBK_FULL_SCREEN_ON,
                        MENU_ID_EBK_FULL_SCREEN_OFF,
                    #ifdef __EBOOK_SEARCH_SUPPORT__                       
                        MENU_ID_EBK_FIND,
                        MENU_ID_EBK_FIND_NEXT,
                    #endif /*__EBOOK_SEARCH_SUPPORT__*/                        
                        MENU_ID_EBK_JUMP,
                        MENU_ID_EBK_ADD_BOOKMARK,
                    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
                        MENU_ID_EBK_FTE_BOOKMARK_LIST,
                    #else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
                        MENU_ID_EBK_GOTO_BOOKMARK,
                        MENU_ID_EBK_REMOVE_BOOKMARK,  
                    #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
                        MENU_ID_EBK_AUTO_SCROLL_ON,
                        MENU_ID_EBK_AUTO_SCROLL_OFF,
                        MENU_ID_EBK_CLOSE};
                    
        S32 option_menu_id_array_size = sizeof(option_menu_id_array) / sizeof(mmi_menu_id);
        cui_menu_set_currlist(p_menu_event_list_entry->sender_id, option_menu_id_array_size, option_menu_id_array);
#ifdef __COSMOS_MMI_PACKAGE__
cui_menu_set_currlist_title(p_menu_event_list_entry->sender_id, (UI_string_type)GetString(STR_GLOBAL_OPTIONS), NULL);

#else
        cui_menu_set_currlist_title(p_menu_event_list_entry->sender_id, (UI_string_type)GetString(STR_GLOBAL_OPTIONS), (UI_image_type)GetImage(GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID)));
#endif     
 //       cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_OPEN_EBOOK_STOP_CONVERTING, (WCHAR*)GetString(STR_STOP_CONVERTING));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_ON, (WCHAR*)GetString(STR_FULL_SCREEN_ON));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_OFF, (WCHAR*)GetString(STR_FULL_SCREEN_OFF));      
    #ifdef __EBOOK_SEARCH_SUPPORT__
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FIND, (WCHAR*)GetString(STR_FIND_EBOOK));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FIND_NEXT, (WCHAR*)GetString(STR_FIND_NEXT_EBOOK));
    #endif /*__EBOOK_SEARCH_SUPPORT__*/
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_JUMP, (WCHAR*)GetString(STR_JUMP_EBOOK));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_ADD_BOOKMARK, (WCHAR*)GetString(STR_ADD_BOOKMARK_EBOOK));
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FTE_BOOKMARK_LIST, (WCHAR*)GetString(STR_ID_EBOOK_FTE_BOOKMARK_LIST));
    #else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_GOTO_BOOKMARK, (WCHAR*)GetString(STR_GOTO_BOOKMARK_EBOOK));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_REMOVE_BOOKMARK, (WCHAR*)GetString(STR_RMV_BOOKMARK_EBOOK));                
    #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_ON, (WCHAR*)GetString(STR_AUTO_SCROLL_ON));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_OFF, (WCHAR*)GetString(STR_AUTO_SCROLL_OFF));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_CLOSE, (WCHAR*)GetString(STR_GLOBAL_CLOSE));

        if (MMI_TRUE == g_ebr_app_context_array_p->auto_scroll)
        {
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_ON, MMI_TRUE);
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_OFF, MMI_FALSE);
        }
        else
        {
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_ON, MMI_FALSE);
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_AUTO_SCROLL_OFF, MMI_TRUE);
        }

        if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
        {
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_ON, MMI_TRUE);
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_OFF, MMI_FALSE);
        }
        else
        {
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_ON, MMI_FALSE);
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FULL_SCREEN_OFF, MMI_TRUE);
        }
        
    #ifdef __EBOOK_SEARCH_SUPPORT__
        if (!((mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->search_string)) &&
              (MMI_TRUE != g_ebr_app_context_array_p->auto_scroll)))
        {
            cui_menu_set_item_hidden(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FIND_NEXT, MMI_TRUE);
        }
        cui_menu_set_non_leaf_item(p_menu_event_list_entry->sender_id, MENU_ID_EBK_FIND, MMI_TRUE);
    #endif /*__EBOOK_SEARCH_SUPPORT__*/
    }
#ifdef __EBOOK_SEARCH_SUPPORT__
    if (MENU_ID_EBK_FIND == p_menu_event_list_entry->parent_menu_id)
    {
        mmi_menu_id option_menu_id_array[] = {MENU_ID_EBK_CASE_SENSITIVE, MENU_ID_EBK_CASE_INSENSITIVE};
        S32 option_menu_id_array_size = sizeof(option_menu_id_array) / sizeof(mmi_menu_id);

        cui_menu_set_currlist(p_menu_event_list_entry->sender_id, option_menu_id_array_size, option_menu_id_array);
        cui_menu_set_currlist_title(p_menu_event_list_entry->sender_id, (UI_string_type)GetString(STR_FIND_EBOOK), (UI_image_type)GetImage(GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID)));

        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_CASE_SENSITIVE, (WCHAR*)GetString(STR_SRCH_CASE_EBOOK));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_CASE_INSENSITIVE, (WCHAR*)GetString(STR_SRCH_CASEIN_EBOOK));
    }
#endif /*__EBOOK_SEARCH_SUPPORT__*/

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    if (MENU_ID_EBK_FTE_BOOKMARK_LIST == p_menu_event_list_entry->parent_menu_id)
    {
        mmi_menu_id option_menu_id_array[] = {MENU_ID_EBK_GOTO_BOOKMARK, MENU_ID_EBK_REMOVE_BOOKMARK};
        S32 option_menu_id_array_size = sizeof(option_menu_id_array) / sizeof(mmi_menu_id);

        cui_menu_set_currlist(p_menu_event_list_entry->sender_id, option_menu_id_array_size, option_menu_id_array);
        #ifdef __COSMOS_MMI_PACKAGE__
        cui_menu_set_currlist_title(p_menu_event_list_entry->sender_id, (UI_string_type)GetString(STR_GLOBAL_OPTIONS), NULL);
#else
        cui_menu_set_currlist_title(p_menu_event_list_entry->sender_id, (UI_string_type)GetString(STR_GLOBAL_OPTIONS), (UI_image_type)GetImage(GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID)));

#endif
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_GOTO_BOOKMARK, (WCHAR*)GetString(STR_GOTO_BOOKMARK_EBOOK));
        cui_menu_set_item_string(p_menu_event_list_entry->sender_id, MENU_ID_EBK_REMOVE_BOOKMARK, (WCHAR*)GetString(STR_RMV_BOOKMARK_EBOOK));
    }
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
#ifdef __COSMOS_MMI_PACKAGE__
      //etKeyHandler(mmi_ebr_option_key_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_menu_item_select_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_MENU_ITEM_SELECT
 * PARAMETERS
 *  p_menu_event_item_select  [IN] The EVT_ID_CUI_MENU_ITEM_SELECT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_menu_item_select_message(cui_menu_event_struct *p_menu_event_item_select)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_MENU_SELECT, p_menu_event_item_select->parent_menu_id, p_menu_event_item_select->highlighted_menu_id);
    if (MENU_ID_EBK_OPEN_OPTIONS == p_menu_event_item_select->parent_menu_id)
    {
        switch (p_menu_event_item_select->highlighted_menu_id)
        {

#ifdef  __EBOOK_SEARCH_SUPPORT__
            case MENU_ID_EBK_FIND:
            {
                mmi_ebr_entry_search_string();
                break;
            }
            case MENU_ID_EBK_FIND_NEXT:
            {
                mmi_ebr_app_search_string_next();
                break;
            }
#endif  /*__EBOOK_SEARCH_SUPPORT__*/
            case MENU_ID_EBK_AUTO_SCROLL_ON:
            {
                mmi_ebr_app_toggle_scroll_mode();
                break;
            }
            case MENU_ID_EBK_AUTO_SCROLL_OFF:
            {
                mmi_ebr_app_toggle_scroll_mode();
                break;
            }
            case MENU_ID_EBK_FULL_SCREEN_ON:
            {
                mmi_ebr_app_toggle_screen_mode();
                break;
            }
            case MENU_ID_EBK_FULL_SCREEN_OFF:
            {
                mmi_ebr_app_toggle_screen_mode();
                break;
            }
            case MENU_ID_EBK_JUMP:
            {
                mmi_ebr_entry_jump_to();
                break;
            }
            case MENU_ID_EBK_ADD_BOOKMARK:
            {
                mmi_ebr_entry_add_book_mark();
                break;
            }
       #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
            case MENU_ID_EBK_FTE_BOOKMARK_LIST:
            {
                mmi_ebr_entry_fte_bookmark_list();
                break;
            }
       #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
            case MENU_ID_EBK_GOTO_BOOKMARK:
            {
                mmi_ebr_entry_goto_book_mark();
                break;
            }
            case MENU_ID_EBK_REMOVE_BOOKMARK:
            {
                mmi_ebr_entry_remove_book_mark();
                break;
            }
            case MENU_ID_EBK_CLOSE:
            {
                mmi_ebr_entry_close_book();
                break;
            }
            default:
            {
                break;
            }
        }
    }
#ifdef  __EBOOK_SEARCH_SUPPORT__
    else if (MENU_ID_EBK_FIND == p_menu_event_item_select->parent_menu_id)
    {
        switch (p_menu_event_item_select->highlighted_menu_id)
        {
            case MENU_ID_EBK_CASE_INSENSITIVE:
                g_ebr_app_context_array_p->search_string_type = SRV_EBR_SEARCH_TYPE_CASE_INSENSITIVE;
                break;
                
            case MENU_ID_EBK_CASE_SENSITIVE:
                g_ebr_app_context_array_p->search_string_type = SRV_EBR_SEARCH_TYPE_CASE_SENSITIVE;
                break;
        }
        mmi_ebr_ebook_search_string();
    }
#endif /*__EBOOK_SEARCH_SUPPORT__*/
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    else if (MENU_ID_EBK_FTE_BOOKMARK_LIST == p_menu_event_item_select->parent_menu_id)
    {
        switch (p_menu_event_item_select->highlighted_menu_id)
        {
            case MENU_ID_EBK_GOTO_BOOKMARK:
            {
                mmi_ebr_fte_goto_selected_bookmark(p_menu_event_item_select->sender_id);
                cui_menu_close(p_menu_event_item_select->sender_id);
                break;
            }
            case MENU_ID_EBK_REMOVE_BOOKMARK:
            {
                mmi_ebr_delete_bookmark();
                break;
            }
            default:
            {
                break;
            }
        }
    }
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_menu_close_request_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_MENU_CLOSE_REQUEST
 * PARAMETERS
 *  p_menu_event_list_entry  [IN] The EVT_ID_CUI_MENU_CLOSE_REQUEST event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_menu_close_request_message(cui_menu_event_struct *p_menu_event_close_request)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_MENU_CLOSE, p_menu_event_close_request->sender_id);
    cui_menu_close(p_menu_event_close_request->sender_id);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_fseditor_submit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_FSEDITOR_SUBMMIT
 * PARAMETERS
 *  p_fseditor_submit  [IN] The EVT_ID_CUI_FSEDITOR_SUBMMIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_fseditor_submit_message(cui_fseditor_evt_struct *p_fseditor_submit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_COMMON_TRC_G1_EBOOK, 
        MMI_EBOOK_OPEN_BOOK_FSEDITOR_SUBMIT, 
        p_fseditor_submit->sender_id, 
        g_ebr_app_context_array_p->search_fseditor_id,
        g_ebr_app_context_array_p->add_bookmark_fseditor_id);
 #ifdef  __EBOOK_SEARCH_SUPPORT__   
    if (p_fseditor_submit->sender_id == g_ebr_app_context_array_p->search_fseditor_id)
    {
		if (cui_fseditor_get_text_len(p_fseditor_submit->sender_id) == 0)
		{
			mmi_popup_display_simple(
                (WCHAR*)GetString(STR_GLOBAL_EMPTY), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_OPEN_BOOK, 
                0);  
			return;
		}
        cui_fseditor_get_text(
            p_fseditor_submit->sender_id, 
            (WCHAR*)g_ebr_app_context_array_p->search_string, 
            sizeof(g_ebr_app_context_array_p->search_string));
        mmi_ebr_app_search_string();
        cui_fseditor_close(g_ebr_app_context_array_p->search_fseditor_id);
    }
#endif    
    if (p_fseditor_submit->sender_id == g_ebr_app_context_array_p->add_bookmark_fseditor_id)
    {
		if (cui_fseditor_get_text_len(p_fseditor_submit->sender_id) == 0)
		{
			mmi_popup_display_simple(
                (WCHAR*)GetString(STR_GLOBAL_EMPTY), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_OPEN_BOOK, 
                0);  
			return;
		} 
        cui_fseditor_get_text(
            p_fseditor_submit->sender_id, 
            (WCHAR*)g_ebr_app_context_array_p->input_bookmark_name, 
            sizeof(g_ebr_app_context_array_p->input_bookmark_name));
        mmi_ebr_app_add_bookmark();
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_fseditor_abort_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_FSEDITOR_ABORT
 * PARAMETERS
 *  p_fseditor_submit  [IN] The EVT_ID_CUI_FSEDITOR_ABORT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_fseditor_abort_message(cui_fseditor_evt_struct *p_fseditor_abort)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_COMMON_TRC_G1_EBOOK, 
        MMI_EBOOK_OPEN_BOOK_FSEDITOR_ABORT, 
        p_fseditor_abort->sender_id, 
        g_ebr_app_context_array_p->search_fseditor_id,
        g_ebr_app_context_array_p->add_bookmark_fseditor_id);
#ifdef __EBOOK_SEARCH_SUPPORT__
    if (p_fseditor_abort->sender_id == g_ebr_app_context_array_p->search_fseditor_id)
    {
        cui_fseditor_close(g_ebr_app_context_array_p->search_fseditor_id);
    }
#endif
    if (p_fseditor_abort->sender_id == g_ebr_app_context_array_p->add_bookmark_fseditor_id)
    {
        cui_fseditor_close(g_ebr_app_context_array_p->add_bookmark_fseditor_id);      
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_inline_submit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_SUBMIT
 * PARAMETERS
 *  p_inline_submit  [IN] The EVT_ID_CUI_INLINE_SUBMIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_inline_submit_message(cui_event_inline_submit_struct *p_inline_submit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_INLINE_SUBMIT, p_inline_submit->item_id);
    /* Processing the jump to operation */
    if ((p_inline_submit->item_id >= MMI_EBR_JUMP_TO_INPUT_LINE_CAPTION_ID) &&
        (p_inline_submit->item_id <= MMI_EBR_JUMP_TO_TOTAL_LINE_DISPLAY_ID))
    {
        cui_inline_get_value(p_inline_submit->sender_id, MMI_EBR_JUMP_TO_INPUT_LINE_EDITOR_ID, g_ebr_app_context_array_p->jump_input_line);
        mmi_ebr_app_jump_to_special_line();
        cui_inline_close(p_inline_submit->sender_id);
        goto end;
    }
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_cui_inline_abort_message
 * DESCRIPTION
 *  The handle function of EVT_ID_CUI_INLINE_ABORT
 * PARAMETERS
 *  p_inline_abort  [IN] The EVT_ID_CUI_INLINE_ABORT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_cui_inline_abort_message(cui_event_inline_abort_struct *p_inline_abort)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_INLINE_ABORT, p_inline_abort->sender_id, p_inline_abort->item_id);
    cui_inline_close(p_inline_abort->sender_id);
    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_handle_alert_quit_message
 * DESCRIPTION
 *  The handle function of EVT_ID_ALERT_QUIT
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_ALERT_QUIT event structure
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_open_book_handle_alert_quit_message(mmi_alert_result_evt_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 user_tag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/            
    user_tag = (U32)(p_event->user_tag);
    switch ((mmi_ebr_book_alert_type_enum)user_tag)
    {
        case MMI_EBR_BOOK_ALERT_TYPE_DELETE_BOOKMARK:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_remove_selected_bookmark();
            }
            break;
        }
        case MMI_EBR_BOOK_ALERT_TYPE_DUPLICATED_BOOKMARK:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_entry_duplicate_book_mark_add();
                cui_fseditor_close(g_ebr_app_context_array_p->add_bookmark_fseditor_id);
            }
            break;
        }
        case MMI_EBR_BOOK_ALERT_TYPE_STOP_CONVERTING_EBOOK:
        {
            if (MMI_ALERT_CNFM_YES == p_event->result)
            {
                mmi_ebr_app_stop_converting_confirm_lsk_handler();
            }
            else if (MMI_ALERT_CNFM_NO == p_event->result)
            {
                mmi_ebr_app_stop_converting_confirm_rsk_handler();
            }
            break;
        }
        default:
        {
            break;
        }
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_open_book_proc
 * DESCRIPTION
 *  The procedure for entrying open book screen
 * PARAMETERS
 *  p_event  [IN] The event sent by framework
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_entry_open_book_proc(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_PROC, p_event->evt_id);
    switch (p_event->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            mmi_ebr_app_open_book_handle_cui_group_deinit_message(p_event);
            break;
        }
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {        
            mmi_ebr_app_open_book_handle_cui_menu_list_entry_message((cui_menu_event_struct*)p_event);   
            break;
        }
        case EVT_ID_CUI_MENU_LIST_EXIT:
        {
            break;
        }
        case EVT_ID_CUI_MENU_ITEM_HILITE:
        {
            break;
        }
        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            mmi_ebr_app_open_book_handle_cui_menu_item_select_message((cui_menu_event_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
        {
            mmi_ebr_app_open_book_handle_cui_menu_close_request_message((cui_menu_event_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_FSEDITOR_SUBMMIT:
        {
            mmi_ebr_app_open_book_handle_cui_fseditor_submit_message((cui_fseditor_evt_struct*)p_event);       
            break;
        }
        case EVT_ID_CUI_FSEDITOR_ABORT:
        {
            mmi_ebr_app_open_book_handle_cui_fseditor_abort_message((cui_fseditor_evt_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            mmi_ebr_app_open_book_handle_cui_inline_submit_message((cui_event_inline_submit_struct*)p_event);
            break;
        }
        case EVT_ID_CUI_INLINE_ABORT:
        {
            mmi_ebr_app_open_book_handle_cui_inline_abort_message((cui_event_inline_abort_struct*)p_event);         
            break;
        }
        case EVT_ID_CUI_INLINE_CSK_PRESS:
        {
            break;
        }
        case EVT_ID_CUI_INLINE_SET_KEY:
        {
            break;
        }
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            break;
        }
        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
        {
            break;
        }
        case EVT_ID_ALERT_QUIT:
        {
            mmi_ebr_app_open_book_handle_alert_quit_message((mmi_alert_result_evt_struct*)p_event);
            break;
        }
		 #ifdef __COSMOS_MMI_PACKAGE__
        case EVT_ID_CUI_FSEDITOR_SET_KEY:
        {

//SetKeyHandler(mmi_ebr_open_add_bmlist_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
//           MMI_CAT_SET_KEY_PROC(mmi_ebr_open_add_bmlist_proc_test,NULL);

            break;
        }
		#endif 
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_init_setting_select_value
 * DESCRIPTION
 *  Initialize the setting's value
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_init_setting_select_value(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_inline_const_string_cntx *p_select_setting_caption = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_select_setting_caption = &g_ebr_app_context_array_p->select_setting_caption;

    /* fill in the font size value */
    p_select_setting_caption->ebook_settings_font_size[EBR_FONT_SIZE_SMALL] = STR_SETTINGS_FONT_SIZE_SMALL;
    p_select_setting_caption->ebook_settings_font_size[EBR_FONT_SIZE_MEDIUM] = STR_GLOBAL_MEDIUM;
    p_select_setting_caption->ebook_settings_font_size[EBR_FONT_SIZE_LARGE] = STR_SETTINGS_FONT_SIZE_LARGE;

    /* fill in the scroll by value */
    p_select_setting_caption->ebook_settings_scroll_by[EBR_SCROLL_BY_LINE] = STR_SETTINGS_SCROLL_BY_LINE;
    p_select_setting_caption->ebook_settings_scroll_by[EBR_SCROLL_BY_PAGE] = STR_SETTINGS_SCROLL_BY_PAGE;

    /* fill in the scroll speed value */
    p_select_setting_caption->ebook_settinsg_auto_scroll_speed[EBR_AUTO_SCROLL_SPEED_1] =
        STR_SETTINGS_AUTO_SCROLL_SPEED_1;
    p_select_setting_caption->ebook_settinsg_auto_scroll_speed[EBR_AUTO_SCROLL_SPEED_2] =
        STR_SETTINGS_AUTO_SCROLL_SPEED_2;
    p_select_setting_caption->ebook_settinsg_auto_scroll_speed[EBR_AUTO_SCROLL_SPEED_3] =
        STR_SETTINGS_AUTO_SCROLL_SPEED_3;
    p_select_setting_caption->ebook_settinsg_auto_scroll_speed[EBR_AUTO_SCROLL_SPEED_4] =
        STR_SETTINGS_AUTO_SCROLL_SPEED_4;
    p_select_setting_caption->ebook_settinsg_auto_scroll_speed[EBR_AUTO_SCROLL_SPEED_5] =
        STR_SETTINGS_AUTO_SCROLL_SPEED_5;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_book_info_proc
 * DESCRIPTION
 *  The procedure for entrying open book info screen
 * PARAMETERS
 *  p_event  [IN] The event sent by framework
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_entry_book_info_proc(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (p_event->evt_id)
    {
        case EVT_ID_SCRN_DEINIT:
        {
            if (NULL != g_ebr_app_context_array_p->book_info_buffer)
            {
                mmi_ebr_app_free_memory((void **)&g_ebr_app_context_array_p->book_info_buffer);
            }
            break;
        }
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_book_info
 * DESCRIPTION
 *  Entry function for book information screen
 * PARAMETERS
 *  p_screen_data  [IN] The content of screen
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_book_info(mmi_scrn_essential_struct *p_screen_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define  EBR_DISPLAY_INFO_DATA  20
#define  EBR_DISPLAY_INFO_SIZE  (600)
    U8 *guiBuffer = NULL;
    WCHAR book_size[EBR_DISPLAY_INFO_DATA];
    S32 file_size, total_size;
    WCHAR *ext = NULL;
    WCHAR type_info[EBR_DISPLAY_INFO_DATA];
    WCHAR tmp_path_buf[(SRV_EBR_MAX_FILE_LEN + 1)];
    mmi_ebr_app_book_info *p_book_info = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == mmi_frm_scrn_enter(
                    p_screen_data->group_id, 
                    p_screen_data->scrn_id, 
                    NULL, 
                    (FuncPtr)mmi_ebr_app_entry_book_info, 
                    MMI_FRM_FULL_SCRN))
    {
        mmi_frm_scrn_set_leave_proc(p_screen_data->group_id, p_screen_data->scrn_id, mmi_ebr_app_entry_book_info_proc);
        guiBuffer = mmi_frm_scrn_get_active_gui_buf();

        p_book_info = &g_ebr_app_context_array_p->highlight_book_info;
        
        mmi_wcscpy(tmp_path_buf, p_book_info->book_name);
         
        ext = srv_fmgr_path_get_extension_ptr(tmp_path_buf);
        if (ext)
        {
            memset(type_info, 0x00, sizeof(type_info));
            mmi_wcscpy(type_info, ext);
            
            ext -= 1;
            ext[0] = 0;
        }
        
        if (NULL == g_ebr_app_context_array_p->book_info_buffer)
        {
            g_ebr_app_context_array_p->book_info_buffer = mmi_ebr_app_malloc_memory(EBR_DISPLAY_INFO_SIZE);
        }

        total_size = p_book_info->book_size;
            
        if (total_size > 1024 * 1024)
        {
            file_size = total_size / 1024;
            kal_wsprintf(book_size, "%d.%dM", (U16)(file_size / 1024), (U16)((file_size % 1024) / 103));
        }
        else if (total_size > 1024)
        {
            kal_wsprintf(book_size, "%d.%dK", (U16)(total_size / 1024), (U16)((total_size % 1024) / 103));            
        }
        else    /* less than 1024 */
        {
            kal_wsprintf(book_size, "%dB", (U16)(total_size));            
        }

        kal_wsprintf(
            g_ebr_app_context_array_p->book_info_buffer, 
            "%w %w\n%w %w\n%w %w",
            (WCHAR*)get_string(STR_EBOOK_BOOK_INFO_TITLE),
            tmp_path_buf,
            (WCHAR*)get_string(STR_EBOOK_BOOK_INFO_SIZE),
            book_size,
            (WCHAR*)get_string(STR_EBOOK_BOOK_INFO_FORMAT),
            type_info);
#ifdef __COSMOS_MMI_PACKAGE__

        ShowCategory74Screen(
            STR_INFO_EBOOK,
            NULL,
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*)g_ebr_app_context_array_p->book_info_buffer,
            mmi_wcslen((const WCHAR*)g_ebr_app_context_array_p->book_info_buffer),
            guiBuffer);
#else
        ShowCategory74Screen(
            STR_INFO_EBOOK,
            GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID),
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*)g_ebr_app_context_array_p->book_info_buffer,
            mmi_wcslen((const WCHAR*)g_ebr_app_context_array_p->book_info_buffer),
            guiBuffer);

#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_help_screen
 * DESCRIPTION
 *  Entry function for help screen
 * PARAMETERS
 *  p_screen_data  [IN] The content of screen
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_help_screen(mmi_scrn_essential_struct *p_screen_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    WCHAR *p_string = NULL;
    S32 string_length = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        p_screen_data->group_id, 
                        p_screen_data->scrn_id,
                        NULL,
                        (FuncPtr)mmi_ebr_app_entry_help_screen,
                        MMI_FRM_FULL_SCRN))
    {
#ifdef __EBOOK_SEARCH_SUPPORT__
        p_string = (WCHAR*)GetString(STR_EBOOK_TOUCH_SCREEN_HELP);
#else
        p_string = (WCHAR*)GetString(STR_EBOOK_TOUCH_SCREEN_HELP_NO_FIND);
#endif
        string_length = mmi_ucs2strlen((const CHAR*)p_string);
#ifdef __COSMOS_MMI_PACKAGE__
        ShowCategory74Screen(
            STR_GLOBAL_HELP,
            NULL,
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*)p_string,
            string_length,
            mmi_frm_scrn_get_active_gui_buf());
#else
        ShowCategory74Screen(
            STR_GLOBAL_HELP,
            GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID),
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*)p_string,
            string_length,
            mmi_frm_scrn_get_active_gui_buf());
#endif
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_show_waiting_screen
 * DESCRIPTION
 *  Entry function for showing "Please wait" screen
 * PARAMETERS
 *  p_screen_data  [IN] The content of screen
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_show_waiting_screen(mmi_scrn_essential_struct *p_screen_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == mmi_frm_scrn_enter(
                    p_screen_data->group_id,
                    p_screen_data->scrn_id,
                    NULL,
                    (FuncPtr)mmi_ebr_app_show_waiting_screen,
                    MMI_FRM_SMALL_SCRN))
    {
    #ifdef __MMI_SCREEN_SWITCH_EFFECT__
        gui_screen_switch_effect_block(MMI_TRUE);
    #endif

        ShowCategory63Screen(
            (U8*)GetString(STR_EBOOK_WAIT),
            mmi_get_event_based_image(MMI_EVENT_PROGRESS),
            NULL);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_display_adding_bookmark_result_popup
 * DESCRIPTION
 *  Prompt user about adding bookmark's result
 * PARAMETERS
 *  group_id               [IN] The group of popup screen
 *  adding_bookmark_result [IN] The result of adding bookmark
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_display_adding_bookmark_result_popup(mmi_id group_id, MMI_BOOL adding_bookmark_result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 string_id;
    mmi_event_notify_enum event_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == adding_bookmark_result)
    {
        string_id = STR_EBOOK_BOOKMARK_ADDED;
        event_id = MMI_EVENT_SUCCESS;
    }
    else
    {
        string_id = STR_EBOOK_BOOKMARK_ADD_FAIL;
        event_id = MMI_EVENT_FAILURE;
    }
    mmi_popup_display_simple(
        (WCHAR*)GetString(string_id), 
        event_id, 
        group_id, 
        0);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_jump_to_special_line
 * DESCRIPTION
 *  The function of jumping to special line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_jump_to_special_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 jump_line = 0;
    U8 jump_line_asc[EBR_LINE_NUMBER_BIT_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ucs2strlen((CHAR*)g_ebr_app_context_array_p->jump_input_line))
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_EMPTY), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    
    memset(jump_line_asc, 0x00, sizeof(jump_line_asc));
    mmi_ucs2_to_asc((CHAR*)jump_line_asc, (CHAR*)g_ebr_app_context_array_p->jump_input_line);
    jump_line = atoi((const CHAR*)jump_line_asc);

    jump_line = jump_line - 1;

    if ((jump_line >= g_ebr_app_context_array_p->jump_screen_total_line_num) || (jump_line < 0))
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_JUMP_ERROR), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }

    if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_jump_to_line(g_ebr_app_context_array_p->book_id, jump_line))
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_JUMP_ERROR), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }        
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_bookshelf_setting
 * DESCRIPTION
 *  The entry function of entering bookshelf's setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_bookshelf_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 nNumofItem = MMI_EBR_SETTING_ITEMS_NUM_TOTAL;
    S32 drive_count = 0;
    cui_inline_struct inline_struct = {0};
    cui_inline_item_caption_struct caption_struct[MMI_EBR_SETTING_ITEMS_NUM_TOTAL / 2];
    cui_inline_item_select_struct select_struct[MMI_EBR_SETTING_ITEMS_NUM_TOTAL / 2];
    cui_inline_item_display_only_struct display_only_struct;
    cui_inline_item_softkey_struct softkey_struct = {{
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},
        {0, CUI_INLINE_SOFTKEY_DEFAULT_VALUE}}};
    cui_inline_set_item_struct *inline_item = NULL;
    mmi_ebr_app_setting_struct *p_setting_struct = NULL;
    S16 error = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_item = mmi_ebr_app_malloc_memory(sizeof(cui_inline_set_item_struct) * MMI_EBR_SETTING_ITEMS_NUM_TOTAL);
    p_setting_struct = mmi_ebr_app_malloc_memory(sizeof(mmi_ebr_app_setting_struct));
    
    /* if there is only one storage, do not show "select storage" option */
    drive_count = mmi_ebr_app_get_storage_number(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE, NULL, 0);
    if (drive_count <= 1)
    {
        nNumofItem = MMI_EBR_SETTING_ITEMS_NUM_TOTAL - 2;
    }
    
    /* Get the setting values */
    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)(p_setting_struct), NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    g_ebr_app_context_array_p->select_bookshelf_drive = p_setting_struct->bookshelf_setting.memory_type;

    /* Fill the setting value */
    {
        caption_struct[0].string_id = STR_SETTINGS_FONT_SIZE;
        inline_item[0].item_id = MMI_EBR_SETTING_FONT_SIZE_CAPTION_ID;
        inline_item[0].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        inline_item[0].image_id = IMG_GLOBAL_L1;
        inline_item[0].item_data = &caption_struct[0];

        select_struct[0].n_items = EBR_FONT_SIZE_TOTAL;
        select_struct[0].highlighted_item = p_setting_struct->bookshelf_setting.font_size;
        select_struct[0].list_of_item_id = (U16*)g_ebr_app_context_array_p->select_setting_caption.ebook_settings_font_size;
        inline_item[1].item_id = MMI_EBR_SETTING_FONT_SIZE_SELECT_ID;
        inline_item[1].item_flag = CUI_INLINE_ITEM_TYPE_SELECT;
        inline_item[1].image_id = 0;
        inline_item[1].item_data = &select_struct[0];

        caption_struct[1].string_id = STR_SETTINGS_SCROLL_BY;
        inline_item[2].item_id = MMI_EBR_SETTING_SCROLL_BY_CAPTION_ID;
        inline_item[2].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        inline_item[2].image_id = IMG_GLOBAL_L2;
        inline_item[2].item_data = &caption_struct[1];

        select_struct[1].n_items = EBR_SCROLL_TYPE_TOTAL;
        select_struct[1].highlighted_item = p_setting_struct->bookshelf_setting.scroll_type;
        select_struct[1].list_of_item_id = (U16*)g_ebr_app_context_array_p->select_setting_caption.ebook_settings_scroll_by;
        inline_item[3].item_id = MMI_EBR_SETTING_SCROLL_BY_SELECT_ID;
        inline_item[3].item_flag = CUI_INLINE_ITEM_TYPE_SELECT;
        inline_item[3].image_id = 0;
        inline_item[3].item_data = &select_struct[1];

        caption_struct[2].string_id = STR_SETTINGS_AUTO_SCROLL_SPEED;
        inline_item[4].item_id = MMI_EBR_SETTING_SCROLL_SPEED_CAPTION_ID;
        inline_item[4].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        inline_item[4].image_id = IMG_GLOBAL_L3;
        inline_item[4].item_data = &caption_struct[2];

        select_struct[2].n_items = EBR_AUTO_SCROLL_SPEED_TOTAL;
        select_struct[2].highlighted_item = p_setting_struct->bookshelf_setting.scroll_speed;
        select_struct[2].list_of_item_id = (U16*)g_ebr_app_context_array_p->select_setting_caption.ebook_settinsg_auto_scroll_speed;
        inline_item[5].item_id = MMI_EBR_SETTING_SCROLL_SPEED_SELECT_ID;
        inline_item[5].item_flag = CUI_INLINE_ITEM_TYPE_SELECT;
        inline_item[5].image_id = 0;
        inline_item[5].item_data = &select_struct[2];

        if (nNumofItem == MMI_EBR_SETTING_ITEMS_NUM_TOTAL)
        {
            caption_struct[3].string_id = STR_SETTINGS_SELECT_MEMORY;
            inline_item[6].item_id = MMI_EBR_SETTING_STORAGE_CAPTION_ID;
            inline_item[6].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
            inline_item[6].image_id = IMG_GLOBAL_L4;
            inline_item[6].item_data = &caption_struct[3];
            
            display_only_struct.string_id = srv_fmgr_drv_get_string(p_setting_struct->bookshelf_setting.memory_type);
            inline_item[7].item_id = MMI_EBR_SETTING_STORAGE_DISPLAY_ID;
            inline_item[7].item_flag = CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY;
            inline_item[7].image_id = 0;
            inline_item[7].item_data = &display_only_struct;
        }
    }
    
    inline_struct.items_count = nNumofItem;
    inline_struct.title = STR_SETTINGS_EBOOK;
    #ifndef __COSMOS_MMI_PACKAGE__
    inline_struct.title_icon = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);
    #endif
    inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP;
    inline_struct.softkey = &softkey_struct;
    inline_struct.items = inline_item;
    
    g_ebr_app_context_array_p->bookshelf_setting_id = cui_inline_create(GRP_ID_EBOOK_BOOKSHELF, &inline_struct);
    cui_inline_run(g_ebr_app_context_array_p->bookshelf_setting_id);
    mmi_ebr_app_free_memory((void**)&inline_item);
    mmi_ebr_app_free_memory((void**)&p_setting_struct);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_save_bookshelf_setting_confirm_lsk_handler
 * DESCRIPTION
 *  Save the bookshelf's setting in nvram
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_save_bookshelf_setting_confirm_lsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_setting_struct nvram_setting;
    srv_ebr_bookshelf_setting setting_struct;
    S16 error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /* mmi_popup_display_simple(
        (WCHAR*)GetString(STR_GLOBAL_SAVED), 
        MMI_EVENT_SUCCESS, 
        GRP_ID_EBOOK_BOOKSHELF, 
        0);*/

    cui_inline_get_value(g_ebr_app_context_array_p->bookshelf_setting_id, MMI_EBR_SETTING_FONT_SIZE_SELECT_ID, &setting_struct.font_size);
    cui_inline_get_value(g_ebr_app_context_array_p->bookshelf_setting_id, MMI_EBR_SETTING_SCROLL_BY_SELECT_ID, &setting_struct.scroll_type);
    cui_inline_get_value(g_ebr_app_context_array_p->bookshelf_setting_id, MMI_EBR_SETTING_SCROLL_SPEED_SELECT_ID, &setting_struct.scroll_speed);

    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)(&nvram_setting), NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    memcpy(&nvram_setting.bookshelf_setting, &setting_struct, sizeof(srv_ebr_bookshelf_setting));
    nvram_setting.bookshelf_setting.memory_type = g_ebr_app_context_array_p->select_bookshelf_drive;
    WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)(&nvram_setting), NVRAM_EF_EBOOK_SETTING_SIZE, &error);

    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_SETTINGS_DONE_HNDLR, g_ebr_app_context_array_p->bookshelf_path[0], g_ebr_app_context_array_p->select_bookshelf_drive);
    if (g_ebr_app_context_array_p->bookshelf_path[0] != g_ebr_app_context_array_p->select_bookshelf_drive)
    {
		srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id);
#ifdef __COSMOS_MMI_PACKAGE__   
        vcui_folder_browser_close(g_ebr_app_context_array_p->folder_browser_id);
#else
        cui_folder_browser_close(g_ebr_app_context_array_p->folder_browser_id);
#endif 
    }
    else
    {
        srv_ebr_bookshelf_set_setting(g_ebr_app_context_array_p->bookshelf_id, &setting_struct);
    }

    cui_inline_close(g_ebr_app_context_array_p->bookshelf_setting_id);
    g_ebr_app_context_array_p->bookshelf_setting_id = GRP_ID_INVALID;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_save_bookshelf_setting_confirm_rsk_handler
 * DESCRIPTION
 *  Donot save the bookshelf's setting in nvram
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_save_bookshelf_setting_confirm_rsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_inline_close(g_ebr_app_context_array_p->bookshelf_setting_id);
    g_ebr_app_context_array_p->bookshelf_setting_id = GRP_ID_INVALID;
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_bookshelf_screen_proc
 * DESCRIPTION
 *  The procedure for entrying bookshelf screen screen
 * PARAMETERS
 *  p_event  [IN] The event sent by framework
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_entry_bookshelf_screen_proc(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (p_event->evt_id)
    {
        case EVT_ID_SCRN_DEINIT:
        {
            if (g_ebr_app_context_array_p->bookshelf_id >= 0)
            {
                srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id);
                g_ebr_app_context_array_p->bookshelf_id = -1;
            }
            break;
        }
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_check_drive_is_external_drive
 * DESCRIPTION
 *  Check whether the drive is memory card or OTG device
 * PARAMETERS
 *  drive    [IN] the drive's number
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ebr_app_check_drive_is_external_drive(CHAR drive, S32 *p_drive_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    WCHAR drive_wcs_path[EBR_DRIVE_WCS_PATH_LEN];
    FS_DEVICE_TYPE_ENUM dev_type = FS_DEVICE_TYPE_CARD;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(drive_wcs_path, 0, sizeof(drive_wcs_path));
    drive_wcs_path[0] = drive;
    mmi_wcscat(drive_wcs_path, L":\\");
    
    dev_type = FS_GetDevType((const WCHAR*)drive_wcs_path);
    if (NULL != p_drive_type)
    {
        *p_drive_type = dev_type;
    }
    return ((FS_DEVICE_TYPE_CARD == dev_type) || (FS_DEVICE_TYPE_EXTERNAL == dev_type));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_check_drive_status
 * DESCRIPTION
 *  Check the drive's statue
 * PARAMETERS
 *  drive    [IN] the drive's number
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ebr_app_check_drive_status(CHAR drive)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!srv_fmgr_drv_is_valid((U8)drive) || 
        (FS_GetDevStatus(drive, FS_MOUNT_STATE_ENUM) != FS_NO_ERROR))
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_change_storage_from_card_to_phone_lsk
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_change_storage_from_card_to_phone_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_setting_struct setting;
	S16 error = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    setting.bookshelf_setting.memory_type = (CHAR)SRV_FMGR_PUBLIC_DRV;
    WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    mmi_ebr_app_entry_bookshelf();
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_bookshelf_list_storage_popup_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  p_event  [IN] The EVT_ID_POPUP_QUIT event structure
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_bookshelf_list_storage_popup_callback(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U32 user_data = 0;
    mmi_ebr_app_setting_struct setting;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    user_data = (U32)((mmi_alert_result_evt_struct*)p_event)->user_tag;
    if (MMI_EBR_POPUPCALLBACK_TAG_LIST_STORAGE == (mmi_ebr_popupcallback_tag_enum)user_data)
    {
        S32 total_drive_num = 0;
        U8 drive_letter_array[SRV_FMGR_DRV_TOTAL];
        mmi_id storage_selector_id = GRP_ID_INVALID;

        total_drive_num = mmi_ebr_app_get_storage_number(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE, drive_letter_array, SRV_FMGR_DRV_TOTAL);

        if (total_drive_num > 0)
        {
            ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
            storage_selector_id = cui_storage_selector_create(GRP_ID_EBOOK_BOOKSHELF, setting.bookshelf_setting.memory_type, 0);
            cui_storage_selector_run(storage_selector_id);
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_pre_entry_book_shel_screen
 * DESCRIPTION
 *  Pre-Entry function for book shelf screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_pre_entry_book_shel_screen(void)
{
#ifndef __COSMOS_MMI_PACKAGE__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_setting_struct setting;
    S16 error = 0;
    S32 total_drive_num = 0;
    mmi_popup_property_struct popup_struct;
    mmi_confirm_property_struct confirm_struct;
    S32 drive_type = FS_DEVICE_TYPE_CARD;
    S32 fs_error = FS_NO_ERROR;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check whether is in USB mode state */
#ifdef __USB_IN_NORMAL_MODE__
	if (srv_usb_is_in_mass_storage_mode())
    {   
        mmi_usb_app_unavailable_popup(0);
        goto end;
    }
#endif 

	if(!mmi_ebr_alloc_buffer(MMI_FALSE))
	{
		return;
	}
	
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_PRE_ENTRY_BOOK_SHEL_SCREEN_LOG1, g_ebr_app_context_array_p->state);
    g_ebr_app_context_array_p->entry_from = MMI_EBR_APP_ENTRY_FROM_EBOOK_READER;
    mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_EBOOK_BOOKSHELF, mmi_ebr_entry_bookshelf_proc, g_ebr_app_context_array_p);
    mmi_frm_group_enter(GRP_ID_EBOOK_BOOKSHELF, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    /* Get the bookshelf's storage */
    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    /* Initialize the drive value in eBook nvram */
    if (0x01 == setting.bookshelf_setting.memory_type)
    {
        setting.bookshelf_setting.memory_type = (CHAR)SRV_FMGR_PUBLIC_DRV;
        WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    }

    fs_error = FS_GetDevStatus(setting.bookshelf_setting.memory_type, FS_FEATURE_STATE_ENUM);
    if (FS_NO_ERROR != fs_error)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(srv_fmgr_fs_error_get_string(fs_error)), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_BOOKSHELF, 
            0);
        goto end;
    }
    
    /* Following memory card's rule */
    if ((MMI_TRUE == mmi_ebr_app_check_drive_is_external_drive(setting.bookshelf_setting.memory_type, &drive_type)) &&
        (MMI_FALSE == mmi_ebr_app_check_drive_status(setting.bookshelf_setting.memory_type)))
    {
        total_drive_num = mmi_ebr_app_get_storage_number(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY, NULL, 0);

        if (0 == total_drive_num)
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_GLOBAL_INSERT_MEMORY_CARD), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_BOOKSHELF, 
                0);
        }
        else if (1 == total_drive_num)
        {
            mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
            confirm_struct.parent_id = GRP_ID_EBOOK_BOOKSHELF;
            confirm_struct.user_tag = (void*)MMI_EBR_BOOKSHELF_ALERT_TYPE_MEMORY_CARD_REMOVE_USE_PHONE;
            if (FS_DEVICE_TYPE_EXTERNAL == drive_type)
            {
                mmi_confirm_display(
                    (WCHAR*)GetString(STR_GLOBAL_OTG_REMOVED_USE_PHONE_QUERY), 
                    MMI_EVENT_QUERY, 
                    &confirm_struct);
            }
            else
            {
                mmi_confirm_display(
                    (WCHAR*)GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE), 
                    MMI_EVENT_QUERY, 
                    &confirm_struct);
            }
        }
        else
        {
            mmi_popup_property_init(&popup_struct);
            popup_struct.callback = mmi_ebr_app_bookshelf_list_storage_popup_callback;
            popup_struct.user_tag = (void*)MMI_EBR_POPUPCALLBACK_TAG_LIST_STORAGE;
            if (FS_DEVICE_TYPE_EXTERNAL == drive_type)
            {
                mmi_popup_display(
                    (WCHAR*)GetString(STR_GLOBAL_OTG_REMOVED), 
                    MMI_EVENT_INFO, 
                    &popup_struct);
            }
            else
            {
                mmi_popup_display(
                    (WCHAR*)GetString(STR_GLOBAL_MC_REMOVED), 
                    MMI_EVENT_INFO, 
                    &popup_struct);
            }
        } 
        goto end;
    }

    mmi_ebr_app_entry_bookshelf();
end:
    return;
#else
U8 drive = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE);
WCHAR bookshelf_path[20];
#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())
    {   
        mmi_usb_app_unavailable_popup(0);
        return;
    }
#endif 
    //g_ebr_app_context_array_p->entry_from = MMI_EBR_APP_ENTRY_FROM_EBOOK_READER;

#ifdef __COSMOS_NO_USER_DRIVE__
   if(srv_fmgr_drv_is_accessible(drive)>0)//memory card
   {
       //U8 drive = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE);       
       kal_wsprintf(bookshelf_path, "%c%s", drive, EBR_DOWNLOADED_EBOOK_PATH);    
       if (srv_fmgr_fs_path_exist(bookshelf_path)<0)
       {
            if (FS_CreateDir(bookshelf_path)<0)
            {
                return;
            }
       }
       mmi_ebr_entry_book_shelf_normal_flow((CHAR*)bookshelf_path);
   }
   else
   {
    
       mmi_frm_nmgr_balloon(
	                    MMI_SCENARIO_ID_GENERAL,
	                    MMI_EVENT_INFO_BALLOON,
	                    MMI_NMGR_BALLOON_TYPE_INFO,
	                    (WCHAR*)GetString(STR_BOLLON_NOT_AVALIABLE));
	                    
   }
   #else
   if(srv_fmgr_drv_is_accessible(drive)>0)
   {
      // U8 drive = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE);
       kal_wsprintf(bookshelf_path, "%c%s", drive, EBR_DOWNLOADED_EBOOK_PATH);
       if (srv_fmgr_fs_path_exist(bookshelf_path)<0)
       {
            if (FS_CreateDir(bookshelf_path)<0)
            {
                return;
            }
       }
       mmi_ebr_entry_book_shelf_normal_flow((CHAR*)bookshelf_path);
   }
   else
   {
   U8 drive_phone = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_PHONE_TYPE); 
      // U8 drive = srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE);    
       kal_wsprintf(bookshelf_path, "%c%s", drive_phone, EBR_DOWNLOADED_EBOOK_PATH);
      if (srv_fmgr_fs_path_exist(bookshelf_path)<0)
      {
           if (FS_CreateDir(bookshelf_path)<0)
           {
               return;
           }
      }
       mmi_ebr_entry_book_shelf_normal_flow((CHAR*)bookshelf_path);
   }
   /*else
   {
       assert(0);
   }*/
#endif
   
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_stop_app_mem_callback
 * DESCRIPTION
 *  to stop ebook reader for releasing app-based asm.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void mmi_ebr_stop_app_mem_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_frm_group_close(GRP_ID_EBOOK_BOOKSHELF);
	
    /* Notify MMI that this application is already stopped */
    applib_mem_ap_notify_stop_finished(
        APPLIB_MEM_AP_ID_EBOOK, KAL_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_init
 * DESCRIPTION
 *  Initialize the mmi_ebr_app_context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    memset(g_ebr_app_context_array_p->search_string, 0, sizeof(g_ebr_app_context_array_p->search_string));
    memset(g_ebr_app_context_array_p->last_search_string, 0, sizeof(g_ebr_app_context_array_p->last_search_string));
    g_ebr_app_context_array_p->book_info_buffer = NULL;
    g_ebr_app_context_array_p->search_found_flag = MMI_FALSE;
    g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
    g_ebr_app_context_array_p->book_id = -1;
    g_ebr_app_context_array_p->send_error_msg_flag = MMI_TRUE;
    g_ebr_app_context_array_p->bookshelf_id = -1;
    g_ebr_app_context_array_p->auto_scroll = MMI_FALSE;
    g_ebr_app_context_array_p->full_screen = MMI_FALSE;
    g_ebr_app_context_array_p->bookshelf_setting_id = GRP_ID_INVALID;
    g_ebr_app_context_array_p->search_string_from_short_key_flag = MMI_FALSE;

    mmi_ebr_app_init_setting_select_value();
}


/*****************************************************************************
 * FUNCTION
 *  InitEbookApp
 * DESCRIPTION
 *  Initialize the eBook application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitEbookApp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_INIT_APP);
    SetProtocolEventHandler(mmi_ebr_fs_op_error_handler, MSG_ID_MMI_EBOOK_CALLBACK_ERROR_IND);
    SetProtocolEventHandler(mmi_ebr_reset_auto_scroll_handler, MSG_ID_MMI_EBOOK_RESET_AUTO_SCROLL_IND);
    SetProtocolEventHandler(mmi_ebr_conversion_complete_handler, MSG_ID_MMI_EBOOK_CONVERSION_COMPLETE_IND);
    // call fs_async_msg_handler when receive  async msg
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_OPEN_RSP);
    SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_FIND_FIRST_RSP);
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_GET_FOLDER_SIZE_RSP);
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_WRITE_RSP);
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_READ_RSP);
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_DELETE_RSP);
	SetProtocolEventHandler(fs_async_msg_handler, MSG_ID_FS_SEEK_RSP);

    applib_mem_ap_register(APPLIB_MEM_AP_ID_EBOOK, 
                       MAIN_MENU_EBOOK_TEXT,
                       IMG_GLOBAL_OK,
                       mmi_ebr_stop_app_mem_callback); 

}
#ifdef __COSMOS_MMI_PACKAGE__

void mmi_ebr_open_book_key_proc(void)
{
    if(g_ebr_app_context_array_p->full_screen == MMI_TRUE)
    {
        mmi_ebr_open_book_fte_toolbar_command(1);
    
    }
    else if(MMI_TRUE == g_ebr_app_context_array_p->auto_scroll)
    {
        mmi_ebr_open_book_fte_toolbar_command(2);
    }
    else 
    {
   if(g_ebr_app_context_array_p->book_id >= 0)
    {
        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
        {
            g_ebr_app_context_array_p->book_id = -1;
            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
             memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
        }
    }
     mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
    }
   //ClearKeyHandler(KEY_BACK, KEY_EVENT_UP);
}
#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_open_book_launch
 * DESCRIPTION
 *  Lauch opening book process
 * PARAMETERS
 *  parent_id   [IN] The parent id of GRP_ID_EBOOK_OPEN_BOOK
 * RETURNS
 *  The mmi_id of opening book process
 *****************************************************************************/
mmi_id mmi_ebr_app_open_book_launch(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_app_book_info *p_open_book_info = NULL, *p_highlight_book_info = NULL;
#ifdef __COSMOS_MMI_PACKAGE__
    ebook_app_flag = MMI_TRUE;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_OPEN_BOOK_LAUNCH, parent_id, g_ebr_app_context_array_p->state, g_ebr_app_context_array_p->entry_from);
    /* Now only support one instance */ 
    mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
    
    mmi_frm_group_create(parent_id, GRP_ID_EBOOK_OPEN_BOOK, mmi_ebr_entry_open_book_proc, g_ebr_app_context_array_p);
    mmi_frm_group_enter(GRP_ID_EBOOK_OPEN_BOOK, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
    p_highlight_book_info = &g_ebr_app_context_array_p->highlight_book_info;

    g_ebr_app_context_array_p->auto_scroll = MMI_FALSE;
    g_ebr_app_context_array_p->full_screen = MMI_FALSE;
    
    mmi_ebr_app_entry_async_open_book();
    return  GRP_ID_EBOOK_OPEN_BOOK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_async_open_book
 * DESCRIPTION
 *  Entry function for opening book screen
 * PARAMETERS
 *  p_screen_data  [IN] The content of screen
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_async_open_book(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_bookshelf_setting bookshelf_setting;
    S32 book_id = 0;
    S16 error = 0;
    mmi_ebr_app_book_info *p_open_book_info = NULL;
    mmi_ebr_app_book_info *p_highlight_book_info = NULL;
    mmi_scrn_essential_struct screen_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_OPEN_BOOK_LOG1,g_ebr_app_context_array_p->book_id);
    p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
    p_highlight_book_info = &g_ebr_app_context_array_p->highlight_book_info;
    
    if ((g_ebr_app_context_array_p->book_id < 0))
    {
        WCHAR *full_path_name = NULL;
        
        ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&bookshelf_setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
        memcpy(
            &g_ebr_app_context_array_p->open_book_info,
            &g_ebr_app_context_array_p->highlight_book_info,
            sizeof(mmi_ebr_app_book_info)); 
        full_path_name = mmi_ebr_app_malloc_memory(SRV_EBR_MAX_PATH_LEN * ENCODING_LENGTH);
        mmi_wcscpy(full_path_name, (const WCHAR*)p_open_book_info->book_path);
        mmi_wcscat(full_path_name, (const WCHAR*)p_open_book_info->book_name);

        book_id = srv_ebr_book_async_open((CHAR*)full_path_name);
        mmi_ebr_app_free_memory((void **)&full_path_name);
        if(book_id >= 0)
        {
            g_ebr_app_context_array_p->book_id = book_id;
        }
        else
        {
            memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
            mmi_popup_display_simple(
                (WCHAR*)GetString(mmi_ebr_get_open_result_code_string_id((srv_ebr_book_open_error_enum)book_id)), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_OPEN_BOOK, 
                0);
            goto end;
        }
      //show loading screen;
       mmi_ebr_async_open_book_loading_screen(); 
    }
    else
    {
        mmi_ebr_app_entry_open_book(&screen_data);
    }
end:
	return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_open_book
 * DESCRIPTION
 *  Entry function for opening book screen
 * PARAMETERS
 *  p_screen_data  [IN] The content of screen
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_open_book(mmi_scrn_essential_struct *p_screen_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 book_id = 0;
    srv_ebr_op_result_enum op_result = SRV_EBR_OP_RESULT_SUCCESS;
    S32 fs_error = 0;
    mmi_ebr_app_book_info *p_open_book_info = NULL;
    mmi_ebr_app_book_info *p_highlight_book_info = NULL;
    wgui_ml_line_base_info *p_screen_display_info = NULL;
    mmi_ebr_frm_book_context *p_book_context = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if(g_ebr_app_context_array_p->book_id < 0)
    {
        mmi_ebr_app_entry_async_open_book();
        return;
    }

    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_OPEN_BOOK,
                        SCR_ID_EBOOK_OPEN_SCREENID,
                        (FuncPtr)mmi_ebr_mmi_ebook_exit, 
                        (FuncPtr)mmi_ebr_app_entry_open_book, 
                        MMI_FRM_FULL_SCRN))
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_OPEN_BOOK_LOG1, p_screen_data, g_ebr_app_context_array_p->book_id);
        p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
        p_highlight_book_info = &g_ebr_app_context_array_p->highlight_book_info;

        if (g_ebr_app_context_array_p->book_id >= 0)
        {   

		//  close loading screen
            mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_LOADINGSCREEN); 

            p_book_context = mmi_ebr_frm_get_book_context(book_id); 
            if(p_book_context->async_book_open_state != MMI_EBR_FRM_ASYNC_BOOK_OPEN_STATE_DONE)
            {

                op_result = srv_ebr_book_convert(book_id, &fs_error, mmi_ebr_open_book_handler);
                if (SRV_EBR_OP_RESULT_BLOCKING == op_result)
                {
                    g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_CONVERTING;
                }
                else if (SRV_EBR_OP_RESULT_FAILURE == op_result)
                {
                    mmi_popup_display_simple(
                        (WCHAR*)GetString(srv_fmgr_fs_error_get_string(fs_error)), 
                        MMI_EVENT_FAILURE, 
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        NULL);
                    mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_OPEN_SCREENID);
                    goto end;
                }
                p_book_context->async_book_open_state = MMI_EBR_FRM_ASYNC_BOOK_OPEN_STATE_DONE;
            }
                
            srv_ebr_book_set_convert_speed(g_ebr_app_context_array_p->book_id, SRV_EBR_BOOK_CONVERT_SPEED_FAST);          
            p_screen_display_info = &g_ebr_app_context_array_p->screen_disply_info;
            mmi_ebr_set_gui_page_info(p_screen_display_info);
            mmi_ebr_show_book_info_screen(&g_ebr_app_context_array_p->open_book_info, &p_screen_display_info);
        }
    }

end:
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_OPEN_BOOK_LOG2, book_id, op_result);
#ifdef __COSMOS_MMI_PACKAGE__
//     SetKeyHandler(mmi_ebr_open_book_key_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
#endif    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_async_open_book_loading_screen
 * DESCRIPTION
 *  Async Open Book Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_async_open_book_loading_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_op_result_enum op_result = SRV_EBR_OP_RESULT_BLOCKING;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        SCR_ID_EBOOK_LOADINGSCREEN, 
                        NULL, 
                        mmi_ebr_async_open_book_loading_screen, 
                        MMI_FRM_FULL_SCRN))
    {
    #ifdef __COSMOS_MMI_PACKAGE__
    ShowCategory66Screen(
            (U16)STR_EBOOK_WAIT,
            NULL,
            0,
            0,
            0,
            0,
            (U8*)GetString(STR_GLOBAL_LOADING),
            0,
            NULL);
    #else
  
        ShowCategory66Screen(
            (U16)STR_EBOOK_WAIT,
            GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID),
            0,
            0,
            0,
            0,
            (U8*)GetString(STR_GLOBAL_LOADING),
            mmi_get_event_based_image(MMI_EVENT_PROGRESS),
            NULL);
     #endif
        SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
        SetRightSoftkeyFunction(NULL, KEY_EVENT_UP);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_refresh_book_shelf
 * DESCRIPTION
 *  Refreshed Book Shelf Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_refresh_book_shelf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    srv_ebr_op_result_enum op_result = SRV_EBR_OP_RESULT_BLOCKING;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state);
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_BOOKSHELF, 
                        SCR_ID_EBOOK_WAITSCREEN, 
                        NULL, 
                        mmi_ebr_entry_refresh_book_shelf, 
                        MMI_FRM_FULL_SCRN))
    {
        guiBuffer = mmi_frm_scrn_get_active_gui_buf();
        if (NULL == guiBuffer)
        {
            op_result = srv_ebr_bookshelf_refresh(
                            g_ebr_app_context_array_p->bookshelf_id,
                            mmi_ebr_refresh_bookshelf_complete_handler);
            if (SRV_EBR_OP_RESULT_BLOCKING != op_result)
            {
                srv_ebr_bookshelf_refresh_result_struct refresh_result;
                refresh_result.bookshelf_id = g_ebr_app_context_array_p->bookshelf_id;
                refresh_result.refresh_result = op_result;
                mmi_ebr_refresh_bookshelf_complete_handler(&refresh_result);
                goto end;
            }
        }
        #ifdef __COSMOS_MMI_PACKAGE__
        ShowCategory66Screen(
            (U16)STR_EBOOK_WAIT,
            NULL,
            0,
            0,
            (U16)STR_GLOBAL_CANCEL,
            0,
            (U8*)GetString(STR_EBOOK_WAIT),
            mmi_get_event_based_image(MMI_EVENT_PROGRESS),
            NULL);
        #else
         ShowCategory66Screen(
            (U16)STR_EBOOK_WAIT,
            GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID),
            0,
            0,
            (U16)STR_GLOBAL_CANCEL,
            0,
            (U8*)GetString(STR_EBOOK_WAIT),
            mmi_get_event_based_image(MMI_EVENT_PROGRESS),
            NULL);
        #endif
        SetRightSoftkeyFunction(mmi_ebr_cancel_refresh_book_shelf, KEY_EVENT_UP);
    }
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_cancel_refresh_book_shelf
 * DESCRIPTION
 *  Cancel refresh bookshelf operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_cancel_refresh_book_shelf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_ebr_bookshelf_abort_refresh(g_ebr_app_context_array_p->bookshelf_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_refresh_book_shelf
 * DESCRIPTION
 *  Set highlight handler for Menu Ooptions
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_refresh_book_shelf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ebr_entry_refresh_book_shelf, KEY_EVENT_UP);
}


/* FMGR_Revise */
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_lsk_hdlr
 * DESCRIPTION
 *  Left soft key handler for opening ebook
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 highlight_index = 0;
    srv_fmgr_fileinfo_struct file_info;
    WCHAR *p_file_name = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __COSMOS_MMI_PACKAGE__   
        vcui_file_selector_get_selected_filepath(
                g_ebr_app_context_array_p->folder_browser_id, 
                &file_info, 
                g_ebr_app_context_array_p->highlight_book_info.book_path, 
                sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#else 
    highlight_index = cui_folder_browser_get_highlight_index(g_ebr_app_context_array_p->folder_browser_id);
    cui_folder_browser_get_filepath(
        g_ebr_app_context_array_p->folder_browser_id, 
        highlight_index, 
        &file_info, 
        g_ebr_app_context_array_p->highlight_book_info.book_path, 
        sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#endif
    p_file_name = srv_fmgr_path_get_filename_ptr(g_ebr_app_context_array_p->highlight_book_info.book_path);
    mmi_wcscpy(g_ebr_app_context_array_p->highlight_book_info.book_name, (const WCHAR*)p_file_name);
    srv_fmgr_path_remove_filename(g_ebr_app_context_array_p->highlight_book_info.book_path);
    g_ebr_app_context_array_p->highlight_book_info.book_size = file_info.size;
    #ifdef __COSMOS_MMI_PACKAGE__
    g_ebr_app_context_array_p->highlight_book_info.icon_id = 0;
    #else
    g_ebr_app_context_array_p->highlight_book_info.icon_id = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);
#endif
    mmi_ebr_app_open_book_launch(GRP_ID_EBOOK_BOOKSHELF);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_open_ebook
 * DESCRIPTION
 *  Set highlight handler for Open book
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
/* FMGR_Revise start */
void mmi_ebr_highlight_open_ebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ebr_open_lsk_hdlr, KEY_EVENT_UP);
}
/* FMGR_Revise end */


/* FMGR_Revise */
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_info_lsk_hdlr
 * DESCRIPTION
 *  Left soft key handler for opening ebook info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_info_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 highlight_index = 0;
    srv_fmgr_fileinfo_struct file_info;
    WCHAR *p_file_name = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_INFO_LSK_HDLR);
#ifdef __COSMOS_MMI_PACKAGE__   
   vcui_file_selector_get_selected_filepath(
           g_ebr_app_context_array_p->folder_browser_id, 
           &file_info, 
           g_ebr_app_context_array_p->highlight_book_info.book_path, 
           sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#else
    highlight_index = cui_folder_browser_get_highlight_index(g_ebr_app_context_array_p->folder_browser_id);
    cui_folder_browser_get_filepath(
        g_ebr_app_context_array_p->folder_browser_id, 
        highlight_index, 
        &file_info, 
        g_ebr_app_context_array_p->highlight_book_info.book_path, 
        sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#endif 
    p_file_name = srv_fmgr_path_get_filename_ptr(g_ebr_app_context_array_p->highlight_book_info.book_path);
    mmi_wcscpy(g_ebr_app_context_array_p->highlight_book_info.book_name, (const WCHAR*)p_file_name);
    srv_fmgr_path_remove_filename(g_ebr_app_context_array_p->highlight_book_info.book_path);
    g_ebr_app_context_array_p->highlight_book_info.book_size = file_info.size;
    #ifndef __COSMOS_MMI_PACKAGE__
    g_ebr_app_context_array_p->highlight_book_info.icon_id = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);
#endif
    mmi_frm_scrn_first_enter(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_INFO_SCREENID, (FuncPtr)mmi_ebr_app_entry_book_info, g_ebr_app_context_array_p);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_higlight_book_info
 * DESCRIPTION
 *  Set highlight handler for Book Info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_higlight_book_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
/* FMGR_Revise */
    SetLeftSoftkeyFunction(mmi_ebr_info_lsk_hdlr, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_delete_ebook
 * DESCRIPTION
 *  Set highlight handler for Delete Book
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_delete_ebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ebr_entry_delete_book_popup, KEY_EVENT_UP);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_delete_book_popup
 * DESCRIPTION
 *  Display popUp for Delete and confirm deletion
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_delete_book_popup(void)
{
    /* FMGR_Revise */
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_fileinfo_struct file_info;
    WCHAR *p_delete_prompt = NULL;
    WCHAR *p_delete_inquire = NULL;
    S32 len = 0;
    S32 highlight_index = 0;
    WCHAR *p_file_name = NULL;
    mmi_confirm_property_struct confirm_struct;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __COSMOS_MMI_PACKAGE__   







   vcui_file_selector_get_selected_filepath(
           g_ebr_app_context_array_p->folder_browser_id, 
           &file_info, 
           g_ebr_app_context_array_p->highlight_book_info.book_path, 
           sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#else
    highlight_index = cui_folder_browser_get_highlight_index(g_ebr_app_context_array_p->folder_browser_id);
    cui_folder_browser_get_filepath(
        g_ebr_app_context_array_p->folder_browser_id, 
        highlight_index, 
        &file_info, 
        g_ebr_app_context_array_p->highlight_book_info.book_path, 
        sizeof(g_ebr_app_context_array_p->highlight_book_info.book_path));
#endif 
    p_file_name = srv_fmgr_path_get_filename_ptr(g_ebr_app_context_array_p->highlight_book_info.book_path);
    mmi_wcscpy(g_ebr_app_context_array_p->highlight_book_info.book_name, (const WCHAR*)p_file_name);
    srv_fmgr_path_remove_filename(g_ebr_app_context_array_p->highlight_book_info.book_path);
    g_ebr_app_context_array_p->highlight_book_info.book_size = file_info.size;
    g_ebr_app_context_array_p->highlight_book_info.icon_id = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);

    p_delete_inquire = (WCHAR*)GetString(STR_EBOOK_DELETE_INQUIRE);
    len = mmi_wcslen((const WCHAR*)p_delete_inquire) + 
          SRV_EBR_MAX_FILE_LEN + 
          1;
    
    p_delete_prompt = mmi_ebr_app_malloc_memory(len * sizeof(WCHAR));

    kal_wsprintf(
        p_delete_prompt, 
        "%w%w", 
        p_delete_inquire,
        g_ebr_app_context_array_p->highlight_book_info.book_name);

    mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
    confirm_struct.parent_id = GRP_ID_EBOOK_BOOKSHELF;
    confirm_struct.user_tag = (void*)MMI_EBR_BOOKSHELF_ALERT_TYPE_DELETE_BOOK;
    confirm_struct.f_auto_map_empty_softkey = 0;
	confirm_struct.f_auto_question_mark = 1;
    mmi_confirm_display(p_delete_prompt, MMI_EVENT_QUERY, &confirm_struct);

    mmi_ebr_app_free_memory((void **)&p_delete_prompt);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_help
 * DESCRIPTION
 *  Set highlight handler for Help
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_help(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetLeftSoftkeyFunction(mmi_ebr_entry_help, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_ebr_entry_help, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_book_shelf_settings
 * DESCRIPTION
 *  Set highlight handler for Settings
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_book_shelf_settings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ebr_app_entry_bookshelf_setting, KEY_EVENT_UP);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_remove_book_mark
 * DESCRIPTION
 *  Entry Function for Remove Bookmark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_remove_book_mark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 string_id = 0;
    S32 error_code = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_FALSE == mmi_ebr_app_get_bookmark_list())
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_REMOVE_BOOK_MARK_LOG1);
        string_id = STR_EBOOK_DELETE_BOOKMARK_FAILED;
        goto error;
    }
    if (0 == g_ebr_app_context_array_p->bookmark_number)
    {
        string_id = STR_NO_BOOK_MARK_PRESENT;
        goto error;
    }
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_REMOVE_BOOK_MARK_LOG2, g_ebr_app_context_array_p->bookmark_number);

    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        SCR_ID_EBOOK_REMOVE_BOOKMARK_SCREENID, 
                        NULL, 
                        mmi_ebr_entry_remove_book_mark, 
                        MMI_FRM_FULL_SCRN))
    {
        guiBuffer = mmi_frm_scrn_get_active_gui_buf();
        SetParentHandler(0);
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
        RegisterHighlightHandler(mmi_ebr_entry_fte_bookmark_list_highlight_handler);
    #else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
        RegisterHighlightHandler(ExecuteCurrHiliteHandler);
    #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
        EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

        wgui_cat1032_show(
            (WCHAR*)GetString(STR_RMV_BOOKMARK_EBOOK),
             NULL,
            (WCHAR*)GetString(STR_GLOBAL_OK),
            (PU8)GetImage(IMG_GLOBAL_OK),
            (WCHAR*)GetString(STR_GLOBAL_BACK),
            (PU8)GetImage(IMG_GLOBAL_BACK),
            g_ebr_app_context_array_p->bookmark_number,
            mmi_ebr_async_get_book_mark_name_list,
            NULL,
            0,
            0,    
            IMG_GLOBAL_L1,
            0,
            guiBuffer,
            &error_code);

        SetLeftSoftkeyFunction(mmi_ebr_delete_bookmark, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_ebr_delete_bookmark, KEY_EVENT_UP);
    }
    return;
error:
    mmi_popup_display_simple(
        (WCHAR*)GetString(string_id), 
        MMI_EVENT_FAILURE, 
        GRP_ID_EBOOK_OPEN_BOOK, 
        0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_delete_bookmark
 * DESCRIPTION
 *  PopuUp display for deletion of BookMark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_delete_bookmark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct confirm_struct;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
    confirm_struct.parent_id = GRP_ID_EBOOK_OPEN_BOOK;
    confirm_struct.user_tag = (void*)MMI_EBR_BOOK_ALERT_TYPE_DELETE_BOOKMARK;
    confirm_struct.f_auto_map_empty_softkey = 0;
    mmi_confirm_display(
        (WCHAR*)GetString(STR_DELETE_BOOK_MARK), 
        MMI_EVENT_QUERY, 
        &confirm_struct);
    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_goto_book_mark
 * DESCRIPTION
 *  Entry Function for Go to BookMark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_goto_book_mark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 string_id = STR_NO_BOOK_MARK_PRESENT;
    S32 error_flag = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_ebr_app_context_array_p->state == MMI_EBR_APP_STATE_CONVERTING)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
		return;
    }
	
    if (MMI_FALSE == mmi_ebr_app_get_bookmark_list())
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_GOTO_BOOK_MARK_LOG1);
        string_id = STR_EBOOK_GOTO_BOOKMARK_FAILED;
        goto error;
    }
    if (0 == g_ebr_app_context_array_p->bookmark_number)
    {   
        string_id = STR_NO_BOOK_MARK_PRESENT;
        goto error;
    }
    
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_GOTO_BOOK_MARK_LOG2, g_ebr_app_context_array_p->bookmark_number);
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        SCR_ID_EBOOK_GOTO_BOOKMARK_SCREENID, 
                        NULL, 
                        mmi_ebr_entry_goto_book_mark, 
                        MMI_FRM_FULL_SCRN))
    {
        guiBuffer = mmi_frm_scrn_get_active_gui_buf();
        SetParentHandler(0);
        RegisterHighlightHandler(mmi_ebr_highlight_selected_bookmark);

        EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

        wgui_cat1032_show(
            (WCHAR*)GetString(STR_GOTO_BOOKMARK_EBOOK),
             NULL,
            (WCHAR*)GetString(STR_GLOBAL_OK),
            (PU8)GetImage(IMG_GLOBAL_OK),
            (WCHAR*)GetString(STR_GLOBAL_BACK),
            (PU8)GetImage(IMG_GLOBAL_BACK),
            g_ebr_app_context_array_p->bookmark_number,
            mmi_ebr_async_get_book_mark_name_list,
            NULL,
            0,
            0,    
            IMG_GLOBAL_L1,
            0,
            guiBuffer,
            &error_flag);
                
        SetLeftSoftkeyFunction(mmi_ebr_goto_selected_bookmark, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_ebr_goto_selected_bookmark, KEY_EVENT_UP);
    }
    return;
    
error:
    mmi_popup_display_simple(
        (WCHAR*)GetString(string_id), 
        MMI_EVENT_FAILURE, 
        GRP_ID_EBOOK_OPEN_BOOK, 
        0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_get_bookmark_list
 * DESCRIPTION
 *  Get the bookmark list information
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ebr_app_get_bookmark_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    S32 bookmark_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_ebr_app_context_array_p->bookmark_id_array, 0, sizeof(g_ebr_app_context_array_p->bookmark_id_array));
    memset(g_ebr_app_context_array_p->bookmark_info_array, 0, sizeof(g_ebr_app_context_array_p->bookmark_info_array));
    
    if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_get_bookmark_list(
                                        g_ebr_app_context_array_p->book_id, 
                                        g_ebr_app_context_array_p->bookmark_id_array, 
                                        &bookmark_count))
    {
        return MMI_FALSE;
    }

    g_ebr_app_context_array_p->bookmark_number = bookmark_count;

    for (i = 0; i < bookmark_count; i++)
    {
        if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_get_bookmark_info(
                                            g_ebr_app_context_array_p->book_id, 
                                            g_ebr_app_context_array_p->bookmark_id_array[i], 
                                            &g_ebr_app_context_array_p->bookmark_info_array[i]))
        {
            return MMI_FALSE;
        }
    }

    if (bookmark_count > 0)
    {
        srv_ebr_book_sort_bookmark(g_ebr_app_context_array_p->bookmark_info_array, g_ebr_app_context_array_p->bookmark_id_array, bookmark_count);
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_selected_bookmark
 * DESCRIPTION
 *  Highlight Handler for Go to BookMark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_selected_bookmark(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ebr_app_context_array_p->current_select_bookmark = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_goto_selected_bookmark
 * DESCRIPTION
 *  Entry Function for Go to BookMark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_goto_selected_bookmark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_book_bookmark_struct *p_bookmark_info = NULL;
	mmi_ebr_frm_book_struct *p_nfo_file = NULL;
    mmi_ebr_frm_book_context *p_book_context = NULL;
	CHAR* bookmark_name;
    U32 line_index;
	int i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GOTO_SELECTED_BOOKMARK);

	if(g_ebr_app_context_array_p->state == MMI_EBR_APP_STATE_CONVERTING)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
		return;
    }

    p_bookmark_info = g_ebr_app_context_array_p->bookmark_info_array;
    bookmark_name = p_bookmark_info[g_ebr_app_context_array_p->current_select_bookmark].bookmark_name;
    p_book_context = mmi_ebr_frm_get_book_context(0);
    p_nfo_file = &p_book_context->nfo_book_struct;

	while ((mmi_ucs2cmp((p_nfo_file->book_marks[i].bookmark_name), bookmark_name)) &&
           (i < SRV_EBR_MAX_BOOKMARK_NUMBER))
    {
        i++;
    }
	if(i == SRV_EBR_MAX_BOOKMARK_NUMBER)
	{
	   // error, bookmark nofound
	}
    line_index = srv_ebr_book_bookmark_offset_to_line_index(0, i);
    if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_jump_to_line(
                                        g_ebr_app_context_array_p->book_id, 
                                        line_index))
    {
        mmi_frm_scrn_multiple_close(
            GRP_ID_EBOOK_OPEN_BOOK, 
            SCR_ID_EBOOK_GOTO_BOOKMARK_SCREENID, 
            MMI_TRUE, 
            0, 
            SCR_ID_EBOOK_OPEN_SCREENID, 
            MMI_FALSE);
    }
    else
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_GOTO_BOOKMARK_FAILED), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_GOTO_BOOKMARK_SCREENID);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_remove_selected_bookmark
 * DESCRIPTION
 *  Exit function for Delete book mark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_remove_selected_bookmark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_op_result_enum remove_result = SRV_EBR_OP_RESULT_FAILURE;
    S32 *p_bookmark_id = NULL;
    S32 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_REMOVE_SELECTED_BOOKMARK);

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    index = g_ebr_app_context_array_p->current_select_bookmark;
#else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
    index = (S32)GetCurrHiliteID();
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

    p_bookmark_id = g_ebr_app_context_array_p->bookmark_id_array;
    remove_result = srv_ebr_book_delete_bookmark(g_ebr_app_context_array_p->book_id, p_bookmark_id[index]);

    if (SRV_EBR_OP_RESULT_SUCCESS == remove_result)
    {
        if (1 == g_ebr_app_context_array_p->bookmark_number)
        {
        #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
		
		#else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
            mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_REMOVE_BOOKMARK_SCREENID);
        #endif  /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
        }
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_BOOKMARK_DELETED), 
            MMI_EVENT_SUCCESS, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
    else
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_DELETE_BOOKMARK_FAILED), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_add_book_mark
 * DESCRIPTION
 *  Entry function for Add book mark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_add_book_mark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 input_buffer_length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_FALSE == mmi_ebr_app_get_bookmark_list())
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_ADD_BOOK_MARK_LOG1);
        mmi_ebr_app_display_adding_bookmark_result_popup(GRP_ID_EBOOK_OPEN_BOOK, MMI_FALSE);
        goto end;
    }
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_ADD_BOOK_MARK_LOG2, g_ebr_app_context_array_p->bookmark_number);
    if (g_ebr_app_context_array_p->bookmark_number >= SRV_EBR_MAX_BOOKMARK_NUMBER)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_MAX_BOOK_MARK), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }

    mmi_ebr_get_default_bookmark_name(g_ebr_app_context_array_p->input_bookmark_name);
    input_buffer_length = sizeof(g_ebr_app_context_array_p->input_bookmark_name) / ENCODING_LENGTH;
    
    g_ebr_app_context_array_p->add_bookmark_fseditor_id = cui_fseditor_create(GRP_ID_EBOOK_OPEN_BOOK);
    #ifdef __COSMOS_MMI_PACKAGE__
    cui_fseditor_set_title(g_ebr_app_context_array_p->add_bookmark_fseditor_id, STR_ADD_BOOKMARK_EBOOK, NULL);
    #else
    cui_fseditor_set_title(g_ebr_app_context_array_p->add_bookmark_fseditor_id, STR_ADD_BOOKMARK_EBOOK, GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID));
#endif
    cui_fseditor_set_text(
        g_ebr_app_context_array_p->add_bookmark_fseditor_id, 
        (WCHAR*)g_ebr_app_context_array_p->input_bookmark_name, 
        sizeof(g_ebr_app_context_array_p->input_bookmark_name), 
        input_buffer_length - 1);
    cui_fseditor_run(g_ebr_app_context_array_p->add_bookmark_fseditor_id);
end:
#ifdef __COSMOS_MMI_PACKAGE__
//     SetKeyHandler(mmi_ebr_open_add_bmlist_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
 //    MMI_CAT_SET_KEY_PROC(mmi_ebr_open_add_bmlist_proc_test,NULL);
#endif  
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_get_book_mark_name_list
 * DESCRIPTION
 *  Call back to get the book mark names
 * PARAMETERS
 *  item_index          [IN]        
 *  str_buff            [IN]        
 *  img_buff_p          [IN]        
 *  str_img_mask        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL mmi_ebr_get_book_mark_name_list(S32 item_index, UI_string_type str_buff, PU8 *img_buff_p, U8 str_img_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2cpy((CHAR*)str_buff, (CHAR*)g_ebr_app_context_array_p->bookmark_info_array[item_index].bookmark_name);
    *img_buff_p = get_image(gIndexIconsImageList[item_index]);
    return TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_async_get_book_mark_name_list
 * DESCRIPTION
 *  Gets the async items for the bookmark list.
 * PARAMETERS
 *  start_index     [IN]
 *  *menu_data      [OUT]
 *  num_items       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ebr_async_get_book_mark_name_list(S32 start_index, gui_iconlist_menu_item *menu_data, S32 num_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < num_items; i++)
    {
        mmi_ebr_get_book_mark_name_list((i + start_index), menu_data[i].item_list[0], &menu_data[i].image_list[0], 0);
    }
    return num_items;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_add_bookmark
 * DESCRIPTION
 *  the pre function of adding bookmark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_add_bookmark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL add_book_mark_result = MMI_FALSE;
    CHAR *book_mark_name = NULL;
    srv_ebr_book_bookmark_struct bookmark;
    srv_ebr_book_line_info book_line_info;
    S32 bookmark_id = 0;
    S32 i = 0;
    srv_ebr_book_bookmark_struct *p_bookmark_info = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    book_mark_name = g_ebr_app_context_array_p->input_bookmark_name;
    if ((book_mark_name[0] == 0) && (book_mark_name[1] == 0))
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_BOOK_MARK_NAME_IS_EMPTY), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }

    p_bookmark_info = g_ebr_app_context_array_p->bookmark_info_array;
    for (i = 0; i < g_ebr_app_context_array_p->bookmark_number; i++)
    {
        if (!mmi_ucs2cmp((const CHAR*)book_mark_name, (const CHAR*)p_bookmark_info[i].bookmark_name))
        {
            g_ebr_app_context_array_p->current_select_bookmark = i;
            mmi_ebr_entry_duplicate_book_mark_pop_up();
            goto end;
        }
    }
    
    cui_fseditor_close(g_ebr_app_context_array_p->add_bookmark_fseditor_id);
 
    srv_ebr_book_get_line_info(g_ebr_app_context_array_p->book_id, &book_line_info);
    bookmark.start_line = book_line_info.start_line;
    memcpy(bookmark.bookmark_name, book_mark_name, (SRV_EBR_MAX_BOOKMARK_NAME_SIZE + 1) * ENCODING_LENGTH);
    bookmark_id = srv_ebr_book_add_bookmark(g_ebr_app_context_array_p->book_id, &bookmark);
    if (bookmark_id >= 0 )
    {
        add_book_mark_result = MMI_TRUE;
    }
    else
    {
        add_book_mark_result = MMI_FALSE;
    }
    mmi_ebr_app_display_adding_bookmark_result_popup(GRP_ID_EBOOK_OPEN_BOOK, add_book_mark_result);
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_get_default_bookmark_name
 * DESCRIPTION
 *  Set the default bookmark name
 * PARAMETERS
 *  bookmark_name  [OUT] the default bookmark name
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_get_default_bookmark_name(char *bookmark_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_of_book_marks = 0;
    S32 counter = 1;
    CHAR counter_ucs2 [(SRV_EBR_MAX_BOOKMARK_NAME_SIZE + 1) * ENCODING_LENGTH];
    U8 *p_exist_bookmark_name = NULL;
    srv_ebr_book_bookmark_struct *p_bookmark_info = NULL;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_bookmark_info = g_ebr_app_context_array_p->bookmark_info_array;
    mmi_ucs2cpy((CHAR*)bookmark_name, GetString((U16)STR_EBOOK_DEFAULT_BOOKMARK));    
    app_ucs2_itoa(counter, (kal_int8*)counter_ucs2, 10);
    mmi_ucs2cat(bookmark_name, counter_ucs2);
    p_exist_bookmark_name = p_bookmark_info[no_of_book_marks].bookmark_name;
    while (((p_exist_bookmark_name[0] != 0) ||
            (p_exist_bookmark_name[1] != 0)) && 
           (no_of_book_marks < SRV_EBR_MAX_BOOKMARK_NUMBER))
    {        
        if (mmi_ucs2cmp(bookmark_name, (const CHAR*)p_exist_bookmark_name) != 0)
        {
            no_of_book_marks++;            
        }
        else
        {
            no_of_book_marks = 0;
            counter++;
            mmi_ucs2cpy((CHAR*)bookmark_name, GetString((U16)STR_EBOOK_DEFAULT_BOOKMARK));
            app_ucs2_itoa(counter, (kal_int8*)counter_ucs2, 10);
            mmi_ucs2cat(bookmark_name, counter_ucs2);             
        }
        p_exist_bookmark_name = p_bookmark_info[no_of_book_marks].bookmark_name;
    }
}
#ifdef __COSMOS_MMI_PACKAGE__



U8 flag_vk_jump_to = 0;
static mmi_ret mmi_ebr_open_jump_to_proc_test(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct *)evt;
    U8 key_code = key_evt->key_code;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((key_evt->evt_id == EVT_ID_PRE_KEY) 
          && (key_evt->key_type == KEY_EVENT_DOWN) 
          && (key_code == KEY_BACK))
    {
       if(mmi_imc_get_ui_style(MMI_IMC_UI_STYLE_VK_ON) && !mmi_imc_is_vk_disabled())
       {
         flag_vk_jump_to = 1;
       }
       else
       {
         flag_vk_jump_to = 0; 
       }

    }

    return MMI_RET_OK;

}

void mmi_ebr_open_jump_to_proc1(void)
{
    cui_inline_close(inline_id);         
}
void mmi_ebr_open_jump_to_proc(void)
{
    if(flag_vk_jump_to)
    {
       // cui_fseditor_rsk_handler_test();
        wgui_inputs_ml_reset_register_up_down_key_funcptr();
        SetKeyHandler(mmi_ebr_open_jump_to_proc1, KEY_BACK, KEY_EVENT_DOWN);
    }
    else
    {
        mmi_ebr_open_jump_to_proc1();
    }
    
}
void  resgister_ebook_key()
{
    SetKeyHandler(mmi_ebr_open_jump_to_proc, KEY_BACK, KEY_EVENT_DOWN);
	MMI_CAT_SET_KEY_PROC(mmi_ebr_open_jump_to_proc_test,NULL);
}
#endif 


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_jump_to
 * DESCRIPTION
 *  Entry Function for jumpTo
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_jump_to(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __COSMOS_MMI_PACKAGE__
    mmi_id inline_id = GRP_ID_INVALID;
#endif 
    cui_inline_struct inline_struct = {0};
    cui_inline_item_softkey_struct softkey_struct = {{
        {STR_GLOBAL_OK, 0},
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},
        {0, CUI_INLINE_SOFTKEY_DEFAULT_VALUE}}};
    cui_inline_item_caption_struct jump_to_input_line_caption = {STR_JUMP_EBOOK};
    cui_inline_item_caption_struct jump_to_total_line_caption = {STR_EBOOK_TOTAL_LINE_NUMS};
    cui_inline_item_text_edit_struct jump_to_input_line_editor = {0, 0, 0, IMM_INPUT_TYPE_NUMERIC, 0, NULL};
    cui_inline_item_caption_struct jump_to_total_line_display;

    cui_inline_set_item_struct item_struct[EBR_JUMP_INLINE_ITEM_COUNT];

    S32 total_line_num = 0;
    srv_ebr_book_line_info book_line_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    {
        item_struct[0].item_id = MMI_EBR_JUMP_TO_INPUT_LINE_CAPTION_ID;
        item_struct[0].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        item_struct[0].image_id = 0;
        item_struct[0].item_data = &jump_to_input_line_caption;

        item_struct[1].item_id = MMI_EBR_JUMP_TO_INPUT_LINE_EDITOR_ID;
        item_struct[1].item_flag = CUI_INLINE_ITEM_TYPE_TEXT_EDIT;
        item_struct[1].image_id = 0;
        item_struct[1].item_data = &jump_to_input_line_editor;

        item_struct[2].item_id = MMI_EBR_JUMP_TO_TOTAL_LINE_CAPTION_ID;
        item_struct[2].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        item_struct[2].image_id = 0;
        item_struct[2].item_data = &jump_to_total_line_caption;

        item_struct[3].item_id = MMI_EBR_JUMP_TO_TOTAL_LINE_DISPLAY_ID;
        item_struct[3].item_flag = CUI_INLINE_ITEM_TYPE_CAPTION;
        item_struct[3].image_id = 0;
        item_struct[3].item_data = &jump_to_total_line_display;
    }
    memset(g_ebr_app_context_array_p->jump_input_line, 0, sizeof(g_ebr_app_context_array_p->jump_input_line));
    memset(g_ebr_app_context_array_p->jump_total_line, 0, sizeof(g_ebr_app_context_array_p->jump_total_line));
    srv_ebr_book_get_line_info(g_ebr_app_context_array_p->book_id, &book_line_info);
    total_line_num = book_line_info.total_line;

    app_ucs2_itoa(total_line_num, (kal_int8*)g_ebr_app_context_array_p->jump_total_line, 10);
    MMI_ASSERT(mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->jump_total_line) <= (EBR_LINE_NUMBER_BIT_LENGTH - 1));
    g_ebr_app_context_array_p->jump_screen_total_line_num = total_line_num;

    jump_to_input_line_editor.buffer_size = mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->jump_total_line) + 1;
    
    inline_struct.items_count = EBR_JUMP_INLINE_ITEM_COUNT;
    inline_struct.title = STR_JUMP_EBOOK;
    #ifndef __COSMOS_MMI_PACKAGE__
    inline_struct.title_icon = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);
    #endif
    inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP | CUI_INLINE_SCREEN_DISABLE_DONE;
    inline_struct.softkey = &softkey_struct;
    inline_struct.items = item_struct;
    inline_id = cui_inline_create(GRP_ID_EBOOK_OPEN_BOOK, &inline_struct);
    cui_inline_set_value(inline_id, MMI_EBR_JUMP_TO_TOTAL_LINE_DISPLAY_ID, g_ebr_app_context_array_p->jump_total_line);
    cui_inline_run(inline_id);
#ifdef __COSMOS_MMI_PACKAGE__
//     SetKeyHandler(mmi_ebr_open_jump_to_proc1, KEY_BACK, KEY_EVENT_UP);//by min 12.19
//     wgui_inputs_ml_set_register_up_down_key_funcptr(resgister_ebook_key);
	//	MMI_CAT_SET_KEY_PROC(mmi_ebr_open_jump_to_proc_test,NULL);
#endif 
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_close_book
 * DESCRIPTION
 *  Entry Function for Close
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_close_book(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_ebr_app_context_array_p->auto_scroll)
    {
        srv_backlight_turn_off();
    }
    mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
    return;
}

#ifdef __EBOOK_SEARCH_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_ebook_search_string_from_shorcut_key
 * DESCRIPTION
 *  Enter search string from shortcut key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_ebook_search_string_from_shorcut_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ebr_app_context_array_p->search_string_from_short_key_flag = MMI_TRUE;
    mmi_ebr_entry_search_string();
    g_ebr_app_context_array_p->search_string_from_short_key_flag = MMI_FALSE;
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_search_string
 * DESCRIPTION
 *  Entry Function for search option Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_search_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id search_option_id = GRP_ID_INVALID;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    /* if enter from shortcut key, create a new option cui */
    if (MMI_TRUE == g_ebr_app_context_array_p->search_string_from_short_key_flag)
    {
        search_option_id = cui_menu_create(
                                GRP_ID_EBOOK_OPEN_BOOK, 
                                CUI_MENU_SRC_TYPE_APPCREATE, 
                                CUI_MENU_TYPE_OPTION, 
                                MENU_ID_EBK_FIND, 
                                MMI_FALSE, 
                                g_ebr_app_context_array_p);
        cui_menu_run(search_option_id);
    }
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_ebook_search_string
 * DESCRIPTION
 *  Set highlight handler for Menu Ooptions
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_ebook_search_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 input_buffer_length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    input_buffer_length = (sizeof(g_ebr_app_context_array_p->search_string) / ENCODING_LENGTH);
    g_ebr_app_context_array_p->search_fseditor_id = cui_fseditor_create(GRP_ID_EBOOK_OPEN_BOOK);
    cui_fseditor_set_title(g_ebr_app_context_array_p->search_fseditor_id, STR_FIND_EBOOK, GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID));
    cui_fseditor_set_text(
        g_ebr_app_context_array_p->search_fseditor_id, 
        (WCHAR*)g_ebr_app_context_array_p->search_string, 
        sizeof(g_ebr_app_context_array_p->search_string), 
        input_buffer_length - 1);
    cui_fseditor_set_input_method(
        g_ebr_app_context_array_p->search_fseditor_id, 
        IMM_INPUT_TYPE_SENTENCE, 
        NULL, 
        INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL);
    cui_fseditor_run(g_ebr_app_context_array_p->search_fseditor_id);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_exit_ebook_search_string
 * DESCRIPTION
 *  exit handler of input search string screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_exit_ebook_search_string(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/       
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_search_string
 * DESCRIPTION
 *  Function for Search
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_search_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_length = 0;
    srv_ebr_book_line_info book_line_info;
    CHAR *p_search_string = NULL;
    srv_ebr_book_search_result search_result;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)   
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    /* translate the string cluster */
    {
        str_length = mmi_ucs2strlen(g_ebr_app_context_array_p->search_string);
        str_length = mmi_lm_cluster_translate((U16*)g_ebr_app_context_array_p->search_string, str_length);
        g_ebr_app_context_array_p->search_string[str_length * 2] = 0;
        g_ebr_app_context_array_p->search_string[str_length * 2 + 1] = 0;
    }
        
    p_search_string = g_ebr_app_context_array_p->search_string;
    
    mmi_ucs2cpy(g_ebr_app_context_array_p->last_search_string, p_search_string);

    str_length = mmi_ucs2strlen((const CHAR*)p_search_string);
    if (str_length == 0)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_EMPTY), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }

    mmi_frm_scrn_first_enter(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_WAITSCREEN, (FuncPtr)mmi_ebr_app_show_waiting_screen, g_ebr_app_context_array_p);
    
    book_line_info.start_line = g_ebr_app_context_array_p->screen_disply_info.start_line_index;
    if (MMI_TRUE == mmi_ebr_get_ebook_screen_highlight())
    {
        book_line_info.start_line_offset = g_ebr_app_context_array_p->screen_disply_info.highlight_offset + 1;
    }
    else
    {
        book_line_info.start_line_offset = 0;
    }

    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_SEARCH_STRING, book_line_info.start_line, book_line_info.start_line_offset);
    if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_search(
                                        g_ebr_app_context_array_p->book_id,
                                        g_ebr_app_context_array_p->search_string_type, 
                                        p_search_string,
                                        book_line_info.start_line,
                                        book_line_info.start_line_offset,
                                        mmi_ebr_search_complete_hdlr))
    {
        search_result.book_id = g_ebr_app_context_array_p->book_id;
        search_result.search_result = SRV_EBR_OP_RESULT_FAILURE;
        search_result.offset = 0;
        mmi_ebr_search_complete_hdlr(&search_result);
    }
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_search_string_next
 * DESCRIPTION
 *  called when find next is executed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_search_string_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_INDIC_ALG__
    MMI_BOOL full_character;
#endif 
    srv_ebr_book_line_info book_line_info;
    CHAR *p_search_string = NULL;
    srv_ebr_book_search_result search_result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)   
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    
    p_search_string = g_ebr_app_context_array_p->search_string;

#ifdef __MMI_INDIC_ALG__
    full_character = mmi_ebr_check_for_full_characters((S16*)p_search_string);
    if (!full_character)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_INCOMPLETE_SEARCH_STRING), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
#endif /* __MMI_INDIC_ALG__ */ 

    mmi_frm_scrn_first_enter(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_WAITSCREEN, (FuncPtr)mmi_ebr_app_show_waiting_screen, g_ebr_app_context_array_p);

    book_line_info.start_line = g_ebr_app_context_array_p->screen_disply_info.start_line_index;
    if (MMI_TRUE == mmi_ebr_get_ebook_screen_highlight())
    {
        book_line_info.start_line_offset = g_ebr_app_context_array_p->screen_disply_info.highlight_offset + 1;
    }
    else
    {
        book_line_info.start_line_offset = 0;
    }
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_SEARCH_STRING_NEXT, book_line_info.start_line, book_line_info.start_line_offset);
    if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_search(
                                        g_ebr_app_context_array_p->book_id,
                                        g_ebr_app_context_array_p->search_string_type, 
                                        p_search_string,
                                        book_line_info.start_line,
                                        book_line_info.start_line_offset,
                                        mmi_ebr_search_complete_hdlr))
    {
        search_result.book_id = g_ebr_app_context_array_p->book_id;
        search_result.search_result = SRV_EBR_OP_RESULT_FAILURE;
        search_result.offset = 0;
        mmi_ebr_search_complete_hdlr(&search_result);
    }

end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_search_complete_hdlr
 * DESCRIPTION
 *  The callback handler which handles the search complete result
 * PARAMETERS
 *  search_result     [IN] the search complete result
 *  offset            [IN] if the string is searched, offset identifies the 
 *                         string's offset from file header
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_search_complete_hdlr(srv_ebr_book_search_result *search_result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GRP_ID_EBOOK_OPEN_BOOK == mmi_frm_group_get_active_id())
    {
        if (SRV_EBR_OP_RESULT_SUCCESS == search_result->search_result)
        {   
            g_ebr_app_context_array_p->auto_scroll = MMI_FALSE;
            g_ebr_app_context_array_p->search_found_flag = MMI_TRUE;
        }
        else if (SRV_EBR_OP_RESULT_FAILURE == search_result->search_result)
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_EBOOK_SEARCH_UN_SUCESSFULL), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_OPEN_BOOK, 
                0);
        }
        else 
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_EBOOK_SEARCH_INVALID), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_OPEN_BOOK, 
                0);
        }
    }
    mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_WAITSCREEN);
    return;
}

#endif /*__EBOOK_SEARCH_SUPPORT__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_book_options
 * DESCRIPTION
 *  Entry book options list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_book_options(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id menu_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    menu_id = cui_menu_create(
                    GRP_ID_EBOOK_OPEN_BOOK, 
                    CUI_MENU_SRC_TYPE_APPCREATE, 
                    CUI_MENU_TYPE_OPTION, 
                    MENU_ID_EBK_OPEN_OPTIONS, 
                    MMI_FALSE, 
                    NULL);
    if(g_ebr_app_context_array_p->state == MMI_EBR_APP_STATE_CONVERTING)
    {
        cui_menu_set_item_disabled(menu_id, MENU_ID_EBK_GOTO_BOOKMARK, MMI_TRUE);
    }
    cui_menu_run(menu_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_delete_ebook
 * DESCRIPTION
 *  Entry Function for Delete Book Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_delete_ebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 return_type = 0;
    mmi_ebr_app_book_info *p_open_book_info = NULL, *p_highlight_book_info = NULL;
    MMI_ID_TYPE string_id = 0;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
    p_highlight_book_info = &g_ebr_app_context_array_p->highlight_book_info;

    return_type = srv_ebr_bookshelf_delete_book(g_ebr_app_context_array_p->bookshelf_id, (CHAR*)p_highlight_book_info->book_name);
    
    if (return_type < 0)
    {
        string_id = srv_fmgr_fs_error_get_string(return_type);

        mmi_popup_display_simple(
            (WCHAR*)GetString(string_id), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_BOOKSHELF, 
            0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_help
 * DESCRIPTION
 *  Entry Function for Help Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_help(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GRP_ID_EBOOK_OPEN_BOOK == mmi_frm_group_get_active_id())
    {
        mmi_frm_scrn_first_enter(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_HELP_SCREEN, (FuncPtr)mmi_ebr_app_entry_help_screen, NULL);
    }
    else
    {
        mmi_frm_scrn_first_enter(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_HELP_SCREEN, (FuncPtr)mmi_ebr_app_entry_help_screen, NULL);
    }
    return;
}


#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_set_key_TS
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void              
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_set_key_TS(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (c)
    {
        case '1':
        {
            mmi_ebr_app_toggle_screen_mode();    
            break;
        }

        case '2':
        {
            mmi_ebr_entry_jump_to();
            break;
        }

        case '3':
        {
            mmi_ebr_entry_add_book_mark();
            break;
        }
        
        case '4':
        {
            mmi_ebr_entry_goto_book_mark();
            break;
        }

        case '5':
        {
            mmi_ebr_entry_remove_book_mark();
            break;
        }

        case '6':
        {
            mmi_ebr_app_toggle_scroll_mode();
            break;
        } 
#ifdef  __EBOOK_SEARCH_SUPPORT__
        case '7':
        {
            mmi_ebr_ebook_search_string_from_shorcut_key();
            break;
        }

        case '8':
        {
            if ((mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->search_string)) && 
                (MMI_TRUE != g_ebr_app_context_array_p->auto_scroll))
            {
                mmi_ebr_app_search_string_next();
            }
            break;
        }
#endif /*__EBOOK_SEARCH_SUPPORT__*/
        case '9':
        {
            mmi_ebr_entry_help();
            break;
        }
            
        default:
            break;
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_mmi_ebook_exit
 * DESCRIPTION
 *  exit function for Open Book
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_mmi_ebook_exit(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_MMI_EBOOK_EXIT);
    if (g_ebr_app_context_array_p->book_id < 0)
	{
		return;
	}
    srv_backlight_turn_off();
    srv_ebr_book_set_convert_speed(g_ebr_app_context_array_p->book_id, SRV_EBR_BOOK_CONVERT_SPEED_SLOW);
    if (MMI_TRUE == mmi_ebr_get_ebook_screen_highlight())
    {
        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_duplicate_book_mark_pop_up
 * DESCRIPTION
 *  Pop Up for Duplicate Book mark
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_duplicate_book_mark_pop_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct confirm_struct;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
    confirm_struct.parent_id = GRP_ID_EBOOK_OPEN_BOOK;
    confirm_struct.user_tag = (void*)MMI_EBR_BOOK_ALERT_TYPE_DUPLICATED_BOOKMARK;
    mmi_confirm_display(
        (WCHAR*)GetString(STR_DUPLICATE_BOOK_MARK), 
        MMI_EVENT_QUERY, 
        &confirm_struct);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_duplicate_book_mark_add
 * DESCRIPTION
 *  The function of adding the duplicated book_mark
 * PARAMETERS
 *  book_mark_name    [IN] the name of the book_mark
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_duplicate_book_mark_add(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_book_line_info book_line_info;
    srv_ebr_book_bookmark_struct bookmark;
    MMI_BOOL add_book_mark_result;
    S32 bookmark_id = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_DUPLICATE_BOOK_MARK_ADD);
    if (SRV_EBR_OP_RESULT_FAILURE == srv_ebr_book_delete_bookmark(
                                        g_ebr_app_context_array_p->book_id, 
                                        g_ebr_app_context_array_p->bookmark_id_array[g_ebr_app_context_array_p->current_select_bookmark]))
    {
        add_book_mark_result = MMI_FALSE;
        goto end;
    }
    srv_ebr_book_get_line_info(g_ebr_app_context_array_p->book_id, &book_line_info);
    bookmark.start_line = book_line_info.start_line;
    memcpy(bookmark.bookmark_name, g_ebr_app_context_array_p->input_bookmark_name, sizeof(g_ebr_app_context_array_p->input_bookmark_name));
    bookmark_id = srv_ebr_book_add_bookmark(g_ebr_app_context_array_p->book_id, &bookmark);
    if (bookmark_id >= 0)
    {
        add_book_mark_result = MMI_TRUE;
    }
    else
    {
        add_book_mark_result = MMI_FALSE;
    }
end:
    mmi_ebr_app_display_adding_book_mark_popup(add_book_mark_result);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_display_adding_book_mark_popup
 * DESCRIPTION
 *  Pop Up for Book Mark added.
 * PARAMETERS
 *  adding_book_mark     [IN] result of adding book_mark
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_display_adding_book_mark_popup(MMI_BOOL adding_book_mark)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(MMI_TRUE != adding_book_mark)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_BOOKMARK_ADD_FAIL), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
	else
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_BOOKMARK_ADDED), 
            MMI_EVENT_SUCCESS, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_display_pop_up_changed_screen_mode
 * DESCRIPTION
 *  Pop Up for Screen mode changed.
 * PARAMETERS
 *  screen_mode     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_display_pop_up_changed_screen_mode(MMI_BOOL screen_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE string_id = 0;
    mmi_event_notify_enum event_id = MMI_EVENT_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_FALSE == screen_mode)
    {
        string_id = STR_FULL_SCREEN_OFF;
        event_id = MMI_EVENT_SUCCESS;
    }
    else if (MMI_TRUE == screen_mode)
    {
        string_id = STR_FULL_SCREEN_ON;
        event_id = MMI_EVENT_SUCCESS;
    }
    mmi_popup_display_simple(
        (WCHAR*)GetString(string_id), 
        event_id, 
        GRP_ID_EBOOK_OPEN_BOOK, 
        0);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_display_pop_up_changed_auto_scroll
 * DESCRIPTION
 *  Pop Up for Auto Scroll changed.
 * PARAMETERS
 *  auto_scroll_mode        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_display_pop_up_changed_auto_scroll(MMI_BOOL auto_scroll_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE string_id = 0;
    mmi_event_notify_enum event_id = MMI_EVENT_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_FALSE == auto_scroll_mode)
    {
        string_id = STR_AUTO_SCROLL_OFF;
        event_id = MMI_EVENT_SUCCESS;
    }
    else if (MMI_TRUE == auto_scroll_mode)
    {
        string_id = STR_AUTO_SCROLL_ON;
        event_id = MMI_EVENT_SUCCESS;
    }
    mmi_popup_display_simple(
        (WCHAR*)GetString(string_id), 
        event_id, 
        GRP_ID_EBOOK_OPEN_BOOK, 
        0);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_select_drive
 * DESCRIPTION
 *  Enter the select drive screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_select_drive(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id storage_selector_id = GRP_ID_INVALID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    storage_selector_id = cui_storage_selector_create(
                            GRP_ID_EBOOK_BOOKSHELF, 
                            g_ebr_app_context_array_p->select_bookshelf_drive,
                            0);
    cui_storage_selector_run(storage_selector_id);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_gui_reset_auto_scroll
 * DESCRIPTION
 *  Reset auto scroll, called by mulitiline category
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_gui_reset_auto_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_reset_auto_scroll_result *reset_struct = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GUI_RESET_AUTO_SCROLL);

    g_ebr_app_context_array_p->auto_scroll = MMI_FALSE;
    
    reset_struct = (mmi_ebr_reset_auto_scroll_result *)OslConstructDataPtr(sizeof(mmi_ebr_reset_auto_scroll_result));
    reset_struct->result = 0;

	msg_send5(MOD_MMI, MOD_MMI, 0, MSG_ID_MMI_EBOOK_RESET_AUTO_SCROLL_IND, (local_para_struct*)reset_struct);
    srv_backlight_turn_off();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_reset_auto_scroll_handler
 * DESCRIPTION
 *  The handler of MSG_ID_MMI_EBOOK_RESET_AUTO_SCROLL_IND
 * PARAMETERS
 *  arg    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_reset_auto_scroll_handler(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_reset_auto_scroll_result *reset_struct = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_RESET_AUTO_SCROLL_HANDLER_LOG1);
    reset_struct = (mmi_ebr_reset_auto_scroll_result *)arg;
    if (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id())
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_RESET_AUTO_SCROLL_HANDLER_LOG2);
        mmi_ebr_app_display_pop_up_changed_auto_scroll(reset_struct->result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_conversion_complete_handler
 * DESCRIPTION
 *  The handler of MSG_ID_MMI_EBOOK_CONVERSION_COMPLETE_IND
 * PARAMETERS
 *  arg    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_conversion_complete_handler(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_CONVERSION_COMPLETE_HANDLER_LOG1);
    if (SCR_ID_EBOOK_BOOK_SETTINGS_SCREENID == mmi_frm_scrn_get_active_id())
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_CONVERSION_COMPLETE_HANDLER_LOG2);        
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_CONVERTING_COMPLETED), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
}


/* new feature */
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_show_book_info_screen
 * DESCRIPTION
 *  Show the book info screen
 * PARAMETERS
 *  display_name   [IN] the display name of the ebook
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_show_book_info_screen(mmi_ebr_app_book_info *p_book_info, wgui_ml_line_base_info **p_line_base_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 lsk = STR_GLOBAL_OPTIONS;
    U16 rsk = STR_GLOBAL_BACK;
    S16 full_screen = 0; 
    S16 auto_scroll_staus = 0;

    S32 strlength = 0;
    WCHAR display_name[SRV_EBR_MAX_FILE_LEN + 1];
    mmi_ebr_app_book_info *p_open_book_info = NULL;
    WCHAR *p_book_full_path_name = NULL;
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    U8 *content_icon[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT];
    U8 *disabled_content_icon[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT];
    U8 *content_string[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT];
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    full_screen = g_ebr_app_context_array_p->full_screen;
    auto_scroll_staus = g_ebr_app_context_array_p->auto_scroll;

    
    if (auto_scroll_staus)
    {
        srv_backlight_turn_on(0);
    }

    strlength = mmi_wcslen((const WCHAR*)p_book_info->book_name);
    
    /* 1 identifies the ".", eg: "ab.txt" -> "ab" */
    
    mmi_wcsncpy(
        display_name,
        (const WCHAR*)p_book_info->book_name,
        strlength - SRV_EBR_EXTENSION_NAME_LENGTH - 1);   

#if defined(__MMI_ICON_BAR_SUPPORT__)
#ifdef __COSMOS_MMI_PACKAGE__
content_icon[0] = (U8*)GetImage(IMAGE_EBOOK_BOOKMARK_LIST);

#else
    content_icon[0] = (U8*)GetImage(IMG_GLOBAL_TOOLBAR_BOOKMARK);
#endif
    content_string[0] = (U8*)GetString(STR_ID_EBOOK_FTE_BOOKMARK_LIST);
    disabled_content_icon[0] = NULL;
    
    if (1 == full_screen)
    {
        content_string[1] = (U8*)GetString(STR_FULL_SCREEN_OFF);
        content_icon[1] = (U8*)GetImage(IMAGE_EBOOK_FTE_NORMAL_SCREEN);
    }
    else
    {
        content_string[1] = (U8*)GetString(STR_FULL_SCREEN_ON);
        content_icon[1] = (U8*)GetImage(IMAGE_EBOOK_FTE_FULL_SCREEN);
    }
    disabled_content_icon[1] = NULL;
    
    content_icon[2] = (U8*)GetImage(IMAGE_EBOOK_FTE_AUTO_SCROLL);
    if (1 == auto_scroll_staus)
    {
        content_string[2] = (U8*)GetString(STR_AUTO_SCROLL_OFF);
    }
    else
    {
        content_string[2] = (U8*)GetString(STR_AUTO_SCROLL_ON);
    }
    disabled_content_icon[2] = NULL;
	
#ifdef  __EBOOK_SEARCH_SUPPORT__
    content_icon[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT - 1] = (U8*)GetImage(IMG_GLOBAL_TOOLBAR_SEARCH);
    content_string[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT - 1] = (U8*)GetString(STR_FIND_EBOOK);
    disabled_content_icon[FTE_OPEN_BOOK_SCREEN_ITEM_COUNT - 1] = (U8*)GetImage(IMG_GLOBAL_TOOLBAR_SEARCH_DISABLED);
#endif

    wgui_icon_bar_setup(
        FTE_OPEN_BOOK_SCREEN_ITEM_COUNT, 
        content_icon, 
        disabled_content_icon, 
        content_string, 
        mmi_ebr_open_book_fte_toolbar_command);

    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
    {
#ifdef  __EBOOK_SEARCH_SUPPORT__		
        wgui_icon_bar_set_item_enable_state(FTE_OPEN_BOOK_SCREEN_ITEM_COUNT - 1, MMI_FALSE);
#endif
    }
#endif /* defined(__MMI_ICON_BAR_SUPPORT__)*/

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    if (full_screen)
    {
        lsk = 0;
        rsk = 0;
    }
    wgui_cat3003_show(
        display_name, 
        p_book_info->icon_id, 
        lsk, 
        IMG_GLOBAL_OK, 
        rsk, 
        IMG_GLOBAL_BACK, 
        NULL, 
        mmi_ebr_gui_reset_auto_scroll,
        p_line_base_info,
        full_screen);

    /* entry full screen show icon bar */
    if (full_screen)
    {
        wgui_cat3003_show_floating_iconbar();
	    SetKeyHandler(mmi_ebr_entry_book_options, KEY_LSK, KEY_EVENT_UP);
        SetKeyHandler(mmi_ebr_app_toggle_screen_mode, KEY_RSK, KEY_EVENT_UP);
    }
    else
    {
        SetLeftSoftkeyFunction(mmi_ebr_entry_book_options, KEY_EVENT_UP);
        SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    }
    wgui_cat3003_register_pen_event_handler(
        mmi_ebr_open_book_fte_tap_callback, 
        mmi_ebr_open_book_fte_move_callback,
        mmi_ebr_open_book_fte_pen_down_icon_bar_callback,
        mmi_ebr_open_book_fte_pen_up_icon_bar_callback);
    
    wgui_cat3003_show_counter();

    if (full_screen || (MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state))
    {
        StartTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER, MMI_EBR_OPEN_BOOK_FTE_TIME_DURATION, mmi_ebr_open_book_fte_timeout_handler);
    }

#else /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    ShowCategory375Screen(
        display_name, 
        p_book_info->icon_id, 
        lsk, 
        IMG_GLOBAL_OK, 
        STR_GLOBAL_BACK, 
        IMG_GLOBAL_BACK, 
        NULL, 
        mmi_ebr_gui_reset_auto_scroll,
        p_line_base_info,
        full_screen);

    if (!full_screen)
    {
        SetLeftSoftkeyFunction(mmi_ebr_entry_book_options, KEY_EVENT_UP);
        SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_ebr_entry_book_options, KEY_EVENT_UP);
    }
    else
    {
        mmi_key_types_enum key_type = KEY_FULL_PRESS_DOWN;
        SetKeyHandler(mmi_ebr_entry_book_options, KEY_LSK, KEY_EVENT_UP);
        SetKeyHandler(mmi_frm_scrn_close_active_id, KEY_RSK, KEY_EVENT_UP);
        for (key_type = KEY_FULL_PRESS_DOWN; key_type < MAX_KEY_TYPE; key_type++)
        {
            SetKeyHandler(NULL, KEY_CSK, key_type);
        }
        SetKeyHandler(mmi_ebr_entry_book_options, KEY_CSK, KEY_EVENT_UP);
    }
    
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */

    register_multiline_inputbox_navigate_callback(mmi_ebr_multiline_inputbox_navigate_callback);

    p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
    p_book_full_path_name = mmi_ebr_app_malloc_memory(SRV_EBR_MAX_PATH_LEN * sizeof(WCHAR));
    mmi_wcscpy(p_book_full_path_name, p_open_book_info->book_path);
    mmi_wcscat(p_book_full_path_name, p_open_book_info->book_name);
    
    SetKeyHandler(mmi_ebr_app_toggle_screen_mode, KEY_1, KEY_EVENT_UP);
    SetKeyHandler(mmi_ebr_entry_jump_to, KEY_2, KEY_EVENT_UP);
    SetKeyHandler(mmi_ebr_entry_add_book_mark, KEY_3, KEY_EVENT_UP);
    SetKeyHandler(mmi_ebr_entry_goto_book_mark, KEY_4, KEY_EVENT_UP);
    SetKeyHandler(mmi_ebr_entry_remove_book_mark, KEY_5, KEY_EVENT_UP);
    SetKeyHandler(mmi_ebr_app_toggle_scroll_mode, KEY_6, KEY_EVENT_UP);
    
#ifdef  __EBOOK_SEARCH_SUPPORT__   
    if (mmi_ucs2cmp((const CHAR*)g_ebr_app_context_array_p->search_string_book_name, (const CHAR*)p_book_full_path_name))
    {
        memset(g_ebr_app_context_array_p->search_string, 0x00, sizeof(g_ebr_app_context_array_p->search_string));
        memset(g_ebr_app_context_array_p->last_search_string, 0x00, sizeof(g_ebr_app_context_array_p->last_search_string));
        memset(g_ebr_app_context_array_p->search_string_book_name, 0x00, sizeof(g_ebr_app_context_array_p->search_string_book_name));
        mmi_ucs2cpy(g_ebr_app_context_array_p->search_string_book_name, (const CHAR*)p_book_full_path_name);
    }

    SetKeyHandler(mmi_ebr_ebook_search_string_from_shorcut_key, KEY_7, KEY_EVENT_UP);
    if ((mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->search_string)) && !auto_scroll_staus)
    {
        SetKeyHandler(mmi_ebr_app_search_string_next, KEY_8, KEY_EVENT_UP);
    }
#endif  /*__EBOOK_SEARCH_SUPPORT__*/
    SetKeyHandler(mmi_ebr_entry_help, KEY_9, KEY_EVENT_UP);

    mmi_ebr_app_free_memory((void **)&p_book_full_path_name);  
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_multiline_inputbox_navigate_callback
 * DESCRIPTION
 *  The callback when scolling the multiline_inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_multiline_inputbox_navigate_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_MULTILINE_INPUTBOX_NAVIGATE_CALLBACK);
    g_ebr_app_context_array_p->screen_disply_info.b_highlight = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_book_shelf_normal_flow
 * DESCRIPTION
 *  The normal flow of entrying the bookshelf
 * PARAMETERS
 *  bookshelf_path  [IN] The path of bookshelf
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_book_shelf_normal_flow(CHAR *bookshelf_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILTER filter = {0};
    U32 option_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_FILTER_INIT(&filter);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_TXT);
	FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_TXZ);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_NF2);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_LTS);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_LTM);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_EBOOK_LTL);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_FOLDER);
   
#ifndef __COSMOS_MMI_PACKAGE__   
    g_ebr_app_context_array_p->folder_browser_id = cui_folder_browser_create(
                                                    GRP_ID_EBOOK_BOOKSHELF, 
                                                    (const WCHAR*)bookshelf_path, 
                                                    (const FMGR_FILTER*)&filter, 
                                                    option_flag, 
                                                    MENU_ID_EBK_BOOKSHELF_OPTION, 
                                                    MENU_ID_EBK_LIMITED_BOOKSHELF_OPTION);
    cui_folder_browser_set_title(g_ebr_app_context_array_p->folder_browser_id, EBOOK_TITLE_BOOKSHELF, GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID));
    cui_folder_browser_run(g_ebr_app_context_array_p->folder_browser_id);

    #else
    #if 1
    vapp_fmgr_launch_by_app((const WCHAR*)bookshelf_path, &filter);
    #else
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    #endif
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_book_shelf_lsk_handler
 * DESCRIPTION
 *  The left soft key handler of bookshelf screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_book_shelf_lsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_BOOK_SHELF_LSK_HANDLER);
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_BOOKSHELF, 
                        SCR_ID_EBOOK_BOOKSHELF_SCREENID, 
                        NULL, 
                        mmi_ebr_app_entry_bookshelf, 
                        MMI_FRM_FULL_SCRN))
    {
        mmi_frm_scrn_set_leave_proc(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_BOOKSHELF_SCREENID, mmi_ebr_app_entry_bookshelf_screen_proc);

        gdi_layer_lock_frame_buffer();
        mmi_ebr_entry_book_shelf_normal_flow(g_ebr_app_context_array_p->bookshelf_path);
        gdi_layer_unlock_frame_buffer();

        memcpy(
            &g_ebr_app_context_array_p->highlight_book_info,
            &g_ebr_app_context_array_p->open_book_info,
            sizeof(mmi_ebr_app_book_info));
        
        mmi_ebr_app_open_book_launch(GRP_ID_EBOOK_BOOKSHELF);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_book_shelf_rsk_handler
 * DESCRIPTION
 *  The right soft key handler of bookshelf screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_book_shelf_rsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ENTRY_BOOK_SHELF_RSK_HANDLER);
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_BOOKSHELF, 
                        SCR_ID_EBOOK_BOOKSHELF_SCREENID, 
                        NULL, 
                        mmi_ebr_app_entry_bookshelf, 
                        MMI_FRM_FULL_SCRN))
    {
        mmi_frm_scrn_set_leave_proc(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_BOOKSHELF_SCREENID, mmi_ebr_app_entry_bookshelf_screen_proc);

        mmi_ebr_entry_book_shelf_normal_flow(g_ebr_app_context_array_p->bookshelf_path);
    }
    return;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_fs_op_error_handler
 * DESCRIPTION
 *  The error handler about file system operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_fs_op_error_handler(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ebr_book_convert_error_struct *convert_error = NULL;
    MMI_BOOL popup_flag = MMI_TRUE;
    U16 string_id = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_FS_OP_ERROR_HANDLER_LOG1, g_ebr_app_context_array_p->state, arg);

#ifdef __DM_LAWMO_SUPPORT__
    if (TRUE == mmi_dmui_is_phone_lock())        
    {
        popup_flag = MMI_FALSE;
    }
#endif /* __DM_LAWMO_SUPPORT__ */
    if (MMI_TRUE == popup_flag)
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_FS_OP_ERROR_HANDLER_LOG2);
        if (NULL != arg)
        {
            convert_error = (mmi_ebr_book_convert_error_struct *)arg;
            if (FS_DISK_FULL == convert_error->fs_error)
            {
                string_id = STR_GLOBAL_NOT_ENOUGH_MEMORY;
            }
            else
            {
                string_id = STR_EBOOK_FS_OP_ERROR;
            }
        }
        else
        {
            string_id = STR_EBOOK_FS_OP_ERROR;
        }
        mmi_frm_nmgr_popup(MMI_SCENARIO_ID_EBR_FS_OP_ERR, MMI_EVENT_FAILURE, (WCHAR *)GetString(string_id));
    }

	if(g_ebr_app_context_array_p)
	{
	    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
	    {
	        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
	        {
	            g_ebr_app_context_array_p->book_id = -1;
	            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
	            memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
	        }
	        if ((MMI_FALSE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF)) &&
	            (g_ebr_app_context_array_p->bookshelf_id >= 0))
	        {
	            if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
	            {
	                g_ebr_app_context_array_p->bookshelf_id = -1;
	            }
	        }
	    }
	    g_ebr_app_context_array_p->send_error_msg_flag = MMI_TRUE;
		mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_display_stop_converting_confirm
 * DESCRIPTION
 *  Display the stop converting ebook confirm
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_display_stop_converting_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct confirm_struct;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&confirm_struct, CNFM_TYPE_YESNO);
    confirm_struct.parent_id = GRP_ID_EBOOK_OPEN_BOOK;
    confirm_struct.user_tag = (void*)MMI_EBR_BOOK_ALERT_TYPE_STOP_CONVERTING_EBOOK;
    mmi_confirm_display(
        (WCHAR*)GetString(STR_EBOOK_IS_STOPING_CONVERTING), 
        MMI_EVENT_QUERY, 
        &confirm_struct);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_stop_converting_confirm_lsk_handler
 * DESCRIPTION
 *  The left soft key handler of the stop converting ebook confirm
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_stop_converting_confirm_lsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_node_struct open_book_struct;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_STOP_CONVERTING_CONFIRM_LSK_HANDLER);
    if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
    {
        g_ebr_app_context_array_p->book_id = -1;
        g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
        memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_SUCCESS), 
            MMI_EVENT_SUCCESS, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        open_book_struct.id = SCR_ID_EBOOK_OPEN_SCREENID;
//        open_book_struct.entry_proc = (mmi_proc_func)mmi_ebr_app_entry_open_book;
        open_book_struct.entry_proc = (mmi_proc_func)mmi_ebr_app_entry_async_open_book;
        open_book_struct.user_data = g_ebr_app_context_array_p;
        mmi_frm_scrn_insert(GRP_ID_EBOOK_OPEN_BOOK, mmi_frm_scrn_get_active_id(), &open_book_struct, MMI_FRM_NODE_BEFORE_FLAG);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_stop_converting_confirm_rsk_handler
 * DESCRIPTION
 *  The right soft key handler of the stop converting ebook confirm
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_stop_converting_confirm_rsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_STOP_CONVERTING_CONFIRM_RSK_HANDLER);
    mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
}


#ifdef __MMI_INDIC_ALG__
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_check_for_full_characters
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pattern     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_ebr_check_for_full_characters(S16 *pattern)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IRE_IS_CHAR_TYPE_HALANT(pattern[mmi_ucs2strlen((const CHAR*)pattern) - 1]))
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}
#endif /*__MMI_INDIC_ALG__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_get_open_result_code_string_id
 * DESCRIPTION
 *  Get the matched string id for the opening book result 
 * PARAMETERS
 *  result_code  [IN] the result of opening book
 * RETURNS
 *  U16 : the string id 
 *****************************************************************************/
U16 mmi_ebr_get_open_result_code_string_id(srv_ebr_book_open_error_enum result_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 string_id = STR_ERROR_OPENINIG_BOOK;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(result_code)
    {
        case SRV_EBR_BOOk_OPEN_ERROR_FIYE_TYPE_NOT_SUPPORTED:
        {
            string_id = STR_GLOBAL_INVALID_FORMAT;
            break;
        }
        case SRV_EBR_BOOk_OPEN_ERROR_FIYE_EMPTY:
        {
            string_id = STR_GLOBAL_EMPTY;
            break;
        }
        case SRV_EBR_BOOK_OPEN_ERROR_MEMORY_NOT_ENOUGH:
        {
            string_id = STR_GLOBAL_NOT_ENOUGH_MEMORY;
            break;
        }
        default:
        {
            string_id = STR_ERROR_OPENINIG_BOOK;
            break;
        }
    }
    return string_id;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_refresh_bookshelf_complete_handler
 * DESCRIPTION
 *  The callback function when refreshing bookshelf completely
 * PARAMETERS
 *  operation_result  [IN] the refresh result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_refresh_bookshelf_complete_handler(srv_ebr_bookshelf_refresh_result_struct *operation_result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((GRP_ID_EBOOK_BOOKSHELF == mmi_frm_group_get_active_id()) &&
        (SCR_ID_EBOOK_WAITSCREEN == mmi_frm_scrn_get_active_id()))
    {
        if (SRV_EBR_OP_RESULT_SUCCESS == operation_result->refresh_result)
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_BOOK_SHELF_REFRESHED), 
                MMI_EVENT_SUCCESS, 
                GRP_ID_EBOOK_BOOKSHELF, 
                0);
        }
        else if (SRV_EBR_OP_RESULT_FAILURE == operation_result->refresh_result)
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_BOOK_SHELF_REFRESH_FAILED), 
                MMI_EVENT_FAILURE, 
                GRP_ID_EBOOK_BOOKSHELF, 
                0);
        }
        else if (SRV_EBR_OP_RESULT_CANCELLED == operation_result->refresh_result)
        {
            mmi_popup_display_simple(
                (WCHAR*)GetString(STR_EBOOK_CANCELLED), 
                MMI_EVENT_SUCCESS, 
                GRP_ID_EBOOK_BOOKSHELF, 
                0);
        }
    }
    mmi_frm_scrn_close(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_WAITSCREEN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_toggle_screen_mode
 * DESCRIPTION
 *  Toggle the screen mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_toggle_screen_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL old_screen_mode;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_screen_mode = g_ebr_app_context_array_p->full_screen;
    
    if (MMI_FALSE == old_screen_mode)
    {
        g_ebr_app_context_array_p->full_screen = MMI_TRUE;
    }
    else
    {
        g_ebr_app_context_array_p->full_screen = MMI_FALSE;
    }
    mmi_ebr_app_display_pop_up_changed_screen_mode(g_ebr_app_context_array_p->full_screen);

    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_TOGGLE_SCREEN_MODE, old_screen_mode);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_toggle_scroll_mode
 * DESCRIPTION
 *  Toggle the scroll mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_toggle_scroll_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (MMI_FALSE == g_ebr_app_context_array_p->auto_scroll)
    {
        g_ebr_app_context_array_p->auto_scroll = MMI_TRUE;
    }
    else
    {
        g_ebr_app_context_array_p->auto_scroll = MMI_FALSE;
    }
    mmi_ebr_app_display_pop_up_changed_auto_scroll(g_ebr_app_context_array_p->auto_scroll);
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_TOGGLE_SCROLL_MODE, g_ebr_app_context_array_p->auto_scroll);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_set_gui_page_info
 * DESCRIPTION
 *  Set the wgui paging inforamtion
 * PARAMETERS
 *  p_line_base_info  [IN] the wgui paging inforamtion
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_set_gui_page_info(wgui_ml_line_base_info *p_line_base_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_book_line_info book_line_info;
    srv_ebr_bookshelf_setting p_bookshelf_setting;
	S16 error = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_ebr_book_get_line_info(g_ebr_app_context_array_p->book_id, &book_line_info);
    p_line_base_info->start_line_index = book_line_info.start_line;
    p_line_base_info->highlight_offset = book_line_info.start_line_offset;
    p_line_base_info->total_line_count = book_line_info.total_line;    
    p_line_base_info->highlight_len = mmi_ucs2strlen((const CHAR*)g_ebr_app_context_array_p->search_string);

	ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&p_bookshelf_setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    p_line_base_info->font_size = p_bookshelf_setting.font_size;
    p_line_base_info->scroll_flag = g_ebr_app_context_array_p->auto_scroll;
    p_line_base_info->scroll_speed = p_bookshelf_setting.scroll_speed + 1;
    p_line_base_info->scroll_type = p_bookshelf_setting.scroll_type;
    p_line_base_info->font_style = FONT_DEFAULT;
    p_line_base_info->override_direction = 0;
    p_line_base_info->b_highlight = g_ebr_app_context_array_p->search_found_flag;
    p_line_base_info->jump_to_end = MMI_FALSE;
#ifdef __MMI_TOUCH_SCREEN__
    p_line_base_info->key_callback = mmi_ebr_set_key_TS;
#endif
    p_line_base_info->get_data_cb = mmi_ebr_app_get_view_data_callback;

    g_ebr_app_context_array_p->search_found_flag = MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_get_ebook_screen_highlight
 * DESCRIPTION
 *  Get whether there is a highlight in current screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL :
 *  MMI_TRUE : there is a highlight in current screen
 *  MMI_FALSE: there is not a highlight in current screen
 *****************************************************************************/
MMI_BOOL mmi_ebr_get_ebook_screen_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GET_EBOOK_SCREEN_HIGHLIGHT, g_ebr_app_context_array_p->screen_disply_info.b_highlight);
    return g_ebr_app_context_array_p->screen_disply_info.b_highlight;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_handler
 * DESCRIPTION
 *  The callback function which is registered when opening a book
 * PARAMETERS
 *  operation_enum  [IN] the operation when oping a book
 *  arg             [IN] the argument with operation_enum
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_handler(srv_ebr_open_book_enum operation_enum, void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (operation_enum)
    {
        case SRV_EBR_OPEN_BOOK_REFRESH_SCREEN:
        {
            srv_ebr_book_refresh_screen_struct *p_refresh_screen_struct = (srv_ebr_book_refresh_screen_struct *)arg;
            if ((GRP_ID_EBOOK_OPEN_BOOK == mmi_frm_group_get_active_id()) &&
                (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id()))
            {
                wgui_inputs_ml_set_total_line_count(p_refresh_screen_struct->line_number, MMI_TRUE);
            #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
                wgui_cat3003_update_counter();
            #endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */
            }
            break;
        }
        case SRV_EBR_OPEN_BOOK_CONVERT_RECORD:
        {
            wgui_inputs_ml_set_dirty(MMI_TRUE);
            break;
        }
        case SRV_EBR_OPEN_BOOK_COMPLETE:
        {
            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
            if ((MMI_SCENARIO_STATE_NONE == mmi_frm_group_get_state(GRP_ID_EBOOK_OPEN_BOOK)) &&
                (MMI_SCENARIO_STATE_NONE == mmi_frm_group_get_state(GRP_ID_EBOOK_BOOKSHELF)))
            {
                if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
                {
                    g_ebr_app_context_array_p->book_id = -1;
                    memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
                }
            }

            if ((MMI_SCENARIO_STATE_NONE == mmi_frm_group_get_state(GRP_ID_EBOOK_BOOKSHELF)) &&
                (g_ebr_app_context_array_p->bookshelf_id >= 0))
            {
                if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
                {
                    g_ebr_app_context_array_p->bookshelf_id = -1;
                }
            }

            if (GRP_ID_EBOOK_OPEN_BOOK == mmi_frm_group_get_active_id())
            {
                if (SCR_ID_EBOOK_BOOK_SETTINGS_SCREENID == mmi_frm_scrn_get_active_id())
                {
                    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_CONVERSION_COMPLETE_HANDLER_LOG2);        
                    mmi_popup_display_simple(
                        (WCHAR*)GetString(STR_EBOOK_CONVERTING_COMPLETED), 
                        MMI_EVENT_FAILURE, 
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        0);
                }
            #if defined(__MMI_ICON_BAR_SUPPORT__)
                else if (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id())
                {
                    StartTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER, MMI_EBR_OPEN_BOOK_FTE_TIME_DURATION, mmi_ebr_open_book_fte_timeout_handler);
#ifdef  __EBOOK_SEARCH_SUPPORT__					
                    wgui_icon_bar_set_item_enable_state(FTE_OPEN_BOOK_SCREEN_ITEM_COUNT - 1, MMI_TRUE);
                    wgui_icon_bar_update();
#endif					
                }
            #endif /* defined(__MMI_ICON_BAR_SUPPORT__) */
            }
            break;
        }
        case SRV_EBR_OPEN_BOOK_ERROR:
        {
            if (MMI_TRUE == g_ebr_app_context_array_p->send_error_msg_flag)
            {
                srv_ebr_book_open_error_struct *p_open_error_struct = (srv_ebr_book_open_error_struct *)arg;
                mmi_ebr_book_convert_error_struct *p_convert_error = NULL;

                p_convert_error = (mmi_ebr_book_convert_error_struct *)OslConstructDataPtr(sizeof(mmi_ebr_book_convert_error_struct));
                p_convert_error->fs_error = p_open_error_struct->fs_error;
				msg_send5(MOD_MMI, MOD_MMI, 0, MSG_ID_MMI_EBOOK_CALLBACK_ERROR_IND, (local_para_struct*)p_convert_error);
                g_ebr_app_context_array_p->send_error_msg_flag = MMI_FALSE;
            }
            break;
        }
        default:
            break;
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_entry_bookshelf
 * DESCRIPTION
 *  Entry the bookshelf
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_entry_bookshelf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
	S32 bookshelf_id = -1;
    mmi_scrn_node_struct bookshelf_screen_info;
    mmi_ebr_app_setting_struct setting;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_ebr_app_context_array_p == NULL)
    {
    mmi_ebr_alloc_buffer(MMI_TRUE);

    }
    if (MMI_RET_OK == mmi_frm_scrn_get_info(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_BOOKSHELF_SCREENID, &bookshelf_screen_info))
    {
        if (MMI_SCENARIO_STATE_ACTIVE == bookshelf_screen_info.state)
        {
            if (g_ebr_app_context_array_p->bookshelf_id >= 0)
            {
                if (SRV_EBR_OP_RESULT_SUCCESS != srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
                {
                    goto end;
                }
                g_ebr_app_context_array_p->bookshelf_id = -1;
            }
        }
    }
    bookshelf_id = mmi_ebr_app_create_bookshelf(g_ebr_app_context_array_p->bookshelf_path);
    if(bookshelf_id >= 0)
    {
        mmi_ebr_app_show_bookshelf_screen(g_ebr_app_context_array_p->bookshelf_path);
        g_ebr_app_context_array_p->bookshelf_id = bookshelf_id;
        srv_ebr_bookshelf_refresh(
                g_ebr_app_context_array_p->bookshelf_id,
                mmi_ebr_refresh_bookshelf_complete_handler);
    }
    else
    {           
    	S32 total_drive_num = 0;
        U8 drive_letter_array[SRV_FMGR_DRV_TOTAL];
        mmi_id storage_selector_id = GRP_ID_INVALID;

		mmi_popup_display_simple(
            (WCHAR*)GetString(srv_fmgr_fs_error_get_string(bookshelf_id)), 
            MMI_EVENT_FAILURE, 
            GRP_ID_ROOT, 
            0);
        total_drive_num = mmi_ebr_app_get_storage_number(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE, drive_letter_array, SRV_FMGR_DRV_TOTAL);
        if (total_drive_num > 0)
        {
            ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
            storage_selector_id = cui_storage_selector_create(GRP_ID_EBOOK_BOOKSHELF, (U8)setting.bookshelf_setting.memory_type, 0);
            cui_storage_selector_run(storage_selector_id);
        } 
    }
end:
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_show_bookshelf_screen
 * DESCRIPTION
 *  Show the bookshelf screen
 * PARAMETERS
 *  bookshelf_path  [IN] The path of the bookshelf
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_show_bookshelf_screen(CHAR *bookshelf_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_BOOKSHELF, 
                        SCR_ID_EBOOK_BOOKSHELF_SCREENID, 
                        NULL, 
                        mmi_ebr_app_entry_bookshelf, 
                        MMI_FRM_FULL_SCRN))
    {
        mmi_frm_scrn_set_leave_proc(GRP_ID_EBOOK_BOOKSHELF, SCR_ID_EBOOK_BOOKSHELF_SCREENID, mmi_ebr_app_entry_bookshelf_screen_proc);
    	mmi_ebr_entry_book_shelf_normal_flow(bookshelf_path);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_get_view_data_callback
 * DESCRIPTION
 *  Get the data between start_line and end_line
 * PARAMETERS
 *  buffer      [OUT]  The pointer points the address of data 
 *  buf_len     [OUT]  The length of the data
 *  start_line  [IN]   The start line of the required data
 *  end_line    [IN]   The end line of the required data 
 * RETURNS
 *  MMI_BOOL:
 *  MMI_TRUE : Get the data successfully
 *  MMI_FALSE: Get the data failed
 *****************************************************************************/
MMI_BOOL mmi_ebr_app_get_view_data_callback(U8 **buffer, S32 *buf_len, S32 start_line, S32 end_line)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 error_code = 0;
    MMI_BOOL result = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ebr_app_context_array_p->screen_disply_info.start_line_index = start_line;
    result = srv_ebr_book_get_data(g_ebr_app_context_array_p->book_id, buffer, buf_len, start_line, end_line, &error_code);

    if (MMI_FALSE == result)
    {
        if (MMI_TRUE == g_ebr_app_context_array_p->send_error_msg_flag)
        {
            mmi_ebr_book_convert_error_struct *p_convert_error = NULL;

            p_convert_error = (mmi_ebr_book_convert_error_struct *)OslConstructDataPtr(sizeof(mmi_ebr_book_convert_error_struct));
            p_convert_error->fs_error = error_code;
			msg_send5(MOD_MMI, MOD_MMI, 0, MSG_ID_MMI_EBOOK_CALLBACK_ERROR_IND, (local_para_struct*)p_convert_error);
            g_ebr_app_context_array_p->send_error_msg_flag = MMI_FALSE;
        }
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_malloc_memory
 * DESCRIPTION
 *  The generalized malloc memory function
 * PARAMETERS
 *  void **     [IN]  The pointer points the address
 *  size        [IN]  The length of the malloced buffer
 * RETURNS
 *  void
 *****************************************************************************/
void *mmi_ebr_app_malloc_memory(S32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *ptr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ebr_app_memory_malloc_count++;
    ptr = OslMalloc(size);
    memset(ptr, 0x00, size);
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_MALLOC_MEMORY, g_ebr_app_memory_malloc_count, ptr, size);
    return ptr;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_free_memory
 * DESCRIPTION
 *  The generalized free memory function
 * PARAMETERS
 *  arg     [IN]  The pointer points the memory      
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_app_free_memory(void **arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (NULL != *arg)
    {
        g_ebr_app_memory_malloc_count--;
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_APP_FREE_MEMORY, g_ebr_app_memory_malloc_count, *arg);
        OslMfree(*arg);
        *arg = NULL;
    }
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_create_bookshelf
 * DESCRIPTION
 *  Create the bookshelf
 * PARAMETERS
 *  new_bookshelf_path   [OUT] The created bookshelf full path
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_ebr_app_create_bookshelf(CHAR *new_bookshelf_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    S32 fs_ret = 0;
    mmi_ebr_app_setting_struct setting;
    S32 bookshelf_id = -1;
    WCHAR *bookshelf_path = NULL;
    srv_ebr_bookshelf_setting bookshelf_setting;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    if (!srv_fmgr_drv_is_valid((U8)setting.bookshelf_setting.memory_type) || 
        (FS_GetDevStatus(setting.bookshelf_setting.memory_type, FS_MOUNT_STATE_ENUM) != FS_NO_ERROR) ||
        (FS_GetDevStatus(setting.bookshelf_setting.memory_type, FS_FEATURE_STATE_ENUM) == FS_DEVICE_BUSY))
    {
        setting.bookshelf_setting.memory_type = SRV_FMGR_PUBLIC_DRV;
        WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
    }

    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_CREATE_BOOKSHELF, setting.bookshelf_setting.memory_type);
    bookshelf_path = mmi_ebr_app_malloc_memory(SRV_EBR_MAX_PATH_LEN * ENCODING_LENGTH);
    kal_wsprintf(bookshelf_path, "%c%s", setting.bookshelf_setting.memory_type, EBR_DOWNLOADED_EBOOK_PATH);

    fs_ret = srv_fmgr_fs_create_folder((const WCHAR*)bookshelf_path);
    if(fs_ret != FS_NO_ERROR)
    {
		mmi_ebr_app_free_memory((void **)&bookshelf_path);
        return fs_ret;
    }
    memcpy(&bookshelf_setting, &setting.bookshelf_setting, sizeof(srv_ebr_bookshelf_setting));
    bookshelf_id = srv_ebr_bookshelf_create((CHAR*)bookshelf_path, &bookshelf_setting);
    if (bookshelf_id >= 0)
    {
        memcpy(new_bookshelf_path, bookshelf_path, SRV_EBR_MAX_PATH_LEN * sizeof(WCHAR));
    }
    mmi_ebr_app_free_memory((void **)&bookshelf_path);
    return bookshelf_id;
}


#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_timeout_handler
 * DESCRIPTION
 *  The time out callback function is used in open book(FTE project)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_timeout_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    srv_ebr_book_setting book_setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER);
    if (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id())
    {
 //       memcpy(&book_setting, srv_ebr_book_get_settings(g_ebr_app_context_array_p->book_id), sizeof(srv_ebr_book_setting));

        if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
        {
            if (wgui_cat3003_icon_bar_is_displayed())
            {
                wgui_cat3003_hide_floating_iconbar();
                if (MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state)
                {
                    if(dm_is_activated())
                    {
                        wgui_cat3003_hide_counter();
                    }
                }
            }
        }
        else
        {
            if (MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state)
            {
                if (wgui_cat3003_counter_is_displayed())
                {
                    if(dm_is_activated())
                    {
                        wgui_cat3003_hide_counter();
                    }
                }
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_tap_callback
 * DESCRIPTION
 *  The callback function is used in open book(FTE project)(tap operation)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_tap_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    srv_ebr_book_setting book_setting;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER);
//    memcpy(&book_setting, srv_ebr_book_get_settings(g_ebr_app_context_array_p->book_id), sizeof(srv_ebr_book_setting));
    
    if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
    {
        if (wgui_cat3003_icon_bar_is_displayed())
        {
            wgui_cat3003_hide_floating_iconbar();
            wgui_cat3003_hide_counter();
        }
        else
        {
            wgui_cat3003_show_floating_iconbar();
            wgui_cat3003_show_counter();
            StartTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER, MMI_EBR_OPEN_BOOK_FTE_TIME_DURATION, mmi_ebr_open_book_fte_timeout_handler);
        }
    }
    else
    {
        if (MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state)
        {
            if (wgui_cat3003_counter_is_displayed())
            {
                wgui_cat3003_hide_counter();
            }
            else
            {
                wgui_cat3003_show_counter();
                StartTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER, MMI_EBR_OPEN_BOOK_FTE_TIME_DURATION, mmi_ebr_open_book_fte_timeout_handler);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_move_callback
 * DESCRIPTION
 *  The callback function is used in open book(FTE project)(move operation)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_move_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    srv_ebr_book_setting book_setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER);
//    memcpy(&book_setting, srv_ebr_book_get_settings(g_ebr_app_context_array_p->book_id), sizeof(srv_ebr_book_setting));
    
    if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
    {
        if (wgui_cat3003_icon_bar_is_displayed())
        {
            wgui_cat3003_hide_floating_iconbar();
            wgui_cat3003_hide_counter();
        }
    }
    else
    {
        if (MMI_EBR_APP_STATE_CONVERTING != g_ebr_app_context_array_p->state)
        {
            if (wgui_cat3003_counter_is_displayed())
            {
                wgui_cat3003_hide_counter();
            }
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_pen_down_icon_bar_callback
 * DESCRIPTION
 *  The callback function is used in open book(FTE project)(pen_down_icon_bar operation)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_pen_down_icon_bar_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 //   srv_ebr_book_setting book_setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    memcpy(&book_setting, srv_ebr_book_get_settings(g_ebr_app_context_array_p->book_id), sizeof(srv_ebr_book_setting));
    
    if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
    {
        StopTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_pen_up_icon_bar_callback
 * DESCRIPTION
 *  The callback function is used in open book(FTE project)(pen_up_icon_bar operation)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_pen_up_icon_bar_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    srv_ebr_book_setting book_setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 //   memcpy(&book_setting, srv_ebr_book_get_settings(g_ebr_app_context_array_p->book_id), sizeof(srv_ebr_book_setting));
    
    if (MMI_TRUE == g_ebr_app_context_array_p->full_screen)
    {
        StartTimer(EBOOK_FTE_REFRESH_OPEN_BOOK_TIMER, MMI_EBR_OPEN_BOOK_FTE_TIME_DURATION, mmi_ebr_open_book_fte_timeout_handler);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_open_book_fte_toolbar_command
 * DESCRIPTION
 *  The callback function is used in open book(FTE project)
 * PARAMETERS
 *  index    [IN] The index of the item
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_open_book_fte_toolbar_command(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __COSMOS_MMI_PACKAGE__
    ebook_app_flag = MMI_FALSE;
#endif
    switch(index)
    {
        case 0:
        {
            mmi_ebr_entry_fte_bookmark_list();
            break;
        }
        case 1:
        {
            mmi_ebr_app_toggle_screen_mode();
            break;
        }
        case 2:
        {
            mmi_ebr_app_toggle_scroll_mode();
            break;
        }
#ifdef  __EBOOK_SEARCH_SUPPORT__       
        case 3:
        {
            mmi_ebr_ebook_search_string_from_shorcut_key();
            break;
        }
#endif  /*__EBOOK_SEARCH_SUPPORT__*/

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_highlight_fte_bookmark_list
 * DESCRIPTION
 *  Set highlight handler for Menu Ooptions
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_highlight_fte_bookmark_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ebr_entry_fte_bookmark_list, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_fte_bookmark_list
 * DESCRIPTION
 *  The entry function of FTE bookmark list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __COSMOS_MMI_PACKAGE__
void mmi_ebr_open_bookmark_list_proc(void)//by min 12.19
{
      mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_FTE_BOOKMARK_LIST);

}
#endif 
void mmi_ebr_entry_fte_bookmark_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    S32 error_flag = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_FALSE == mmi_ebr_app_get_bookmark_list())
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_ID_EBOOK_FTE_ENTRY_BOOKMARK_LIST_FAILED), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
        goto end;
    }
    if (MMI_TRUE == mmi_frm_scrn_enter(
                        GRP_ID_EBOOK_OPEN_BOOK, 
                        SCR_ID_EBOOK_FTE_BOOKMARK_LIST,
                        NULL,
                        (FuncPtr)mmi_ebr_entry_fte_bookmark_list, 
                        MMI_FRM_FULL_SCRN))
    {
        guiBuffer = mmi_frm_scrn_get_active_gui_buf();
        SetParentHandler(0);
		EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
        RegisterHighlightHandler(mmi_ebr_entry_fte_bookmark_list_highlight_handler);
        if (0 == g_ebr_app_context_array_p->bookmark_number)
        {
             wgui_cat1032_show(
                (WCHAR*)GetString(STR_ID_EBOOK_FTE_BOOKMARK_LIST),
                NULL,
                NULL,
                NULL,
                (WCHAR*)GetString(STR_GLOBAL_BACK),
                (PU8)GetImage(IMG_GLOBAL_BACK),
                g_ebr_app_context_array_p->bookmark_number,
                mmi_ebr_async_get_book_mark_name_list,
                NULL,
                0,
                0,    
                IMG_GLOBAL_L1,
                0,
                guiBuffer,
                &error_flag);
        }
        else
        {        
             wgui_cat1032_show(
                (WCHAR*)GetString(STR_ID_EBOOK_FTE_BOOKMARK_LIST),
                NULL,
                (WCHAR*)GetString(STR_GLOBAL_OPTIONS),
                (PU8)GetImage(IMG_GLOBAL_OPTIONS),
                (WCHAR*)GetString(STR_GLOBAL_BACK),
                (PU8)GetImage(IMG_GLOBAL_BACK),
                g_ebr_app_context_array_p->bookmark_number,
                mmi_ebr_async_get_book_mark_name_list,
                NULL,
                0,
                0,    
                IMG_GLOBAL_L1,
                0,
                guiBuffer,
                &error_flag);
           
            wgui_register_tap_callback(mmi_ebr_fte_bookmark_list_tap_callback_funtion);
			
			SetCenterSoftkeyFunction(mmi_ebr_entry_fte_bookmark_list_option, KEY_EVENT_UP);
            SetLeftSoftkeyFunction(mmi_ebr_entry_fte_bookmark_list_option, KEY_EVENT_UP);
        }
    }
end:
#ifdef __COSMOS_MMI_PACKAGE__
  //   SetKeyHandler(mmi_ebr_open_bookmark_list_proc, KEY_BACK, KEY_EVENT_UP);//by min 12.19
#endif 
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_fte_bookmark_list_tap_callback_funtion
 * DESCRIPTION
 *  The tap callback function of FTE bookmark list
 * PARAMETERS
 *  tap_type  [IN] the type of tap
 *  index     [IN] the index of the bookmark
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_fte_bookmark_list_tap_callback_funtion(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ENUM_TAP_ON_NONHIGHLIGHTED_ITEM == tap_type)
    {
        return;
    }
    else
    {
        mmi_ebr_fte_goto_selected_bookmark(index);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_fte_bookmark_list_highlight_handler
 * DESCRIPTION
 *  The highlight handker of FTE bookmark list
 * PARAMETERS
 *  index     [IN] the index of the options
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_fte_bookmark_list_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ebr_app_context_array_p->current_select_bookmark = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_fte_bookmark_list_option
 * DESCRIPTION
 *  The entry function of FTE bookmark list option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_fte_bookmark_list_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id bookmark_list_option_id = GRP_ID_INVALID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bookmark_list_option_id = cui_menu_create(
                                GRP_ID_EBOOK_OPEN_BOOK, 
                                CUI_MENU_SRC_TYPE_APPCREATE, 
                                CUI_MENU_TYPE_OPTION, 
                                MENU_ID_EBK_FTE_BOOKMARK_LIST, 
                                MMI_FALSE, 
                                g_ebr_app_context_array_p);
    cui_menu_run(bookmark_list_option_id);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_entry_fte_bookmark_list_option_highlight_handler
 * DESCRIPTION
 *  The highlight handker of FTE bookmark list option
 * PARAMETERS
 *  index     [IN] the index of the options
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ebr_entry_fte_bookmark_list_option_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (0 == index)
    {
        SetLeftSoftkeyFunction(mmi_ebr_goto_selected_bookmark, KEY_EVENT_UP);
    }
    else
    {
        SetLeftSoftkeyFunction(mmi_ebr_delete_bookmark, KEY_EVENT_UP);        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_fte_goto_selected_bookmark
 * DESCRIPTION
 *  The goto bookmark function in FTE project
 * PARAMETERS
 *  bookmark_list_option_id     [IN] the group id of bookmark list option
 * RETURNS
 *  void
 *****************************************************************************/
 void mmi_ebr_fte_goto_selected_bookmark(mmi_id bookmark_list_option_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_ebr_book_bookmark_struct *p_bookmark_info = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GOTO_SELECTED_BOOKMARK);

	if(g_ebr_app_context_array_p->state == MMI_EBR_APP_STATE_CONVERTING)
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
		return;
    }

    p_bookmark_info = g_ebr_app_context_array_p->bookmark_info_array;
    if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_jump_to_line(
                                        g_ebr_app_context_array_p->book_id, 
                                        p_bookmark_info[g_ebr_app_context_array_p->current_select_bookmark].start_line))
    {
        mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_FTE_BOOKMARK_LIST);
    }
    else
    {
        mmi_popup_display_simple(
            (WCHAR*)GetString(STR_EBOOK_GOTO_BOOKMARK_FAILED), 
            MMI_EVENT_FAILURE, 
            GRP_ID_EBOOK_OPEN_BOOK, 
            0);
    }
    return;
}
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) */


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_lcd_sleepout_handler
 * DESCRIPTION
 *  The callback when LCD's backlight is turned on
 * PARAMETERS
 *  p_evevnt
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_lcd_sleepout_handler(mmi_event_struct *p_evevnt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_ebr_app_context_array_p)
	{
	    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
	    {
	        if (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id())
	        {
	            srv_ebr_book_set_convert_speed(g_ebr_app_context_array_p->book_id, SRV_EBR_BOOK_CONVERT_SPEED_FAST);
	        }
	    }
	}
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_lcd_sleepin_handler
 * DESCRIPTION
 *  The callback when LCD's backlight is turned off
 * PARAMETERS
 *  p_evevnt
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_lcd_sleepin_handler(mmi_event_struct *p_evevnt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_ebr_app_context_array_p)
	{
	    if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
	    {
	        if (SCR_ID_EBOOK_OPEN_SCREENID == mmi_frm_scrn_get_active_id())
	        {
	            srv_ebr_book_set_convert_speed(g_ebr_app_context_array_p->book_id, SRV_EBR_BOOK_CONVERT_SPEED_SLOW);
	        }
	    }
	}
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_dev_plug_out_handler
 * DESCRIPTION
 *  The callback when device is plugged out
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_dev_plug_out_handler(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count = 0;
    mmi_ebr_app_book_info *p_open_book_info = NULL;
    srv_fmgr_notification_dev_plug_event_struct *p_event = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(!g_ebr_app_context_array_p)
	{
	    return MMI_RET_OK;
	}
    p_event = (srv_fmgr_notification_dev_plug_event_struct*)event;
    p_open_book_info = &g_ebr_app_context_array_p->open_book_info;
    
    for (count = 0; count < p_event->count; count++)
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_DEV_PLUG_OUT_HANDLER_LOG, *(p_open_book_info->book_path), p_event->drv_letters[count], p_event->count, g_ebr_app_context_array_p->bookshelf_id);
        if (*((U8*)(p_open_book_info->book_path)) == p_event->drv_letters[count])
        {      
            if (g_ebr_app_context_array_p->book_id >= 0)
            {
                if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
                {
                    g_ebr_app_context_array_p->book_id = -1;
                    g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
                    memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
                }
                if ((MMI_FALSE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF))&&
                    (g_ebr_app_context_array_p->bookshelf_id >= 0))
                {
                    if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
                    {
                        g_ebr_app_context_array_p->bookshelf_id = -1;
                    }
                }
				mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
            }
        }
        if (g_ebr_app_context_array_p && g_ebr_app_context_array_p->bookshelf_path[0] == p_event->drv_letters[count])
        {
            if (g_ebr_app_context_array_p->bookshelf_id >= 0)
            {
                mmi_frm_group_close(GRP_ID_EBOOK_BOOKSHELF);
            }
        }
    }
    return MMI_RET_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebook_usb_mode_on
 * DESCRIPTION
 *  For USB Power On Mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_ebook_usb_mode_on(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (g_ebr_app_context_array_p && g_ebr_app_context_array_p->book_id >= 0)
    {
        MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_USB_MODE_ON, g_ebr_app_context_array_p->book_id);
        g_ebr_app_context_array_p->is_usb_plugged_in = MMI_TRUE;
		
        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
        {
            g_ebr_app_context_array_p->book_id = -1;
            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
            memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
        }
        if ((MMI_FALSE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF)) &&
            (g_ebr_app_context_array_p->bookshelf_id >= 0))
        {
            if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
            {
                g_ebr_app_context_array_p->bookshelf_id = -1;
            }
        }
    }

#ifdef __COSMOS_MMI_PACKAGE__
   if(MMI_TRUE == mmi_frm_group_is_present(GRP_ID_EBOOK_OPEN_BOOK))
    {
        mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);

    }
#endif
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ebook_usb_mode_off
 * DESCRIPTION
 *  For USB Power On Mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_ebook_usb_mode_off(mmi_event_struct *p_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_USB_MODE_OFF);
	if (g_ebr_app_context_array_p)
	{
        g_ebr_app_context_array_p->is_usb_plugged_in = MMI_FALSE;
	}
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_action_adv_handler
 * DESCRIPTION
 *  The callback when action adv
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_ebr_app_action_adv_handler(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_notification_adv_action_event_struct *p_event = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_event = (srv_fmgr_notification_adv_action_event_struct*)event;
    if(!g_ebr_app_context_array_p)
	{
	    return MMI_RET_OK;
	}
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_ACTION_ADV_HANDLER, p_event->action, p_event->state, g_ebr_app_context_array_p->bookshelf_id);
    switch (p_event->action)
    {
        case SRV_FMGR_NOTIFICATION_ACTION_DELETE:
        case SRV_FMGR_NOTIFICATION_ACTION_DELETE_ALL:
        {
            if (SRV_FMGR_NOTIFICATION_STATE_BEFORE == p_event->state)
            {
                if ((MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)) 
                {
                    MMI_BOOL close_open_book = MMI_FALSE;
                    WCHAR *open_book_full_path = NULL;

                    if ((p_event->src_fileinfo.attribute & FS_ATTR_DIR))
                    {
                        if (!mmi_wcsnicmp(
                                (const WCHAR*)p_event->src_filepath, 
                                (const WCHAR*)g_ebr_app_context_array_p->open_book_info.book_path, 
                                (U32)mmi_wcslen(p_event->src_filepath)))
                        {
                            close_open_book = MMI_TRUE;
                        }
                    }
                    else
                    {
                        open_book_full_path = mmi_ebr_app_malloc_memory(SRV_EBR_MAX_PATH_LEN * sizeof(WCHAR));
                        kal_wsprintf(
                            open_book_full_path, 
                            "%w%w", 
                            g_ebr_app_context_array_p->open_book_info.book_path,
                            g_ebr_app_context_array_p->open_book_info.book_name);
                        if (!mmi_wcscmp((const WCHAR*)p_event->src_filepath, (const WCHAR*)open_book_full_path))
                        {
                            close_open_book = MMI_TRUE;
                        }
                        mmi_ebr_app_free_memory((void**)&open_book_full_path);
                    }

                    if (MMI_TRUE == close_open_book)
                    {
                        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
                        {
                            g_ebr_app_context_array_p->book_id = -1;
                            g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
                            memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
                        }
                        if ((MMI_FALSE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF)) &&
                            (g_ebr_app_context_array_p->bookshelf_id >= 0))
                        {
                            if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
                            {
                                g_ebr_app_context_array_p->bookshelf_id = -1;
                            }
                        }
                    }
                }
            }
            else if (SRV_FMGR_NOTIFICATION_STATE_AFTER == p_event->state && p_event->result >= 0)
            {
                if ((SRV_FMGR_NOTIFICATION_ACTION_DELETE == p_event->action) && !(p_event->src_fileinfo.attribute & FS_ATTR_DIR))
                {
                    WCHAR *p_ext_name = NULL;
                    p_ext_name = srv_fmgr_path_get_extension_ptr((WCHAR*)p_event->src_filepath);

                    if (p_ext_name != NULL && (!mmi_wcsicmp((const WCHAR*)p_ext_name, (const WCHAR*)L"TXT")))
                    {
                        srv_ebr_delete_book((CHAR*)p_event->src_filepath);
                    }
                }
            }
            break;
        }
        case SRV_FMGR_NOTIFICATION_ACTION_RENAME:
        {
            if (SRV_FMGR_NOTIFICATION_STATE_AFTER == p_event->state && p_event->result >= 0)
            {
                if (!(p_event->src_fileinfo.attribute & FS_ATTR_DIR))
                {
                    WCHAR *p_ext_name = NULL;
                    p_ext_name = srv_fmgr_path_get_extension_ptr((WCHAR*)p_event->src_filepath);

                    if (p_ext_name != NULL && (!mmi_wcsicmp((const WCHAR*)p_ext_name, (const WCHAR*)L"TXT"))) 
                    {
                        srv_ebr_delete_book((CHAR*)p_event->src_filepath);
                    }                 
                }
            }
            break;
        }
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_set_def_storage_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  p_event
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_set_def_storage_handler(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ret result_value = MMI_RET_OK;
    mmi_ebr_app_setting_struct setting;
    S16 error;
    srv_fmgr_notification_set_def_storage_event_struct *p_event = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_event = (srv_fmgr_notification_set_def_storage_event_struct*)event;
    if(!g_ebr_app_context_array_p)
	{
	    return MMI_RET_OK;
	}
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_SET_DEFAULT_STORAGE_HANDLER, p_event->state, g_ebr_app_context_array_p->state);
    switch (p_event->state)
    {
        case SRV_FMGR_NOTIFICATION_STATE_QUERY:
        {
            if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
            {
                result_value = MMI_RET_ERR;
            }
            break;
        }
        case SRV_FMGR_NOTIFICATION_STATE_AFTER:
        {
            ReadRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
            setting.bookshelf_setting.memory_type = (CHAR)(p_event->drv_letter);
            WriteRecord(NVRAM_EF_EBOOK_SETTINGS_LID, 1, (void*)&setting, NVRAM_EF_EBOOK_SETTING_SIZE, &error);
            break;
        }
        default:
        {
            break;
        }
    }
    return result_value;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_format_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  p_event
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_ebr_app_format_handler(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_notification_format_event_struct *p_event = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_event = (srv_fmgr_notification_format_event_struct*)event;
	if(!g_ebr_app_context_array_p)
	{
	    return MMI_RET_OK;
	}
    MMI_TRACE(
        MMI_COMMON_TRC_G1_EBOOK, 
        MMI_EBOOK_FORMAT_HANDLER, 
        p_event->state, 
        g_ebr_app_context_array_p->state, 
        *((U8*)g_ebr_app_context_array_p->open_book_info.book_path),
        p_event->drv_letter);
    switch (p_event->state)
    {
        case SRV_FMGR_NOTIFICATION_STATE_BEFORE:
        {
            if (MMI_EBR_APP_STATE_CONVERTING == g_ebr_app_context_array_p->state)
            {
                if (*((U8*)g_ebr_app_context_array_p->open_book_info.book_path) == p_event->drv_letter)
                {
                    if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_book_close(g_ebr_app_context_array_p->book_id))
                    {
                        g_ebr_app_context_array_p->book_id = -1;
                        g_ebr_app_context_array_p->state = MMI_EBR_APP_STATE_IDLE;
                        memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
                    }
                    if ((MMI_FALSE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF)) &&
                        (g_ebr_app_context_array_p->bookshelf_id >= 0))
                    {
                        if (SRV_EBR_OP_RESULT_SUCCESS == srv_ebr_bookshelf_close(g_ebr_app_context_array_p->bookshelf_id))
                        {
                            g_ebr_app_context_array_p->bookshelf_id = -1;
                        }
                    }
                }
            }
            break;
        }
        default:
        {
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ebr_app_get_storage_number
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ebr_app_get_storage_number(srv_fmgr_drivelist_type_enum b_access, U8 *p_drive_letter, S32 drive_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    SRV_FMGR_DRVLIST_HANDLE drvlist;
    S32 i, count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE == b_access)
    {
        drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE);
    }
    else if (SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY == b_access)
    {
        drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
    }
    else
    {
        drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
    }
    
    count = srv_fmgr_drivelist_count(drvlist);
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GET_STORAGE_NUMBER_LOG1, b_access, p_drive_letter, drive_size, count);

    if (NULL != p_drive_letter)
    {
        if (drive_size > count)
        {
            drive_size = count;
        }
        
        for(i = 0; i < drive_size; i++)
        {
            p_drive_letter[i] = srv_fmgr_drivelist_get_drv_letter(drvlist, i);
            MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_GET_STORAGE_NUMBER_LOG2, i, p_drive_letter[i]);
        }
    }
    
    return count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgr_ebook_option_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgr_ebook_option_hdlr(mmi_menu_id item_id, const WCHAR* filepath, const srv_fmgr_fileinfo_struct* fileinfo)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G1_EBOOK, MMI_EBOOK_FMGR_OPTION_HDLR, item_id, filepath, fileinfo);
	mmi_wcscpy(g_fmgr_highlight_book_info.book_name, (const WCHAR*)filepath);
	g_fmgr_highlight_book_info.book_size = fileinfo->size;
	if(!mmi_ebr_alloc_buffer(MMI_TRUE))
	{
		return;
	}

    switch (item_id)
    {
        case MENU_ID_FMGR_EBOOK_OPTION_OPEN_NEW:
        {
            WCHAR *p_file_name = NULL;
#ifndef __COSMOS_MMI_PACKAGE__   
       
            if (MMI_TRUE == mmi_frm_group_is_present(GRP_ID_EBOOK_BOOKSHELF))
            {
                mmi_popup_display_simple( 
                    (WCHAR*)GetString(STR_EBOOK_EXIT_EBOOK_READER), 
                    MMI_EVENT_FAILURE,
                    GRP_ID_ROOT,
                    0);
                return;
            }
#endif
            
            mmi_wcscpy(g_ebr_app_context_array_p->highlight_book_info.book_path, (const WCHAR*)filepath);
            p_file_name = srv_fmgr_path_get_filename_ptr((WCHAR*)g_ebr_app_context_array_p->highlight_book_info.book_path);
            mmi_wcscpy(g_ebr_app_context_array_p->highlight_book_info.book_name, (const WCHAR*)p_file_name);
            *p_file_name = 0;
            
            g_ebr_app_context_array_p->highlight_book_info.book_size = fileinfo->size;
            #ifndef __COSMOS_MMI_PACKAGE__
            g_ebr_app_context_array_p->highlight_book_info.icon_id = GetRootTitleIcon(MAIN_MENU_EBOOK_MENUID);
#endif
            g_ebr_app_context_array_p->entry_from = MMI_EBR_APP_ENTRY_FROM_FMGR;
            mmi_frm_group_close(GRP_ID_EBOOK_OPEN_BOOK);
            mmi_ebr_app_open_book_launch(GRP_ID_ROOT);
            break;
        }
        default:
        {
            break;
        }
    }
    return;    
}


void mmi_ebr_app_async_open_error_handler(mmi_ebr_frm_op_result_enum error)
{
   if(g_ebr_app_context_array_p)
   {
       memset(&g_ebr_app_context_array_p->open_book_info, 0, sizeof(g_ebr_app_context_array_p->open_book_info));
   }
   mmi_popup_display_simple(
       (WCHAR*)GetString(mmi_ebr_get_open_result_code_string_id((srv_ebr_book_open_error_enum)error)), 
       MMI_EVENT_FAILURE, 
       GRP_ID_EBOOK_OPEN_BOOK, 
       0);
   mmi_frm_scrn_close(GRP_ID_EBOOK_OPEN_BOOK, SCR_ID_EBOOK_LOADINGSCREEN);
}

/*****************************************************************************
 * FUNCTION
 *  highlight_mainmenu_ebook
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void highlight_mainmenu_ebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetLeftSoftkeyFunction(mmi_ebr_pre_entry_book_shel_screen, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_ebr_pre_entry_book_shel_screen, KEY_EVENT_UP);
}

#endif /* __MMI_EBOOK_READER__ */

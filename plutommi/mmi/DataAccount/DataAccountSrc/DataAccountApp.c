/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * DataAccount.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ¡K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

 /**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

#ifdef __TCPIP__

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "MMI_features.h"
#if defined (__DCM_WITH_COMPRESSION_MMI_AP__) && defined(__MTK_TARGET__)
#include "mmi_ap_dcm_config.h" 
#endif
#include "MMIDataType.h"
#include "ConnectManageGprot.h"
#include "DtcntSrvGprot.h"
#include "DtcntSrvIprot.h"
#include "menucuigprot.h"
#include "inlinecuigprot.h"
#include "cbm_consts.h"
#include "SimCtrlSrvGprot.h"
#include "app_url.h"
#include "kal_general_types.h"
#include "wgui_inline_edit.h"
#include "DataAccountDef.h"
#include "DataAccountStruct.h"
#include "DataAccountGProt.h"
#include "DataAccountEnum.h"
#include "kal_public_api.h"
#include "cbm_api.h"
#include "DebugInitDef_Int.h"
#include "mmi_frm_nvram_gprot.h"
#include "nvram_common_defs.h"
#include "common_nvram_editor_data_item.h"
#include "string.h"
#include "stdlib.h"
#include "custom_data_account.h"
#include "MMI_conn_app_trc.h"
#include "kal_trace.h"
#include "DataAccountProt.h"
#include "Unicodexdcl.h"
#include "mmi_rp_app_dataaccount_def.h"
#include "CustDataRes.h"
#include "mmi_frm_events_gprot.h"
#include "GlobalResDef.h"
#include "AlertScreen.h"
#include "CommonScreensResDef.h"
#include "mmi_frm_scenario_gprot.h"
#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "stdio.h"
#include "stack_config.h"
#include "mmi_frm_history_gprot.h"
#include "wgui_categories_util.h"
#include "ImeGprot.h"
#include "wgui_categories_inputs.h"
#include "ProfilesSrvGprot.h"
#include "GlobalConstants.h"
#include "gui_typedef.h"
#include "wgui_categories_list.h"
#include "CommonScreens.h"
#include "gui_data_types.h"
#include "gui.h"
#include "abm_api.h"
#include "mmi_frm_mem_gprot.h"
#include "NetSetSrvGprot.h"
#include "NetSetAppGprot.h"
#include "mmi_frm_input_gprot.h"
#ifdef __MMI_CCA_SUPPORT__
#include "mmi_rp_app_cca_def.h"
#endif
#include "wgui_categories_text_viewer.h"
#include "mmi_cb_mgr_gprot.h"
#include "TetheringSrvGprot.h"
#include "CbmsrvGprot.h"
#include "mmi_frm_utility_gprot.h"
#ifdef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
#include "NetSetAppGprot.h"
#endif
#include "CentralConfigAgentGProt.h"
#include "Conversions.h"
#include "mmi_rp_app_profiles_def.h"

/***************************************************************************** 
 * Define
 *****************************************************************************/
#define MMI_DTCNT_MAX_PLMN_LEN  (SRV_MAX_PLMN_LEN + 1)
#define MMI_DTCNT_INVALID_ID (0x00003e3e)   /* (cbm_encode_data_account_id(CBM_INVALID_NWK_ACCT_ID, CBM_SIM_ID_SIM1, 0, 0)) */
#define MMI_DTCNT_DEFAULT_ID (0x00003e00)
#define MMI_DTCNT_CONF_NAME_LEN (32)


/***************************************************************************** 
 * Global variable
 *****************************************************************************/
MMI_BOOL g_dtcnt_acct_ready = MMI_FALSE;
mmi_dtcnt_list_disp_struct g_mmi_dtcnt_list_item[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM];
U32 g_mmi_dtcnt_acct_num;
mmi_dtcnt_hotswap_del_prof_struct g_hotswap_del_prof;

#ifdef __MMI_AP_DCM_DTCNT__
#pragma arm section rodata = "DYNAMIC_CODE_SETTINGS_RODATA" , code = "DYNAMIC_CODE_SETTINGS_ROCODE"
#endif

void (*g_DTCNTReadyCallback) (void) = NULL;
void (*g_dtcnt_ready_check_cb[DTCNT_READY_CHECK_NUM])(void);


U8 g_always_ask_screen_del_handler_flag; // only used for wifi

#ifdef __MMI_CCA_SUPPORT__
srv_dtcnt_prov_ind_evt_struct g_prov_ind;
U8 cur_prov_list_index;
U8 cur_prov_acct_id;
MMI_BOOL g_need_abort_flag;
static mmi_ret mmi_dtcnt_prov_reg_event(void *user_data);
static U16 *g_dtcnt_name;
static U8 *g_dtcnt_addr;
#endif

#ifdef __MMI_WLAN_FEATURES__
extern mmi_id wlan_parent_group_id;
extern mmi_ret mmi_wlan_cui_event_proc(mmi_event_struct *evt);
#endif


#if defined(__DA_SMART_SELECTION_SUPPORT__)
static S32 g_dtcnt_factory = MMI_FALSE;
// sim related initial
static S32 g_dtcnt_file_exist = 0;
static S32 g_dtcnt_init_plmn = 0;

// for plmn evt, because need to proc the evt when the last plmn send at bootup 
MMI_BOOL g_first_proc_plmn_evt = MMI_TRUE;
U16 g_dtcnt_plmn_evt_num = 0;
U16 g_dtcnt_plmn_proc_num = 0;
// save plmn and xml file name
static CHAR g_dtcnt_sim[MMI_SIM_TOTAL][MMI_DTCNT_MAX_PLMN_LEN];
static kal_wchar g_dtcnt_conf[MMI_SIM_TOTAL][MMI_DTCNT_CONF_NAME_LEN];
MMI_BOOL g_sim_changed[MMI_SIM_TOTAL];
#endif /* __DA_SMART_SELECTION_SUPPORT__ */

U8 homepage[MAX_ADDRESS_NAME_LEN]; // used to save temp homepage buffer

extern mmi_dtcnt_comm_disp_name_addr g_comm_disp_name_addr_arr[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM + MAX_DATA_ACCOUN_CUI_FIX_ITEM];
mmi_dtcnt_node_display_struct g_data_account_display_cntx;

#ifdef __MMI_GPRS_FEATURES__
srv_dtcnt_prof_gprs_struct g_data_account_gprs_profile_srv;
#endif

#ifdef __TCPIP_OVER_CSD__
srv_dtcnt_prof_csd_struct g_data_account_csd_profile_srv;
#endif

static U8 g_conn_type;/* use this variable to diable port when conn. type is Wap */
static U8 g_use_proxy;

#define DTCNT_INLINE_ITEMS
/*****************************************************************************
 * Static varaible definition
 *****************************************************************************/
/* for inline editor cui */

static const MMI_STR_ID auth_type_sel_str[] = 
{
    STR_GLOBAL_NORMAL,
    STR_ID_DTCNT_GPRS_CHAP_AUTH
};

#ifdef __MMI_GPRS_FEATURES__
static const cui_inline_item_caption_struct apn_caption = {STR_ID_DTCNT_GPRS_APN};
static const cui_inline_item_text_edit_struct apn_textedit = 
{
    0,
    0,
    MAX_GPRS_MMI_APN_LEN + 1,
    IMM_INPUT_TYPE_ASCII_CHAR,
    0,
    NULL
};
static const cui_inline_item_display_only_struct apn_displayonly = {0};

static const cui_inline_item_caption_struct auth_type_caption = {STR_ID_DTCNT_GPRS_AUTH_TYP};
static const cui_inline_item_select_struct auth_type_select = 
{
    sizeof(auth_type_sel_str)/sizeof(auth_type_sel_str[0]),
    0,
    auth_type_sel_str
};
static const cui_inline_item_display_only_struct auth_type_displayonly = {0};
#endif

#ifdef __TCPIP_OVER_CSD__
static const MMI_STR_ID dial_type_sel_str[] = 
{
    STR_ID_DTCNT_ANALOGUE_STR, 
    STR_ID_DTCNT_ISDN_STR
};
static const MMI_STR_ID data_rate_sel_str[] = 
{
    STR_ID_DTCNT_RATE_STR_ZERO, 
    STR_ID_DTCNT_RATE_STR_ONE,
    STR_ID_DTCNT_RATE_STR_TWO,
    STR_ID_DTCNT_RATE_STR_THREE,
    STR_ID_DTCNT_RATE_STR_FOUR
};

static const cui_inline_item_caption_struct dial_number_caption = {STR_ID_DTCNT_DIAL_NUMBER};
static const cui_inline_item_text_edit_struct dial_number_textedit = 
{
    0,
    0,
    MAX_DIAL_NUM_LEN,
    IMM_INPUT_TYPE_PHONE_NUMBER | INPUT_TYPE_PLUS_CHARACTER_HANDLING,
    0,
    NULL
};
static const cui_inline_item_display_only_struct dial_number_displayonly = {0};

static const cui_inline_item_caption_struct dial_type_caption = {STR_ID_DTCNT_DIAL_TYPE};
static const cui_inline_item_select_struct dial_type_select = 
{
    sizeof(dial_type_sel_str)/sizeof(dial_type_sel_str[0]),
    0,
    dial_type_sel_str
};
static const cui_inline_item_display_only_struct dial_type_displayonly = {0};

static const cui_inline_item_caption_struct data_rate_caption = {STR_ID_DTCNT_DATA_RATE};
static const cui_inline_item_select_struct data_rate_select =
{
    sizeof(data_rate_sel_str)/sizeof(data_rate_sel_str[0]),
    0,
    data_rate_sel_str
};
static const cui_inline_item_display_only_struct data_rate_displayonly = {0};
#endif
#ifndef WAP2_HTTP
static const MMI_STR_ID conn_type_sel_str[] = 
{
    STR_GLOBAL_WAP, 
    STR_GLOBAL_HTTP
};
#endif

static const MMI_STR_ID use_proxy_sel_str[] = 
{
    STR_GLOBAL_NO, 
    STR_GLOBAL_YES
};

static const cui_inline_item_caption_struct account_name_caption = {STR_ID_DTCNT_RENAME};
static const cui_inline_item_text_edit_struct account_name_textedit = 
{
    0, 
    0, 
    MAX_DATA_ACCOUNT_NAME_LEN + 1, 
    IMM_INPUT_TYPE_SENTENCE, 
    INPUT_TYPE_EXT_ASCII_ENCODING_BASE_LENGTH, 
    NULL
};
static const cui_inline_item_display_only_struct account_name_displayonly = {0};

static const cui_inline_item_caption_struct username_caption = {STR_GLOBAL_USERNAME};
static const cui_inline_item_text_edit_struct username_textedit = 
{
    0,
    0,
    MAX_USER_LEN + 1,
    IMM_INPUT_TYPE_ASCII_CHAR,
    0,
    NULL
};
static const cui_inline_item_display_only_struct username_displayonly = {0};

static const cui_inline_item_caption_struct passwd_caption = {STR_GLOBAL_PASSWORD};
static const cui_inline_item_text_edit_struct passwd_textedit = 
{
    0,
    0,
    MAX_PASSWD_LEN + 1,
    IMM_INPUT_TYPE_ASCII_PASSWORD,
    0,
    NULL
};
static const cui_inline_item_display_only_struct passwd_displayonly = {0};

static const cui_inline_item_display_only_struct advance_displayonly = {STR_ID_DTCNT_ADVANCED_SETTING};

static const cui_inline_item_caption_struct homepage_caption = {STR_ID_DTCNT_HOME_PAGE};
static const cui_inline_item_fullscreen_edit_struct homepage_fsedit = 
{
    0,
    0,
    STR_ID_DTCNT_HOME_PAGE,
    0,
    INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL | INPUT_TYPE_EXT_ASCII_ENCODING_BASE_LENGTH,    
    IMM_INPUT_TYPE_URL,
    MAX_ADDRESS_NAME_LEN,
    NULL
};
static const cui_inline_item_display_only_struct homepage_displayonly = {0};

static const cui_inline_item_caption_struct conn_type_caption = {STR_ID_DTCNT_CONNECTION_TYPE};
#ifndef WAP2_HTTP
static const cui_inline_item_select_struct conn_type_select = 
{
    sizeof(conn_type_sel_str)/sizeof(conn_type_sel_str[0]),
    0,
    conn_type_sel_str
};
#else
static const cui_inline_item_caption_struct conn_type_http_caption = {STR_GLOBAL_HTTP};
#endif

static const cui_inline_item_display_only_struct conn_type_displayonly = {0};

static const cui_inline_item_caption_struct use_proxy_caption = {STR_ID_DTCNT_USE_PROXY};
static const cui_inline_item_select_struct use_proxy_select = 
{
    sizeof(use_proxy_sel_str)/sizeof(use_proxy_sel_str[0]),
    0,
    use_proxy_sel_str
};
static const cui_inline_item_display_only_struct use_proxy_displayonly = {0};

static const cui_inline_item_caption_struct proxy_address_caption = {STR_ID_DTCNT_PROXY_ADDRESS};
static const cui_inline_item_fullscreen_edit_struct proxy_address_fsedit = 
{
    0,
    0,
    STR_ID_DTCNT_PROXY_ADDRESS,
    0,
    INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL | INPUT_TYPE_EXT_ASCII_ENCODING_BASE_LENGTH,    
    IMM_INPUT_TYPE_URL,
    MMI_DTCNT_MAX_PROXY_URL_LEN + 1,
    NULL
};
static const cui_inline_item_display_only_struct proxy_address_displayonly = {0};

static const cui_inline_item_caption_struct proxy_port_caption = {STR_ID_DTCNT_PROXY_PORT};
static const cui_inline_item_text_edit_struct proxy_port_textedit = 
{
    0,
    0,
    MMI_DTCNT_MAX_PORT_LENGTH + 1,
    IMM_INPUT_TYPE_NUMERIC,
    0,
    NULL
};
static const cui_inline_item_display_only_struct proxy_port_displayonly = {0};

static const cui_inline_item_caption_struct proxy_username_caption = {STR_ID_DTCNT_PROXY_USER_NAME};
static const cui_inline_item_fullscreen_edit_struct proxy_username_fsedit = 
{
    0,
    0,
    STR_ID_DTCNT_PROXY_USER_NAME,
    0,
    INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL,
    IMM_INPUT_TYPE_ASCII_CHAR,
    MAX_PROXY_USER_LEN + 1,
    NULL
};
static const cui_inline_item_display_only_struct proxy_username_displayonly = {0};

static const cui_inline_item_caption_struct proxy_password_caption = {STR_ID_DTCNT_PROXY_PASS_WORD};
static const cui_inline_item_fullscreen_edit_struct proxy_password_fsedit = 
{
    0,
    0,
    STR_ID_DTCNT_PROXY_PASS_WORD,
    0,
    INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL,
    IMM_INPUT_TYPE_ASCII_PASSWORD,
    MAX_PROXY_PASSWD_LEN + 1,
    NULL
};
static const cui_inline_item_display_only_struct proxy_password_displayonly = {0};

#ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
static const cui_inline_item_caption_struct dns_address1_caption = {STR_ID_DTCNT_DNS_ADDRESS1};
static const cui_inline_item_ip4_struct dns_address1_ip4 = {0, 0, 0, 0};
static const cui_inline_item_display_only_struct dns_address1_displayonly = {0};

static const cui_inline_item_caption_struct dns_address2_caption = {STR_ID_DTCNT_DNS_ADDRESS2};
static const cui_inline_item_ip4_struct dns_address2_ip4 = {0, 0, 0, 0};
static const cui_inline_item_display_only_struct dns_address2_displayonly = {0};

static const cui_inline_item_caption_struct ip_address_caption = {STR_ID_DTCNT_IP_ADDRESS};
static const cui_inline_item_ip4_struct ip_address_ip4 = {0, 0, 0, 0};
static const cui_inline_item_display_only_struct ip_address_displayonly = {0};

static const cui_inline_item_caption_struct subnet_caption = {STR_ID_DTCNT_SUBNET_MASK};
static const cui_inline_item_ip4_struct subnet_ip4 = {0, 0, 0, 0};
static const cui_inline_item_display_only_struct subnet_displayonly = {0};
#endif

#ifdef __TCPIP_OVER_CSD__
static const cui_inline_set_item_struct csd_common_inline_edit_items[CSD_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE] =
{
    {COMMON_NAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&account_name_caption},
    {COMMON_NAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&account_name_textedit},
    {COMMON_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&dial_number_caption},
    {COMMON_ADDR_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&dial_number_textedit},
    {COMMON_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&username_caption},
    {COMMON_USERNAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&username_textedit},
    {COMMON_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&passwd_caption},
    {COMMON_PASSWD_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&passwd_textedit},
    {CSD_DIAL_TYPE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&dial_type_caption},
    {CSD_DIAL_TYPE_SELECT_ID, CUI_INLINE_ITEM_TYPE_SELECT, 0, (void*)&dial_type_select},
    {CSD_DATA_RATE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L6, (void*)&data_rate_caption},
    {CSD_DATA_RATE_SELECT_ID, CUI_INLINE_ITEM_TYPE_SELECT, 0, (void*)&data_rate_select},
    {CSD_ADVANCE_DISPLAY_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, IMG_GLOBAL_L7, (void*)&advance_displayonly}
};

static const cui_inline_set_item_struct csd_common_inline_view_items[CSD_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE] =
{
    {COMMON_NAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&account_name_caption},
    {COMMON_NAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&account_name_displayonly},
    {COMMON_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&dial_number_caption},
    {COMMON_ADDR_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&dial_number_displayonly},
    {COMMON_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&username_caption},
    {COMMON_USERNAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&username_displayonly},
    {COMMON_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&passwd_caption},
    {COMMON_PASSWD_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&passwd_displayonly},
    {CSD_DIAL_TYPE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&dial_type_caption},
    {CSD_DIAL_TYPE_SELECT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&dial_type_displayonly},
    {CSD_DATA_RATE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L6, (void*)&data_rate_caption},
    {CSD_DATA_RATE_SELECT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&data_rate_displayonly},
    {CSD_ADVANCE_DISPLAY_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, IMG_GLOBAL_L7, (void*)&advance_displayonly}
};

#endif

#ifdef __MMI_GPRS_FEATURES__
static const cui_inline_set_item_struct gprs_common_inline_edit_items[GPRS_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE] =
{
    {COMMON_NAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&account_name_caption},
    {COMMON_NAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&account_name_textedit},
    {COMMON_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&apn_caption},
    {COMMON_ADDR_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&apn_textedit},
    {COMMON_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&username_caption},
    {COMMON_USERNAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&username_textedit},
    {COMMON_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&passwd_caption},
    {COMMON_PASSWD_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0, (void*)&passwd_textedit},
    {GPRS_AUTH_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&auth_type_caption},
    {GPRS_AUTH_SELECT_ID, CUI_INLINE_ITEM_TYPE_SELECT, 0, (void*)&auth_type_select},
    {GPRS_ADVANCE_DISPLAY_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, IMG_GLOBAL_L6, (void*)&advance_displayonly}
};

static const cui_inline_set_item_struct gprs_common_inline_view_items[GPRS_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE] =
{
    {COMMON_NAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&account_name_caption},
    {COMMON_NAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&account_name_displayonly},
    {COMMON_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&apn_caption},
    {COMMON_ADDR_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&apn_displayonly},
    {COMMON_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&username_caption},
    {COMMON_USERNAME_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&username_displayonly},
    {COMMON_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&passwd_caption},
    {COMMON_PASSWD_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&passwd_displayonly},
    {GPRS_AUTH_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&auth_type_caption},
    {GPRS_AUTH_SELECT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&auth_type_displayonly},
    {GPRS_ADVANCE_DISPLAY_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, IMG_GLOBAL_L6, (void*)&advance_displayonly}
};
#endif

static const cui_inline_set_item_struct advanced_common_inline_edit_items[ADVANCED_SUBNET_END - CUI_INLINE_ITEM_ID_BASE - 1] =
{
    {ADVANCED_HOMEPAGE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&homepage_caption},
    {ADVANCED_HOMEPAGE_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, (void*)&homepage_fsedit},
    {ADVANCED_CONN_TYPE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&conn_type_caption},
#ifndef WAP2_HTTP
    {ADVANCED_CONN_TYPE_SELECT_ID, CUI_INLINE_ITEM_TYPE_SELECT, 0, (void*)&conn_type_select},
#else
    {ADVANCED_CONN_TYPE_SELECT_ID, CUI_INLINE_ITEM_TYPE_CAPTION, 0, (void*)&conn_type_http_caption},
#endif
    {ADVANCED_USER_PROXY_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&use_proxy_caption},
    {ADVANCED_USER_PROXY_SELECT_ID, CUI_INLINE_ITEM_TYPE_SELECT, 0, (void*)&use_proxy_select},
    {ADVANCED_PROXY_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&proxy_address_caption},
    {ADVANCED_PROXY_ADDR_IP4_ID, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, (void*)&proxy_address_fsedit},
    {ADVANCED_PROXY_PORT_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&proxy_port_caption},
    {ADVANCED_PROXY_PORT_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_TEXT_EDIT  | CUI_INLINE_ITEM_NO_LEADING_ZERO, 0, (void*)&proxy_port_textedit},
    {ADVANCED_PROXY_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L6, (void*)&proxy_username_caption},
    {ADVANCED_PROXY_USERNAME_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, (void*)&proxy_username_fsedit},
    {ADVANCED_PROXY_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L7, (void*)&proxy_password_caption},
    {ADVANCED_PROXY_PASSWD_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT, 0, (void*)&proxy_password_fsedit},    
#ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
    {ADVANCED_DNS1_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L8, (void*)&dns_address1_caption},
    {ADVANCED_DNS1_IP4_ID, CUI_INLINE_ITEM_TYPE_IP4, 0, (void*)&dns_address1_ip4},    
    {ADVANCED_DNS2_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L9, (void*)&dns_address2_caption},
    {ADVANCED_DNS2_IP4_ID, CUI_INLINE_ITEM_TYPE_IP4, 0, (void*)&dns_address2_ip4},
    {ADVANCED_IP_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L10, (void*)&ip_address_caption},
    {ADVANCED_IP_IP4_ID, CUI_INLINE_ITEM_TYPE_IP4, 0, (void*)&ip_address_ip4},
    {ADVANCED_SUBNET_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L11, (void*)&subnet_caption},
    {ADVANCED_SUBNET_IP4_ID, CUI_INLINE_ITEM_TYPE_IP4, 0, (void*)&subnet_ip4},
#endif
};


#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
static const cui_inline_set_item_struct advanced_common_inline_view_items[ADVANCED_SUBNET_END - CUI_INLINE_ITEM_ID_BASE - 1] =
{
    {ADVANCED_HOMEPAGE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L1, (void*)&homepage_caption},
    {ADVANCED_HOMEPAGE_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&homepage_displayonly},
    {ADVANCED_CONN_TYPE_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L2, (void*)&conn_type_caption},
    {ADVANCED_CONN_TYPE_SELECT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&conn_type_displayonly},
    {ADVANCED_USER_PROXY_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L3, (void*)&use_proxy_caption},
    {ADVANCED_USER_PROXY_SELECT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&use_proxy_displayonly},
    {ADVANCED_PROXY_ADDR_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L4, (void*)&proxy_address_caption},
    {ADVANCED_PROXY_ADDR_IP4_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&proxy_address_displayonly},
    {ADVANCED_PROXY_PORT_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L5, (void*)&proxy_port_caption},
    {ADVANCED_PROXY_PORT_TEXTEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&proxy_port_displayonly},
    {ADVANCED_PROXY_USERNAME_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L6, (void*)&proxy_username_caption},
    {ADVANCED_PROXY_USERNAME_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&proxy_username_displayonly},
    {ADVANCED_PROXY_PASSWD_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L7, (void*)&proxy_password_caption},
    {ADVANCED_PROXY_PASSWD_FSEDIT_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&proxy_password_displayonly},    
#ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
    {ADVANCED_DNS1_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L8, (void*)&dns_address1_caption},
    {ADVANCED_DNS1_IP4_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&dns_address1_displayonly},    
    {ADVANCED_DNS2_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L9, (void*)&dns_address2_caption},
    {ADVANCED_DNS2_IP4_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&dns_address2_displayonly},
    {ADVANCED_IP_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L10, (void*)&ip_address_caption},
    {ADVANCED_IP_IP4_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&ip_address_displayonly},
    {ADVANCED_SUBNET_CAPTION_ID, CUI_INLINE_ITEM_TYPE_CAPTION, IMG_GLOBAL_L11, (void*)&subnet_caption},
    {ADVANCED_SUBNET_IP4_ID, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY | CUI_INLINE_ITEM_DISPLAY_ONLY_SHOW, 0, (void*)&subnet_displayonly},
#endif
};
#endif

static const U16 mmi_dtcnt_sim_str_id[] = 
{
    STR_GLOBAL_SIM_1,
    STR_GLOBAL_SIM_2,
    STR_GLOBAL_SIM_3,
    STR_GLOBAL_SIM_4,
};

#ifdef __MMI_AP_DCM_DTCNT__
#pragma arm section rodata , code
#endif

/***************************************************************************** 
 * Static functions
 *****************************************************************************/
static void mmi_dtcnt_delete_account(void);
static void mmi_dtcnt_delete_account_confirm(void);
static void mmi_dtcnt_go_to_main_list(void);
static void mmi_dtcnt_entry_change_default(void);
static void mmi_dtcnt_prepare_data_account_list(srv_dtcnt_sim_type_enum sim_type, mmi_dtcnt_prepare_data_enum prepare_data_type);
static void mmi_dtcnt_get_inline_ip_value(mmi_id group_id, U16 item_id, U8 *ip_array);
static mmi_ret mmi_dtcnt_cui_event_proc(mmi_event_struct *evt);
static mmi_ret mmi_dtcnt_main_scrn_proc(mmi_event_struct *evt);
static void mmi_dtcnt_entry_option(void);
static void mmi_dtcnt_ok_popup(void);
static MMI_BOOL mmi_dtcnt_check_advanced_setting(U8 use_proxy, U8* port_str, U8* ip);
static void mmi_dtcnt_add_disp_list(U32 acct_id, U8 bearer_type, srv_dtcnt_prof_acc_type_enum account_type, U8 conn_type, U8 sim_info, U8 read_only);
static void mmi_dtcnt_update_disp_list(U32 acct_id, U8 bearer_type, srv_dtcnt_prof_acc_type_enum account_type, U8 conn_type, U8 sim_info, U8 read_only);
static void mmi_dtcnt_display_confirm_popup(U32 auto_map, mmi_proc_func proc_func, U16 str_id);

// INLINE
static void mmi_dtcnt_password_display(U8 *password_buf);
static void mmi_dtcnt_set_inline_proxy_info_attr(mmi_id group_id, U8 use_proxy);
static void mmi_dtcnt_entry_account(dtcnt_set_profile_enum set_type, srv_dtcnt_bearer_enum bearer);
static void mmi_dtcnt_init_display_context(void);
static void mmi_dtcnt_load_display_context(U32 account_id, srv_dtcnt_bearer_enum bearer);
static void mmi_dtcnt_entry_account_common(srv_dtcnt_bearer_enum bearer);
static mmi_ret mmi_dtcnt_confirm_callback(mmi_alert_result_evt_struct *evt);
static void mmi_dtcnt_set_account_confirm(srv_dtcnt_bearer_enum bearer);
static void mmi_dtcnt_set_account(srv_dtcnt_bearer_enum bearer);
static void mmi_dtcnt_convert_ip_to_display(U8 *string_buffer, U8 *IP);
static void mmi_dtcnt_entry_advanced_settings(void);

static void mmi_dtcnt_get_defined_prof(void);
static U8 mmi_dtcnt_get_index_by_port(U16 port);  
static U16 mmi_dtcnt_get_port_by_index(U8 index);
static U8 mmi_dtcnt_get_acct_num_exclude_sim_prov_per_sim(srv_dtcnt_sim_type_enum sim_type);
#if defined(__DA_SMART_SELECTION_SUPPORT__)
static void mmi_dtcnt_close_group(void);
#endif
void mmi_dtcnt_prov_ind_hdlr(mmi_event_struct *param);


/***************************************************************************** 
 * Global functions
 *****************************************************************************/
extern void cui_dtcnt_close_all_group(U32 sim_selection);
extern void cui_inline_set_all_items_softkey_text(mmi_id gid, WGUI_SOFTKEY_ENUM key, U16 string_id);

#if defined (__MMI_AP_DCM_DTCNT__)
extern void mmi_dtcnt_post_unload_dcm(void);
extern void mmi_dtcnt_send_unload_dcm(void);
#endif

/***************************************************************************** 
 * Functions
 *****************************************************************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_defined_prof
 * DESCRIPTION
 *  Get the defined profile.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_dtcnt_get_defined_prof(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 0, j = 0;
    srv_dtcnt_result_enum result;
    srv_dtcnt_store_prof_qry_struct acct_id_query;   
    srv_dtcnt_connection_type_enum conn_type = SRV_DTCNT_CONN_TYPE_WAP;
    srv_dtcnt_sim_type_enum sim_info = SRV_DTCNT_SIM_TYPE_NONE;
    srv_dtcnt_prof_app_info_struct invalid_info;
    MMI_BOOL ret;
    mmi_sim_enum availSimEnum = MMI_SIM_NONE;
    U32 default_account_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // get profile
    acct_id_query.qry_info.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE;
    for (i = 0; i < SRV_DTCNT_PROF_TYPE_DM_CONF; i++)
    {
        acct_id_query.qry_info.acc_type_info = (srv_dtcnt_prof_acc_type_enum)(SRV_DTCNT_PROF_TYPE_USER_CONF + i);
        result = srv_dtcnt_store_qry_ids(&acct_id_query);
        if (result == SRV_DTCNT_RESULT_FS_ERROR || acct_id_query.num_ids > SRV_DTCNT_PROF_MAX_ACCOUNT_NUM)
        {
            g_dtcnt_acct_ready = MMI_FALSE;
            return;
        }
        
        for (j = 0; j < acct_id_query.num_ids; j++)
        {
            g_mmi_dtcnt_list_item[j + g_mmi_dtcnt_acct_num].profile_id = acct_id_query.ids[j];
            g_mmi_dtcnt_list_item[j + g_mmi_dtcnt_acct_num].account_type = (srv_dtcnt_prof_acc_type_enum)(SRV_DTCNT_PROF_TYPE_USER_CONF + i);
        }
        g_mmi_dtcnt_acct_num += acct_id_query.num_ids;
    }

    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        ret = srv_dtcnt_get_default_account((srv_dtcnt_sim_type_enum)(i + SRV_DTCNT_SIM_TYPE_1), &default_account_id);
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_DEFAULT_ACCOUNT, (i + SRV_DTCNT_SIM_TYPE_1), default_account_id, ret);
    }

    /* 5 to get each profile settings */
    for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
    {
        //srv_dtcnt_store_update_acc_apinfo(g_mmi_dtcnt_list_item[i].profile_id, 0, &(g_mmi_dtcnt_list_item[i].app_info));

        srv_dtcnt_get_connection_type(g_mmi_dtcnt_list_item[i].profile_id, &conn_type);

        g_mmi_dtcnt_list_item[i].connection_type = conn_type;

        srv_dtcnt_get_sim_info(g_mmi_dtcnt_list_item[i].profile_id, &sim_info);

        g_mmi_dtcnt_list_item[i].sim_info = sim_info;

        if (srv_dtcnt_acct_is_read_only(g_mmi_dtcnt_list_item[i].profile_id))
        {
            g_mmi_dtcnt_list_item[i].read_only = 1;
        }
        else
        {
            g_mmi_dtcnt_list_item[i].read_only = 0;
        }

        if (SRV_DTCNT_BEARER_CSD == 
            srv_dtcnt_get_bearer_type(g_mmi_dtcnt_list_item[i].profile_id, SRV_DTCNT_ACCOUNT_PRIMARY))
        {
            g_mmi_dtcnt_list_item[i].bearer_type = DATA_ACCOUNT_BEARER_CSD;
        }
        if (SRV_DTCNT_BEARER_GPRS == 
            srv_dtcnt_get_bearer_type(g_mmi_dtcnt_list_item[i].profile_id, SRV_DTCNT_ACCOUNT_PRIMARY))
        {
            g_mmi_dtcnt_list_item[i].bearer_type = DATA_ACCOUNT_BEARER_GPRS;
        }

    }
    
    ret = srv_dtcnt_get_sim_preference(&sim_info);
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DATA_CONNECTION_SIM_GET_SIM_PREFERENCE, sim_info, ret);

#ifdef __MMI_TELEPHONY_SUPPORT__
    availSimEnum = (mmi_sim_enum)srv_sim_ctrl_get_one_available_sim();
#else
    availSimEnum = 0;
#endif
    if (!availSimEnum)
    {
        ret = srv_dtcnt_set_sim_preference(SRV_DTCNT_SIM_TYPE_NONE);
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DATA_CONNECTION_SIM_SET_SIM_PREFERENCE, SRV_DTCNT_SIM_TYPE_NONE, ret);
    }
    else
    {
        U32 availSimIndex = 0;
        availSimIndex = mmi_frm_sim_to_index(availSimEnum);
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DATA_CONNECTION_SIM_GET_SIM_PREFERENCE, availSimEnum, availSimIndex);
    #ifdef __MMI_TELEPHONY_SUPPORT__
        if (sim_info == SRV_DTCNT_SIM_TYPE_NONE ||
            !srv_sim_ctrl_is_available(mmi_frm_index_to_sim((U32)sim_info - 1)))
    #else
        if (sim_info == SRV_DTCNT_SIM_TYPE_NONE)
    #endif /* __MMI_TELEPHONY_SUPPORT__ */
        {
            ret = srv_dtcnt_set_sim_preference((srv_dtcnt_sim_type_enum)(availSimIndex + 1));
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DATA_CONNECTION_SIM_SET_SIM_PREFERENCE, availSimIndex + 1, ret);
    #if (MMI_MAX_SIM_NUM >= 2)
            //s_simPreferFlag = availSimIndex + 1; use to display popup
    #endif
        }
    }
    memset(&invalid_info, 0, sizeof(srv_dtcnt_prof_app_info_struct));
    srv_dtcnt_store_update_acc_apinfo(&invalid_info);
    g_dtcnt_acct_ready = MMI_TRUE;
    for (i = 0; i < DTCNT_READY_CHECK_NUM; i++)
    {
        if (g_dtcnt_ready_check_cb[i])
        {
            g_dtcnt_ready_check_cb[i]();
            g_dtcnt_ready_check_cb[i] = NULL;
        }
    }
}



#if defined(__DA_SMART_SELECTION_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_sim_match
 * DESCRIPTION
 *  Check if SIM matches the phone's one.
 * PARAMETERS
 *  operate   [IN]      operator name.
 *  code      [IN]      SIM card code that is separated with ",", such as "0061, 0089".
 * RETURNS
 *  Return KAL_TRUE on match, otherwise return KAL_FALSE.
 *****************************************************************************/
U8 mmi_dtcnt_sim_match(const CHAR *operate, const CHAR *code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const char *sim_id = "00000";
    U8 sim_match = 0;
    U32 i;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (code == NULL)
    {
        return sim_match;
    }
    if (strcmp(code, sim_id) == 0)
    {
        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            if ((g_dtcnt_sim[i][0] != 0) && g_sim_changed[i])
            {
                
                sim_match += (U8)mmi_frm_index_to_sim(i);
            }
        }
    }
    else
    {    
        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            if ((g_dtcnt_sim[i][0] != 0) && strstr(code, g_dtcnt_sim[i]) && g_sim_changed[i])
            {
                sim_match += (U8)mmi_frm_index_to_sim(i);
            }
        }
    }    
    return sim_match;
}


#ifndef __MMI_DTCNT_XML_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_account_item_start
 * DESCRIPTION
 *  Initialize one data account that xml will store the field into the variable.
 * PARAMETERS
 *  bearer              [IN]      bearer type: GPRS or CSD.
 *  comm_dtcnt_data     [OUT] account common data
 *  acct_name           [OUT] account name
 *  addr                [OUT] apn or dial number
 *  dialType            [OUT] used for CSD only
 *  dataRate            [OUT] used for CSD only
 * RETURNS
 *  Return account variable on success, otherwise return NULL.
 *****************************************************************************/
void mmi_dtcnt_account_item_start(
    S32 bearer, 
    srv_dtcnt_prof_common_header_struct **comm_dtcnt_data, 
    U8 **acct_name, 
    U8 **addr, 
    srv_dtcnt_prof_csd_dial_type_enum **dialType, 
    srv_dtcnt_prof_csd_rate_enum **dataRate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    //initial global variable
    *comm_dtcnt_data = NULL;
    g_data_account_display_cntx.data_account_name[0] = 0;
    g_data_account_display_cntx.data_account_name[1] = 0;
    g_data_account_display_cntx.addr[0] = 0;
    g_data_account_display_cntx.addr[1] = 0;

    *acct_name = g_data_account_display_cntx.data_account_name;
    *addr = g_data_account_display_cntx.addr;

    switch (bearer)
    {
        case SRV_DTCNT_BEARER_GPRS:
        #ifdef __MMI_GPRS_FEATURES__
            memset(&g_data_account_gprs_profile_srv, 0, sizeof(srv_dtcnt_prof_gprs_struct));
            *comm_dtcnt_data = &g_data_account_gprs_profile_srv.prof_common_header;
        #endif
            break;
        case SRV_DTCNT_BEARER_CSD:
        #ifdef __TCPIP_OVER_CSD__
            memset(&g_data_account_csd_profile_srv, 0, sizeof(srv_dtcnt_prof_csd_struct));
            g_data_account_csd_profile_srv.DataRate = SRV_DTCNT_PROF_CSD_RATE_NINE_SIX;
            *dialType = &g_data_account_csd_profile_srv.DialType;
            *dataRate = &g_data_account_csd_profile_srv.DataRate;
            *comm_dtcnt_data = &g_data_account_csd_profile_srv.prof_common_header;
        #endif
            break;
    }
    if (*comm_dtcnt_data)
    {
        (*comm_dtcnt_data)->px_service = SRV_DTCNT_PROF_PX_SRV_HTTP;
        (*comm_dtcnt_data)->acct_type = SRV_DTCNT_PROF_TYPE_FACTORY_CONF;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_type
 * DESCRIPTION
 *  To add display list
 * PARAMETERS
 *  index        [IN]      diplay list 
 *  acct_id
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_dtcnt_get_type(mmi_dtcnt_type_enum option, const CHAR *name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!name)
    {
        return 0;
    }
    switch (option)
    {
        case MMI_DTCNT_CONN_TYPE:
        {
            if (strcmp(name, "WAP") == 0)
            {
                return SRV_DTCNT_PROF_PX_SRV_CO_WSP;
            }
            else if (strcmp(name, "HTTP") == 0)
            {
                return SRV_DTCNT_PROF_PX_SRV_HTTP;
            }
            else
            {
                return SRV_DTCNT_PROF_PX_SRV_HTTP; 
            }
        }
        case MMI_DTCNT_APP_TYPE:
        {
            return mmi_custom_account_get_apptype(name);
        }
        case MMI_DTCNT_DIAL_TYPE:
        {
            if (strcmp(name, "Analogue") == 0)
            {
                return 0;
            }
            else if (strcmp(name, "ISDN") == 0)
            {
                return 1;
            }
            else
            {
                return 0; 
            }
        }
        case MMI_DTCNT_DATA_RATE_TYPE:
        {
            if (strcmp(name, "2.4") == 0)
            {
                return 0;
            }
            else if (strcmp(name, "4.8") == 0)
            {
                return 1;
            }
            else if (strcmp(name, "9.6") == 0)
            {
                return 2;
            }
            else if (strcmp(name, "14.4") == 0)
            {
                return 3; 
            }
            else if (strcmp(name, "Auto") == 0)
            {
                return 4;
            }
            else
            {
                return 2;
            }
        }
        case MMI_DTCNT_AUTH_TYPE:
        {
            if (strcmp(name, "Normal") == 0)
            {
                return 0;
            }
            else if (strcmp(name, "Secure") == 0)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        default:
        {
            return 0;
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_address
 * DESCRIPTION
 *  To add display list
 * PARAMETERS
 *  ip          [OUT]      array to store ip[4]
 *  data        [IN]      ip data "10.0.0.101" 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_get_address(U8 *ip, const CHAR *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ip_address[MAX_PART_IP_ADDRESS]; /* use U16 to justify ip value > 255 */
    CHAR tmp_buf[MAX_PART_IP_ADDRESS * 4];
    CHAR *point, *p, *q;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!data)
    {
        return;
    }
    //
    strcpy(tmp_buf, data);
    /* not allow blank space */
    if (strchr(tmp_buf, ' '))
    {
        return;
    }
    p = tmp_buf;
    while ((i < MAX_PART_IP_ADDRESS) && p)
    {
        point = strchr(p, '.');
        if (point)
        {
            q = point + 1;
            point = NULL;
        }
        else
        {
            q = NULL;
        }
        if (!p || !strlen(p))
        {
            return;
        }
        ip_address[i] = atoi(p);
        p = q;
        if (ip_address[i++] > 255)
        {
            return;
        }
    }
    if (i != MAX_PART_IP_ADDRESS)
    {
        return;
    }
    for (i = 0; i < MAX_PART_IP_ADDRESS; i++)
    {
        ip[i] = (U8)ip_address[i];
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *    mmi_dtcnt_account_item_end
 * DESCRIPTION
 *    Finish parsing one data account.
 * PARAMETERS
 *    bearer            [IN] bearer type: GPRS or CSD.
 *    comm_dtcnt_data   [IN] account common data
 *    acct_name         [IN] account name
 *    addr              [IN] apn or dial number
 *    dialType          [IN] csd only
 *    dataRate          [IN] csd only
 * RETURNS
 *    void.
 *****************************************************************************/
void mmi_dtcnt_account_item_end(
        S32 bearer, 
        srv_dtcnt_prof_common_header_struct *comm_dtcnt_data, 
        U8 *acct_name, 
        U8 *addr)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_data_struct prof_info;
    U32 acct_id;
    srv_dtcnt_result_enum result;
    U8 sim_match;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __TCPIP_OVER_CSD__
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {        
        prof_info.prof_type = SRV_DTCNT_BEARER_CSD;
        g_data_account_csd_profile_srv.DialNumber = addr;
        prof_info.prof_data = &g_data_account_csd_profile_srv;
    }
#endif
#ifdef __MMI_GPRS_FEATURES__
    if (bearer == SRV_DTCNT_BEARER_GPRS)
    {        
        prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;
        g_data_account_gprs_profile_srv.APN = addr;
        prof_info.prof_data = &g_data_account_gprs_profile_srv;
    }
#endif
#if defined (__MMI_GPRS_FEATURES__) || defined (__TCPIP_OVER_CSD__)
    if (!strlen((char*)addr))
    {
        return;
    }
    if (comm_dtcnt_data->AppType & DTCNT_APPTYPE_DM)
    {
        comm_dtcnt_data->acct_type = SRV_DTCNT_PROF_TYPE_DM_CONF;
    }
    else
    {            
        comm_dtcnt_data->acct_type = SRV_DTCNT_PROF_TYPE_FACTORY_CONF;
    }    
    comm_dtcnt_data->AccountName = acct_name;
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_ALL;
    sim_match = comm_dtcnt_data->sim_info;
    //mmi_dtcnt_save_csd_display_context();
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        if (sim_match & mmi_frm_index_to_sim(i))
        {
            comm_dtcnt_data->sim_info = (srv_dtcnt_sim_type_enum)(SRV_DTCNT_SIM_TYPE_1 + i);
            result = srv_dtcnt_store_add_prof(&prof_info, &acct_id);
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ADD_SIM_PROF, acct_id, result);
        }
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *    mmi_dtcnt_account_parse_end
 * DESCRIPTION
 *    parse end callback function.
 * PARAMETERS
 *    ret      [IN]      parse result.
 * RETURNS
 *    void.
 *****************************************************************************/
void mmi_dtcnt_account_parse_end(S32 ret)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
#if defined(__XML_SUPPORT__)
    U32 i;
    mmi_sim_enum simEnum = MMI_SIM1;
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__XML_SUPPORT__)
    if (g_dtcnt_file_exist)
    {
        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            simEnum = mmi_frm_index_to_sim(i);
            if (g_dtcnt_file_exist & simEnum)
            {
                MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_XML_PARSE_SIM, simEnum);
                g_dtcnt_file_exist -= simEnum;
                mmi_dtcnt_xml_parse(g_dtcnt_conf[i]);
                break;
            }
        }
    }
    else
    {
        mmi_dtcnt_get_defined_prof();
    }
#endif
    return;
}
#endif /* #ifndef __MMI_DTCNT_XML_SLIM__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_add_sim_prof
 * DESCRIPTION
 *  Add SIM profile to service.
 * PARAMETERS
 *  sim             : [IN]  Which SIM
 *  out_buffer      : [OUT] PLMN buffer to be filled in, it shall at least
 *                          (SRV_MAX_PLMN_LEN + 1) bytes.
 * RETURN VALUES
 *  Return SRV_DTCNT_RESULT_SUCCESS on success, otherwise return erroce code
 *****************************************************************************/
static srv_dtcnt_result_enum mmi_dtcnt_add_sim_prof(U8 sim_match, 
                        srv_dtcnt_sim_type_enum *sim_info,    
                        srv_dtcnt_store_prof_data_struct *prof,
                        U32 *acct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    srv_dtcnt_result_enum result = SRV_DTCNT_RESULT_FAILED;
    U32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        if (sim_match & mmi_frm_index_to_sim(i))
        {
            *sim_info = (srv_dtcnt_sim_type_enum)(SRV_DTCNT_SIM_TYPE_1 + i);
            result = srv_dtcnt_store_add_prof(prof, acct_id);
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ADD_SIM_PROF, *acct_id, result);
        }
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_add_config_account
 * DESCRIPTION
 *  add csd account
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_add_config_account(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_data_struct prof_info;
    U32 acct_id;
    U8 sim_match;
    srv_dtcnt_result_enum result;

    srv_dtcnt_prof_gprs_struct *gprs_account, gprs_acct_tmp;
    srv_dtcnt_prof_csd_struct *csd_account, csd_acct_tmp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_GPRS_FEATURES__
    /* save gprs account */
    prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;    
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_ALL;
    gprs_account = (srv_dtcnt_prof_gprs_struct *)custom_config_get_account(SRV_DTCNT_BEARER_GPRS);
    
    while (gprs_account)
    {
        if (!gprs_account->APN)
        {
            gprs_account = (srv_dtcnt_prof_gprs_struct *)custom_config_get_account(SRV_DTCNT_BEARER_GPRS);
            continue;
        }
        gprs_acct_tmp = *gprs_account;
        gprs_account = &gprs_acct_tmp;
        sim_match = mmi_dtcnt_sim_match(NULL, (CHAR *)gprs_account->prof_common_header.user_data);

        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ADD_CONFIG_ACCOUNT, 1, sim_match);

        /* add code to process sim match */
        gprs_account->prof_common_header.sim_info = SRV_DTCNT_SIM_TYPE_1;
        prof_info.prof_data = gprs_account;

        if (sim_match)
        {
            result = mmi_dtcnt_add_sim_prof(sim_match, 
                &(gprs_account->prof_common_header.sim_info), 
                &prof_info, 
                &acct_id);
        }

        gprs_account = (srv_dtcnt_prof_gprs_struct *)custom_config_get_account(SRV_DTCNT_BEARER_GPRS);
    }
#endif
#ifdef __TCPIP_OVER_CSD__
    /* save csd account */
    prof_info.prof_type = SRV_DTCNT_BEARER_CSD;    
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_ALL;
    csd_account = (srv_dtcnt_prof_csd_struct *)custom_config_get_account(SRV_DTCNT_BEARER_CSD);

    while (csd_account)
    {
        if (!csd_account->DialNumber)
        {
            csd_account = (srv_dtcnt_prof_csd_struct *)custom_config_get_account(SRV_DTCNT_BEARER_CSD);
            continue;
        }
        csd_acct_tmp = *csd_account;
        csd_account = &csd_acct_tmp;
        sim_match = mmi_dtcnt_sim_match(NULL, (CHAR *)csd_account->prof_common_header.user_data);
        
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ADD_CONFIG_ACCOUNT, 2, sim_match);

        /* add code to process sim match */
        csd_account->prof_common_header.sim_info = SRV_DTCNT_SIM_TYPE_1;
        prof_info.prof_data = csd_account;
        if (sim_match)
        {
            result = mmi_dtcnt_add_sim_prof(sim_match, 
                &(csd_account->prof_common_header.sim_info), 
                &prof_info, 
                &acct_id);
        }

        csd_account = (srv_dtcnt_prof_csd_struct *)custom_config_get_account(SRV_DTCNT_BEARER_CSD);
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_is_conf_file_exit
 * DESCRIPTION
 *  add csd account
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  Return non zero on success, otherwise return 0.
 *****************************************************************************/
static S32 mmi_dtcnt_is_conf_file_exit(void)
{
#ifndef __MMI_DTCNT_XML_SLIM__
#if defined(__XML_SUPPORT__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE acct_file;
    U32 i, j;
    MMI_BOOL need_fs_open = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        for (j = 0; j < i; j++)
        {
            if (!mmi_wcscmp(g_dtcnt_conf[i], g_dtcnt_conf[j]))
            {
                need_fs_open = MMI_FALSE;
                break;
            }
        }
        if (need_fs_open)
        {
            acct_file = FS_Open((kal_wchar*)g_dtcnt_conf[i], FS_READ_ONLY);
            if (acct_file >= FS_NO_ERROR)
            {
                FS_Close(acct_file);
                g_dtcnt_file_exist += (S32)mmi_frm_index_to_sim(i);
            }
        }
        need_fs_open = MMI_TRUE;
    }
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_IS_CONF_FILE_EXIST, g_dtcnt_file_exist);
    return g_dtcnt_file_exist;
#else
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_IS_CONF_FILE_EXIST, 0);
    return 0;
#endif    
#else
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_IS_CONF_FILE_EXIST, 0);
    return 0;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_pre_install_parse
 * DESCRIPTION
 *  add csd account
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_dtcnt_pre_install_parse(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 acct_file;
    U32 i;
    mmi_sim_enum simEnum = MMI_SIM1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_DTCNT_XML_SLIM__
#if defined(__XML_SUPPORT__)
    acct_file = mmi_dtcnt_is_conf_file_exit();

    if (acct_file)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PRE_INSTALL_PARSE, 1);

        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            simEnum = mmi_frm_index_to_sim(i);
            if (acct_file & simEnum)
            {
                MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_XML_PARSE_SIM, simEnum);
                g_dtcnt_file_exist -= simEnum;
                mmi_dtcnt_xml_parse(g_dtcnt_conf[i]);
                break;
            }
        }
    }
    else
#endif
#endif
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PRE_INSTALL_PARSE, 3);

        mmi_dtcnt_add_config_account();
        mmi_dtcnt_get_defined_prof();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_sim_plmn
 * DESCRIPTION
 *  Get Home PLMN specified in the SIM.
 *
 *  NOTE: It requires time to read Home PLMN. Home PLMN is ready only if
 *  SRV_SIM_CTRL_HOME_PLMN_CHANGED has been emitted after SIM is available.
 * PARAMETERS
 *  sim             : [IN]  Which SIM
 *  out_buffer      : [OUT] PLMN buffer to be filled in, it shall at least
 *                          (SRV_MAX_PLMN_LEN + 1) bytes.
 * RETURN VALUES
 *  MMI_TRUE    : If home PLMN is available and returned.
 *  MMI_FALSE   : Home PLMN is unavailable; for example, SIM is not inserted.
 * SEE ALSO
 *  SRV_SIM_CTRL_HOME_PLMN_CHANGED
 *****************************************************************************/
static MMI_BOOL mmi_dtcnt_get_sim_plmn(mmi_sim_enum sim, CHAR *out_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    MMI_BOOL retn = MMI_FALSE;
    S32 end = SRV_MAX_PLMN_LEN;
    S32 digits_of_mnc;
    CHAR imsi[SRV_MAX_IMSI_LEN + 1];
    CHAR temp_mcc[SRV_MCC_LEN + 1];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TELEPHONY_SUPPORT__
    if (srv_sim_ctrl_is_available(sim))
    {
        retn = srv_sim_ctrl_get_home_plmn(sim, out_buffer, MMI_DTCNT_MAX_PLMN_LEN);
        if (retn)
        {
            // get mnc length
            digits_of_mnc = srv_sim_ctrl_get_mnc_len_in_ef_ad(sim); //TODO:
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_MNC_LEN_IN_EF_AD, digits_of_mnc, sim);
            if ((digits_of_mnc != 0x2) || (digits_of_mnc != 0x3))
            {
                memset(temp_mcc, 0, (SRV_MCC_LEN + 1));
                strncpy(temp_mcc, out_buffer, SRV_MCC_LEN);
                if (0 == strcmp(temp_mcc, "405"))
                {
                    memset(imsi, 0, (SRV_MAX_IMSI_LEN + 1));
                    if (MMI_TRUE == srv_sim_ctrl_get_imsi(sim, (CHAR*)imsi, SRV_MAX_IMSI_LEN + 1))
                    {
                        switch(imsi[4])
                        {
                            case '0':
                            {
                                switch(imsi[5])
                                {
                                    case '1':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                        digits_of_mnc = 2;
                                        break;
                                    default:
                                        digits_of_mnc = 3;
                                        break;
                                }
                            }
                            break;
                            case '1':
                            case '2':
                            {
                                digits_of_mnc = 2;
                            }
                            break;
                            case '4':
                            {
                                if(imsi[5] == '8')
                                {
                                    digits_of_mnc = 2;
                                }
                                else
                                {
                                    digits_of_mnc = 3;
                                }
                            }
                            break;
                            case '5':
                            case '6':
                            {
                                digits_of_mnc = 2;
                            }
                            break;
                            case '7':
                            {
                                if(imsi[5] == '0')
                                {
                                    digits_of_mnc = 2;
                                }
                                else
                                {
                                    digits_of_mnc = 3;
                                }
                            }
                            break;
                            default:
                            {
                                digits_of_mnc = 3;
                            }
                            break;
                        } 
                        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_IMSI, imsi[4], imsi[5], digits_of_mnc);
                        if (digits_of_mnc == 3)
                        {
                            strncpy(out_buffer, (CHAR*)&(imsi[1]), SRV_MAX_PLMN_LEN);
                        }
                    }
                }
            }
        }
        out_buffer[end] = 0;
    }
#endif

    return retn;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_is_sim_card_changed
 * DESCRIPTION
 *  To check if the sim card is changed
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_is_sim_card_changed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 sim_card_id[4 * MMI_DTCNT_MAX_PLMN_LEN + 1];
    S16 error;
    MMI_BOOL sim_change = MMI_FALSE;
    CHAR conf_name[MMI_DTCNT_CONF_NAME_LEN * 2];
    U8 *sim_card_id_temp;
    MMI_BOOL retn;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(sim_card_id, 0, 4 * MMI_DTCNT_MAX_PLMN_LEN + 1);
    ReadRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);

    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {        
        sim_card_id_temp = &sim_card_id[MMI_DTCNT_MAX_PLMN_LEN * i];
        memset(g_dtcnt_sim[i], 0, MMI_DTCNT_MAX_PLMN_LEN);
        retn = mmi_dtcnt_get_sim_plmn(mmi_frm_index_to_sim(i), g_dtcnt_sim[i]);    
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_SIM_CARD_CHANGED, 10, retn);
        if (!retn)
        {
            memset(g_dtcnt_sim[i], 0, MMI_DTCNT_MAX_PLMN_LEN);
            if (strcmp((CHAR*)g_dtcnt_sim[i], (CHAR*)sim_card_id_temp))
            {
                memset(sim_card_id_temp, 0, MMI_DTCNT_MAX_PLMN_LEN);
                sim_change = MMI_TRUE;
            }
            else
            {
                g_sim_changed[i] = MMI_FALSE;
            }
        }
        else
        {
            sprintf(conf_name, "z:\\%s.xml", g_dtcnt_sim[i]);
            mmi_asc_to_ucs2((CHAR*) g_dtcnt_conf[i], (CHAR*) conf_name);
            MMI_PRINT(MOD_MMI_CONN_APP, MMI_CONN_TRC_G6_DTCNT, "[DTCNT APP] sim id = %s-%s : 1", (char *)g_dtcnt_sim[i], (char *)sim_card_id_temp);
        
            if (strcmp((CHAR*)g_dtcnt_sim[i], (CHAR*)sim_card_id_temp)) /* SIM1 changed */
            {
                MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_SIM_CARD_CHANGED, 11, 1); // sim1 changed
            
                strcpy((CHAR*)sim_card_id_temp, (CHAR*)g_dtcnt_sim[i]);
                //WriteRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);
                sim_change = MMI_TRUE;
            }
            else
            {
                g_sim_changed[i] = MMI_FALSE;
            }
        }
    }
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_SIM_CARD_CHANGED, 50, sim_change);

    if (sim_change)
    {
        WriteRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_SIM_CARD_CHANGED, 51, sim_change);
    }
    return sim_change;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_delete_any_sim_profile
 * DESCRIPTION
 *  delete accounts related to one sim, include DM, sim provisioning and factory config.
 * PARAMETERS
 *  sim [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_delete_any_sim_profile(srv_dtcnt_sim_type_enum sim)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_qry_filter_struct delete_query;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_DELETE_ANY_SIM_PROFILE, sim);
    memset(&delete_query, 0, sizeof(delete_query));
    delete_query.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE | SRV_DTCNT_STORE_QRY_TYPE_SIM;
    delete_query.sim_qry_info = sim;

    /* Delete Factory Profile */
    delete_query.acc_type_info = SRV_DTCNT_PROF_TYPE_FACTORY_CONF;
    srv_dtcnt_store_delete_prof_by_qry(&delete_query, MMI_TRUE, NULL, NULL);

    /* Delete SIM Profile */
    delete_query.acc_type_info = SRV_DTCNT_PROF_TYPE_SIM_PROF;
    srv_dtcnt_store_delete_prof_by_qry(&delete_query, MMI_TRUE, NULL, NULL);

    /* Delete DM Profile */
    delete_query.acc_type_info = SRV_DTCNT_PROF_TYPE_DM_CONF;
    srv_dtcnt_store_delete_prof_by_qry(&delete_query, MMI_TRUE, NULL, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_sim_prof_delete
 * DESCRIPTION
 *  Process SIM profile.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_sim_prof_delete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        if (g_sim_changed[i])
        {
            mmi_dtcnt_delete_any_sim_profile((srv_dtcnt_sim_type_enum)(SRV_DTCNT_SIM_TYPE_1 + i));
        }
    }
}


#endif /* __DA_SMART_SELECTION_SUPPORT__ */

#ifdef __MMI_AP_DCM_DTCNT__
#pragma arm section rodata = "DYNAMIC_CODE_SETTINGS_RODATA" , code = "DYNAMIC_CODE_SETTINGS_ROCODE"
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_acct_num_exclude_sim_prov_per_sim
 * DESCRIPTION
 *  This function is used to get account num exclude sim provisioning about one SIM card.
 * PARAMETERS
 *
 * RETURNS
 *  return profile number exclude sim provisioning accounts
 *****************************************************************************/
U8 mmi_dtcnt_get_acct_num_exclude_sim_prov_per_sim(srv_dtcnt_sim_type_enum sim_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                     */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_qry_struct acct_id_query;
    U8 num = 0;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                                                           */
    /*----------------------------------------------------------------*/
    acct_id_query.qry_info.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE | SRV_DTCNT_STORE_QRY_TYPE_SIM;
    acct_id_query.qry_info.sim_qry_info = sim_type;
    acct_id_query.qry_info.acc_type_info = SRV_DTCNT_PROF_TYPE_USER_CONF;
    
    srv_dtcnt_store_qry_ids(&acct_id_query);
    num += acct_id_query.num_ids;
    
    acct_id_query.qry_info.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE | SRV_DTCNT_STORE_QRY_TYPE_SIM;
    acct_id_query.qry_info.acc_type_info = SRV_DTCNT_PROF_TYPE_FACTORY_CONF;
    
    srv_dtcnt_store_qry_ids(&acct_id_query);
    num += acct_id_query.num_ids;
    
    acct_id_query.qry_info.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE | SRV_DTCNT_STORE_QRY_TYPE_SIM;
    acct_id_query.qry_info.acc_type_info = SRV_DTCNT_PROF_TYPE_OTA_CONF;
    
    srv_dtcnt_store_qry_ids(&acct_id_query);
    num += acct_id_query.num_ids;
    
    return num;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_add_disp_list
 * DESCRIPTION
 *  To add display list
 * PARAMETERS
 *  index        [IN]      diplay list 
 *  acct_id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_add_disp_list(U32 acct_id, U8 bearer_type, srv_dtcnt_prof_acc_type_enum account_type, U8 conn_type, U8 sim_info, U8 read_only)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* error handler */
    if (g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].bearer_type != 0)
    {
        return;
    }
    /* update account list context */
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].account_type = account_type;
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].bearer_type = bearer_type;
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].profile_id = acct_id;
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].connection_type = conn_type;
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].sim_info = sim_info;
    g_mmi_dtcnt_list_item[g_mmi_dtcnt_acct_num].read_only = read_only;
    g_mmi_dtcnt_acct_num++;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_update_disp_list
 * DESCRIPTION
 *  To add display list
 * PARAMETERS
 *  index        [IN]      diplay list 
 *  acct_id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_update_disp_list(U32 acct_id, U8 bearer_type, srv_dtcnt_prof_acc_type_enum account_type, U8 conn_type, U8 sim_info, U8 read_only)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    U32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
    {
        if (g_mmi_dtcnt_list_item[i].profile_id == acct_id)
        {
            g_mmi_dtcnt_list_item[i].account_type = account_type;
            g_mmi_dtcnt_list_item[i].bearer_type = bearer_type;
            g_mmi_dtcnt_list_item[i].connection_type = conn_type;
            g_mmi_dtcnt_list_item[i].sim_info = sim_info;
            g_mmi_dtcnt_list_item[i].read_only = read_only;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_set_account_default_app_type
 * DESCRIPTION
 *  To set default app type
 * PARAMETERS
 *  acct_id   
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_set_account_default_app_type(U32 acct_id, MMI_BOOL with_popup_result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_data_struct prof_info;
    srv_dtcnt_result_enum result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __TCPIP_OVER_CSD__
    if (SRV_DTCNT_BEARER_CSD == srv_dtcnt_get_bearer_type(acct_id, SRV_DTCNT_ACCOUNT_PRIMARY))
    {        
        prof_info.prof_type = SRV_DTCNT_BEARER_CSD;
        prof_info.prof_data = &g_data_account_csd_profile_srv;
        prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_APP_TYPE;
    
        srv_dtcnt_store_qry_prof(acct_id, &prof_info);
        g_data_account_csd_profile_srv.prof_common_header.AppType |= 0x01;
    }
#endif
#ifdef __MMI_GPRS_FEATURES__
    if (SRV_DTCNT_BEARER_GPRS == srv_dtcnt_get_bearer_type(acct_id, SRV_DTCNT_ACCOUNT_PRIMARY))
    {
        prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;
        prof_info.prof_data = &g_data_account_gprs_profile_srv;
        prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_APP_TYPE;    
        srv_dtcnt_store_qry_prof(acct_id, &prof_info);        
        g_data_account_gprs_profile_srv.prof_common_header.AppType |= 0x01;
    }
#endif
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_APP_TYPE;
    result = srv_dtcnt_store_update_prof(acct_id, &prof_info);

    if (result == SRV_DTCNT_RESULT_SUCCESS)
    {
        MMI_TRACE(
            MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_SET_DEFAULT_ACCOUNT, 
            g_data_account_display_cntx.curr_sim_type, acct_id, result);
        //g_data_account_display_cntx.default_profile_id = acct_id;
    }
    if (with_popup_result == MMI_TRUE)
    {
        if (result == SRV_DTCNT_RESULT_SUCCESS)
        {
            mmi_popup_display_simple_ext(STR_GLOBAL_DONE, MMI_EVENT_SUCCESS, GRP_ID_DTCNT, NULL);
        }
        else
        {
            mmi_popup_display_simple_ext(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE, GRP_ID_DTCNT, NULL);        
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_clear_disp_list
 * DESCRIPTION
 *  To clear display context
 * PARAMETERS
 *  index        [IN]      diplay list 
 *  acct_id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_clear_disp_list(U32 index, U32 acct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    U32 i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_DTCNT_PROF_MAX_ACCOUNT_NUM; i++)
    {
        if (g_mmi_dtcnt_list_item[i].profile_id == acct_id)
        {
            memset(&g_mmi_dtcnt_list_item[i], 0, sizeof(mmi_dtcnt_list_disp_struct));
            for (j = i; j < g_mmi_dtcnt_acct_num - 1; j++)
            {
                memcpy(&g_mmi_dtcnt_list_item[j], &g_mmi_dtcnt_list_item[j + 1], sizeof(mmi_dtcnt_list_disp_struct));    
            }
            memset(&g_mmi_dtcnt_list_item[j], 0, sizeof(mmi_dtcnt_list_disp_struct));
        }
    }
    g_mmi_dtcnt_acct_num--;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_delete_account
 * DESCRIPTION
 *  To delete an account
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_delete_account(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    U32 acct_id, index;//, new_index;
    srv_dtcnt_result_enum result;
    MMI_BOOL ret;
    U32 default_account_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = g_data_account_display_cntx.cur_index;
    g_data_account_display_cntx.profile_setted = MMI_FALSE;
    acct_id = g_data_account_display_cntx.profile_list[index].profile_id;    

    if (mmi_dtcnt_is_account_in_use(acct_id))
    {
        mmi_popup_display_simple_ext(STR_ID_DTCNT_NOT_ALLOW_DELETE, MMI_EVENT_FAILURE, GRP_ID_DTCNT, NULL);
        return;
    }
    g_data_account_display_cntx.set_type = MMI_DTCNT_PROFILE_DELETE;
    /* delete profile */
    result = srv_dtcnt_store_delete_prof(acct_id, MMI_FALSE, NULL, NULL);

    if (result == SRV_DTCNT_RESULT_SUCCESS)
    {
        ret = srv_dtcnt_get_default_account(g_data_account_display_cntx.curr_sim_type, &default_account_id);
        MMI_TRACE(
            MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_DEFAULT_ACCOUNT, 
            g_data_account_display_cntx.curr_sim_type, default_account_id, ret);
        mmi_dtcnt_clear_disp_list(index, acct_id);
        mmi_dtcnt_ok_popup();
    }
}


/******************************************************************************
 * FUNCTION
 *  mmi_dtcnt_delete_account_confirm
 * DESCRIPTION
 *  delete account confirm
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_delete_account_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index;
    U16 str_id;
    U32 acct_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = g_data_account_display_cntx.cur_index;
    acct_id = g_data_account_display_cntx.profile_list[index].profile_id;

    if (mmi_dtcnt_is_account_in_use(acct_id))
    {
        mmi_popup_display_simple_ext(STR_ID_DTCNT_NOT_ALLOW_DELETE, MMI_EVENT_FAILURE, GRP_ID_DTCNT, NULL);
        return;
    }

    #ifndef __MMI_DTCNT_SLIM__
        str_id = STR_ID_DTCNT_DELETE_ASK;
    #else
        str_id = STR_GLOBAL_DELETE_ASK;
    #endif
    g_data_account_display_cntx.set_type = MMI_DTCNT_PROFILE_DELETE;
    mmi_dtcnt_display_confirm_popup(
        0, 
        (mmi_proc_func)mmi_dtcnt_confirm_callback,
        str_id);
}





/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_go_to_main_list
 * DESCRIPTION
 *  Go back 2 history screens to Data Account list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_go_to_main_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_prof_stop_tone(SRV_PROF_TONE_WARNING);
    mmi_frm_group_close(g_data_account_display_cntx.common_inline_group_id);
    mmi_frm_group_close(g_data_account_display_cntx.advanced_inline_group_id);
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_entry_change_default
 * DESCRIPTION
 *  To enter edit profile screen
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_entry_change_default(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_dtcnt_set_account_default_app_type(g_data_account_display_cntx.cur_profile_id, MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_arrange_account_list
 * DESCRIPTION
 *  Arrange the account list in order.
 * PARAMETERS
 *  prof_list    [IN]  profile list
 *  name_addr_arr [IN] account name and address array point which is related to profile list
 *  start        [IN]  start position
 *  end          [IN]  end position
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_dtcnt_arrange_account_list(mmi_dtcnt_list_disp_struct *prof_list, mmi_dtcnt_comm_disp_name_addr *name_addr_arr, S32 start, S32 end)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;
    S32 size1 = sizeof(mmi_dtcnt_list_disp_struct);
    S32 size2 = sizeof(mmi_dtcnt_comm_disp_name_addr);
    mmi_dtcnt_list_disp_struct prof_list_tmp;
    mmi_dtcnt_comm_disp_name_addr name_addr_tmp;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (end <= (start + 1))
    {
        return;
    }

    for (i = start; i < end - 1; i++)
    {    
        for(j = i; j < end; j++)
        {
            if (mmi_ucs2cmp((CHAR*)name_addr_arr[i].data_account_name, (CHAR*)name_addr_arr[j].data_account_name) > 0)
            {
                /* the two array is related by the same index */
                memcpy(&prof_list_tmp, &prof_list[i], size1);
                memcpy(&prof_list[i], &prof_list[j], size1);
                memcpy(&prof_list[j], &prof_list_tmp, size1);

                memcpy(&name_addr_tmp, &name_addr_arr[i], size2);
                memcpy(&name_addr_arr[i], &name_addr_arr[j], size2);
                memcpy(&name_addr_arr[j], &name_addr_tmp, size2);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prepare_data_account_list
 * DESCRIPTION
 *  To prepare CSD & GPRS profile list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_prepare_data_account_list(srv_dtcnt_sim_type_enum sim_type, mmi_dtcnt_prepare_data_enum prepare_data_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 bearer;
    U32 i, j;
    S32 start = 0;
    MMI_BOOL setted = g_data_account_display_cntx.profile_setted;
    mmi_id option_group_id = g_data_account_display_cntx.option_group_id;
    mmi_id sim_list_group_id = g_data_account_display_cntx.sim_list_group_id;
    srv_dtcnt_sim_type_enum curr_sim_type = g_data_account_display_cntx.curr_sim_type;
    srv_dtcnt_prof_str_info_qry_struct acct_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_comm_disp_name_addr_arr, 0, sizeof(g_comm_disp_name_addr_arr));
    memset(&g_data_account_display_cntx, 0, sizeof(mmi_dtcnt_node_display_struct));
    g_data_account_display_cntx.profile_setted = setted;
    g_data_account_display_cntx.option_group_id = option_group_id;
    g_data_account_display_cntx.sim_list_group_id = sim_list_group_id;
    g_data_account_display_cntx.curr_sim_type = curr_sim_type;

    for (j = 0; j < MMI_DTCNT_LIST_TYPE_TOTAL; j++)
    {
        if (j == MMI_DTCNT_LIST_TYPE_GPRS_USER || 
            j == MMI_DTCNT_LIST_TYPE_GPRS_FACTORY)
        {
            bearer = DATA_ACCOUNT_BEARER_GPRS;
        }
        else
        {
            bearer = DATA_ACCOUNT_BEARER_CSD;
        }
        for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
        {
            if (g_mmi_dtcnt_list_item[i].bearer_type == bearer)
            {
                if ((g_mmi_dtcnt_list_item[i].account_type == SRV_DTCNT_PROF_TYPE_USER_CONF || 
                    g_mmi_dtcnt_list_item[i].account_type == SRV_DTCNT_PROF_TYPE_OTA_CONF) &&
                    (j == MMI_DTCNT_LIST_TYPE_GPRS_FACTORY || 
                    j == MMI_DTCNT_LIST_TYPE_CSD_FACTORY))
                {
                    continue;
                }
                if ((g_mmi_dtcnt_list_item[i].account_type == SRV_DTCNT_PROF_TYPE_FACTORY_CONF || 
                    g_mmi_dtcnt_list_item[i].account_type == SRV_DTCNT_PROF_TYPE_SIM_PROF) &&
                    (j == MMI_DTCNT_LIST_TYPE_GPRS_USER || 
                    j == MMI_DTCNT_LIST_TYPE_CSD_USER))
                {
                    continue;
                }
                /* read only can't be replaced by provisioning */
                if (prepare_data_type == MMI_DTCNT_PREPARE_DATA_FOR_PROV && 
                    (g_mmi_dtcnt_list_item[i].read_only || 
                    mmi_dtcnt_is_account_in_use(g_mmi_dtcnt_list_item[i].profile_id)))
                {
                    continue;
                }
                // skip accounts which are different from current sim type's account
                if (sim_type != g_mmi_dtcnt_list_item[i].sim_info)
                {
                    continue;
                }
                g_data_account_display_cntx.profile_list[g_data_account_display_cntx.list_number].profile_id = g_mmi_dtcnt_list_item[i].profile_id;
                g_data_account_display_cntx.profile_list[g_data_account_display_cntx.list_number].read_only = g_mmi_dtcnt_list_item[i].read_only;
                g_data_account_display_cntx.profile_list[g_data_account_display_cntx.list_number].account_type = g_mmi_dtcnt_list_item[i].account_type;
                g_data_account_display_cntx.profile_list[g_data_account_display_cntx.list_number].bearer_type = bearer;

                /* use common data block to store list */
                acct_data.dest_len = (SRV_DTCNT_PROF_MAX_ACC_NAME_LEN + 1) * ENCODING_LENGTH;
                acct_data.dest = (CHAR*)g_comm_disp_name_addr_arr[g_data_account_display_cntx.list_number].data_account_name;
                srv_dtcnt_get_account_name(
                    g_mmi_dtcnt_list_item[i].profile_id,
                    &acct_data,
                    SRV_DTCNT_ACCOUNT_PRIMARY);
                if (bearer == DATA_ACCOUNT_BEARER_GPRS)
                {
                    mmi_dtcnt_get_apn(g_mmi_dtcnt_list_item[i].profile_id, (CHAR*)g_comm_disp_name_addr_arr[g_data_account_display_cntx.list_number].data_account_addr, MAX_DTCNT_LIST_ADDR_LEN * ENCODING_LENGTH);
                }
                else
                {
                    mmi_dtcnt_get_csd_number(g_mmi_dtcnt_list_item[i].profile_id, (CHAR*)g_comm_disp_name_addr_arr[g_data_account_display_cntx.list_number].data_account_addr, MAX_DTCNT_LIST_ADDR_LEN  * ENCODING_LENGTH);
                }
                g_data_account_display_cntx.list_number++;
            }
        }    
        mmi_dtcnt_arrange_account_list(g_data_account_display_cntx.profile_list, 
            g_comm_disp_name_addr_arr,
            start, 
            g_data_account_display_cntx.list_number);
        start = g_data_account_display_cntx.list_number;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_cui_event_proc
 * DESCRIPTION
 *  data account cui event proc
 *  
 * PARAMETERS
 *  mmi_event_struct      [IN]        
 * RETURNS
 *  return MMI_RET_OK
 *****************************************************************************/
mmi_ret mmi_dtcnt_cui_event_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct *menu_evt;
    cui_event_inline_abort_struct *inline_abort_event;
    cui_event_inline_submit_struct *inline_submit_event;
    cui_event_inline_notify_struct *inline_notify_event;
    cui_event_inline_set_key_struct *inline_set_key_event; 
    cui_event_inline_common_struct *inline_common_event;
    cui_inline_item_text_edit_struct advanced_proxy_port_textedit;
    cui_inline_item_select_struct advanced_proxy_port_select;
    cui_inline_set_item_struct set_item;
    /* for varify advanced setting */
    U8 temp_str[(MMI_DTCNT_MAX_PORT_LENGTH + 1) * ENCODING_LENGTH]; /* temp value for verify advanced setting */
    U8 use_proxy;
    U8 ip[4];
    U32 i;
#ifdef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
    WCHAR tempStr[DTCNT_DYNAMIC_SIM_NAME_MAX_LEN];
    mmi_menu_id menu_list[] = {
                                MENU_ID_DTCNT_SIM_1,
                    #if (MMI_MAX_SIM_NUM >= 2)
                                MENU_ID_DTCNT_SIM_2,
                    #endif
                    #if (MMI_MAX_SIM_NUM >= 3)
                                MENU_ID_DTCNT_SIM_3,
                    #endif
                    #if (MMI_MAX_SIM_NUM >= 4)
                                MENU_ID_DTCNT_SIM_4
                    #endif
                            };
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Menu cui revise */
    menu_evt = (cui_menu_event_struct*)evt;  
    if (menu_evt->sender_id == g_data_account_display_cntx.option_group_id)
    {
        switch (menu_evt->evt_id)
        {
            case EVT_ID_CUI_MENU_LIST_ENTRY:
                cui_menu_set_default_title_image_by_id(
                    menu_evt->sender_id, 
                    GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));
                break;

            case EVT_ID_CUI_MENU_ITEM_SELECT:
            case EVT_ID_CUI_MENU_ITEM_CSK_SELECT:
            {
                switch (menu_evt->highlighted_menu_id) 
                {
                #if defined(__MMI_GPRS_FEATURES__)
                    case MENU_ID_DTCNT_OPT_ADD_GPRS:
                    case MENU_ID_DTCNT_OPT2_ADD_GPRS:
                    case MENU_ID_DTCNT_OPT3_ADD_GPRS:
                        mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_ADD, SRV_DTCNT_BEARER_GPRS);                    
                        break;
                #endif

                #if defined(__TCPIP_OVER_CSD__)
                    case MENU_ID_DTCNT_OPT_ADD_CSD:
                    case MENU_ID_DTCNT_OPT2_ADD_CSD:
                    case MENU_ID_DTCNT_OPT3_ADD_CSD:
                        mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_ADD, SRV_DTCNT_BEARER_CSD); 
                        break;
                #endif
                        
                    case MENU_ID_DTCNT_OPT_EDIT:
                        mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_EDIT, SRV_DTCNT_BEARER_UNKNOWN);                   
                        break;

                #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
                    case MENU_ID_DTCNT_OPT3_VIEW:
                        mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_VIEW, SRV_DTCNT_BEARER_UNKNOWN);
                        break;
                #endif
                        
                    case MENU_ID_DTCNT_OPT_DELETE:
                        mmi_dtcnt_delete_account_confirm();
                        break;
                        
                    case MENU_ID_DTCNT_OPT_CHANGE_DEFAULT:
                    case MENU_ID_DTCNT_OPT3_CHANGE_DEFAULT:
                        mmi_dtcnt_entry_change_default();
                        break;
                        
                    default:
                        break;
                }
                break;
            }            
            case EVT_ID_CUI_MENU_CLOSE_REQUEST:            
                cui_menu_close(menu_evt->sender_id);
                g_data_account_display_cntx.option_group_id = GRP_ID_INVALID;
                break;

            default:
                break;
        }
    }
    else if (menu_evt->sender_id == g_data_account_display_cntx.sim_list_group_id)
    {
        switch (menu_evt->evt_id)
        {
            case EVT_ID_CUI_MENU_LIST_ENTRY:
            {
                cui_menu_set_default_title_by_id(
                    menu_evt->sender_id,
                    STR_GLOBAL_DATA_ACCOUNTS,
                    GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));
            #ifdef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
                cui_menu_set_currlist(
                    menu_evt->sender_id,
                    sizeof(menu_list)/sizeof(menu_list[0]),
                    menu_list);
            #endif
                cui_menu_set_currlist_flags(
                    menu_evt->sender_id, 
                    CUI_MENU_NORMAL_LIST_WITH_NUMBERED_ICONS);

                for (i = 0; i < MMI_SIM_TOTAL; i++)
                {
                #ifdef __MMI_TELEPHONY_SUPPORT__
                    if (srv_sim_ctrl_is_available(mmi_frm_index_to_sim(i)))
                    {
                        cui_menu_set_item_hidden(
                            menu_evt->sender_id,
                            MENU_ID_DTCNT_SIM_1 + i,
                            MMI_FALSE);
                    #ifdef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
                        mmi_netset_get_sim_name_with_simx_and_brace(
                            mmi_frm_index_to_sim(i),
                            tempStr,
                            DTCNT_DYNAMIC_SIM_NAME_MAX_LEN * ENCODING_LENGTH);
                        cui_menu_set_item_string(
                            menu_evt->sender_id,
                            MENU_ID_DTCNT_SIM_1 + i,
                            tempStr);
                    #endif
                    }
                    else
                #endif /* __MMI_TELEPHONY_SUPPORT__ */
                    {
                        cui_menu_set_item_hidden(
                            menu_evt->sender_id,
                            MENU_ID_DTCNT_SIM_1 + i,
                            MMI_TRUE);
                    }
                }
               break;
            }

            case EVT_ID_CUI_MENU_ITEM_SELECT:
            case EVT_ID_CUI_MENU_ITEM_CSK_SELECT:
            {
                switch(menu_evt->highlighted_menu_id)
                {
                    case MENU_ID_DTCNT_SIM_1:
                    #if (MMI_MAX_SIM_NUM >= 2)
                    case MENU_ID_DTCNT_SIM_2:
                    #endif
                    #if (MMI_MAX_SIM_NUM >= 3)
                    case MENU_ID_DTCNT_SIM_3:
                    #endif
                    #if (MMI_MAX_SIM_NUM >= 4)
                    case MENU_ID_DTCNT_SIM_4:
                    #endif
                    {
                        g_data_account_display_cntx.curr_sim_type = 
                            (srv_dtcnt_sim_type_enum)(SRV_DTCNT_SIM_TYPE_1 + (menu_evt->highlighted_menu_id - MENU_ID_DTCNT_SIM_1));
                        mmi_frm_scrn_create(
                                    GRP_ID_DTCNT,
                                    SCR_ID_DTCNT_LIST,
                                    mmi_dtcnt_main_scrn_proc,
                                    NULL);
                        break;
                    }
                    default:
                        break;
                }
                break;
            }

            case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            {
                cui_menu_close(menu_evt->sender_id);
                g_data_account_display_cntx.sim_list_group_id = GRP_ID_INVALID;
                break;
            }

            default:
                break;
        }
    }
    
    /* inline cui */
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_INLINE_SUBMIT:
            inline_submit_event = (cui_event_inline_submit_struct*)evt;
            if (inline_submit_event->sender_id == g_data_account_display_cntx.common_inline_group_id)
            {
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    COMMON_NAME_TEXTEDIT_ID, 
                    g_data_account_display_cntx.data_account_name);
                
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    COMMON_ADDR_TEXTEDIT_ID, 
                    g_data_account_display_cntx.addr);
                
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    COMMON_USERNAME_TEXTEDIT_ID, 
                    g_data_account_display_cntx.user_name);
                
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    COMMON_PASSWD_TEXTEDIT_ID, 
                    g_data_account_display_cntx.password);
                if (g_data_account_display_cntx.bearer == SRV_DTCNT_BEARER_GPRS)
                {
                #ifdef __MMI_GPRS_FEATURES__
                    cui_inline_get_value(
                        inline_submit_event->sender_id,
                        GPRS_AUTH_SELECT_ID,
                        &g_data_account_display_cntx.auth_type);
                #endif
                }
                else
                {
                #ifdef __TCPIP_OVER_CSD__
                    cui_inline_get_value(
                        inline_submit_event->sender_id, 
                        CSD_DIAL_TYPE_SELECT_ID, 
                        &g_data_account_display_cntx.dial_type);
                    
                    cui_inline_get_value(
                        inline_submit_event->sender_id, 
                        CSD_DATA_RATE_SELECT_ID, 
                        &g_data_account_display_cntx.dial_rate);
                #endif
                }
                mmi_dtcnt_set_account_confirm(g_data_account_display_cntx.bearer);
            }
            if (inline_submit_event->sender_id == g_data_account_display_cntx.advanced_inline_group_id)
            {
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_USER_PROXY_SELECT_ID, 
                    &use_proxy);
                
                if (g_conn_type)
                {
                    cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_PROXY_PORT_TEXTEDIT_ID, 
                    temp_str);
                }
                else
                {
                    mmi_wcscpy((WCHAR*)temp_str, L"1"); //here use fade value 1 for check function
                }
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_HOMEPAGE_FSEDIT_ID, 
                    g_data_account_display_cntx.home_page);
                if (mmi_dtcnt_validate_url((PU8)g_data_account_display_cntx.home_page, MMI_TRUE) < 0)
                {   
                    mmi_popup_display_simple_ext(
                        STR_GLOBAL_INVALID_URL,
                        MMI_EVENT_ERROR,
                        GRP_ID_DTCNT,
                        NULL);
                    break;
                }
                if (use_proxy)
                {
                    U8 proxy_addr[(MMI_DTCNT_MAX_PROXY_URL_LEN + 1) * ENCODING_LENGTH];
                    U8 proxy_addr_ascii[MMI_DTCNT_MAX_PROXY_URL_LEN + 1];
                    cui_inline_get_value(
                        inline_submit_event->sender_id, 
                        ADVANCED_PROXY_ADDR_IP4_ID, 
                        proxy_addr);
                    mmi_wcs_to_asc((CHAR*)proxy_addr_ascii, (WCHAR*)proxy_addr);
                    if (applib_url_is_valid_ext((char*)proxy_addr_ascii, KAL_TRUE, KAL_FALSE) < 0)
                    {
                        mmi_popup_display_simple_ext(
                            STR_GLOBAL_INVALID_URL,
                            MMI_EVENT_ERROR,
                            GRP_ID_DTCNT,
                            NULL);
                        break;
                    }
                }
                if (!mmi_dtcnt_check_advanced_setting(use_proxy, temp_str, ip))
                {
                    break;
                }
                g_data_account_display_cntx.use_proxy = use_proxy;
                if (g_conn_type)
                {
                    mmi_wcscpy((WCHAR*)g_data_account_display_cntx.proxy_port_str, (WCHAR*)temp_str); 
                }
                else
                {
                    cui_inline_get_value(
                        inline_submit_event->sender_id, 
                        ADVANCED_PROXY_PORT_TEXTEDIT_ID, 
                        &g_data_account_display_cntx.wap_port_index);
                }
#ifdef WAP2_HTTP
                g_data_account_display_cntx.connection_type = 1;
#else
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_CONN_TYPE_SELECT_ID, 
                    &g_data_account_display_cntx.connection_type);                        
#endif
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_PROXY_ADDR_IP4_ID, 
                    g_data_account_display_cntx.proxy_ip);
                
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_PROXY_USERNAME_FSEDIT_ID, 
                    g_data_account_display_cntx.proxy_user_name);
                
                cui_inline_get_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_PROXY_PASSWD_FSEDIT_ID, 
                    g_data_account_display_cntx.proxy_password);

            #ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
                mmi_dtcnt_get_inline_ip_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_DNS1_IP4_ID, 
                    g_data_account_display_cntx.dns1_ip);

                mmi_dtcnt_get_inline_ip_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_DNS2_IP4_ID, 
                    g_data_account_display_cntx.dns2_ip);

                mmi_dtcnt_get_inline_ip_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_IP_IP4_ID, 
                    g_data_account_display_cntx.ip);

                mmi_dtcnt_get_inline_ip_value(
                    inline_submit_event->sender_id, 
                    ADVANCED_SUBNET_IP4_ID, 
                    g_data_account_display_cntx.submask_ip);
            #endif
                g_data_account_display_cntx.advanced_modified = MMI_TRUE;
                cui_inline_close(inline_submit_event->sender_id);
            }       
            break;
        
        case EVT_ID_CUI_INLINE_ABORT:
        {
            inline_abort_event = (cui_event_inline_abort_struct*)evt;
            if(inline_abort_event->sender_id == g_data_account_display_cntx.advanced_inline_group_id)
            {
                if (g_data_account_display_cntx.set_type != MMI_DTCNT_PROFILE_VIEW)
                {
                    mmi_asc_to_ucs2((CHAR*) g_data_account_display_cntx.home_page, (CHAR*)homepage);
                }
            }
            cui_inline_close(inline_abort_event->sender_id);
            break;
        }
        
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            inline_notify_event = (cui_event_inline_notify_struct *)evt;
            switch (inline_notify_event->event_type)
            {
                case CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED:
                    if (inline_notify_event->sender_id == g_data_account_display_cntx.advanced_inline_group_id)
                    {
                        switch (inline_notify_event->item_id)
                        {                                           
                            case ADVANCED_USER_PROXY_SELECT_ID:
                                if (g_use_proxy == inline_notify_event->param)
                                {
                                    break;
                                }
                                g_use_proxy = inline_notify_event->param;
                                mmi_dtcnt_set_inline_proxy_info_attr(
                                    inline_notify_event->sender_id,
                                    inline_notify_event->param);
                                break;
                                
                            #ifndef WAP2_HTTP
                            case ADVANCED_CONN_TYPE_SELECT_ID: 
                                if (g_conn_type == inline_notify_event->param)
                                {
                                    break;
                                }
                                g_conn_type = inline_notify_event->param;
                                if (inline_notify_event->param)
                                {
                                    cui_inline_lock_main_screen(inline_notify_event->sender_id);
                                    cui_inline_delete_item(inline_notify_event->sender_id, ADVANCED_PROXY_PORT_TEXTEDIT_ID);
                                    
                                    advanced_proxy_port_textedit.string_id = 0;
                                    advanced_proxy_port_textedit.default_text_id = 0;
                                    advanced_proxy_port_textedit.buffer_size = MMI_DTCNT_MAX_PORT_LENGTH + 1;
                                    advanced_proxy_port_textedit.input_type = IMM_INPUT_TYPE_NUMERIC;
                                    advanced_proxy_port_textedit.input_extended_type = 0;
                                    advanced_proxy_port_textedit.required_input_mode_set = NULL;
                                    
                                    set_item.item_id = ADVANCED_PROXY_PORT_TEXTEDIT_ID;
                                    if (g_use_proxy)
                                    {
                                        set_item.item_flag = CUI_INLINE_ITEM_TYPE_TEXT_EDIT | CUI_INLINE_ITEM_NO_LEADING_ZERO;
                                    }
                                    else
                                    {
                                        set_item.item_flag = CUI_INLINE_ITEM_TYPE_TEXT_EDIT | CUI_INLINE_ITEM_NO_LEADING_ZERO | CUI_INLINE_ITEM_DISABLE;
                                    }
                                    set_item.image_id = 0;
                                    set_item.item_data = &advanced_proxy_port_textedit;

                                    cui_inline_insert_item(inline_notify_event->sender_id, ADVANCED_PROXY_USERNAME_CAPTION_ID, &set_item);
                                    cui_inline_set_value(
                                        inline_notify_event->sender_id, 
                                        ADVANCED_PROXY_PORT_TEXTEDIT_ID, 
                                        g_data_account_display_cntx.proxy_port_str);
                                    cui_inline_set_highlight_item(inline_notify_event->sender_id, inline_notify_event->item_id);
                                    cui_inline_unlock_main_screen(inline_notify_event->sender_id);
                                    cui_inline_redraw_screen(inline_notify_event->sender_id);
                                }
                                else
                                {
                                    cui_inline_lock_main_screen(inline_notify_event->sender_id);
                                    cui_inline_delete_item(inline_notify_event->sender_id, ADVANCED_PROXY_PORT_TEXTEDIT_ID);

                                    advanced_proxy_port_select.n_items = sizeof(auth_type_sel_str)/sizeof(auth_type_sel_str[0]);
                                    advanced_proxy_port_select.highlighted_item= g_data_account_display_cntx.wap_port_index;
                                    advanced_proxy_port_select.list_of_item_id = auth_type_sel_str;

                                    set_item.item_id = ADVANCED_PROXY_PORT_TEXTEDIT_ID; // use the same id with text port
                                    if (g_use_proxy)
                                    {
                                        set_item.item_flag = CUI_INLINE_ITEM_TYPE_SELECT;
                                    }
                                    else
                                    {
                                        set_item.item_flag = CUI_INLINE_ITEM_TYPE_SELECT | CUI_INLINE_ITEM_DISABLE;
                                    }
                                    set_item.image_id = 0;
                                    set_item.item_data = &advanced_proxy_port_select;

                                    cui_inline_insert_item(inline_notify_event->sender_id, ADVANCED_PROXY_USERNAME_CAPTION_ID, &set_item);
                                    //cui_inline_set_value(inline_notify_event->sender_id, ADVANCED_PROXY_PORT_TEXTEDIT_ID, g_cconv_cntx->ForeBuff);
                                    cui_inline_set_highlight_item(inline_notify_event->sender_id, inline_notify_event->item_id);
                                    cui_inline_unlock_main_screen(inline_notify_event->sender_id);
                                    cui_inline_redraw_screen(inline_notify_event->sender_id);
                                }
                                break;
                            #endif
                            default:
                                break;
                        }
                    }
                    break;
                default:
                    break;
            }
            break;
        }

        case EVT_ID_CUI_INLINE_SET_KEY:
            inline_set_key_event = (cui_event_inline_set_key_struct*)evt;
            if (inline_set_key_event->sender_id == g_data_account_display_cntx.common_inline_group_id)
            {
                U16 str_id;
                U16 item_id;
            #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
                if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
                {
                    str_id = STR_GLOBAL_VIEW;
                }
                else
           #endif
                {
                    str_id = STR_GLOBAL_EDIT;
                }
                if (g_data_account_display_cntx.bearer == SRV_DTCNT_BEARER_GPRS)
                {
                    item_id = GPRS_ADVANCE_DISPLAY_ID;
                }
                else
                {
                    item_id = CSD_ADVANCE_DISPLAY_ID;
                }
                if (item_id == inline_set_key_event->item_id)
                {
                    cui_inline_set_softkey_text(
                        inline_set_key_event->sender_id, 
                        item_id, 
                        MMI_LEFT_SOFTKEY, 
                        str_id);
                    cui_inline_set_softkey_icon(
                        inline_set_key_event->sender_id, 
                        item_id, 
                        MMI_CENTER_SOFTKEY, 
                        IMG_GLOBAL_COMMON_CSK);
                    if (g_data_account_display_cntx.set_type != MMI_DTCNT_PROFILE_VIEW)
                    {
                        wgui_inline_set_lsk_function(mmi_dtcnt_entry_advanced_settings);
                    }
                #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
                    else
                    {
                        SetLeftSoftkeyFunction(mmi_dtcnt_entry_advanced_settings, KEY_EVENT_UP);
                    }
                #endif
                    
                    SetCenterSoftkeyFunction(mmi_dtcnt_entry_advanced_settings, KEY_EVENT_UP);
                }
            }
            break;

        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
            inline_common_event = (cui_event_inline_common_struct*)evt;
            if (inline_common_event->sender_id == g_data_account_display_cntx.common_inline_group_id)
            {
                if (g_data_account_display_cntx.advanced_modified == MMI_TRUE)
                {
                    cui_inline_set_screen_attributes(inline_common_event->sender_id, CUI_INLINE_SET_ATTRIBUTE, CUI_INLINE_SCREEN_CHANGED);
                }
            }
            break;

        default:
            break;
    }
#if defined (__MMI_AP_DCM_DTCNT__)
    if(menu_evt->evt_id == EVT_ID_GROUP_DEINIT)
    {
        mmi_dtcnt_post_unload_dcm();
    }
#endif
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_inline_ip_value
 * DESCRIPTION
 *  get ip value from inline cui ip item
 * PARAMETERS
 *  group_id      [IN]        
 *  item_id       [IN]        
 *  ip_array      [OUT]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_get_inline_ip_value(mmi_id group_id, U16 item_id, U8 *ip_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_inline_item_ip4_struct ip4;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_inline_get_value(group_id, item_id, &ip4);
    ip_array[0] = ip4.b1;
    ip_array[1] = ip4.b2;
    ip_array[2] = ip4.b3;
    ip_array[3] = ip4.b4;
}


#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
* FUNCTION
*  mmi_dtcnt_main_list_fte_callback
* DESCRIPTION
*  Execute correspoding function of selected shortcuts.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_dtcnt_main_list_fte_callback(mmi_tap_type_enum tap_type, S32 index)
{
    if (tap_type == ENUM_TAP_ON_NONHIGHLIGHTED_ITEM) 
    {
        /* only change highlight.  do nothing in tap callback function */
        return;
    }
    
    if (!wgui_category_if_pop_option_menu())
    {
        if (!g_data_account_display_cntx.read_only)
        {
            mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_EDIT, SRV_DTCNT_BEARER_UNKNOWN);
        }
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        else
        {
            mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_VIEW, SRV_DTCNT_BEARER_UNKNOWN);
        }
    #endif
    }    
}
#endif


#ifdef __MMI_WGUI_DISABLE_CSK__ 
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_main_scrn_csk_hdlr
 * DESCRIPTION
 *  csk hdlr function for main screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_main_scrn_csk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, 0);
	evt.evt_id = EVT_ID_WGUI_CSK_CLICK;
    MMI_FRM_CB_EMIT_EVENT(&evt);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_main_scrn_proc
 * DESCRIPTION
 *  proc function for main screen
 * PARAMETERS
 *  evt     [IN] 
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_dtcnt_main_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
        {            
            U32 i;    
            U32 default_account_id;
            MMI_BOOL ret;
            U16 title_id;
            U8 *DataAccountName[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM];
            U8 *PopUpDescription[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM];
            WCHAR tempStr[DTCNT_DYNAMIC_SIM_NAME_MAX_LEN];
            mmi_frm_scrn_active_evt_struct *active_evt;
            active_evt = (mmi_frm_scrn_active_evt_struct *)evt;
            mmi_dtcnt_prepare_data_account_list(g_data_account_display_cntx.curr_sim_type, MMI_DTCNT_PREPARE_DATA_FOR_SETTING);
            // get default account id
            ret = srv_dtcnt_get_default_account(g_data_account_display_cntx.curr_sim_type, &default_account_id);
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_DEFAULT_ACCOUNT, g_data_account_display_cntx.curr_sim_type, default_account_id, ret);
            for (i = 0; i < g_data_account_display_cntx.list_number; i++)
            {
                DataAccountName[i] = g_comm_disp_name_addr_arr[i].data_account_name;
                if (mmi_ucs2strlen((CHAR*) g_comm_disp_name_addr_arr[i].data_account_addr) > 0)
                {
                    PopUpDescription[i] = g_comm_disp_name_addr_arr[i].data_account_addr;
                    if (default_account_id == g_data_account_display_cntx.profile_list[i].profile_id)
                    {                
                        g_data_account_display_cntx.main_list_icon[i] = IMG_ID_PROF_ACTIVATED;
                    }
                    else
                    {
                    #ifndef __MMI_PROF_SLIM_PROFILES__
                        g_data_account_display_cntx.main_list_icon[i] = IMG_ID_PROF_NO_IMAGE;
                    #else
                        g_data_account_display_cntx.main_list_icon[i] = 0;
                    #endif
                    }
                }
            }
            if (g_data_account_display_cntx.profile_setted)
            {
                active_evt->gui_buffer = NULL;
                g_data_account_display_cntx.cur_index = 0;
                g_data_account_display_cntx.profile_setted = MMI_FALSE;
            }

            if (mmi_dtcnt_get_available_sim_num() > 1)
            {
                title_id = mmi_dtcnt_sim_str_id[g_data_account_display_cntx.curr_sim_type - 1];
            }
            else
            {
                title_id = STR_GLOBAL_DATA_ACCOUNTS;
            }
        #ifndef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
            mmi_wcscpy(tempStr, (WCHAR*)GetString(title_id));
        #else
            if (mmi_dtcnt_get_available_sim_num() > 1)
            {
                mmi_netset_get_sim_name_with_simx_and_brace(
                    mmi_frm_index_to_sim(g_data_account_display_cntx.curr_sim_type - 1),
                    tempStr,
                    DTCNT_DYNAMIC_SIM_NAME_MAX_LEN * ENCODING_LENGTH);
            }
            else
            {
                mmi_wcscpy(tempStr, (WCHAR*)GetString(title_id));
            }
        #endif
            wgui_override_list_menu_slim_style(WGUI_LIST_MENU_SLIM_STYLE_DRAW_ICON);
            ShowCategory353Screen(
                (U8*)tempStr,
                GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID),
                STR_GLOBAL_OPTIONS,
                IMG_GLOBAL_OPTIONS,
                STR_GLOBAL_BACK,
                IMG_GLOBAL_BACK,
                g_data_account_display_cntx.list_number,
                (U8 **) DataAccountName,
                g_data_account_display_cntx.main_list_icon,
                PopUpDescription,
                0,
                g_data_account_display_cntx.cur_index,
                active_evt->gui_buffer);
            wgui_restore_list_menu_slim_style();
            #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
            wgui_register_tap_callback(mmi_dtcnt_main_list_fte_callback);
            #endif            
        #ifndef __MMI_WGUI_DISABLE_CSK__ 
            ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
        #else
            SetCenterSoftkeyFunction(mmi_dtcnt_main_scrn_csk_hdlr, KEY_EVENT_UP);
        #endif
            break;
        }
        case EVT_ID_WGUI_LSK_CLICK:
        {
            mmi_dtcnt_entry_option();
            return MMI_RET_KEY_HANDLED;
        }
        case EVT_ID_WGUI_CSK_CLICK:
        {
            if (!g_data_account_display_cntx.list_number)
            {
            #if defined(__MMI_GPRS_FEATURES__)
                mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_ADD, SRV_DTCNT_BEARER_GPRS);
            #elif defined(__TCPIP_OVER_CSD__)
                mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_ADD, SRV_DTCNT_BEARER_CSD);
            #endif
            }
            else
            {
                if (!g_data_account_display_cntx.read_only)
                {
                    mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_EDIT, SRV_DTCNT_BEARER_UNKNOWN);
                }
            #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
                else
                {
                    mmi_dtcnt_entry_account(MMI_DTCNT_PROFILE_VIEW, SRV_DTCNT_BEARER_UNKNOWN);
                }
            #endif
            }
            return MMI_RET_KEY_HANDLED;
        }
        case EVT_ID_SCRN_HIGHLIGHT_CHANGE:
        {
            cat_evt_struct *cat_evt = (cat_evt_struct *)evt;
            U32 index = cat_evt->item_index;
            g_data_account_display_cntx.cur_index = (U8)index;
            g_data_account_display_cntx.cur_profile_id = g_data_account_display_cntx.profile_list[index].profile_id;
        #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
            g_data_account_display_cntx.read_only = g_data_account_display_cntx.profile_list[index].read_only;
        #else
            g_data_account_display_cntx.read_only = 0;
        #endif
            return MMI_RET_CHANGED;
        }
        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_entry_option
 * DESCRIPTION
 *  Entry the option screen
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_entry_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_data_account_display_cntx.list_number == 0)
    {
        g_data_account_display_cntx.option_group_id = cui_menu_create_and_run(
            GRP_ID_DTCNT,
            CUI_MENU_SRC_TYPE_RESOURCE,
            CUI_MENU_TYPE_OPTION,
            MENU_ID_DTCNT_ACCOUNT_OPTION2,
            MMI_TRUE,
            NULL);
    }
    else if (!g_data_account_display_cntx.read_only)
    {
        g_data_account_display_cntx.option_group_id = cui_menu_create_and_run(
            GRP_ID_DTCNT, 
            CUI_MENU_SRC_TYPE_RESOURCE, 
            CUI_MENU_TYPE_OPTION, 
            MENU_ID_DTCNT_ACCOUNT_OPTION, 
            MMI_TRUE, 
            NULL);
    }
    else
    {
        g_data_account_display_cntx.option_group_id = cui_menu_create_and_run(
            GRP_ID_DTCNT, 
            CUI_MENU_SRC_TYPE_RESOURCE, 
            CUI_MENU_TYPE_OPTION, 
            MENU_ID_DTCNT_ACCOUNT_OPTION3, 
            MMI_TRUE, 
            NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_ok_popup
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_ok_popup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_data_account_display_cntx.profile_setted = MMI_TRUE;
    mmi_frm_group_close(g_data_account_display_cntx.common_inline_group_id);
    mmi_frm_group_close(g_data_account_display_cntx.advanced_inline_group_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_check_advanced_setting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_dtcnt_check_advanced_setting(U8 use_proxy, U8* port_str, U8* ip)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 temp_val; /* temp value may great than 65535 */
    U8 port_ascii[MMI_DTCNT_MAX_PORT_LENGTH + 1];
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!use_proxy)
    {
        return MMI_TRUE;
    }
    if (port_str[0] == 0 && port_str[1] == 0)
    {
        mmi_popup_display_simple_ext(
            STR_ID_DTCNT_ERR_MSG_EMPTY_PORT_NUMBER,
            MMI_EVENT_ERROR,
            GRP_ID_DTCNT,
            NULL);
        return MMI_FALSE;
    }
    mmi_wcs_to_asc((CHAR*)port_ascii, (WCHAR*)port_str);
    temp_val = (U32)atoi((S8*)port_ascii);
    if (temp_val == 0 || temp_val > MMI_DTCNT_MAX_PORT_NUM)
    {
        mmi_popup_display_simple_ext(
            STR_ID_DTCNT_ERR_MSG_INVALID_PORT,
            MMI_EVENT_ERROR,
            GRP_ID_DTCNT,
            NULL);
        return MMI_FALSE;
    }
    return MMI_TRUE;
}


#define APP_EXT_API
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_valid_acc_by_type
 * DESCRIPTION
 *  dummy function
 * PARAMETERS
 *  type : [IN]
 *  app_id: [IN]
 * RETURNS
 *  U32
 *****************************************************************************/
U32 mmi_dtcnt_get_valid_acc_by_type(srv_dtcnt_bearer_enum type, U8 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_subscribe_account
 * DESCRIPTION
 *  Because need all applications handle update/delete event, this function phase out.
 *
 * PARAMETERS
 *  acct_old     [IN]    encoded old account id.
 *  acct_new     [IN]    encoded new account id.
 *  app_str_id   [IN]    string id of application.
 *  app_icon_id  [IN]    icon id of application.
 * RETURNS
 *  Return MMI_TRUE on success, otherwise return MMI_FALSE.
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_subscribe_account(U32 acct_old, U32 acct_new, U16 app_str_id, U16 app_icon_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_reset_acct_subscription
 * DESCRIPTION
 *  Because need all applications handle update/delete event, this function phase out.
 *
 * PARAMETERS
 *  acct_id      [IN]    encoded account id. 
 *  app_str_id   [IN]    string id of application.
 *  app_icon_id  [IN]    icon id of application.
 * RETURNS
 *  Return MMI_TRUE on success, otherwise return MMI_FALSE.
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_reset_acct_subscription(U32 acct_id, U16 app_str_id, U16 app_icon_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_TRUE;
}


#define INLINE
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_password_display
 * DESCRIPTION
 *  change string to '*'
 * PARAMETERS
 *  password_buf    [IN]   Unicode type buffer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_password_display(U8 *password_buf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 len, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    len = mmi_wcslen((WCHAR*)password_buf);
    mmi_wcscpy((WCHAR*)password_buf, (WCHAR*)(L""));
    for (i = 0; i < len; i++)
    {
        mmi_wcscat((WCHAR*)password_buf, (WCHAR*)(L"*"));
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_set_inline_proxy_info_attr
 * DESCRIPTION
 *  common api to enable or disable proxy info inline items
 * PARAMETERS
 *  group_id    [IN]   
 *  use_proxy   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_set_inline_proxy_info_attr(mmi_id group_id, U8 use_proxy)
{
    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 operation = CUI_INLINE_RESET_ATTRIBUTE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (use_proxy)
    {
        operation = CUI_INLINE_RESET_ATTRIBUTE;
    }
    else
    {
        operation = CUI_INLINE_SET_ATTRIBUTE;
    }
    cui_inline_set_item_attributes(
        group_id,
        ADVANCED_PROXY_ADDR_IP4_ID,
        operation,
        CUI_INLINE_ITEM_DISABLE);
    cui_inline_set_item_attributes(
        group_id,
        ADVANCED_PROXY_PORT_TEXTEDIT_ID,
        operation,
        CUI_INLINE_ITEM_DISABLE);
    cui_inline_set_item_attributes(
        group_id,
        ADVANCED_PROXY_USERNAME_FSEDIT_ID,
        operation,
        CUI_INLINE_ITEM_DISABLE);
    cui_inline_set_item_attributes(
        group_id,
        ADVANCED_PROXY_PASSWD_FSEDIT_ID,
        operation,
        CUI_INLINE_ITEM_DISABLE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_entry_account
 * DESCRIPTION
 *  To enter profile screen
 * PARAMETERS
 *  set_type [IN]   
 *  bearer   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_entry_account(dtcnt_set_profile_enum set_type, srv_dtcnt_bearer_enum bearer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 index;
    U32 account_id;
    U8 acct_num;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = g_data_account_display_cntx.cur_index;
    g_data_account_display_cntx.profile_setted = MMI_FALSE;

    if (set_type == MMI_DTCNT_PROFILE_ADD)
    {
        acct_num = mmi_dtcnt_get_acct_num_exclude_sim_prov_per_sim(g_data_account_display_cntx.curr_sim_type);
        if (acct_num == SRV_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM)
        {
            g_data_account_display_cntx.cur_index = 0;
            mmi_popup_display_simple_ext(STR_ID_DTCNT_MAX_CSD_ACCOUNT_REACHED, MMI_EVENT_FAILURE, GRP_ID_DTCNT, NULL);
            return;
        }
        mmi_dtcnt_init_display_context();
    }
    else
    {        
        account_id = g_data_account_display_cntx.profile_list[index].profile_id;
        if (set_type == MMI_DTCNT_PROFILE_EDIT)
        {
            if (mmi_dtcnt_is_account_in_use(account_id))
            {
                mmi_popup_display_simple_ext(STR_ID_DTCNT_NOT_ALLOW_EDIT, MMI_EVENT_FAILURE, GRP_ID_DTCNT, NULL);
                return;
            }
        }
        
        if (g_data_account_display_cntx.profile_list[index].bearer_type == DATA_ACCOUNT_BEARER_CSD)
        {
            bearer = SRV_DTCNT_BEARER_CSD;
        }
        else
        {
            bearer = SRV_DTCNT_BEARER_GPRS;
        }
        mmi_dtcnt_load_display_context(account_id, bearer);
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        if (set_type == MMI_DTCNT_PROFILE_VIEW)
        {
            mmi_dtcnt_convert_ip_to_display(
                g_data_account_display_cntx.ip_address_display, 
                g_data_account_display_cntx.ip);
            mmi_dtcnt_convert_ip_to_display(
                g_data_account_display_cntx.dns1_ip_address_display, 
                g_data_account_display_cntx.dns1_ip);
            mmi_dtcnt_convert_ip_to_display(
                g_data_account_display_cntx.dns2_ip_address_display, 
                g_data_account_display_cntx.dns2_ip);
            mmi_dtcnt_convert_ip_to_display(
                g_data_account_display_cntx.submask_ip_address_display, 
                g_data_account_display_cntx.submask_ip);
        }
    #endif
    }
    g_data_account_display_cntx.set_type = set_type;
    g_data_account_display_cntx.bearer = bearer;
    mmi_dtcnt_entry_account_common(bearer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_init_display_context
 * DESCRIPTION
 *  Init data account display context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_init_display_context(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR str_digist[16];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_data_account_display_cntx.dial_rate = 2; // CSD used only
    g_data_account_display_cntx.read_only = 0;
    g_data_account_display_cntx.connection_type = 1;
    g_data_account_display_cntx.proxy_port = 0;
    sprintf(str_digist, "%d", g_data_account_display_cntx.proxy_port);
    mmi_asc_to_ucs2((CHAR*) g_data_account_display_cntx.proxy_port_str, (CHAR*) str_digist);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_load_display_context
 * DESCRIPTION
 *  To load profile context to global context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_load_display_context(U32 account_id, srv_dtcnt_bearer_enum bearer)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_result_enum result;
    srv_dtcnt_store_prof_data_struct prof_info;
    srv_dtcnt_prof_common_header_struct *common_header = NULL;    
    S32 i;
    CHAR str_digist[16];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        prof_info.prof_type = SRV_DTCNT_BEARER_CSD;
        prof_info.prof_data = &g_data_account_csd_profile_srv;
        common_header = &g_data_account_csd_profile_srv.prof_common_header;
    #endif
    }
    else
    {
    #ifdef __MMI_GPRS_FEATURES__
        prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;
        prof_info.prof_data = &g_data_account_gprs_profile_srv;
        common_header = &g_data_account_gprs_profile_srv.prof_common_header;
    #endif
    }
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_ALL;
    result =  srv_dtcnt_store_qry_prof(account_id, &prof_info);

    if (result != SRV_DTCNT_RESULT_SUCCESS)
    {
        return;
    }
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.addr, (CHAR*)g_data_account_csd_profile_srv.DialNumber);
        g_data_account_display_cntx.dial_rate = (S32) g_data_account_csd_profile_srv.DataRate;
        g_data_account_display_cntx.dial_type = (S32) g_data_account_csd_profile_srv.DialType;
    #endif
    }
    else
    {
    #ifdef __MMI_GPRS_FEATURES__
        mmi_asc_to_ucs2((CHAR*) g_data_account_display_cntx.addr, (CHAR*)g_data_account_gprs_profile_srv.APN);
    #endif
    }
    
    mmi_ucs2cpy((CHAR*)g_data_account_display_cntx.data_account_name, (CHAR*)common_header->AccountName);
    mmi_asc_to_ucs2((CHAR*) g_data_account_display_cntx.user_name, (CHAR*)common_header->Auth_info.UserName);
    mmi_asc_to_ucs2((CHAR*) g_data_account_display_cntx.password, (CHAR*)common_header->Auth_info.Passwd);    
    g_data_account_display_cntx.auth_type = (S32)common_header->Auth_info.AuthType;
    if (common_header->use_proxy)
    {
        g_data_account_display_cntx.use_proxy = 1;
        g_data_account_display_cntx.proxy_port = common_header->px_port;
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_ip, (CHAR*)common_header->px_addr);
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_user_name, (CHAR*)common_header->px_authid);
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_password, (CHAR*)common_header->px_authpw);
    }
    else
    {
        g_data_account_display_cntx.use_proxy = 0;
        g_data_account_display_cntx.proxy_port = 0;
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_ip, (CHAR*)"");
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_user_name, (CHAR*)"");
        mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_password, (CHAR*)"");
    }

    mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.home_page, (CHAR*)common_header->HomePage);

    for (i = 0 ; i < MAX_PART_IP_ADDRESS; i++)
    {
        g_data_account_display_cntx.ip[i] = common_header->StaicIPAddr[i];
        g_data_account_display_cntx.dns1_ip[i] = common_header->PrimaryAddr[i];
        g_data_account_display_cntx.dns2_ip[i] = common_header->SecondaryAddr[i];
        g_data_account_display_cntx.submask_ip[i] = common_header->NetMask[i];
    }
//    g_data_account_display_cntx.sim_info = common_header->sim_info - 1;
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    g_data_account_display_cntx.read_only = common_header->read_only;
#else
    g_data_account_display_cntx.read_only = 0;
#endif

#ifndef WAP2_HTTP
    if (common_header->px_service <= SRV_DTCNT_PROF_PX_SRV_CO_SEC_WTA)
    {
        g_data_account_display_cntx.connection_type = 0;

    }
    else
#endif
    {
        g_data_account_display_cntx.connection_type = 1;
    }

    //used when choose wap
    if (g_data_account_display_cntx.connection_type)
    {
        g_data_account_display_cntx.wap_port_index = 0;
    }
    else
    {
        g_data_account_display_cntx.wap_port_index = 
        mmi_dtcnt_get_index_by_port((U16)g_data_account_display_cntx.proxy_port);
    }

    sprintf(str_digist, "%d", g_data_account_display_cntx.proxy_port);
    mmi_asc_to_ucs2((CHAR*)g_data_account_display_cntx.proxy_port_str, (CHAR*)str_digist);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_entry_account_common
 * DESCRIPTION
 *  entry add screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_entry_account_common(srv_dtcnt_bearer_enum bearer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 title_id = STR_GLOBAL_ADD;
    cui_inline_struct common_inline_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_data_account_display_cntx.set_type)
    {
        case MMI_DTCNT_PROFILE_ADD:
            title_id = STR_GLOBAL_ADD;
            break;
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        case MMI_DTCNT_PROFILE_VIEW:
            title_id = STR_GLOBAL_VIEW;
            break;
    #endif
        default:
            title_id = STR_GLOBAL_EDIT;
            break;
    }

    common_inline_struct.title = title_id;
    common_inline_struct.title_icon = GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID);
    if (g_data_account_display_cntx.set_type != MMI_DTCNT_PROFILE_VIEW)
    {
        common_inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP;
    }
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    else
    {
        common_inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP | CUI_INLINE_SCREEN_DISABLE_DONE;
    }
#endif
    common_inline_struct.softkey = NULL;
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        common_inline_struct.items_count = CSD_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE;
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
        {
            common_inline_struct.items = csd_common_inline_view_items;
        }
        else
    #endif
        {
            common_inline_struct.items = csd_common_inline_edit_items;
        }
    #endif
    }
    else if (bearer == SRV_DTCNT_BEARER_GPRS)
    {
    #ifdef __MMI_GPRS_FEATURES__
        common_inline_struct.items_count = GPRS_ADVANCE_DISPLAY_ID - CUI_INLINE_ITEM_ID_BASE;
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
        {
            common_inline_struct.items = gprs_common_inline_view_items;
        }
        else
    #endif
        {
            common_inline_struct.items = gprs_common_inline_edit_items;
        }
    #endif
    }

    g_data_account_display_cntx.common_inline_group_id = cui_inline_create(
                            GRP_ID_DTCNT,
                            &common_inline_struct);
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
    {
        cui_inline_set_all_items_softkey_text(
            g_data_account_display_cntx.common_inline_group_id,
            MMI_LEFT_SOFTKEY,
            0);
    }
#endif
    cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, COMMON_NAME_TEXTEDIT_ID, g_data_account_display_cntx.data_account_name);
    
    cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, COMMON_ADDR_TEXTEDIT_ID, g_data_account_display_cntx.addr);

    cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, COMMON_USERNAME_TEXTEDIT_ID, g_data_account_display_cntx.user_name);
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
    {
        mmi_dtcnt_password_display(g_data_account_display_cntx.password);
    }
#endif
    cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, COMMON_PASSWD_TEXTEDIT_ID, g_data_account_display_cntx.password);

    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
    #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
        if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
        {
            cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, CSD_DIAL_TYPE_SELECT_ID, GetString(dial_type_sel_str[g_data_account_display_cntx.dial_type])); 
            cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, CSD_DATA_RATE_SELECT_ID, GetString(data_rate_sel_str[g_data_account_display_cntx.dial_rate])); 
        }
        else
    #endif
        {
            cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, CSD_DIAL_TYPE_SELECT_ID, (void*)g_data_account_display_cntx.dial_type);
            cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, CSD_DATA_RATE_SELECT_ID, (void*)g_data_account_display_cntx.dial_rate);
        }
    #endif
    }
    else if (bearer == SRV_DTCNT_BEARER_GPRS)
    {
    #ifdef __MMI_GPRS_FEATURES__
        #ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
            if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
            {
                cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, GPRS_AUTH_SELECT_ID, GetString(auth_type_sel_str[g_data_account_display_cntx.auth_type]));
            }
            else
        #endif
            {
                cui_inline_set_value(g_data_account_display_cntx.common_inline_group_id, GPRS_AUTH_SELECT_ID, (void*)g_data_account_display_cntx.auth_type);
            }
    #endif
    }
    cui_inline_run(g_data_account_display_cntx.common_inline_group_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_confirm_callback
 * DESCRIPTION
 *  callback function for dtcnt confirm screen.
 * PARAMETERS
 *  evt :      [IN]  confirm event.
 * RETURNS
 *  Return MMI_RET_OK
 *****************************************************************************/
mmi_ret mmi_dtcnt_confirm_callback(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_YES:
                if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_DELETE)
                {
                    mmi_dtcnt_delete_account();
                }
                else
                {
                    mmi_frm_scrn_close_active_id();
                }
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_dtcnt_go_to_main_list();
                break;
            default:
                break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_csd_number
 * DESCRIPTION
 *  
 * PARAMETERS
 *  account_id      [IN]        
 *  dest            [OUT]         
 *  len             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
BOOL mmi_dtcnt_get_csd_number(U32 account_id, CHAR *dest, U8 len)
{
#ifdef __TCPIP_OVER_CSD__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prof_str_info_qry_struct acct_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    acct_data.dest_len = len;
    acct_data.dest = (CHAR*)dest;
    return srv_dtcnt_get_csd_number(account_id, &acct_data, SRV_DTCNT_ACCOUNT_PRIMARY);
#else
    return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_set_account_confirm
 * DESCRIPTION
 *  Notification Screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_set_account_confirm(srv_dtcnt_bearer_enum bearer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 str_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_EDIT)
    {
        if (mmi_dtcnt_is_account_in_use(g_data_account_display_cntx.cur_profile_id))
        {
            mmi_frm_group_close(g_data_account_display_cntx.common_inline_group_id);
            return;
        }
    }
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        str_id = STR_ID_DTCNT_CSD_INPUT_LACK;
    #endif
    }
    else
    {
    #ifdef __MMI_GPRS_FEATURES__
        str_id = STR_ID_DTCNT_GPRS_INPUT_LACK;
    #endif
    }
    if (g_data_account_display_cntx.addr[0] == 0 &&
        g_data_account_display_cntx.addr[1] == 0)
    {
        mmi_dtcnt_display_confirm_popup(
            1, 
            (mmi_proc_func)mmi_dtcnt_confirm_callback,
            str_id);
        return;
    }
    mmi_dtcnt_set_account(bearer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_add_csd_account
 * DESCRIPTION
 *  add csd account
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_set_account(srv_dtcnt_bearer_enum bearer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_store_prof_data_struct prof_info;
    srv_dtcnt_prof_common_header_struct *common_header = NULL;
    U32 acct_id;
    srv_dtcnt_result_enum result;    
    U8 str_digit[MAX_IPADDRES_LEN * ENCODING_LENGTH];
    U8 temp[MAX_GPRS_MMI_APN_LEN + 1];
    S32 i;
    U8 bearer_type = DATA_ACCOUNT_BEARER_GPRS;
    MMI_BOOL ret;
    U32 default_account_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2_to_asc((CHAR*)temp, (CHAR*) g_data_account_display_cntx.addr);
    strcpy((char*)g_data_account_display_cntx.addr,(char*)temp);
    if (bearer == SRV_DTCNT_BEARER_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_ADD)
        {            
            memset(&g_data_account_csd_profile_srv, 0, sizeof(g_data_account_csd_profile_srv));
        }
        prof_info.prof_type = SRV_DTCNT_BEARER_CSD;
        prof_info.prof_data = &g_data_account_csd_profile_srv;        
        g_data_account_csd_profile_srv.DialNumber = g_data_account_display_cntx.addr;
        g_data_account_csd_profile_srv.DialType = g_data_account_display_cntx.dial_type;
        g_data_account_csd_profile_srv.DataRate = g_data_account_display_cntx.dial_rate;
        common_header = &g_data_account_csd_profile_srv.prof_common_header;
        bearer_type = DATA_ACCOUNT_BEARER_CSD;
    #endif
    }
    else
    {
    #ifdef __MMI_GPRS_FEATURES__
        if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_ADD)
        {
            memset(&g_data_account_gprs_profile_srv, 0, sizeof(g_data_account_gprs_profile_srv));
        }
        prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;
        prof_info.prof_data = &g_data_account_gprs_profile_srv;        
        g_data_account_gprs_profile_srv.APN = g_data_account_display_cntx.addr;
        common_header = &g_data_account_gprs_profile_srv.prof_common_header;
        bearer_type = DATA_ACCOUNT_BEARER_GPRS;
    #endif
    }    
    prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_ALL;
    /* change the second DNS to first if first is empty and second is not empty */    
    if ((g_data_account_display_cntx.dns1_ip[0] == 0 &&
         g_data_account_display_cntx.dns1_ip[1] == 0 &&
         g_data_account_display_cntx.dns1_ip[2] == 0 &&
         g_data_account_display_cntx.dns1_ip[3] == 0) && 
        (g_data_account_display_cntx.dns2_ip[0] != 0 ||
         g_data_account_display_cntx.dns2_ip[1] != 0 ||
         g_data_account_display_cntx.dns2_ip[2] != 0 ||
         g_data_account_display_cntx.dns2_ip[3] != 0))
    {
        g_data_account_display_cntx.dns1_ip[0] = g_data_account_display_cntx.dns2_ip[0];
        g_data_account_display_cntx.dns1_ip[1] = g_data_account_display_cntx.dns2_ip[1];
        g_data_account_display_cntx.dns1_ip[2] = g_data_account_display_cntx.dns2_ip[2];
        g_data_account_display_cntx.dns1_ip[3] = g_data_account_display_cntx.dns2_ip[3];
        g_data_account_display_cntx.dns2_ip[0] = 0;
        g_data_account_display_cntx.dns2_ip[1] = 0;
        g_data_account_display_cntx.dns2_ip[2] = 0;
        g_data_account_display_cntx.dns2_ip[3] = 0;
    }
    //get real port number
    if (g_data_account_display_cntx.connection_type)
    {
        mmi_ucs2_to_asc((CHAR*) str_digit, (CHAR*) g_data_account_display_cntx.proxy_port_str);
        g_data_account_display_cntx.proxy_port = (U32)atoi((CHAR*)str_digit);
    }
    else
    {
        g_data_account_display_cntx.proxy_port = (U32)mmi_dtcnt_get_port_by_index(g_data_account_display_cntx.wap_port_index);
    }

    common_header->AccountName = g_data_account_display_cntx.data_account_name;
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_ADD)
    {
        common_header->acct_type = SRV_DTCNT_PROF_TYPE_USER_CONF;
    }
    //memset(temp, 0, (MAX_GPRS_MMI_APN_LEN + 1));

    common_header->Auth_info.AuthType = (srv_dtcnt_prof_gprs_auth_type_enum)g_data_account_display_cntx.auth_type;

    common_header->use_proxy = g_data_account_display_cntx.use_proxy;
    common_header->px_port = (U16)g_data_account_display_cntx.proxy_port;
    mmi_ucs2_to_asc((CHAR*)common_header->Auth_info.UserName, (CHAR*)g_data_account_display_cntx.user_name);
    mmi_ucs2_to_asc((CHAR*)common_header->Auth_info.Passwd, (CHAR*)g_data_account_display_cntx.password);
    mmi_ucs2_to_asc((CHAR*)common_header->px_addr, (CHAR*)g_data_account_display_cntx.proxy_ip);
    mmi_ucs2_to_asc((CHAR*)common_header->px_authid, (CHAR*)g_data_account_display_cntx.proxy_user_name);
    mmi_ucs2_to_asc((CHAR*)common_header->px_authpw, (CHAR*)g_data_account_display_cntx.proxy_password);
    mmi_ucs2_to_asc((CHAR*)common_header->HomePage, (CHAR*)g_data_account_display_cntx.home_page);

    //common_header->sim_info = g_data_account_display_cntx.sim_info + 1;
    common_header->sim_info = g_data_account_display_cntx.curr_sim_type;
    common_header->read_only = g_data_account_display_cntx.read_only;

#ifndef WAP2_HTTP
    if (g_data_account_display_cntx.connection_type == 0)
    {
        common_header->px_service = SRV_DTCNT_PROF_PX_SRV_CO_WSP;
    }
    else if (g_data_account_display_cntx.connection_type == 1)
#endif
    {
        common_header->px_service = SRV_DTCNT_PROF_PX_SRV_HTTP;

    }
    for (i = 0; i< MAX_PART_IP_ADDRESS; i++)
    {
        common_header->StaicIPAddr[i] = g_data_account_display_cntx.ip[i];
        common_header->PrimaryAddr[i] = g_data_account_display_cntx.dns1_ip[i];
        common_header->SecondaryAddr[i] = g_data_account_display_cntx.dns2_ip[i];
        common_header->NetMask[i] = g_data_account_display_cntx.submask_ip[i];
    }

    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_ADD)
    {
        result = srv_dtcnt_store_add_prof(&prof_info, &acct_id);
        if (result == SRV_DTCNT_RESULT_SUCCESS)
        {
            mmi_dtcnt_add_disp_list(acct_id, 
                                    bearer_type,
                                    common_header->acct_type,
                                    g_data_account_display_cntx.connection_type,
                                    g_data_account_display_cntx.curr_sim_type,
                                    g_data_account_display_cntx.read_only);
            ret = srv_dtcnt_get_default_account(g_data_account_display_cntx.curr_sim_type, &default_account_id);
            MMI_TRACE(
                MMI_CONN_TRC_G6_DTCNT, TRC_DTCNT_GET_DEFAULT_ACCOUNT, 
                g_data_account_display_cntx.curr_sim_type, default_account_id, ret);
            mmi_dtcnt_ok_popup();
        }
    }
    else
    {
        result = srv_dtcnt_store_update_prof(g_data_account_display_cntx.cur_profile_id, &prof_info);
        if (result == SRV_DTCNT_RESULT_SUCCESS)
        {
            mmi_dtcnt_update_disp_list(g_data_account_display_cntx.cur_profile_id, 
                                       bearer_type,
                                       common_header->acct_type,
                                       g_data_account_display_cntx.connection_type,
                                       g_data_account_display_cntx.curr_sim_type,
                                       g_data_account_display_cntx.read_only);
            mmi_dtcnt_ok_popup();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_entry_advanced_settings
 * DESCRIPTION
 *  entry advanced setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_entry_advanced_settings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_inline_item_select_struct advanced_proxy_port_select;
    cui_inline_set_item_struct set_item;
    cui_inline_struct advanced_inline_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_conn_type = g_data_account_display_cntx.connection_type;
    g_use_proxy = g_data_account_display_cntx.use_proxy;

    advanced_inline_struct.items_count = ADVANCED_SUBNET_END - CUI_INLINE_ITEM_ID_BASE - 1;
    advanced_inline_struct.title_icon = GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID);
    if (g_data_account_display_cntx.set_type != MMI_DTCNT_PROFILE_VIEW)
    {
        advanced_inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP;
    }
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    else
    {
        advanced_inline_struct.screen_flag = CUI_INLINE_SCREEN_LOOP | CUI_INLINE_SCREEN_DISABLE_DONE;
    }
#endif
    advanced_inline_struct.softkey = NULL;
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
    {
        advanced_inline_struct.title = STR_ID_DTCNT_ADVANCED_SETTING;
        advanced_inline_struct.items = advanced_common_inline_view_items;
    }
    else
#endif
    {
        advanced_inline_struct.title = STR_ID_DTCNT_ADVANCED_SETTING;
        advanced_inline_struct.items = advanced_common_inline_edit_items;
    }
    
    g_data_account_display_cntx.advanced_inline_group_id = cui_inline_create(
                            GRP_ID_DTCNT,
                            &advanced_inline_struct);
    
#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
    {
        cui_inline_set_all_items_softkey_text(
            g_data_account_display_cntx.advanced_inline_group_id,
            MMI_LEFT_SOFTKEY,
            0);
    }
#endif
    cui_inline_set_value(
        g_data_account_display_cntx.advanced_inline_group_id, 
        ADVANCED_HOMEPAGE_FSEDIT_ID, 
        g_data_account_display_cntx.home_page); 
    cui_inline_set_value(
        g_data_account_display_cntx.advanced_inline_group_id, 
        ADVANCED_PROXY_ADDR_IP4_ID, 
        g_data_account_display_cntx.proxy_ip);    
    cui_inline_set_value(
        g_data_account_display_cntx.advanced_inline_group_id, 
        ADVANCED_PROXY_USERNAME_FSEDIT_ID, 
        g_data_account_display_cntx.proxy_user_name);    

#ifdef __MMI_DTCNT_READ_ONLY_DTCNT_SUPPORT__
    if (g_data_account_display_cntx.set_type == MMI_DTCNT_PROFILE_VIEW)
    {        
#ifndef WAP2_HTTP
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_CONN_TYPE_SELECT_ID, 
            GetString(conn_type_sel_str[g_data_account_display_cntx.connection_type])); 
#endif
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_USER_PROXY_SELECT_ID, 
            GetString(use_proxy_sel_str[g_data_account_display_cntx.use_proxy])); 
        
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_PORT_TEXTEDIT_ID, 
            g_data_account_display_cntx.proxy_port_str); 

        mmi_dtcnt_password_display(g_data_account_display_cntx.proxy_password);
        
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_PASSWD_FSEDIT_ID, 
            g_data_account_display_cntx.proxy_password); 

    #ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_DNS1_IP4_ID, 
            g_data_account_display_cntx.dns1_ip_address_display); 

        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_DNS2_IP4_ID, 
            g_data_account_display_cntx.dns2_ip_address_display);     

        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_IP_IP4_ID, 
            g_data_account_display_cntx.ip_address_display); 

        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_SUBNET_IP4_ID, 
            g_data_account_display_cntx.submask_ip_address_display); 
    #endif
    }
    else
#endif
    {
        /* set fseditor in inline editor title icon */
        cui_inline_set_fullscreen_edit_title_icon(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_HOMEPAGE_FSEDIT_ID, 
            GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));
        cui_inline_set_fullscreen_edit_title_icon(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_ADDR_IP4_ID, 
            GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));
        cui_inline_set_fullscreen_edit_title_icon(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_USERNAME_FSEDIT_ID, 
            GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));
        cui_inline_set_fullscreen_edit_title_icon(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_PASSWD_FSEDIT_ID, 
            GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID));

    #ifndef WAP2_HTTP
        if (!g_conn_type)
        {
            cui_inline_delete_item(g_data_account_display_cntx.advanced_inline_group_id, ADVANCED_PROXY_PORT_TEXTEDIT_ID);
            advanced_proxy_port_select.n_items = sizeof(auth_type_sel_str)/sizeof(auth_type_sel_str[0]);
            advanced_proxy_port_select.highlighted_item= g_data_account_display_cntx.wap_port_index;
            advanced_proxy_port_select.list_of_item_id = auth_type_sel_str;
            set_item.item_id = ADVANCED_PROXY_PORT_TEXTEDIT_ID; // use the same id with text port
            set_item.item_flag = CUI_INLINE_ITEM_TYPE_SELECT;
            set_item.image_id = 0;
            set_item.item_data = &advanced_proxy_port_select;
            cui_inline_insert_item(g_data_account_display_cntx.advanced_inline_group_id, ADVANCED_PROXY_USERNAME_CAPTION_ID, &set_item);
        }
    #endif
        mmi_dtcnt_set_inline_proxy_info_attr(
            g_data_account_display_cntx.advanced_inline_group_id, 
            g_data_account_display_cntx.use_proxy);

        mmi_ucs2_to_asc((CHAR*)homepage, (CHAR*)g_data_account_display_cntx.home_page);
    #ifndef WAP2_HTTP
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_CONN_TYPE_SELECT_ID,
            (void*)g_data_account_display_cntx.connection_type);
    #endif
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_USER_PROXY_SELECT_ID,
            (void*)g_data_account_display_cntx.use_proxy);
        if (g_conn_type)
        {
            cui_inline_set_value(
                g_data_account_display_cntx.advanced_inline_group_id, 
                ADVANCED_PROXY_PORT_TEXTEDIT_ID, 
                g_data_account_display_cntx.proxy_port_str);
        }
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id, 
            ADVANCED_PROXY_PASSWD_FSEDIT_ID, 
            g_data_account_display_cntx.proxy_password);        
    #ifdef __MMI_DTCNT_ADVANCE_SETTINGS__
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_DNS1_IP4_ID,
            (void*)g_data_account_display_cntx.dns1_ip);
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_DNS2_IP4_ID,
            (void*)g_data_account_display_cntx.dns2_ip);
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_IP_IP4_ID,
            (void*)g_data_account_display_cntx.ip);
        cui_inline_set_value(
            g_data_account_display_cntx.advanced_inline_group_id,
            ADVANCED_SUBNET_IP4_ID,
            (void*)g_data_account_display_cntx.submask_ip);
    #endif
    }
    cui_inline_run(g_data_account_display_cntx.advanced_inline_group_id);
}

#define PROVIONING
#ifdef __MMI_CCA_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_prepare_prof_info
 * DESCRIPTION
 *  Compose the profile information to be displayed.
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_dtcnt_prov_prepare_prof_info(CHAR *info, srv_dtcnt_prov_ind_evt_struct *prov_ind)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR* tempBufUnicode = OslMalloc(MAX_DTCNT_LIST_ADDR_LEN * ENCODING_LENGTH);
    U8* num_ascii_str = OslMalloc(MMI_DTCNT_GENERAL_STRING_LEN);
    U8* num_unicode_str = OslMalloc(MMI_DTCNT_GENERAL_STRING_LEN);
    srv_dtcnt_prov_csd_gprs_ind_struct *prov_acct = (srv_dtcnt_prov_csd_gprs_ind_struct *)(prov_ind->prof_data);
    S32 sub_len = 0, copy_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_PROV_PREPARE_PROF_INFO);
    
    if (prov_acct == NULL)
    {
        return;
    }

    /* APP Name: Data Account */
    mmi_ucs2cpy(info, GetString(STR_GLOBAL_DATA_ACCOUNT));
    mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n"); 

    /* Data Account Profile num */
    mmi_ucs2cat(info, GetString(STR_ID_CCA_PROFILE)); 
    mmi_ucs2cat(info, GetString(STR_ID_DTCNT_COLON)); 
    mmi_ucs2cat(info, (CHAR *)L" ");
    sprintf((CHAR *)num_ascii_str, "%d/%d", prov_ind->cur_prof_idx, prov_ind->num_profs);

    mmi_asc_n_to_ucs2((CHAR*) num_unicode_str, (CHAR*) num_ascii_str, sizeof(num_unicode_str));
    mmi_ucs2cat((CHAR*) info, (CHAR*) num_unicode_str);
    mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n");

#ifdef __MMI_CCA_OMACP_BOOTSTRAP_UPDATE_SUPPORT__
    if (prov_ind->prov_type == SRV_DTCNT_PROV_TYPE_UPDATE)
    {
        mmi_ucs2cat(info, (CHAR*)GetString(STR_ID_CCA_UPDATE_PROFILE));
        mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n");
    }
#endif /* __MMI_CCA_OMACP_BOOTSTRAP_UPDATE_SUPPORT__ */

    mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n");

    /* Data Account Name */
    mmi_ucs2cat((CHAR*) info, GetString(STR_ID_DTCNT_RENAME));
    mmi_ucs2cat(info, GetString(STR_ID_DTCNT_COLON)); 
    mmi_ucs2cat((CHAR*) info, (CHAR*) L" ");

    mmi_ucs2cpy(tempBufUnicode, (CHAR*)g_dtcnt_name);
    
    mmi_ucs2cat((CHAR*) info, tempBufUnicode);

    mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n");

    memset(tempBufUnicode, 0, MAX_DTCNT_LIST_ADDR_LEN * ENCODING_LENGTH);
    
    sub_len = strlen((char*)g_dtcnt_addr);        
    if (g_prov_ind.prov_ind == SRV_DTCNT_PROV_IND_CSD)
    {
    #ifdef __TCPIP_OVER_CSD__
        copy_len = (sub_len > (MAX_DIAL_NUM_LEN) ? (MAX_DIAL_NUM_LEN) : sub_len);
        mmi_ucs2cat((CHAR*) info, GetString(STR_ID_DTCNT_DIAL_NUMBER));
    #endif
    }
    else if(prov_ind->prov_ind == SRV_DTCNT_PROV_IND_GPRS)
    {
    #ifdef __MMI_GPRS_FEATURES__
        copy_len = (sub_len > (MAX_GPRS_MMI_APN_LEN) ? (MAX_GPRS_MMI_APN_LEN) : sub_len);
        mmi_ucs2cat((CHAR*) info, GetString(STR_ID_DTCNT_GPRS_APN));
    #endif
    }
    mmi_ucs2cat(info, GetString(STR_ID_DTCNT_COLON)); 
    mmi_ucs2cat((CHAR*) info, (CHAR*) L" ");        
    mmi_asc_n_to_ucs2(tempBufUnicode, (CHAR*)g_dtcnt_addr, copy_len);
    mmi_ucs2cat((CHAR*) info, (CHAR*) tempBufUnicode);
    mmi_ucs2cat((CHAR*) info, (CHAR*) L"\n");
    /* release control buffers */
    OslMfree(tempBufUnicode);
    OslMfree(num_ascii_str);
    OslMfree(num_unicode_str);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_install_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void      [IN]            
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_prov_install_rsp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_INSTALL_RSP, g_prov_ind.cnf_callback);

    if (g_prov_ind.cnf_callback)
    {
        g_prov_ind.cnf_callback(SRV_DTCNT_PROV_CNF_INSTALL,g_prov_ind.cur_prof_idx);
        memset(&g_prov_ind, 0, sizeof(srv_dtcnt_prov_ind_evt_struct));
        g_need_abort_flag = MMI_FALSE;
    }

    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_select_replace
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void      [IN]            
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_prov_select_replace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_SELECT_REPLACE, g_prov_ind.cnf_callback);

    if (g_prov_ind.cnf_callback)
    {
        g_prov_ind.cnf_callback(SRV_DTCNT_PROV_CNF_REPLACE, cur_prov_acct_id);
        memset(&g_prov_ind, 0, sizeof(srv_dtcnt_prov_ind_evt_struct));
        g_need_abort_flag = MMI_FALSE;
    }
    mmi_frm_scrn_close(GRP_ID_DTCNT_PROV, SCR_ID_DTCNT_OTA_MAIN);
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_ota_list_scrn_proc
 * DESCRIPTION
 *  proc function for ota replace screen
 * PARAMETERS
 *  evt     [IN] 
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_dtcnt_ota_list_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
        {
            U32 i;
            U8 *DataAccountName[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM];
            U8 *PopUpDescription[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM];
            mmi_frm_scrn_active_evt_struct *active_evt;
            active_evt = (mmi_frm_scrn_active_evt_struct *)evt;

            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_ENTRY_SELECT_PROFILE, 0);
            mmi_dtcnt_prepare_data_account_list(g_prov_ind.sim_info, MMI_DTCNT_PREPARE_DATA_FOR_PROV);

            for (i = 0; i < g_data_account_display_cntx.list_number; i++)
            {
                DataAccountName[i] = g_comm_disp_name_addr_arr[i].data_account_name;
                if (mmi_ucs2strlen((CHAR*) g_comm_disp_name_addr_arr[i].data_account_addr) > 0)
                {
                    PopUpDescription[i] = g_comm_disp_name_addr_arr[i].data_account_addr;
                }
            }

            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_ENTRY_SELECT_PROFILE, 3);
    
            ShowCategory53Screen(
                STR_ID_CCA_REPLACE_SETTING,
                GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID),
                STR_GLOBAL_INSTALL,
                IMG_GLOBAL_OK,
                STR_GLOBAL_BACK,
                IMG_GLOBAL_BACK,
                g_data_account_display_cntx.list_number,
                (U8 **) DataAccountName,
                (PU16) gIndexIconsImageList,
                PopUpDescription,
                0,
                0,
                active_evt->gui_buffer);

        #ifndef __MMI_WGUI_DISABLE_CSK__ 
            ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
        #else
            SetCenterSoftkeyFunction(mmi_dtcnt_main_scrn_csk_hdlr, KEY_EVENT_UP);
        #endif
            break;
        }
        case EVT_ID_WGUI_LSK_CLICK:
        case EVT_ID_WGUI_CSK_CLICK:
        {
            mmi_dtcnt_prov_select_replace();
            return MMI_RET_KEY_HANDLED;
        }
        case EVT_ID_SCRN_HIGHLIGHT_CHANGE:
        {
            cat_evt_struct *cat_evt = (cat_evt_struct *)evt;
            U32 index = cat_evt->item_index;
            cur_prov_list_index = (U8)index;
            cur_prov_acct_id = (U8)g_data_account_display_cntx.profile_list[index].profile_id;
            return MMI_RET_CHANGED;
        }
        default:
            break;
    }
    return MMI_RET_OK;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_profile_skip_confirm
 * DESCRIPTION
 *  This function is responsible for processing provisioning cancel confirm
 *  data account.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_dtcnt_ota_cca_rsp_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prov_type_enum prov_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_OTA_CCA_RSP_HANDLER, g_prov_ind.cnf_callback);

    prov_type = g_prov_ind.prov_type;

    if (g_prov_ind.cnf_callback)
    {
        g_prov_ind.cnf_callback(SRV_DTCNT_PROV_CNF_SKIP, g_prov_ind.cur_prof_idx);
        memset(&g_prov_ind, 0, sizeof(srv_dtcnt_prov_ind_evt_struct));
    }

    mmi_frm_scrn_close_active_id();

    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_OTA_CCA_RSP_HANDLER, prov_type);
    if (prov_type != SRV_DTCNT_PROV_TYPE_REPLACE)
    {
        mmi_frm_scrn_close(GRP_ID_DTCNT_PROV, SCR_ID_DTCNT_OTA_MAIN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_ota_main_scrn_proc
 * DESCRIPTION
 *  proc function for ota main screen
 * PARAMETERS
 *  evt     [IN] 
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_dtcnt_ota_main_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_INIT:
        {
            g_dtcnt_name = OslMalloc((MAX_DATA_ACCOUNT_NAME_LEN + 1) * ENCODING_LENGTH);
            g_dtcnt_addr = OslMalloc(MAX_DTCNT_LIST_ADDR_LEN);
            break;
        }
        case EVT_ID_SCRN_ACTIVE:
        {
            CHAR *info;
            srv_dtcnt_prov_csd_gprs_ind_struct *csd_gprs_prov_acct;            
            mmi_frm_scrn_active_evt_struct *active_evt;
            active_evt = (mmi_frm_scrn_active_evt_struct *)evt;
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_PROV_ENTRY_INSTALL_CSD_GPRS);            
            csd_gprs_prov_acct = (srv_dtcnt_prov_csd_gprs_ind_struct *)(g_prov_ind.prof_data);

            /* Obtain a temporary buffer to show messages. */
            info = (CHAR*) subMenuData;
            
            if (active_evt->is_first_active)
            {
                mmi_ucs2cpy((CHAR*)g_dtcnt_name, (CHAR*)csd_gprs_prov_acct->AccountName);
                strcpy((char *)g_dtcnt_addr, (const char *)csd_gprs_prov_acct->Address);
            }
            
            mmi_dtcnt_prov_prepare_prof_info(info, &g_prov_ind);
            
            ShowCategory74Screen(
                STR_ID_CCA_INSTALL_SETTING,
                GetRootTitleIcon(SERVICES_DATA_CONNECT_MAIN_MENU_ID),
                STR_GLOBAL_INSTALL,
                IMG_GLOBAL_YES,
                STR_ID_CCA_SKIP,
                IMG_GLOBAL_NO,
                (U8 *)info,
                MAX_SUB_MENUS * MAX_SUB_MENU_SIZE,
                active_evt->gui_buffer);
            
        #ifndef __MMI_WGUI_DISABLE_CSK__ 
            ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);            
        #else
            SetCenterSoftkeyFunction(mmi_dtcnt_main_scrn_csk_hdlr, KEY_EVENT_UP);
        #endif
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_PROV_ENTRY_INSTALL_CSD_GPRS_TYPE, g_prov_ind.prov_type);
            break;
        }
        case EVT_ID_SCRN_DEINIT:
        {
            MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_OTA_INTALL_ABORT_STEP, 0);
            if (g_need_abort_flag)
            {
                if (g_prov_ind.cnf_callback)
                {
                    g_prov_ind.cnf_callback(SRV_DTCNT_PROV_CNF_ABORT, g_prov_ind.cur_prof_idx);
                    memset(&g_prov_ind, 0, sizeof(srv_dtcnt_prov_ind_evt_struct));
                }
            }            
            OslMfree(g_dtcnt_name);
            OslMfree(g_dtcnt_addr);
            return MMI_RET_ALLOW_CLOSE;
        }
        case EVT_ID_WGUI_LSK_CLICK:
        case EVT_ID_WGUI_CSK_CLICK:
        {
            U8 acct_num;
            acct_num = mmi_dtcnt_get_acct_num_exclude_sim_prov_per_sim(g_prov_ind.sim_info);
            if ((acct_num == SRV_DTCNT_PROF_MAX_ACCOUNT_NUM_PER_SIM) && 
                (g_prov_ind.prov_type != SRV_DTCNT_PROV_TYPE_UPDATE))
            {
                mmi_frm_scrn_create(
                    GRP_ID_DTCNT_PROV,
                    SCR_ID_DTCNT_OTA_LIST,
                    mmi_dtcnt_ota_list_scrn_proc,
                    NULL);
            }
            else
            {
                mmi_dtcnt_prov_install_rsp();
            }
            return MMI_RET_KEY_HANDLED;
        }
        case EVT_ID_WGUI_RSK_CLICK:
        {
            g_need_abort_flag = MMI_FALSE;
            mmi_cca_ui_common_cancel_with_sg(GRP_ID_DTCNT_PROV, STR_ID_CCA_SKIP_PROFILE, mmi_dtcnt_ota_cca_rsp_handler);
            return MMI_RET_KEY_HANDLED;
        }
        default:
            break;
    }
    return MMI_RET_OK;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_install_one_done
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param      [IN]            
 * RETURNS
 *  
 *****************************************************************************/
void mmi_dtcnt_prov_install_one_done(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prov_install_res_ind_evt_struct *prov_ind;
    U32 i = 0, replace = MMI_FALSE;
    U8 bearer = DATA_ACCOUNT_BEARER_CSD;
    srv_dtcnt_sim_type_enum sim_info = SRV_DTCNT_SIM_TYPE_1;
    srv_dtcnt_connection_type_enum conn_type = SRV_DTCNT_CONN_TYPE_HTTP;
    U8 read_only = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prov_ind = (srv_dtcnt_prov_install_res_ind_evt_struct *)param;

    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_INSTALL_ONE_DONE, prov_ind->install_result, prov_ind->prov_ind);

    if (!prov_ind->install_result)
    {
        return;
    }

    if (prov_ind->prov_ind == SRV_DTCNT_PROV_IND_CSD || prov_ind->prov_ind == SRV_DTCNT_PROV_IND_GPRS)
    {
        for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
        {
            if (g_mmi_dtcnt_list_item[i].profile_id == prov_ind->acct_id)
            {
                replace = MMI_TRUE;
            }
        }

        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_PROV_INSTALL_ONE_DONE_REPLACE, replace);

        if (prov_ind->prov_ind == SRV_DTCNT_PROV_IND_CSD)
        {
            bearer = DATA_ACCOUNT_BEARER_CSD;
        }
        else
        {
            bearer = DATA_ACCOUNT_BEARER_GPRS;
        }
        
        srv_dtcnt_get_sim_info(prov_ind->acct_id, &sim_info);
        srv_dtcnt_get_connection_type(prov_ind->acct_id, &conn_type);
        if (srv_dtcnt_acct_is_read_only(prov_ind->acct_id))
        {
            read_only = 1;
        }
        else
        {
            read_only = 0;
        }

        if (replace)
        {
            mmi_dtcnt_update_disp_list(prov_ind->acct_id, 
                bearer, 
                prov_ind->prof_type, 
                (U8)conn_type,
                (U8)sim_info,
                read_only);
        }
        else
        {
            mmi_dtcnt_add_disp_list(prov_ind->acct_id, 
                bearer, 
                prov_ind->prof_type, 
                (U8)conn_type,
                (U8)sim_info,
                read_only);
        }
    }
#ifdef __MMI_WLAN_FEATURES__
    else if (prov_ind->prov_ind == SRV_DTCNT_PROV_IND_WLAN)
    {        
        mmi_wlan_prov_install_one_done(prov_ind->acct_id);    
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_callback_handler
 * DESCRIPTION
 *  function to handle the service callback
 * PARAMETERS
 *    param :      [IN]  event parameter.
 * RETURNS
 *  Return MMI_RET_OK if success;
 *****************************************************************************/
static S32 mmi_dtcnt_prov_callback_handler(mmi_event_struct* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_WLAN_EVENT_ID, param->evt_id);

    switch (param->evt_id)
    {
    case EVT_ID_SRV_DTCNT_PROV_IND:
        mmi_dtcnt_prov_ind_hdlr(param);
        break;
    case EVT_ID_SRV_DTCNT_PROV_INSTALL_RES_IND:
        mmi_dtcnt_prov_install_one_done(param);
        break;
    default:
        break;
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_reg_event
 * DESCRIPTION
 *  Register event callback dynamically with user data pointer.
 * PARAMETERS
 *  evt_id :      [IN]  callback execution type.
 *  user_data :   [IN]  user data pointer.
 * RETURNS
 *  Return MMI_RET_OK if success to register callback with designated user data;
 *  return MMI_RET_ERR_HAS_BEEN_REGISTERED if the designated callback with 
 *  designated user data has been registered.
 *****************************************************************************/
static mmi_ret mmi_dtcnt_prov_reg_event(void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_PROV_IND, mmi_dtcnt_prov_callback_handler, user_data);
    mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_PROV_INSTALL_RES_IND, mmi_dtcnt_prov_callback_handler, user_data);
    //mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_PROV_DONE_IND, mmi_dtcnt_prov_callback_handler, user_data);

    return MMI_RET_OK;
}


#endif   /* __MMI_CCA_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_index_by_port
 * DESCRIPTION
 *  This function is used to get index to set spin control higlight by wap port
 * PARAMETERS     
 *  port       [IN]     port   
 * RETURNS
 *  return index to highlight spin control box
 *****************************************************************************/
U8 mmi_dtcnt_get_index_by_port(U16 port)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                     */
    /*----------------------------------------------------------------*/
    U8 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                                                           */
    /*----------------------------------------------------------------*/
    switch (port)
    {
        case 9201:
            index = 0;
            break;
        case 9203:
            index = 1;
            break;
        default :
            index = 0;
            break;
    }
    return index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_port_by_index
 * DESCRIPTION
 *  This function is used to get wap port by spin control index value
 * PARAMETERS     
 *  index       [IN]     spin control index value  
 * RETURNS
 *  return wap really used port
 *****************************************************************************/
U16 mmi_dtcnt_get_port_by_index(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                     */
    /*----------------------------------------------------------------*/
    U16 port_val;

    /*----------------------------------------------------------------*/
    /* Code Body                                                                                           */
    /*----------------------------------------------------------------*/
    switch (index)
    {
        case 0:
            port_val = 9201;
            break;
        case 1:
            port_val = 9203;
            break;
        default :
            port_val = 9201;
            break;
    }
    return port_val;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_display_confirm_popup
 * DESCRIPTION
 *  This function is used to display confirm popup
 * PARAMETERS     
 *  auto_map       [IN]
 *  proc_func      [IN]
 *  str_id         [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_display_confirm_popup(U32 auto_map, mmi_proc_func proc_func, U16 str_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.f_auto_map_empty_softkey = auto_map;
    arg.callback = proc_func;
    arg.parent_id = GRP_ID_DTCNT;
    mmi_confirm_display_ext(str_id, MMI_EVENT_QUERY, &arg);
}

#ifdef __MMI_AP_DCM_DTCNT__
#pragma arm section rodata , code
#endif

#define DTCNT_SIM_HOT_SWAP

#if defined(__DA_SMART_SELECTION_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_close_group
 * DESCRIPTION
 *  This function is used to close data account setting
 * PARAMETERS     
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_close_group(void)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_group_is_present(GRP_ID_DTCNT))
    {
        mmi_frm_group_close(GRP_ID_DTCNT);
    }
    if (mmi_frm_group_is_present(GRP_ID_DATA_CONNECTION_SIM))
    {
        mmi_frm_group_close(GRP_ID_DATA_CONNECTION_SIM);
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_apn
 * DESCRIPTION
 *  
 * PARAMETERS
 *  account_id      [IN]        
 *  dest            [OUT]         
 *  len             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
BOOL mmi_dtcnt_get_apn(U32 account_id, CHAR *dest, U8 len)
{
#ifdef __MMI_GPRS_FEATURES__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prof_str_info_qry_struct acct_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    acct_data.dest_len = len;
    acct_data.dest = (CHAR*)dest;
    return srv_dtcnt_get_apn(account_id, &acct_data, SRV_DTCNT_ACCOUNT_PRIMARY);
#else
    return MMI_FALSE;
#endif
}


#ifdef __MMI_OP01_DCD__
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_dcd_acct_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_dtcnt_get_dcd_acct_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return CBM_DCD_ACCT_ID;
}
#endif /* __MMI_OP01_DCD__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_first_account_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bearers     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U32 mmi_dtcnt_get_first_account_id(U8 bearers)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return 0xFF;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_account_select_highlight_hdlr
 * DESCRIPTION
 *  highlight handler for DTCNTAppList
 *  
 *  Index values start on zero for first Listesd item.
 * PARAMETERS
 *  nIndex      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_dtcnt_get_invalid_name_str_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return STR_ID_DTCNT_NAME_INVALID;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_default_name_str_id
 * DESCRIPTION
 *  To get default account  name, APP use this API to get default non-selected account name, it will be "Auto"
 * PARAMETERS
 *  void       
 * RETURNS
 *  U16   : String ID
 *****************************************************************************/
U16 mmi_dtcnt_get_default_name_str_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return STR_GLOBAL_AUTOMATIC;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_apn_list_ids
 * DESCRIPTION
 *  To get account id array for unique apn
 * PARAMETERS
 *  ids     [OUT] account id array buffer point;
 *  num_ids [OUT] number of account ids;
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_get_apn_list_ids(U32 *ids, U32 *num_ids, srv_dtcnt_sim_type_enum sim_type)
{   
#ifdef __MMI_GPRS_FEATURES__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i, j;
    U32 gprsNum = 0, apnNumber = 0;
    U32 gprsArray[MMI_DTCNT_PROF_MAX_ACCOUNT_NUM];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!ids || !num_ids)
    {
        return MMI_FALSE;
    }

    for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
    {
    	if (g_mmi_dtcnt_list_item[i].sim_info == sim_type)
		{
	        if (g_mmi_dtcnt_list_item[i].bearer_type == DATA_ACCOUNT_BEARER_GPRS)
	        {            
	            mmi_dtcnt_get_apn(
	                g_mmi_dtcnt_list_item[i].profile_id, 
	                (CHAR*)g_comm_disp_name_addr_arr[gprsNum].data_account_addr, 
	                MAX_DTCNT_LIST_ADDR_LEN * ENCODING_LENGTH);
	            gprsArray[gprsNum++] = g_mmi_dtcnt_list_item[i].profile_id;
	        }
		}
    }
    
    *num_ids = 0; 
    if (gprsNum == 0)
    {
        return MMI_TRUE;
    }
    ids[apnNumber++] = gprsArray[0];
    for (i = 1; i < gprsNum; i++)
    {
        for (j = 0; j < i; j++)
        {
            if (mmi_ucs2icmp(
                    g_comm_disp_name_addr_arr[i].data_account_addr,
                    g_comm_disp_name_addr_arr[j].data_account_addr) == 0)
            {
                break;
            }
        }
        if (i == j)
        {
            ids[apnNumber++] = gprsArray[i];
        }
    }
    *num_ids = apnNumber;
    return MMI_TRUE;
#else
    return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_set_GPRS_APN_for_project_mode
 * DESCRIPTION
 *  Set GPRS profile APN for APP
 * PARAMETERS
 *  APN            [IN]
 *  account_id  [IN]
 *  callback      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_set_GPRS_APN_for_project_mode(CHAR *APN, U32 account_id)
{
#ifdef __MMI_GPRS_FEATURES__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cbm_account_info_struct* acct_info = OslMalloc(sizeof(cbm_account_info_struct));
    U8 original_id;
    srv_dtcnt_store_prof_data_struct prof_info;
    srv_dtcnt_result_enum result;
    U32 acct_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_dtcnt_get_auto_acc_id(account_id, &acct_id);
    cbm_decode_data_account_id_ext(acct_id, acct_info);
    original_id = acct_info->account[0].account_id;
    OslMfree(acct_info);
    if (SRV_DTCNT_BEARER_CSD == srv_dtcnt_get_bearer_type(original_id, SRV_DTCNT_ACCOUNT_PRIMARY))
    {   
        return MMI_FALSE;
    }
    else if (SRV_DTCNT_BEARER_GPRS == srv_dtcnt_get_bearer_type(original_id, SRV_DTCNT_ACCOUNT_PRIMARY))
    {
        prof_info.prof_type = SRV_DTCNT_BEARER_GPRS;
        prof_info.prof_data = &g_data_account_gprs_profile_srv;
        prof_info.prof_fields = SRV_DTCNT_PROF_FIELD_APN_DIAL_NUM;
        memset(&g_data_account_gprs_profile_srv, 0, sizeof(srv_dtcnt_prof_gprs_struct));
        g_data_account_gprs_profile_srv.APN = APN;
        result = srv_dtcnt_store_update_prof(original_id, &prof_info);
        if (SRV_DTCNT_RESULT_SUCCESS == result)
        {
            return MMI_TRUE;
        }
   }
#endif
   return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_ready_check
 * DESCRIPTION
 *  Data account ready check
 * PARAMETERS
 *  ready_callback
 * RETURNS
 *  U8
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_ready_check(FuncPtr ready_callback, MMI_BOOL with_scr_lock)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    MMI_BOOL ret = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_dtcnt_acct_ready == MMI_TRUE)
    {
        ret = MMI_TRUE;
    }
    else
    {
        if (with_scr_lock)
        {
            ClearInputEventHandler(MMI_DEVICE_ALL);
            ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
        }
        for (i = 0; i < DTCNT_READY_CHECK_NUM; i++)
        {
            if(!g_dtcnt_ready_check_cb[i])
            {
                g_dtcnt_ready_check_cb[i] = ready_callback;
                ret = MMI_FALSE;
                break;
            }
        }
    }
    return ret;
}


#if defined(__DA_SMART_SELECTION_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_on_cbm_bearer_info
 * DESCRIPTION
 *  This function used to delete some profile ids which is being used when plug out SIM card
 * PARAMETERS
 *  event           : [IN]      Event
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_dtcnt_on_cbm_bearer_info(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 pure_id;
    U32 i, j;
    srv_cbm_bearer_info_struct *evt = (srv_cbm_bearer_info_struct *)event;
    srv_dtcnt_result_enum result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->state == SRV_CBM_DEACTIVATED)
    {
        pure_id = cbm_get_original_account(evt->account_id);        
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_ON_BEARER_INFO, pure_id, g_hotswap_del_prof.num_ids);
        for (i = 0; i < g_hotswap_del_prof.num_ids; i++)
        {
            if (pure_id == g_hotswap_del_prof.ids[i])
            {
                result = srv_dtcnt_store_delete_prof(
                            (U32)g_hotswap_del_prof.ids[i], 
                            MMI_TRUE, 
                            NULL, 
                            NULL);
                for (j = i; j < g_hotswap_del_prof.num_ids - 1; j++)
                {
                    g_hotswap_del_prof.ids[i] = g_hotswap_del_prof.ids[i + 1];
                }
                g_hotswap_del_prof.num_ids--;                
                MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_ON_BEARER_INFO, pure_id, g_hotswap_del_prof.num_ids);
                break;
            }
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_on_home_plmn_changed
 * DESCRIPTION
 *  Process SIM change.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_dtcnt_on_home_plmn_changed(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    mmi_sim_enum sim_enum = MMI_SIM1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PROCESS_SIM_CHANGE, 0);
    if(g_first_proc_plmn_evt)
    {
        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            sim_enum = mmi_frm_index_to_sim(i);
        #ifdef __MMI_TELEPHONY_SUPPORT__
            if (srv_sim_ctrl_is_available(sim_enum))
            {
                g_dtcnt_plmn_evt_num++;
            }
        #endif
        }
        g_first_proc_plmn_evt = MMI_FALSE;
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ON_HOME_PLMN_CHANGED, 0, 1, g_dtcnt_plmn_evt_num);
    }
    g_dtcnt_plmn_proc_num++;
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ON_HOME_PLMN_CHANGED, 0, 2, g_dtcnt_plmn_proc_num);
    if (g_dtcnt_plmn_proc_num < g_dtcnt_plmn_evt_num)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ON_HOME_PLMN_CHANGED, 0, 2, g_dtcnt_plmn_proc_num);
        return MMI_RET_OK;
    }

    if (g_dtcnt_init_plmn & MMI_DTCNT_INIT_PLMN)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PROCESS_SIM_CHANGE, 2);
        return MMI_RET_OK;
    }

    g_dtcnt_init_plmn |= MMI_DTCNT_PLMN;

    if ((g_dtcnt_init_plmn & MMI_DTCNT_INIT) != MMI_DTCNT_INIT)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PROCESS_SIM_CHANGE, 4);
        return MMI_RET_OK;
    }

    if (!mmi_dtcnt_is_sim_card_changed() && !g_dtcnt_factory)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PROCESS_SIM_CHANGE, 6);
        g_dtcnt_init_plmn |= MMI_DTCNT_INIT_PLMN;
        mmi_dtcnt_get_defined_prof();

        return MMI_RET_OK;
    }

    if (g_dtcnt_factory)
    {
        for (i = 0; i < MMI_SIM_TOTAL; i++)
        {
            g_sim_changed[i] = MMI_TRUE;
        }
    }

    /* delete sim profile */
    mmi_dtcnt_sim_prof_delete();

    /* add pre-install account */
    mmi_dtcnt_pre_install_parse();

//    mmi_dtcnt_get_defined_prof();

    g_dtcnt_init_plmn |= MMI_DTCNT_INIT_PLMN;

    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_PROCESS_SIM_CHANGE, 10);
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_on_sim_detected
 * DESCRIPTION
 *  This function is used to process sim hot swap
 * PARAMETERS     
 *  evt       [IN]     event id
 * RETURNS
 *  return MMI_RET_OK
 *****************************************************************************/
mmi_ret mmi_dtcnt_on_sim_detected(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sim_ctrl_event_detected_evt_struct *detected_evt = (srv_sim_ctrl_event_detected_evt_struct *)evt;
    U32 sim_index;    
    U8 sim_card_id[4 * MMI_DTCNT_MAX_PLMN_LEN + 1];
    U8 sim_card_id_temp[MMI_DTCNT_MAX_PLMN_LEN];
    S16 error;
    srv_dtcnt_store_prof_qry_struct acct_id_query;
    srv_dtcnt_result_enum result;
    U32 i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_ON_SIM_DETECTED, detected_evt->type, detected_evt->sim);
    sim_index = mmi_frm_sim_to_index(detected_evt->sim);
    switch (detected_evt->type)
    {
        case SRV_SIM_CTRL_EVENT_DET_BT_ACCESS_ON:
        case SRV_SIM_CTRL_EVENT_DET_REMOVED:
        case SRV_SIM_CTRL_EVENT_DET_RECOVERY_START:
        {
            g_dtcnt_acct_ready = MMI_FALSE;
            mmi_dtcnt_close_group(); // delete app setting
            cui_dtcnt_close_all_group(sim_index); // delete cui
            //mmi_dtcnt_delete_any_sim_profile((srv_dtcnt_sim_type_enum)(sim_index + 1)); // delete removed SIM's account
            memset(&acct_id_query, 0, sizeof(srv_dtcnt_store_prof_qry_struct));
            acct_id_query.qry_info.filters = SRV_DTCNT_STORE_QRY_TYPE_SIM | SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE;
            acct_id_query.qry_info.sim_qry_info = (srv_dtcnt_sim_type_enum)(sim_index + 1);
            for (i = SRV_DTCNT_PROF_TYPE_FACTORY_CONF; i < SRV_DTCNT_PROF_TYPE_TOTAL; i++)
            {                
                acct_id_query.qry_info.acc_type_info = i;
                result = srv_dtcnt_store_qry_ids(&acct_id_query);
                for (j = 0; j < acct_id_query.num_ids; j++)
                {
                    if (!mmi_dtcnt_is_account_in_use(acct_id_query.ids[j]))
                    {                    
                        result = srv_dtcnt_store_delete_prof(
                            acct_id_query.ids[j], 
                            MMI_TRUE, 
                            NULL, 
                            NULL);                        
                        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_ON_SIM_DETECTED_DELETED, acct_id_query.ids[j]);
                    }
                    else
                    {
                        g_hotswap_del_prof.ids[g_hotswap_del_prof.num_ids++] = (U8)acct_id_query.ids[j];                        
                        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_ON_SIM_DETECTED_UNDELETED, acct_id_query.ids[j], g_hotswap_del_prof.num_ids);
                    }
                }
            }
            
            // update PLMN to NVRAM
            memset(sim_card_id, 0, 4 * MMI_DTCNT_MAX_PLMN_LEN + 1);
            ReadRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);            
            memset(sim_card_id_temp, 0, MMI_DTCNT_MAX_PLMN_LEN);
            strcpy((CHAR*)&sim_card_id[sim_index * MMI_DTCNT_MAX_PLMN_LEN], (CHAR*)sim_card_id_temp);
            WriteRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);

            g_mmi_dtcnt_acct_num = 0; // reset
            memset(g_mmi_dtcnt_list_item, 0, MMI_DTCNT_PROF_MAX_ACCOUNT_NUM * sizeof(mmi_dtcnt_list_disp_struct)); // reset
            mmi_dtcnt_get_defined_prof(); // get defined profiles
            break;
        }
        case SRV_SIM_CTRL_EVENT_DET_BT_ACCESS_OFF:
        case SRV_SIM_CTRL_EVENT_DET_INSERTED:
        case SRV_SIM_CTRL_EVENT_DET_RECOVERY_END:
        {
            g_dtcnt_acct_ready = MMI_FALSE;
            g_dtcnt_init_plmn = MMI_DTCNT_INIT;
            mmi_dtcnt_close_group(); // delete app setting
            cui_dtcnt_close_all_group(sim_index); // delete cui
            for (i = 0; i < MMI_SIM_TOTAL; i++)
            {
                g_sim_changed[i] = MMI_TRUE;
            }
            g_mmi_dtcnt_acct_num = 0; // reset
            memset(&g_hotswap_del_prof, 0, sizeof(mmi_dtcnt_hotswap_del_prof_struct)); // don't need to delete when deatived
            memset(g_mmi_dtcnt_list_item, 0, MMI_DTCNT_PROF_MAX_ACCOUNT_NUM * sizeof(mmi_dtcnt_list_disp_struct)); // reset
            break;
        }
        default:
        {
            break;
        }
    }
    
    return MMI_RET_OK;
}


#endif /* #if defined(__DA_SMART_SELECTION_SUPPORT__) */

/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_acct_is_valid
 * DESCRIPTION
 *  To check if the encoded account ID is valid
 * PARAMETERS
 *  encoded_acct_id    [IN]   APP must pass the  
 * RETURNS
 *  mmi_dtcnt_acct_valid_type_enum  
 *****************************************************************************/
mmi_dtcnt_acct_valid_type_enum mmi_dtcnt_acct_is_valid(U32 encoded_acct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cbm_account_info_struct *acct_info_ptr = NULL;
    U32 first_acct_id;
    U32 i;
    mmi_sim_enum sim = MMI_SIM1;
    cbm_app_info_struct app_info;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ACCT_IS_VALID, encoded_acct_id);
    acct_info_ptr = OslMalloc(sizeof(cbm_account_info_struct));
    cbm_decode_data_account_id_ext(encoded_acct_id, acct_info_ptr);
    abm_get_registered_app_name(acct_info_ptr->app_id, &app_info);
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_ACCT_IS_VALID_APPINFO, app_info.app_str_id, app_info.app_icon_id);

    first_acct_id = acct_info_ptr->account[0].account_id;

    OslMfree(acct_info_ptr);
    acct_info_ptr = NULL;

    if (CBM_DEFAULT_ACCT_ID == first_acct_id)
    {
        return MMI_DTCNT_ACCT_VALID_FIRST;        
    }
    if (CBM_WIFI_ACCT_ID == first_acct_id)
    {
    
    #ifdef __MMI_WLAN_FEATURES__
        return MMI_DTCNT_ACCT_VALID_FIRST;
    #endif
        return MMI_DTCNT_ACCT_VALID_NONE;
    }

    for (i = 0; i < g_mmi_dtcnt_acct_num; i++)
    {
        if (g_mmi_dtcnt_list_item[i].profile_id == first_acct_id)
        {
            sim = mmi_frm_index_to_sim((U32)(g_mmi_dtcnt_list_item[i].sim_info - 1));
        #ifdef __MMI_TELEPHONY_SUPPORT__
            if (!srv_sim_ctrl_is_available(sim))
            {
                return MMI_DTCNT_ACCT_VALID_NONE;
            }
            return MMI_DTCNT_ACCT_VALID_FIRST;
        #else
            return MMI_DTCNT_ACCT_VALID_NONE;
        #endif
        }
    }
    return MMI_DTCNT_ACCT_VALID_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_app_init
 * DESCRIPTION
 *  Initialize the Data Account App
 *  
 *  This is used to initialized the Data Account application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_app_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_result_enum result;
#if defined(__DA_SMART_SELECTION_SUPPORT__)
    U32 i;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = srv_dtcnt_store_create();
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 1, result);

    if (result != SRV_DTCNT_RESULT_FS_ERROR)
    {
        result = srv_dtcnt_store_open();
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 3, result);

        if (result == SRV_DTCNT_RESULT_FS_ERROR)
        {
            /* popup failure message */
            return;
        }
    #if defined(__DA_SMART_SELECTION_SUPPORT__)
        if (result == SRV_DTCNT_RESULT_RESET_FACTORY)
        {
            g_dtcnt_factory = MMI_TRUE;
        }
    #endif
    }
#if defined (__MMI_AP_DCM_DTCNT__)
    mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_SETTINGS);
#endif

#ifdef __MMI_WLAN_FEATURES__
    mmi_wlan_init();
#elif defined(__MMI_CCA_SUPPORT__)
    mmi_dtcnt_prov_reg_event(NULL);
#endif

#if defined(__DA_SMART_SELECTION_SUPPORT__)
    g_dtcnt_init_plmn |= MMI_DTCNT_INIT;
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        g_sim_changed[i] = MMI_TRUE; // initial value
    }
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 4, 0);

#ifdef __MMI_TELEPHONY_SUPPORT__
    if (srv_sim_ctrl_get_one_available_sim())
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 5, 0);
        
        if (g_dtcnt_init_plmn & MMI_DTCNT_PLMN)
        {
            mmi_dtcnt_on_home_plmn_changed(NULL);
        }
    #if defined (__MMI_AP_DCM_DTCNT__)
        mmi_dtcnt_send_unload_dcm();
    #endif
        return;
    }
#endif

    if (result == SRV_DTCNT_RESULT_FIRST_BOOTUP)
    {
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 7, result);
    }
    else
    {
        U8 sim_card_id[4 * MMI_DTCNT_MAX_PLMN_LEN + 1];
        S16 error;
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 9, result);
        memset(sim_card_id, 0, 4 * MMI_DTCNT_MAX_PLMN_LEN + 1);
        ReadRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);
        if (sim_card_id[0] || sim_card_id[MMI_DTCNT_MAX_PLMN_LEN] ||
            sim_card_id[MMI_DTCNT_MAX_PLMN_LEN * 2] || sim_card_id[MMI_DTCNT_MAX_PLMN_LEN * 3])
        {
            memset(sim_card_id, 0, 4 * MMI_DTCNT_MAX_PLMN_LEN + 1);
            WriteRecord(NVRAM_EF_DTCNT_SIM_ID_LID, 1, &sim_card_id, NVRAM_MAX_DTCNT_SIM_ID_SIZE, &error);
            mmi_dtcnt_sim_prof_delete();
        }
    }
    
    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, 10, 0);
#else /* __DA_SMART_SELECTION_SUPPORT__ */
    if (result == SRV_DTCNT_RESULT_FIRST_BOOTUP ||
        result == SRV_DTCNT_RESULT_RESET_FACTORY)
    {   
        // read pre-defined account, 
        srv_dtcnt_store_prof_qry_filter_struct delete_query;
        // just support to read account from custom_config_account.c when turn off smart selection
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DAPP_INIT, result, 0);
        // delete pre-defined account
        memset(&delete_query, 0, sizeof(delete_query));
        delete_query.filters = SRV_DTCNT_STORE_QRY_TYPE_ACC_TYPE;
        delete_query.acc_type_info = SRV_DTCNT_PROF_TYPE_FACTORY_CONF;
        srv_dtcnt_store_delete_prof_by_qry(&delete_query, MMI_TRUE, NULL, NULL);

        //add pre-defined account
    }
#endif /* __DA_SMART_SELECTION_SUPPORT__ */
#if defined (__MMI_AP_DCM_DTCNT__)
    mmi_dtcnt_send_unload_dcm();
#endif
    mmi_dtcnt_get_defined_prof();
}


#ifdef __MMI_CCA_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_prov_ind_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param      [IN]            
 * RETURNS
 *  
 *****************************************************************************/
void mmi_dtcnt_prov_ind_hdlr(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prov_ind_evt_struct *prov_ind;
    MMI_ID cca_group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cca_group_id = mmi_cca_get_root_group();
    prov_ind = (srv_dtcnt_prov_ind_evt_struct *)param;

    MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, MMI_DTCNT_PROV_IND_HDLR, cca_group_id, prov_ind->prov_ind);
    if (prov_ind->prov_ind == SRV_DTCNT_PROV_IND_CSD || prov_ind->prov_ind == SRV_DTCNT_PROV_IND_GPRS)
    {
    #if defined (__MMI_AP_DCM_DTCNT__)
        mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_SETTINGS);
    #endif
        g_prov_ind = *prov_ind;
        g_need_abort_flag = MMI_TRUE;
        if (mmi_frm_group_is_present(GRP_ID_DTCNT))
        {
            mmi_frm_group_close(GRP_ID_DTCNT);
        }
        if (mmi_frm_group_is_present(GRP_ID_DTCNT_PROV))
        {
            mmi_frm_group_close(GRP_ID_DTCNT_PROV);
        }
        mmi_frm_group_create_ex(
            cca_group_id,
            GRP_ID_DTCNT_PROV,
            mmi_dtcnt_cui_event_proc,
            NULL,
            MMI_FRM_NODE_SMART_CLOSE_FLAG);

        mmi_frm_scrn_create(
            GRP_ID_DTCNT_PROV,
            SCR_ID_DTCNT_OTA_MAIN,
            mmi_dtcnt_ota_main_scrn_proc,
            NULL);
        
    }
#if defined(__MMI_WLAN_OTAP_OMAEXT__) || defined(__MMI_WLAN_OTAP_DMP__)
    else if (prov_ind->prov_ind == SRV_DTCNT_PROV_IND_WLAN)
    {
        g_prov_ind = *prov_ind;

        wlan_parent_group_id = mmi_frm_group_create_ex(
            cca_group_id,
            GRP_ID_AUTO_GEN,
            mmi_wlan_cui_event_proc,
            NULL,
            MMI_FRM_NODE_SMART_CLOSE_FLAG);

        mmi_wlan_prov_entry_install_wlan();        
    }
#endif
}
#endif /* #ifdef __MMI_CCA_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_ready_status
 * DESCRIPTION
 *  This function is used to get data account ready status
 * PARAMETERS     
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_get_ready_status(void)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_PRINT(MOD_MMI_CONN_APP, MMI_CONN_TRC_G6_DTCNT, "[DTCNT APP] mmi_dtcnt_get_ready_status, g_dtcnt_acct_ready = %d", g_dtcnt_acct_ready);
    return g_dtcnt_acct_ready;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_get_full_account_name
 * DESCRIPTION
 *  Display bearers info included within a data-account ID.
 * PARAMETERS
 *  account_id      [IN]        
 *  dest            [OUT]         
 *  len             [IN]
 *  type           [IN]
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_get_full_account_name(U32 acct_id, CHAR *dest, U8 len, mmi_dtcnt_get_acct_name_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cbm_account_info_struct acct_info;
    MMI_BOOL ret_val = MMI_FALSE;
    MMI_BOOL ret;
    srv_dtcnt_sim_type_enum srv_sim_id = SRV_DTCNT_SIM_TYPE_1;
    srv_dtcnt_prof_str_info_qry_struct acct_data;
    CHAR tempSimInfo[(DATA_ACCOUNT_NAME_SUFFIX_LEN + 1) * ENCODING_LENGTH];
    srv_dtcnt_result_enum result;
    U32 out_account_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(dest == NULL)
    {
        return MMI_FALSE;
    }
    len = (len > MAX_DATA_ACCOUNT_NAME_WITH_SUFFIX_LEN) ? MAX_DATA_ACCOUNT_NAME_WITH_SUFFIX_LEN : len; 
    cbm_decode_data_account_id_ext(acct_id, &acct_info);
    #ifdef __MMI_WLAN_FEATURES__
    if (acct_info.account[0].account_id == CBM_WIFI_ACCT_ID)
    {
        mmi_ucs2ncpy(dest, (CHAR*)GetString(SERVICES_DATA_CONNECT_WLAN_STRING_ID), len);
        return MMI_TRUE;
    }
    #endif

    // When no sim card available
#ifdef __MMI_TELEPHONY_SUPPORT__
    if (!srv_sim_ctrl_any_sim_is_available())
#else
    if (MMI_TRUE)  //no sim available
#endif
    {
        mmi_ucs2ncpy(dest, (CHAR*)GetString(STR_ID_DTCNT_NO_AVAILABLE_ACCOUNT), len);
        return MMI_TRUE;
    }

    // specail case for USB
    if (acct_info.account[0].account_id == CBM_USB_TR_PS_ACCT_ID)
    {
        acct_info.account[0].account_id = (U8)srv_tethering_usb_qurey_acct_id();
    }

    if (acct_info.account[0].account_id == CBM_DEFAULT_ACCT_ID)
    {
        result = srv_dtcnt_get_auto_acc_id(acct_id, &out_account_id);

        if (result != SRV_DTCNT_RESULT_SUCCESS) // no accounts
        {
            mmi_ucs2ncpy((CHAR *)dest, (CHAR *)GetString(STR_ID_DTCNT_NO_AVAILABLE_ACCOUNT), len);
            return MMI_TRUE;
        }
        else
        {
            acct_info.account[0].account_id = cbm_get_original_account(out_account_id);
            if (acct_info.account[0].account_id == CBM_DEFAULT_ACCT_ID)
            {
                mmi_ucs2ncpy((CHAR *)dest, (CHAR *)GetString(STR_ID_DTCNT_NO_AVAILABLE_ACCOUNT), len);
                return MMI_TRUE;
            }
        }
    }

    acct_data.dest_len = (len + 1) * ENCODING_LENGTH;
    acct_data.dest = (CHAR*)dest;
    ret = srv_dtcnt_get_account_name(
            acct_info.account[0].account_id,
            &acct_data,
            SRV_DTCNT_ACCOUNT_PRIMARY); 
    if (ret)
    {
        if (mmi_dtcnt_get_available_sim_num() > 1)
        {
            srv_dtcnt_get_sim_info(acct_info.account[0].account_id, &srv_sim_id);
            kal_wsprintf((WCHAR*)tempSimInfo, "(SIM %d)", srv_sim_id);
            mmi_ucs2cat((CHAR*)dest, (CHAR*)tempSimInfo);
        }
        return MMI_TRUE;
    }

    if (!ret_val) /* for single */
    {
        mmi_ucs2ncpy(dest, GetString(STR_ID_DTCNT_NO_AVAILABLE_ACCOUNT), len);
    }
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  PreparedIPAddressString
 * DESCRIPTION
 *  Prepared the Data Account IP Address to Show on Screen.
 * PARAMETERS
 *  string_buffer       [?]     
 *  IP1                 [?]     
 *  IP2                 [?]     
 *  IP3                 [?]     
 *  IP4                 [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void PreparedIPAddressString(U8 *string_buffer, U8 *IP1, U8 *IP2, U8 *IP3, U8 *IP4)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 IPAddress[MAX_PART_IP_ADDRESS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    IPAddress[0] = (U8) gui_atoi((UI_string_type) IP1);
    IPAddress[1] = (U8) gui_atoi((UI_string_type) IP2);
    IPAddress[2] = (U8) gui_atoi((UI_string_type) IP3);
    IPAddress[3] = (U8) gui_atoi((UI_string_type) IP4);

    mmi_dtcnt_convert_ip_to_display(string_buffer, IPAddress);
}


/*****************************************************************************
 * FUNCTION
 *  ReturnThreeDigitString
 * DESCRIPTION
 *  This Fun Convert the integer value to String with prefix zero.
 *  
 *  Works only for three digit integer.(0-256)
 * PARAMETERS
 *  StringVal       [IN]        
 *  DigitVal        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void ReturnThreeDigitString(PU8 StringVal, U8 DigitVal)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR LocalBuffer[8];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (DigitVal < 10)
    {
        sprintf(LocalBuffer, "00%d", DigitVal);
    }
    else if (DigitVal < 100)
    {
        sprintf(LocalBuffer, "0%d", DigitVal);
    }
    else
    {
        sprintf(LocalBuffer, "%d", DigitVal);
    }
    mmi_asc_to_ucs2((CHAR*)StringVal, (CHAR*)LocalBuffer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_validate_url
 * DESCRIPTION
 *  Utility function to validate the url.
 * PARAMETERS
 *  url_p                        [IN]        Url in unicode to be validated
 *  b_blank_url_is_valid   [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
S16 mmi_dtcnt_validate_url(U8 *url_p, MMI_BOOL b_blank_url_is_valid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 temp[MAX_ADDRESS_NAME_LEN];
    U8 url_ascii[MAX_ADDRESS_NAME_LEN];
    U8 uri_schm_len;
    applib_url_struct url_info;
    S16 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check the zero length */
    if (MMI_FALSE == b_blank_url_is_valid)
    {
        if (!mmi_ucs2strlen((CHAR*)url_p))
        {
            return APPLIB_URL_ERR_INVALID_PARAM;
        }
    }
    else
    {
        if (!mmi_ucs2strlen((CHAR*)url_p))
        {
            return 0;
        }
    }

    /* convert the UCS2 URL string into UTF-8 */
    mmi_chset_ucs2_to_utf8_string((U8*)url_ascii, MAX_ADDRESS_NAME_LEN, (U8*)url_p);

    /* parse the URL string by using Applib API */
    if (!(S32) applib_parse_url((CHAR*)url_ascii, &url_info))
    {
        /* if there is an empty URI scheme in the URL then append the default ("http://") */
        /* URI scheme */
        if (url_info.scheme_type == applib_scheme_empty)
        {
            uri_schm_len = strlen((CHAR*)MMI_DTCNT_DEFAULT_URL);
            if (strlen((CHAR*)url_ascii) > (MAX_ADDRESS_NAME_LEN - uri_schm_len - 1))
            {
                strncpy((CHAR*)temp, (CHAR*)url_ascii, MAX_ADDRESS_NAME_LEN - uri_schm_len - 1);
                temp[MAX_ADDRESS_NAME_LEN - uri_schm_len - 1] = '\0';
            }
            else
            {
                strcpy((CHAR*) temp, (CHAR*) url_ascii);
            }
            strcpy((CHAR*) url_ascii, (CHAR*) MMI_DTCNT_DEFAULT_URL);
            strcat((CHAR*) url_ascii, (CHAR*) temp);
            
            /* check whether it contain HTTP or HTTPS URI scheme with empty host */
            if (MMI_FALSE == b_blank_url_is_valid)
            {
                if (!(S32) applib_parse_url((CHAR*) url_ascii, &url_info))
                {
                    if ((url_info.scheme_type == applib_scheme_http) || (url_info.scheme_type == applib_scheme_https))
                    {

                        if (!url_info.len[APPLIB_URL_HOST_PART])
                        {
                            return APPLIB_URL_ERR_INVALID_HOST;
                        }
                    }
                }
            }
        }
        /* check whether it contain HTTP or HTTPS URI scheme with empty host */
        else if ((url_info.scheme_type == applib_scheme_http) || (url_info.scheme_type == applib_scheme_https))
        {
            if (MMI_FALSE == b_blank_url_is_valid)
            {
                if (!url_info.len[APPLIB_URL_HOST_PART])
                {
                    return APPLIB_URL_ERR_INVALID_HOST;
                }
            }
        }
    }

    /* validate the UTF-8 URL string by using Applib API */
    ret = (S16)applib_url_is_valid((CHAR*) url_ascii);
    if (ret == 0)
    {        
        mmi_chset_utf8_to_ucs2_string((U8*) url_p, (MAX_ADDRESS_NAME_LEN) * ENCODING_LENGTH, (U8*) url_ascii);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_convert_ip_to_display
 * DESCRIPTION
 *  converter u8 to string for display
 * PARAMETERS
 *     
 * RETURNS
 *  
 ****************************************************************************/
void mmi_dtcnt_convert_ip_to_display(U8 *string_buffer, U8 *IP)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 tmp[MAX_PART_IP_ADDRESS * 2];
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* net ip */    
    mmi_ucs2cpy((CHAR*)string_buffer, (CHAR*)(L""));    
    for (i = 0; i < MAX_PART_IP_ADDRESS - 1; i++)
    {
        ReturnThreeDigitString(tmp, IP[i]);
        mmi_ucs2cat((CHAR*)string_buffer, (CHAR*)tmp);
        mmi_ucs2cat((CHAR*)string_buffer, (CHAR*)(L"."));
    }
    ReturnThreeDigitString(tmp, IP[i]);
    mmi_ucs2cat((CHAR*)string_buffer, (CHAR*)tmp);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_pre_entry_main
 * DESCRIPTION
 *  pre entry function for main screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_dtcnt_pre_entry_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_dtcnt_acct_ready)
    {
        mmi_popup_display_simple_ext(STR_ID_DTCNT_NOT_READY, MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);
        return;
    }
    if (mmi_frm_group_is_present(GRP_ID_DTCNT))
    {
        mmi_frm_group_close(GRP_ID_DTCNT);
    }
#if defined (__MMI_AP_DCM_DTCNT__)
    mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_SETTINGS);
#endif
    mmi_frm_group_create_ex(
        GRP_ID_ROOT,
        GRP_ID_DTCNT,
        mmi_dtcnt_cui_event_proc,
        NULL,
        MMI_FRM_NODE_SMART_CLOSE_FLAG);
    if (mmi_dtcnt_get_available_sim_num() > 1)
    {
    #ifndef __MMI_DYNAMIC_SIM_DYNAMIC_UI__
        g_data_account_display_cntx.sim_list_group_id = cui_menu_create(
                                                            GRP_ID_DTCNT,
                                                            CUI_MENU_SRC_TYPE_RESOURCE,
                                                            CUI_MENU_TYPE_APPMAIN,
                                                            MENU_ID_DATA_CONNECTION_SIM, // just use its menu item
                                                            MMI_TRUE,
                                                            NULL);
    #else
        g_data_account_display_cntx.sim_list_group_id = cui_menu_create(
                                                            GRP_ID_DTCNT,
                                                            CUI_MENU_SRC_TYPE_APPCREATE,
                                                            CUI_MENU_TYPE_APPMAIN,
                                                            MENU_ID_DATA_CONNECTION_SIM, // just use its menu item
                                                            MMI_FALSE,
                                                            NULL);
    #endif
        cui_menu_run(g_data_account_display_cntx.sim_list_group_id);
    }
    else
    {
        ret = srv_dtcnt_get_sim_preference(&g_data_account_display_cntx.curr_sim_type);
        MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, TRC_DATA_CONNECTION_SIM_GET_SIM_PREFERENCE, g_data_account_display_cntx.curr_sim_type, ret);
        mmi_frm_scrn_create(
            GRP_ID_DTCNT,
            SCR_ID_DTCNT_LIST,
            mmi_dtcnt_main_scrn_proc,
            NULL);
    }
}


/*****************************************************************************
* FUNCTION
*  DataConnectHiliteHandler
* DESCRIPTION
*  Hilite Handler for Data Connect Sub Menu
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void DataConnectHiliteHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
#ifndef __MMI_WGUI_DISABLE_CSK__ 
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
#endif
    SetLeftSoftkeyFunction(mmi_dtcnt_pre_entry_main, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_dtcnt_pre_entry_main, KEY_EVENT_UP);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_main_menu_should_hide
 * DESCRIPTION
 *  shows the main menu list
 *  
 *  This is used to shows the main menu list of data account
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_dtcnt_main_menu_should_hide(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TELEPHONY_SUPPORT__
    return (MMI_BOOL)!srv_sim_ctrl_any_sim_is_available();
#else
    return MMI_TRUE;
#endif
}


#if defined (__MMI_AP_DCM_DTCNT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_post_unload_dcm
 * DESCRIPTION
 *  API to unload the DCM region 
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
void mmi_dtcnt_post_unload_dcm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!mmi_frm_app_is_launched(APP_SETTING_NEW))
    {
        mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_SETTINGS);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_dtcnt_send_unload_dcm
 * DESCRIPTION
 *  API to unload the DCM region 
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
void mmi_dtcnt_send_unload_dcm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!mmi_frm_app_is_launched(APP_SETTING_NEW))
    {
        mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_SETTINGS);
    }
}
#endif

#endif /* __TCPIP__ */ 




/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
* Filename:
* ---------
*  RingtoneComposerMainScreen.c
*
* Project:
* --------
*   MAUI
*
* Description:
* ------------
*   Ringtone Composer main screen
*
* Author:
* -------
 * -------
*
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/


#include "MMI_features.h"

#if defined(__MMI_RING_COMPOSER__) && defined(__MMI_IMELODY_SUPPORT__)

/* RHR */
#include "CustThemesRes.h"
#include "gui_data_types.h"
#include "MMIDataType.h"
#include "ComposeRingToneTypes.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gui_theme_struct.h"
#include "gui_themes.h"
#include "mmi_frm_input_gprot.h"
#include "gui_switch.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "wgui.h"
//#include "kal_general_types.h"
#include "gdi_include.h"
#include "wgui_include.h"
#include "wgui_categories_util.h"
#include "GlobalResDef.h"
#include "mmi_frm_scenario_gprot.h"
#include "gui_config.h"
#include "ScreenRotationGprot.h"
#include "wgui_inputs.h"
#include "CustDataRes.h"
#include "mmi_frm_mem_gprot.h"
//#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "string.h"
#include "CustMenuRes.h"
#include "gui_fixed_menuitems.h"
#include "TimerEvents.h"
#include "mmi_frm_timer_gprot.h"
#include "GlobalConstants.h"

//#include "operator_gui.h"
#include "kal_general_types.h"
#include "kal_public_api.h"

/* RHR */

//#include "mmi_include.h"
#include "ComposeRingToneEngineProts.h"
#include "ComposeRingToneEngineDefs.h"
//#include "Asciiprot.h"
#include "ComposeRingToneDefs.h"
//#include "SettingProfile.h"
//#include "CustDataProts.h"
#include "ComposeRingToneProts.h"
#include "mmi_rp_app_ringtonecomposer_def.h"
#include "ComposeRingToneMainScreenProts.h"
//#include "gpioInc.h"
//#include "ProfileGprots.h"
//#include "mdi_datatype.h"
//#include "mdi_audio.h"
//#include "FileManagerDef.h"
//#include "FileManagerGprot.h"
//#include "CommonScreens.h"
//#include "fs_type.h"
//#include "FS_Func.h"
//#include "fs_errcode.h"
#include "gui_font_size.h"
#include "Gui.h" /* for MMI_title_height */
#include "Gui_typedef.h" /* for UI_device_width, UI_device_height, r2lMMIFlag */
#include "gui_horizontal_selector.h"

#ifdef __MMI_TOUCH_RING_COMPOSER__
//#include "wgui_softkeys.h"
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 

#ifdef __DRM_SUPPORT__
//#include "drm_gprot.h"
#endif /* __DRM_SUPPORT__ */

#if defined(__MMI_BACKGROUND_CALL__)
//#include "UCMGProt.h"
#endif



/* To draw the background color behind the remaining number of notes */
const UI_filled_area lightblue_color_dialog_background = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {108, 182, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

/* Background color behind the instrument bar */
#ifdef RNGC_HAS_INST_RECTANGLE
const UI_filled_area rngc_instrument_select_background = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
#if (defined(__MMI_MAINLCD_320X240__) || defined(__MMI_MAINLCD_240X400__))
    {56, 70, 82, 100},
#elif (defined(__MMI_MAINLCD_320X480__))
    {52, 52, 52, 100},
#else
    {215, 215, 215, 100}, 
#endif
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    0
};
#endif /* RNGC_HAS_INST_RECTANGLE*/ 

#if defined(RNGC_SUPPORT_INSTR_STYLE1)
const U8 CurrentInstrument[] = 
{
    INSTR_PIANO,
    INSTR_GUITAR,                    
    INSTR_VIOLIN,                    
    INSTR_SPHONE,                    
    INSTR_SDRUMS,
    INSTR_FLUTE,
    INSTR_HARMONICA,
    INSTR_TRUMPET
};
#elif defined(RNGC_SUPPORT_INSTR_STYLE2)
const U8 CurrentInstrument[] = 
{
    INSTR_GUITAR,
    INSTR_VIOLIN,
    INSTR_FLUTE,
    INSTR_TRUMPET
};
#else
const U8 CurrentInstrument[] = 
{
    INSTR_PIANO,
    INSTR_GUITAR,
    INSTR_VIOLIN,
    INSTR_SPHONE,
    INSTR_SDRUMS,
    INSTR_FLUTE,
    INSTR_HARMONICA,
    INSTR_TRUMPET,
    INSTR_MUSICBOX,
    INSTR_XYLOPHONE
};
#endif

rngc_skin_layout_struct g_rngc_skin_layout;
extern rngc_context_struct g_rngc_cntx;  
extern rngc_engine_context_struct *g_rngc_eng_cntx;  

#ifdef __MMI_TOUCH_RING_COMPOSER__
touch_rngc_struct touch_rngc_context;
rngc_selection_area_layout_struct const *selection_area_context;
S32 rngc_pen_event_on_object;
extern S32 touch_ring_comp_mem;
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 

#ifdef __GDI_MEMORY_PROFILE_2__
GDI_HANDLE rngc_osd_layer;
GDI_HANDLE rngc_skin_layer;
GDI_HANDLE rngc_old_alpha_blending_src_layer;
BOOL is_rngc_skin_layer_drawn = FALSE;
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

#ifdef RNGC_HAS_INST_RECTANGLE
gui_horizontal_select_item_struct MMI_rngc_instrument_select_items[ENUM_TOTAL_INSTR];
gui_horizontal_select_struct MMI_rngc_instrument_select_menu;
UI_horizontal_select_theme MMI_rngc_instrument_select_theme =
{
    (UI_filled_area*)&rngc_instrument_select_background,
    (PU8)NULL,
    (PU8)NULL,
    (PU8)NULL,
    (PU8)NULL,
    (UI_filled_area*)NULL,
    (UI_filled_area*)NULL,
    (PU8)NULL,
    &UI_DEFAULT_FONT,
#if (defined(__MMI_MAINLCD_240X400__)) || (defined(__MMI_MAINLCD_320X480__)) || (defined(__MMI_MAINLCD_320X240__))
    {255, 255, 255 ,100}
#else
    {0, 0, 0, 100}
#endif
};
#endif

#if defined(__MMI_TOUCH_RING_COMPOSER__)
static mmi_pen_point_struct SK_points[4];
static mmi_pen_polygon_area_struct SK_area;
#endif 

#if defined(__MMI_MAINLCD_176X220__) && defined(__MMI_TOUCH_RING_COMPOSER__)
static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
{
    {1, 185, 34, 14, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
    {36, 185, 45, 14, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
    {82, 185, 45, 14, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
    {128, 185, 23, 14, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
    {152, 185, 23, 14, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
};

#ifdef __MMI_RING_COMPOSER_REPEAT__
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {131, 151, 18, 23, TOUCH_IMG_REPEAT_START, REPEAT_START},
    {134, 175, 18, 23, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
    {153, 151, 22, 23, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
    {153, 151, 22, 23, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
    {153, 175, 22, 23, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {134, 151, 18, 23, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {153, 151, 22, 23, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {134, 175, 41, 23, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	

#elif defined(__MMI_MAINLCD_240X320__)
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {1, NORMAL_TOOLBAR_IMAGE_Y + 1, 57, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {59, NORMAL_TOOLBAR_IMAGE_Y + 1, 52, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {112, NORMAL_TOOLBAR_IMAGE_Y + 1, 59, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {172, NORMAL_TOOLBAR_IMAGE_Y + 1, 33, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {206, NORMAL_TOOLBAR_IMAGE_Y + 1, 33, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};
	/* Notice: If you want to change the button size, please remember to modify the memory size defined in ScrMemMgr.h */
#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {173, NOTE_SELECTION_IMAGE_Y + 1, 24, 31, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {176, NOTE_SELECTION_IMAGE_Y + 34, 24, 31, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
	    {201, NOTE_SELECTION_IMAGE_Y + 1, 38, 31, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
	    {201, NOTE_SELECTION_IMAGE_Y + 1, 34, 31, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
	    {201, NOTE_SELECTION_IMAGE_Y + 34, 38, 31, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {176, NOTE_SELECTION_IMAGE_Y + 1, 24, 31, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {201, NOTE_SELECTION_IMAGE_Y + 1, 38, 31, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {176, NOTE_SELECTION_IMAGE_Y + 34, 63, 31, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/

#elif defined(__MMI_MAINLCD_320X240__)
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {19, NORMAL_TOOLBAR_IMAGE_Y, 65, NORMAL_TOOLBAR_HEIGHT - 1, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {84, NORMAL_TOOLBAR_IMAGE_Y, 65, NORMAL_TOOLBAR_HEIGHT - 1, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {149, NORMAL_TOOLBAR_IMAGE_Y, 65, NORMAL_TOOLBAR_HEIGHT - 1, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {216, NORMAL_TOOLBAR_IMAGE_Y, 41, NORMAL_TOOLBAR_HEIGHT - 1, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {257, NORMAL_TOOLBAR_IMAGE_Y , 41, NORMAL_TOOLBAR_HEIGHT - 1, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};

#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {236, NOTE_SELECTION_IMAGE_Y + 1, 30, 24, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {236, NOTE_SELECTION_IMAGE_Y + 24, 30, 24, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
	    {264, NOTE_SELECTION_IMAGE_Y + 1, 30, 24, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
	    {267, NOTE_SELECTION_IMAGE_Y + 1, 30, 24, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
	    {267, NOTE_SELECTION_IMAGE_Y + 24, 30, 24, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {236, NOTE_SELECTION_IMAGE_Y + 1, 30, 24, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {267, NOTE_SELECTION_IMAGE_Y + 1, 30, 24, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {236, NOTE_SELECTION_IMAGE_Y + 24, 62, 24, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/

#elif defined(__MMI_MAINLCD_240X400__)
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {2, NORMAL_TOOLBAR_IMAGE_Y + 3, 55, NORMAL_TOOLBAR_HEIGHT - 7, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {58, NORMAL_TOOLBAR_IMAGE_Y + 3, 52, NORMAL_TOOLBAR_HEIGHT - 7, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {112, NORMAL_TOOLBAR_IMAGE_Y + 3, 58, NORMAL_TOOLBAR_HEIGHT - 7, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {172, NORMAL_TOOLBAR_IMAGE_Y + 3, 32, NORMAL_TOOLBAR_HEIGHT - 7, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {206, NORMAL_TOOLBAR_IMAGE_Y + 3, 32, NORMAL_TOOLBAR_HEIGHT - 7, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};
#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {176, NOTE_SELECTION_IMAGE_Y + 3, 24, 30, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {176, NOTE_SELECTION_IMAGE_Y + 37, 24, 30, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
	    {202, NOTE_SELECTION_IMAGE_Y + 3, 36, 31, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
	    {202, NOTE_SELECTION_IMAGE_Y + 3, 36, 31, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
	    {202, NOTE_SELECTION_IMAGE_Y + 36, 36, 31, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {177, NOTE_SELECTION_IMAGE_Y + 3, 24, 30, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {202, NOTE_SELECTION_IMAGE_Y + 3, 36, 31, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {177, NOTE_SELECTION_IMAGE_Y + 36, 61, 31, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/

#elif defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {3, NORMAL_TOOLBAR_IMAGE_Y + 5, 72, NORMAL_TOOLBAR_HEIGHT - 10, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {79, NORMAL_TOOLBAR_IMAGE_Y + 5, 67, NORMAL_TOOLBAR_HEIGHT - 10, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {150, NORMAL_TOOLBAR_IMAGE_Y + 5, 76, NORMAL_TOOLBAR_HEIGHT - 10, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {230, NORMAL_TOOLBAR_IMAGE_Y + 5, 41, NORMAL_TOOLBAR_HEIGHT - 10, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {276, NORMAL_TOOLBAR_IMAGE_Y + 5, 40, NORMAL_TOOLBAR_HEIGHT - 10, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};

#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {230, NOTE_SELECTION_IMAGE_Y + 5, 30, 34, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {236, NOTE_SELECTION_IMAGE_Y + 46, 30, 34, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
	    {264, NOTE_SELECTION_IMAGE_Y + 5, 50, 34, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
	    {267, NOTE_SELECTION_IMAGE_Y + 5, 50, 34, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
	    {267, NOTE_SELECTION_IMAGE_Y + 46, 50, 34, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {234, NOTE_SELECTION_IMAGE_Y + 5, 30, 34, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {267, NOTE_SELECTION_IMAGE_Y + 5, 50, 34, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {234, NOTE_SELECTION_IMAGE_Y + 46, 83, 34, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/

#elif defined(__MMI_MAINLCD_128X160__)
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {0, NORMAL_TOOLBAR_IMAGE_Y + 1, 25, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {27, NORMAL_TOOLBAR_IMAGE_Y + 1, 33, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {60, NORMAL_TOOLBAR_IMAGE_Y + 1, 33, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {93, NORMAL_TOOLBAR_IMAGE_Y + 1, 17, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {110, NORMAL_TOOLBAR_IMAGE_Y + 1, 17, NORMAL_TOOLBAR_HEIGHT - 2, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};

#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {99, NOTE_SELECTION_IMAGE_Y + 1, 14, 16, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {99, NOTE_SELECTION_IMAGE_Y + 19, 14, 16, TOUCH_IMG_REPEAT_END, REPEAT_END},
#ifdef __MMI_RNGC_ENABLE_INS_LED_NOTE__
	    {110, NOTE_SELECTION_IMAGE_Y + 1, 14, 16, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#else 
	    {113, NOTE_SELECTION_IMAGE_Y + 1, 14, 16, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#endif /*__MMI_RNGC_ENABLE_INS_LED_NOTE__*/
	    {113, NOTE_SELECTION_IMAGE_Y + 19, 14, 16, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
#ifdef __MMI_RNGC_ENABLE_INS_LED_NOTE__
    {99, NOTE_SELECTION_IMAGE_Y + 1, 14, 16, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {113, NOTE_SELECTION_IMAGE_Y + 1, 14, 16, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else 
    {127, NOTE_SELECTION_IMAGE_Y + 1, 1, 1, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {99, NOTE_SELECTION_IMAGE_Y + 1, 28, 16, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#endif /*__MMI_RNGC_ENABLE_INS_LED_NOTE__*/
    {99, NOTE_SELECTION_IMAGE_Y + 19, 28, 16, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/

#else 
#ifdef __MMI_TOUCH_RING_COMPOSER__
	static const rngc_custom_key_layout_struct normal_toolbar_custom_layout[] = 
	{
	    {1, 185, 34, 14, IMG_TOUCH_RING_EDIT, GUI_RNGC_KEY_EDIT},
	    {36, 185, 45, 14, IMG_TOUCH_RING_INSERT, GUI_RNGC_KEY_INSERT},
	    {82, 185, 45, 14, IMG_TOUCH_RING_PLAY, GUI_RNGC_KEY_PLAY},
	    {128, 185, 23, 14, IMG_TOUCH_RING_PREV, GUI_RNGC_KEY_PREV},
	    {152, 185, 23, 14, IMG_TOUCH_RING_NEXT, GUI_RNGC_KEY_NEXT}
	};

#ifdef __MMI_RING_COMPOSER_REPEAT__
	static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
	{
	    {134, 152, 18, 23, TOUCH_IMG_REPEAT_START, REPEAT_START},
	    {134, 176, 18, 23, TOUCH_IMG_REPEAT_END, REPEAT_END},
#if !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__)
	    {150, 152, 22, 23, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
#else /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */    
	    {153, 152, 22, 23, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
#endif /* !defined(__MMI_RNGC_ENABLE_INS_LED_NOTE__) */
	    {153, 176, 22, 23, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
	};
#else /* __MMI_RING_COMPOSER_REPEAT__ */
static rngc_custom_key_layout_struct note_selection_custom_layout[] = 
{
    {134, 152, 18, 23, IMG_RING_EVENTLED_ON, NOTE_LED_ON},
    {153, 152, 22, 23, IMG_RING_EVENTBL_ON, NOTE_BACKLIGHT_ON},
    {134, 176, 41, 23, IMG_TOUCH_RING_DOWN, GUI_RNGC_KEY_OK},
};
#endif /* __MMI_RING_COMPOSER_REPEAT__ */	
#endif /*__MMI_TOUCH_RING_COMPOSER__*/
#endif /*defined(__MMI_MAINLCD_176X220__) && defined(__MMI_TOUCH_RING_COMPOSER__)*/

#ifdef __MMI_TOUCH_RING_COMPOSER__
static const rngc_matrix_key_layout_struct normal_toolbar_matrix_layout = 
{
    RNGC_TOOL_BAR_LEFT_OFFSET, RNGC_TOOL_BAR_TOP_OFFSET,
    2, 7,
    RNGC_NOTE_SELECT_MATRIX_WIDTH, RNGC_NOTE_SELECT_MATRIX_HEIGHT,
    RNGC_MATRIX_KEY_WIDTH, RNGC_MATRIX_KEY_HEIGHT,
    {
     {IMG_TOUCH_RING_UP, TOUCH_IMG_1_OCT_L_M_N, TOUCH_IMG_1BY2_OCT_L_M_N, TOUCH_IMG_1BY4_OCT_L_M_N,
      TOUCH_IMG_1BY8_OCT_L_M_N, TOUCH_IMG_1BY16_OCT_L_M_N, IMG_RING_EVENTVIB_ON},
     {IMG_TOUCH_RING_DOWN, TOUCH_IMG_1BY4_OCT_L_M, TOUCH_IMG_1BY8_OCT_L_M, TOUCH_IMG_1BY16_OCT_L_M, IMG_TOUCH_RNGC_HASH,
      IMG_TOUCH_RING_P, IMG_TOUCH_RING_DOT},
     },
    {
     {GUI_RNGC_OCTAVE_UP, GUI_RNGC_KEY_NOTE1, GUI_RNGC_KEY_NOTE2, GUI_RNGC_KEY_NOTE3, GUI_RNGC_KEY_NOTE4,
      GUI_RNGC_KEY_NOTE5, NOTE_VIBRATION_ON},
     {GUI_RNGC_OCTAVE_DOWN, GUI_RNGC_KEY_NOTE6, GUI_RNGC_KEY_NOTE7, GUI_RNGC_KEY_NOTE8, GUI_RNGC_KEY_SHARP,
      GUI_RNGC_KEY_FLAT, GUI_RNGC_KEY_DOT},
     }
};

const static rngc_selection_area_layout_struct normal_toolbar_layout = 
{
    0,
    5,
    NORMAL_TOOLBAR_IMAGE_X,
    NORMAL_TOOLBAR_IMAGE_Y,
    (rngc_matrix_key_layout_struct *) & normal_toolbar_matrix_layout,
    (rngc_custom_key_layout_struct *) normal_toolbar_custom_layout,
    1,
    0,
    IMG_TOUCH_RING_NORMAL
};

const static rngc_matrix_key_layout_struct note_selection_matrix_layout = 
{
    RNGC_TOOL_BAR_LEFT_OFFSET, RNGC_TOOL_BAR_TOP_OFFSET,
    2, 7,
    RNGC_NOTE_SELECT_MATRIX_WIDTH, RNGC_NOTE_SELECT_MATRIX_HEIGHT,
    RNGC_MATRIX_KEY_WIDTH, RNGC_MATRIX_KEY_HEIGHT,
    {
     {IMG_TOUCH_RING_UP, TOUCH_IMG_1_OCT_L_M_N, TOUCH_IMG_1BY2_OCT_L_M_N, TOUCH_IMG_1BY4_OCT_L_M_N,
      TOUCH_IMG_1BY8_OCT_L_M_N, TOUCH_IMG_1BY16_OCT_L_M_N, IMG_RING_EVENTVIB_ON},
     {IMG_TOUCH_RING_DOWN, TOUCH_IMG_1BY4_OCT_L_M, TOUCH_IMG_1BY8_OCT_L_M, TOUCH_IMG_1BY16_OCT_L_M, IMG_TOUCH_RNGC_HASH,
      IMG_TOUCH_RING_P, IMG_TOUCH_RING_DOT},
     },
    {
     {GUI_RNGC_OCTAVE_UP, GUI_RNGC_KEY_NOTE1, GUI_RNGC_KEY_NOTE2, GUI_RNGC_KEY_NOTE3, GUI_RNGC_KEY_NOTE4,
      GUI_RNGC_KEY_NOTE5, NOTE_VIBRATION_ON},
     {GUI_RNGC_OCTAVE_DOWN, GUI_RNGC_KEY_NOTE6, GUI_RNGC_KEY_NOTE7, GUI_RNGC_KEY_NOTE8, GUI_RNGC_KEY_SHARP,
      GUI_RNGC_KEY_FLAT, GUI_RNGC_KEY_DOT},
     }
};

static const rngc_selection_area_layout_struct note_selection_layout = 
{
    14,
#ifdef __MMI_RING_COMPOSER_REPEAT__
    4,
#else /* __MMI_RING_COMPOSER_REPEAT__ */
    3,
#endif /* __MMI_RING_COMPOSER_REPEAT__ */
    NOTE_SELECTION_IMAGE_X,
    NOTE_SELECTION_IMAGE_Y,
    (rngc_matrix_key_layout_struct *) & note_selection_matrix_layout,
    (rngc_custom_key_layout_struct *) note_selection_custom_layout,
    RNGC_NOTE_SELECTION_HORZ_GAP,
    RNGC_NOTE_SELECTION_VERTICAL_GAP,
    IMG_TOUCH_RING_SELECTION
};

const UI_filled_area touch_rngc_color_key_filler = {UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
#if (defined(__MMI_MAINLCD_320X480__))
    {146, 28, 255, 100},
#else
    {128, 255, 255, 100},
#endif
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

#endif /* __MMI_TOUCH_RING_COMPOSER__ */
#define BACK_START_Y1 24

extern MMI_BOOL g_current_insert_mode;
/*****************************************************************************
* FUNCTION
*  mmi_rngc_show_composer
* DESCRIPTION
*  Show ringtone composer screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_show_composer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_layer_multi_layer_enable();
    
    /* get base layer as skin layer */
    gdi_layer_get_base_handle(&rngc_osd_layer);
    gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_create(0, 0, UI_device_width, UI_device_height, &rngc_skin_layer);
    gdi_layer_set_blt_layer(rngc_skin_layer, rngc_osd_layer, 0, 0);
    gdi_get_alpha_blending_source_layer(&rngc_old_alpha_blending_src_layer);
    gdi_set_alpha_blending_source_layer(rngc_skin_layer);
    is_rngc_skin_layer_drawn = FALSE;
#endif 
    
    clear_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    
    /* associate functions */
    RedrawCategoryFunction = mmi_rngc_redraw_main_screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    
    /* draw screen */
    mmi_rngc_redraw_main_screen();
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_LSK
* DESCRIPTION
*  Changes the text of LSK 
* PARAMETERS
*  bPressed  [IN] Checks whether up(0) or down(1)
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_LSK(BOOL bPressed)
{
    mmi_rngc_redraw_SK(bPressed, MMI_LEFT_SOFTKEY, STR_GLOBAL_OPTIONS);
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_RSK
* DESCRIPTION
*  Changes the text of RSK 
* PARAMETERS
*  bPressed  [IN] Checks whether up(0) or down(1)
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_RSK(BOOL bPressed)
{
    if (g_rngc_eng_cntx->TotalNotes == 0)	
    {
        mmi_rngc_redraw_SK(bPressed, MMI_RIGHT_SOFTKEY, STR_GLOBAL_BACK);      
        change_right_softkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    }
    else
    {
        mmi_rngc_redraw_SK(bPressed, MMI_RIGHT_SOFTKEY, STR_GLOBAL_CLEAR);
        change_right_softkey(STR_GLOBAL_CLEAR, IMG_GLOBAL_CLEAR);
    }
}
extern UI_filled_area* dm_get_current_scr_bg_filler(void);
/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_SK
* DESCRIPTION
*  Changes the text of SK 
* PARAMETERS
*  bPressed  [IN] Checks whether up(0) or down(1)
*  softkey   [IN] MMI_RIGHT_SOFTKEY or MMI_LEFT_SOFTKEY
*  softkey_text [IN] 
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_SK(BOOL bPressed, WGUI_SOFTKEY_ENUM key, U16 softkey_text)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_w, str_h;
    S32 x1, y1, x2, y2;
    S32 clip_x1 = 0, clip_x2 = 0;
    MMI_BOOL truncated = MMI_FALSE;
    S32 truncated_width;
    UI_string_type text = 0;
    color c;
    UI_filled_area  *bg_image_filler;
    S32 image_bg_h = 0, image_bg_w = 0; 
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(mmi_frm_scrn_get_active_id()!= SCR_COMPOSER_ENGINE)
	{
		return;
	}
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
    bg_image_filler = dm_get_current_scr_bg_filler();
    gdi_layer_push_clip();
    gui_push_text_clip();
    gui_set_font(gui_font_get_type(GUI_FONT_SIZE_BUTTON));
    if (key == MMI_LEFT_SOFTKEY)
    {
    	wgui_clear_left_softkey();
        if (bPressed)
        {
            gui_set_text_color(*(current_MMI_theme->LSK_down_text_color));  
        }
        else
        {
            gui_set_text_color(*(current_MMI_theme->LSK_up_text_color));  
        }
        clip_x1 = 0;
        clip_x2 = UI_device_width/2;
    }        
    else if (key == MMI_RIGHT_SOFTKEY)
    {
        wgui_clear_right_softkey();
        if (bPressed)
        {
            gui_set_text_color(*(current_MMI_theme->RSK_down_text_color));  
        }
        else
        {
            gui_set_text_color(*(current_MMI_theme->RSK_up_text_color));  
        }
        clip_x1 = UI_device_width/2;
        clip_x2 = UI_device_width - 1;
    }

    gui_set_text_border_color(*(current_MMI_theme->softkey_text_border_color));
    if (softkey_text == 0)
    {
        x1 = 0;
        x2 = UI_device_width/2;
        y1 = UI_device_height - MMI_BUTTON_BAR_HEIGHT;
        y2 = UI_device_height;
    }
    else
    {
        text = get_string(softkey_text);
        truncated = wgui_softkey_get_offset(
                        text,
                        &x1,
                        &y1,
                        &truncated_width,
                        key,
                        mmi_frm_get_screen_rotate());

        gui_measure_string(text, &str_w, &str_h);
        if (truncated == MMI_TRUE)
        {
            str_w = truncated_width; /* only need to display truncated string */
        }
        if(r2lMMIFlag)
        {
            x2 = x1 + 1;
            x1 = x1 - str_w;
        }
        else
        {
            x2 = x1 + str_w + 1;
        }
        y2 = y1 + str_h + 1;

        if (bPressed)
        {
            x1++;
            y1++;
        }
    #ifdef __MMI_TOUCH_RING_COMPOSER__
        SK_area.num = 4;
        SK_area.points = (mmi_pen_point_struct*) SK_points;
        SK_points[0].y = SK_points[1].y = y1;
        SK_points[2].y = SK_points[3].y = y2 + 1;
        if (r2lMMIFlag)
        {
            SK_points[0].x = SK_points[3].x = x2;
            SK_points[1].x = SK_points[2].x = x1 + 1;
        }
        else
        {
            SK_points[0].x = SK_points[3].x = x1;
            SK_points[1].x = SK_points[2].x = x2 + 1;
        }
    #endif /* __MMI_TOUCH_RING_COMPOSER__ */
    }    
#ifdef __GDI_MEMORY_PROFILE_2__
gdi_layer_push_and_set_active(rngc_skin_layer);
#endif
#if defined(__MMI_MAINLCD_128X160__)
    gui_measure_image((PU8) GetImage(g_rngc_skin_layout.main_bg_img_id), (S32*) &image_bg_w, (S32*) &image_bg_h);
    gdi_layer_set_clip(clip_x1, BKG_IMG_Y1 + image_bg_h, clip_x2 , UI_device_height);
#else
    gdi_layer_set_clip(clip_x1, UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1, clip_x2 , UI_device_height);
#endif
#ifdef __GDI_MEMORY_PROFILE_2__
    #if defined(__MMI_MAINLCD_128X160__)
	gdi_draw_solid_rect(clip_x1, BKG_IMG_Y1 + image_bg_h, clip_x2 , UI_device_height, GDI_COLOR_TRANSPARENT);
    #else
        gdi_draw_solid_rect(clip_x1, UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1 , clip_x2 , UI_device_height, GDI_COLOR_TRANSPARENT);
    #endif
    #if (defined(__MMI_MAINLCD_128X160__)) 
	gui_draw_filled_area(clip_x1, BKG_IMG_Y1 + image_bg_h, clip_x2, UI_device_height, bg_image_filler);
    #endif
	gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#else 
    gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#endif
#ifdef __GDI_MEMORY_PROFILE_2__
	     gdi_layer_pop_and_restore_active();
#endif
    if (softkey_text != 0)
    {
        gui_set_text_clip(x1-1, y1 - 1, x2, y2);
        if (r2lMMIFlag)
        {
            gui_move_text_cursor(x1 + str_w, y1);
        }
        else
        {
            gui_move_text_cursor(x1, y1);
        }
        #ifdef __GDI_MEMORY_PROFILE_2__
	        gdi_draw_solid_rect(x1 -4, y1 -1, x2 , y2, GDI_COLOR_TRANSPARENT);
        #else   
            gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
        #endif

        if (truncated)
        {
            gui_print_truncated_borderd_text(x1, y1, truncated_width, text);
        }
        else
        {
            gui_print_bordered_text(text);
        }
    }
	else
	{
		        gui_set_text_clip(x1-1, y1 - 1, x2, y2);
        #ifdef __GDI_MEMORY_PROFILE_2__
	        gdi_draw_solid_rect(x1 -4, y1 -1, x2 , y2, GDI_COLOR_TRANSPARENT);
        #else   
            gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
        #endif

	}
    gui_pop_text_clip();
    gdi_layer_pop_clip();
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(clip_x1, UI_device_height - MMI_BUTTON_BAR_HEIGHT, clip_x2, UI_device_height);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_main_screen
* DESCRIPTION
*  Redraws the main screen of the composer 
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_main_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    gui_push_clip();
    
#ifdef __GDI_MEMORY_PROFILE_2__
    if (!is_rngc_skin_layer_drawn)
    {
        S32 y2;
        
        /* background image on skin layer */
    #ifdef __MMI_TOUCH_RING_COMPOSER__
        if (touch_rngc_context.area_type == GUI_RNGC_NORMAL_TOOLBAR)
        {
            y2 = g_rngc_skin_layout.main_bg_img_area_y2 - NORMAL_TOOLBAR_HEIGHT;
        }
        else if (touch_rngc_context.area_type == GUI_RNGC_NOTE_SELECTION)
        {
            y2 = g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT;
        }
    #else /* __MMI_TOUCH_RING_COMPOSER__ */ 
        y2 = g_rngc_skin_layout.main_bg_img_area_y2;
    #endif /* __MMI_TOUCH_RING_COMPOSER__ */ 
        
        gdi_layer_push_and_set_active(rngc_skin_layer);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    
        gui_set_clip(0, g_rngc_skin_layout.main_bg_img_area_y1, UI_device_width - 1, UI_device_height - 1);
        gui_show_image(0, g_rngc_skin_layout.main_bg_img_area_y1, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#ifdef __GDI_MEMORY_PROFILE_2__
        is_rngc_skin_layer_drawn = TRUE;
        gdi_layer_pop_and_restore_active();
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

    gui_pop_clip();
    
    mmi_rngc_draw_status_icons();
    mmi_rngc_redraw_stave();
    mmi_rngc_redraw_remaining_notes();
    /* Also invokes redraw_instrument so no need to explicitly call */    	
    mmi_rngc_redraw_title();
    mmi_rngc_redraw_touch_screen();
    
#ifdef __MMI_TOUCH_RING_COMPOSER__
    if (touch_rngc_context.area_type != GUI_RNGC_NOTE_SELECTION)
    {
        mmi_rngc_redraw_LSK(0);
    }
#else /* __MMI_TOUCH_RING_COMPOSER__ */ 
    mmi_rngc_redraw_LSK(0);
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 
    mmi_rngc_redraw_RSK(0);

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}

/*****************************************************************************
* FUNCTION
*  mmi_rngc_draw_status_icons
* DESCRIPTION
*  redraw rngc status icons
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_draw_status_icons(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*if show title status area*/
#ifndef RNGC_STATUS_BAR_TRANSPANT_BG
#ifdef GUI_COMMON_SHOW_STATUS_ICON
    show_title_status_icon();
    wgui_status_icon_bar_update();
#endif  /*GUI_COMMON_SHOW_STATUS_ICON*/
#else /* RNGC_STATUS_BAR_TRANSPANT_BG */
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        mmi_rngc_redraw_statusbar_bg_callback);
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_status_icon_bar_update();
#endif /*RNGC_STATUS_BAR_TRANSPANT_BG*/
}    

/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_stave
* DESCRIPTION
*  Draws the current stave list
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_stave(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, index = 0;
    S32 img_width, img_height;
    color c;
            
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
    gui_push_clip();
    gui_set_clip(RNGC_X_POS_BASED, g_rngc_skin_layout.stave_rectangle_y1, UI_device_width, 
                g_rngc_skin_layout.stave_rectangle_y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(RNGC_X_POS_BASED, g_rngc_skin_layout.stave_rectangle_y1, UI_device_width, 
                g_rngc_skin_layout.stave_rectangle_y2, GDI_COLOR_TRANSPARENT);
#else 
    gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#endif
    width = g_rngc_eng_cntx->CursorWidth;
    for (index = 0; index < NUM_NOTES_IN_STAVE; index++)
    {
        if ((g_rngc_eng_cntx->ImageList[index] != NULL))
        {
            gui_measure_image(g_rngc_eng_cntx->ImageList[index], (S32*) & img_width, (S32*) & img_height);
            gui_show_transparent_image(
                (RNGC_X_POS_BASED + index * RNGC_X_POS_OFFSET + ((width - img_width) >> 1)),
                g_rngc_eng_cntx->YPos[index],
                g_rngc_eng_cntx->ImageList[index],
                gui_transparent_color(255, 255, 255));
        }
    }
    
    /*Begin: draw rectangle around the stave */
    c = gui_color(0, 0, 240);
    width = g_rngc_eng_cntx->CursorWidth;
    
#ifdef __MMI_TOUCH_RING_COMPOSER__
    if (touch_rngc_context.mode == GUI_RNGC_EDIT || touch_rngc_context.mode == GUI_RNGC_INSERT_EDIT)
    {
        c = gui_color(255, 0, 0);
    }
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 
    gui_draw_rectangle(
        (RNGC_X_POS_BASED + g_rngc_eng_cntx->CurrUIPos * RNGC_X_POS_OFFSET),
        g_rngc_skin_layout.stave_rectangle_y1,
        (RNGC_X_POS_BASED + g_rngc_eng_cntx->CurrUIPos * RNGC_X_POS_OFFSET + width + 1),
        g_rngc_skin_layout.stave_rectangle_y2,
        c);
    /*End: draw rectangle around stave*/
    gui_pop_clip();
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(RNGC_X_POS_BASED, g_rngc_skin_layout.stave_rectangle_y1, 
                        UI_device_width, g_rngc_skin_layout.stave_rectangle_y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}    


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_remaining_notes
* DESCRIPTION
*  redraw remaining number of notes
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_remaining_notes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y1, y2, x1;
    S32 temp_height = 0, temp_width = 0;
    UI_character_type string_conv[6], max_string[6];
    color c;
#if (!defined(__MMI_MAINLCD_240X400__)) && (!defined(__MMI_MAINLCD_320X480__))
    color text_color = gui_color(0, 0, 0);
    color text_border_color = gui_color(255, 255, 255);
#else
    color text_color = gui_color(255, 255, 255);
    color text_border_color = gui_color(0, 0, 0);
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
    gui_push_clip();
    /*Begin: draw remaining notes number rectangle*/
    y1 = g_rngc_skin_layout.remain_notes_rect_y1;
    y2 = g_rngc_skin_layout.remain_notes_rect_y1 + g_rngc_skin_layout.remain_notes_rect_height;

    /* remaining number of notes */
    c = gui_color(0, 0, 0);
    gui_set_font(&MMI_small_font);
    gui_set_text_color(text_color); 
    gui_set_text_border_color(text_border_color);
    gui_itoa((S32) (MAX_NOTES - g_rngc_eng_cntx->TotalNotes), string_conv, 10);
    /* Character 4 requires MAX width */
    gui_itoa((S32) (MAX_NOTES - 6), max_string, 10);
    gui_measure_string((UI_string_type) max_string, &temp_width, &temp_height);
    
    if(g_rngc_skin_layout.is_draw_notes_rect_bg_color)
    {
        x1 = 0;
    }
    else
    {
        x1 = UI_device_width - temp_width - RNGC_NUM_RIGHT_ALIGN_OFFSET;
    }
    gui_set_clip(x1, y1-1, UI_device_width, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1-1, UI_device_width, y2, GDI_COLOR_TRANSPARENT);
#else 
    gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#endif

    /*in some LCD size, need draw background rectangle color*/
    /*in some other LCD size, draw text on main background image directly*/
    /*draw background rectangle color*/
    if(g_rngc_skin_layout.is_draw_notes_rect_bg_color)
    {
        gui_draw_filled_area(x1, y1-1, UI_device_width, y2, (UI_filled_area*)&lightblue_color_dialog_background);     
    }
    
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(UI_device_width - RNGC_NUM_RIGHT_ALIGN_OFFSET, y1 + NOTE_BAR_HEIGHT - temp_height);
    }
    else
    {
        gui_move_text_cursor(UI_device_width - temp_width - RNGC_NUM_RIGHT_ALIGN_OFFSET, y1 + NOTE_BAR_HEIGHT - temp_height);
    }

    gui_print_bordered_text((UI_string_type) string_conv);
    gui_set_font(&MMI_default_font);
    /*End : drawing remaining notes number rectangle*/
    gui_pop_clip();
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1-1, UI_device_width, y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */   
}    


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_instrument
* DESCRIPTION
*  redraw the instrument
*  void
* RETURNS
*  The width of the instrument image
*****************************************************************************/
S32 mmi_rngc_redraw_instrument(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_width, img_height;
    S32 x1, y1, x2, y2;
    PU8 MMI_title_icon_ring_comp = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
     if(mmi_frm_scrn_get_active_id()!= SCR_COMPOSER_ENGINE)
     {
	return;
     }
    
    /* In some LCD size, has a rectangle for instrument select and implemented 
    /* by GUI interfaces in some other LCD size, do not has instrument select 
    /* rectangle but show instrument image on title area right side           */
    MMI_title_icon_ring_comp = (PU8) get_image(GetInstrumentImage(g_rngc_cntx.CurrInstr));
    gui_measure_image(MMI_title_icon_ring_comp, (S32*) & img_width, (S32*) & img_height);
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
    gui_push_clip();
    /*if show instrument horizontal select rectangle */
#ifdef RNGC_HAS_INST_RECTANGLE
    x1 = 0;
    y1 = g_rngc_skin_layout.instr_sel_rect_y1;
    x2 = UI_device_width;
    y2 = g_rngc_skin_layout.instr_sel_rect_y2;

    gui_set_clip(x1, y1, x2, y2);    
    gui_draw_filled_area(x1, y1, x2, y2, 
        (UI_filled_area*)&rngc_instrument_select_background);
    gui_show_image(
        g_rngc_skin_layout.instr_img_x1, y1 + ((y2 - y1 - img_height) >> 1),
        MMI_title_icon_ring_comp);    
    gui_horizontal_select_show(&MMI_rngc_instrument_select_menu);
#else /*RNGC_HAS_INST_RECTANGLE*/
    x1 = UI_device_width - 1 - img_width;
    y1 = g_rngc_skin_layout.title_rect_y1 + 
        ((g_rngc_skin_layout.title_rect_height - img_height) >> 1);
    x2 = UI_device_width;
    y2 = (g_rngc_skin_layout.title_rect_y1 + g_rngc_skin_layout.title_rect_height) - 1;

    gui_set_clip(x1, y1, x2, y2);
    gui_show_image(x1, y1, MMI_title_icon_ring_comp);
    img_width = 0;    
#endif /*RNGC_HAS_INST_RECTANGLE*/    
    
    gui_pop_clip();    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */
    return img_width;
}    


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_main_title_background
* DESCRIPTION
*  redraw rngc main title background
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_main_title_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c = gui_color(255, 255, 255);
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif   
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
#if !(defined(__MMI_MAINLCD_320X240__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X480__))
    gui_fill_rectangle(x1, y1, x2, y2, c);
    gui_draw_filled_area(x1, y1, x2, y2,
#ifdef GUI_COMMON_USE_THICK_TITLE
        current_UI_theme->thick_title_theme->active_filler);
#else /* GUI_COMMON_USE_THICK_TITLE */
        current_UI_theme->window_title_theme->active_filler);
#endif /* GUI_COMMON_USE_THICK_TITLE */
#endif /* !defined(__MMI_MAINLCD_320X240__) ||... */

    gui_pop_clip();    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_title
* DESCRIPTION
*  redraw rngc main title 'Stave'
*  Invokes redraw_instrument 
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_title(void)
{        

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    S32 width = 0, width_title, height_title;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    y1 = g_rngc_skin_layout.title_rect_y1;
    x2 = UI_device_width - 1;
    y2 = y1 + g_rngc_skin_layout.title_rect_height - 1;
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
      
    mmi_rngc_redraw_main_title_background(x1, y1, x2, y2);
#ifndef RNGC_HAS_INST_RECTANGLE   
    width = mmi_rngc_redraw_instrument();
#else
    mmi_rngc_redraw_instrument();
#endif /*RNGC_HAS_INST_RECTANGLE*/

    gui_push_clip();
    gui_set_text_color(*(current_MMI_theme->title_text_color));  
    gui_set_text_border_color(*(current_MMI_theme->title_text_border_color));
    gui_measure_string((UI_string_type) get_string(STR_RING_COMPOSE_TITLE), &width_title, &height_title);

    if (r2lMMIFlag)
    {
        gui_move_text_cursor((((UI_device_width - 1 - width) >> 1) - (width_title >> 1)) + width_title,
            g_rngc_skin_layout.title_rect_y1 + ((g_rngc_skin_layout.title_rect_height - height_title) >> 1));
    }
    else
    {
        gui_move_text_cursor((((UI_device_width - 1 - width) >> 1) - (width_title >> 1)),
            g_rngc_skin_layout.title_rect_y1 + ((g_rngc_skin_layout.title_rect_height - height_title) >> 1));
    }
    gui_set_clip(x1, y1, x2, y2);    
    gui_print_bordered_text((UI_string_type) get_string(STR_RING_COMPOSE_TITLE));
    gui_pop_clip();
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_redraw_touch_screen
* DESCRIPTION
*  redraw rngc touch screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_redraw_touch_screen(void)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_RING_COMPOSER__
    if ((touch_rngc_context.flag & RNGC_SELECTION_AREA_REDRAW) == RNGC_SELECTION_AREA_REDRAW)
    {
        show_touch_rngc_selection_area();
    }
#endif /* __MMI_TOUCH_RING_COMPOSER__ */     
}


/*****************************************************************************
* FUNCTION
*  mmi_rngc_exit_mainscreen
* DESCRIPTION
*  exit ring composer main screen
*  Frees the memory allocated
*  Flatten to base the various layers
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_rngc_exit_mainscreen(void)
{
#ifdef __GDI_MEMORY_PROFILE_2__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 #ifdef __MMI_TOUCH_RING_COMPOSER__
    if (selection_area_context == &note_selection_layout)
    {
        selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image = IMG_TOUCH_RING_DOWN;
    }
    selection_area_context = &normal_toolbar_layout;
    touch_rngc_context.area_type = GUI_RNGC_NORMAL_TOOLBAR;

    if (touch_rngc_context.selected_key_bitmap.buf_ptr)
    {
        mmi_frm_scrmem_free((void*)touch_rngc_context.selected_key_bitmap.buf_ptr);
        touch_rngc_context.selected_key_bitmap.buf_ptr = NULL;
    }
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 
 
    gdi_set_alpha_blending_source_layer(rngc_old_alpha_blending_src_layer);
    gdi_layer_flatten_to_base(rngc_skin_layer, rngc_osd_layer, 0, 0);
    gdi_layer_free(rngc_skin_layer);
    gdi_layer_multi_layer_disable();
    
    /* restore blt layer as base layer only */
    gdi_layer_set_blt_layer(rngc_osd_layer, 0, 0, 0);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

#ifdef RNGC_HAS_INST_RECTANGLE
    gui_horizontal_select_close(&MMI_rngc_instrument_select_menu);      
#endif /*RNGC_HAS_INST_RECTANGLE*/

}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_initialize_skinlayout
 * DESCRIPTION
 *  Initializes the variables of g_rngc_skin_layout
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_initialize_skinlayout(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 title_bar_y1, title_bar_height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
#ifdef GUI_COMMON_USE_THICK_TITLE
    title_bar_y1 = 0;
    title_bar_height = MMI_THICK_TITLE_HEIGHT;
#else /*GUI_COMMON_USE_THICK_TITLE*/
    title_bar_y1 = MMI_title_y;
    title_bar_height = MMI_title_height;
#endif /*GUI_COMMON_USE_THICK_TITLE*/
/* 240X320 begin */
#if  defined(__MMI_MAINLCD_240X320__)
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = 0;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT;

    /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = title_bar_y1 + title_bar_height + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT + RNGC_INSTR_SELECT_MARGIN * 2 + NOTE_BAR_HEIGHT + 5;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 4;

    g_rngc_skin_layout.stave_rectangle_y2 -= NOTE_SELECTION_HEIGHT;

    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_FALSE;
    g_rngc_skin_layout.remain_notes_rect_y1 = title_bar_y1 + title_bar_height + RNGC_INSTR_SELECT_MARGIN * 2 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;

    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = title_bar_y1 + title_bar_height + 2;
    g_rngc_skin_layout.instr_sel_rect_y2 = g_rngc_skin_layout.instr_sel_rect_y1 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT;
    g_rngc_skin_layout.instr_img_x1 = RNGC_INSTR_SELECT_X_OFFSET*2;

    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 240 X 320 end */    
#elif defined(__MMI_MAINLCD_320X240__)
/* 320 X240 begin */
    title_bar_height = 31;
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = 0;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1;
    
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_FALSE;
    g_rngc_skin_layout.remain_notes_rect_y1 =  title_bar_height + RNGC_INSTR_SELECT_MARGIN * 2 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT + 5;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;

    /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = g_rngc_skin_layout.remain_notes_rect_y1 + NOTE_BAR_HEIGHT - 3;
    
#if defined ( __MMI_TOUCH_RING_COMPOSER__)
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - NOTE_SELECTION_HEIGHT - 4;
#else /*because the new background image has the edge rect, should not overlape the line*/
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 16;
#endif

    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = title_bar_height + RNGC_INSTR_SELECT_MARGIN;
    g_rngc_skin_layout.instr_sel_rect_y2 = g_rngc_skin_layout.instr_sel_rect_y1 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT;
    g_rngc_skin_layout.instr_img_x1 = RNGC_INSTR_SELECT_X_OFFSET*2;

    g_rngc_skin_layout.title_rect_y1 = 0;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 320 X 240 end */
#elif defined(__MMI_MAINLCD_240X400__)
/* 240 X 400 begin */
    title_bar_height = 45;
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = 0;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
 
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_FALSE;
    g_rngc_skin_layout.remain_notes_rect_y1 =  title_bar_y1 + title_bar_height + RNGC_INSTR_SELECT_MARGIN * 2 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT + 5;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;

     /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = title_bar_y1 + g_rngc_skin_layout.remain_notes_rect_y1 + NOTE_BAR_HEIGHT - 1;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 30;

#ifdef __MMI_TOUCH_RING_COMPOSER__
    g_rngc_skin_layout.stave_rectangle_y2 -= NOTE_SELECTION_HEIGHT;
#endif 

    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = title_bar_y1 + title_bar_height + RNGC_INSTR_SELECT_MARGIN;
    g_rngc_skin_layout.instr_sel_rect_y2 = g_rngc_skin_layout.instr_sel_rect_y1 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT;
    g_rngc_skin_layout.instr_img_x1 = RNGC_INSTR_SELECT_X_OFFSET*2;

    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
    
/* 240 X 400 end */    

#elif defined(__MMI_MAINLCD_320X480__)
/* 320 X 480 begin */
    title_bar_height = 45;
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_TOUCH_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = 0;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
 
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_FALSE;
    g_rngc_skin_layout.remain_notes_rect_y1 =  title_bar_y1 + title_bar_height + RNGC_INSTR_SELECT_MARGIN * 2 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT + 5;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;

     /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = title_bar_y1 + g_rngc_skin_layout.remain_notes_rect_y1 + NOTE_BAR_HEIGHT - 1;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 25;

#ifdef __MMI_TOUCH_RING_COMPOSER__
    g_rngc_skin_layout.stave_rectangle_y2 -= NOTE_SELECTION_HEIGHT;
#endif 

    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = title_bar_y1 + title_bar_height + RNGC_INSTR_SELECT_MARGIN;
    g_rngc_skin_layout.instr_sel_rect_y2 = g_rngc_skin_layout.instr_sel_rect_y1 + MMI_RNGC_INSTRUMENT_SELECT_HEIGHT;
    g_rngc_skin_layout.instr_img_x1 = RNGC_INSTR_SELECT_X_OFFSET*2;

    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 320 X 480 end */  

#elif defined(__MMI_MAINLCD_128X160__)
/* 128X160 begin */
    g_rngc_skin_layout.main_bg_img_id = IMG_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = BKG_IMG_Y1;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
    
    /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = (title_bar_y1 + title_bar_height) + NOTE_BAR_HEIGHT + 2;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 4;

    g_rngc_skin_layout.stave_rectangle_y2 -= NOTE_SELECTION_HEIGHT;
    
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_TRUE;
    g_rngc_skin_layout.remain_notes_rect_y1 = title_bar_y1 + title_bar_height + 1;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;
    
    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = 0;
    g_rngc_skin_layout.instr_sel_rect_y2 = 0;
    g_rngc_skin_layout.instr_img_x1 = 0;
    
    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 128x160 end */
#elif defined(__MMI_MAINLCD_176X220__)
/* 176x220 begin */
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_TOUCH_RING_COMPOSER_BACKGROUND;
    g_rngc_skin_layout.main_bg_img_area_y1 = 0;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT;

    /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = (title_bar_y1 + title_bar_height) + NOTE_BAR_HEIGHT + 2;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
 
   g_rngc_skin_layout.stave_rectangle_y2 -= NOTE_SELECTION_HEIGHT;
    
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_TRUE;
    g_rngc_skin_layout.remain_notes_rect_y1 = title_bar_y1 + title_bar_height + 1;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;
    
    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = 0;
    g_rngc_skin_layout.instr_sel_rect_y2 = 0;
    g_rngc_skin_layout.instr_img_x1 = 0;

    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 176x220 end */
#else
/* 128x128 begin */
    /*main background image*/
    g_rngc_skin_layout.main_bg_img_id = IMG_RING_COMPOSER_BACKGROUND;

    g_rngc_skin_layout.main_bg_img_area_y1 = BACK_START_Y1;
    g_rngc_skin_layout.main_bg_img_area_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT;

    /*the rectangle around stave coordinate*/
    g_rngc_skin_layout.stave_rectangle_y1 = (title_bar_y1 + title_bar_height) + NOTE_BAR_HEIGHT + 2;
    g_rngc_skin_layout.stave_rectangle_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
    
    /*if draw background rectangle for indicating remaining notes number*/
    g_rngc_skin_layout.is_draw_notes_rect_bg_color = MMI_TRUE;
    g_rngc_skin_layout.remain_notes_rect_y1 = title_bar_y1 + title_bar_height;
    g_rngc_skin_layout.remain_notes_rect_height = NOTE_BAR_HEIGHT;
    
    /*if draw instrument select rectangle */
    g_rngc_skin_layout.instr_sel_rect_y1 = 0;
    g_rngc_skin_layout.instr_sel_rect_y2 = 0;
    g_rngc_skin_layout.instr_img_x1 = 0;

    g_rngc_skin_layout.title_rect_y1 = title_bar_y1;
    g_rngc_skin_layout.title_rect_height = title_bar_height;
/* 128x128 end */
#endif /*defined(__MMI_MAINLCD_240X320__) */

}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_initialize_composer
 * DESCRIPTION
 *  This function is to clear stave, speed, instrument and get cursor width
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_initialize_composer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RngcInitCursor();
    RngcClearStave();
    g_rngc_cntx.CurrSpeed = NORMAL_SPEED;
    g_rngc_cntx.CurrInstr = RNGC_DEFAULT_FIRST_INSTR;
//#ifdef __MMI_RING_COMPOSER_STYLE__
    g_rngc_cntx.CurrStyle = NORMAL_STYLE;
//#endif    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_redraw_notes
 * DESCRIPTION
 *  RedrawNotes (old name)
 *  This function is to redraw the stave
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_rngc_redraw_notes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 nFirstNoteIndex;
    S16 nEndNote;
    U16 nTemp;
    U16 nImageId = 0;
    U16 nCount = 0;
    U16 nYVal = 0;
    DisplayInfo sDisplayInfo[NUM_NOTES_IN_STAVE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get the first note to be drawed */
    nFirstNoteIndex = g_rngc_eng_cntx->CurrNoteIndex - g_rngc_eng_cntx->CurrUIPos;
    if (nFirstNoteIndex < 0)
    {
        nFirstNoteIndex = 0;
    }

    /* get the last note to be drawed */
    if (nFirstNoteIndex + NUM_NOTES_IN_STAVE >= g_rngc_eng_cntx->TotalNotes)    /* tail */
    {
        nEndNote = g_rngc_eng_cntx->TotalNotes - 1;
    }
    else
    {
        nEndNote = (nFirstNoteIndex + NUM_NOTES_IN_STAVE) - 1;
    }

    for (nTemp = nFirstNoteIndex; nTemp <= nEndNote; ++nTemp)
    {
        if (!GetIndexInList(g_rngc_eng_cntx->NotesList[nTemp], &nImageId, &nYVal))
        {
            return MMI_FALSE;
        }
        sDisplayInfo[nCount].nImageId = nImageId;
        sDisplayInfo[nCount].nXPos = (U8) nTemp;
        sDisplayInfo[nCount].nYPos = nYVal;
        ++nCount;
    }

    mmi_rngc_refresh_notes_list(nCount, (DisplayInfo*) sDisplayInfo);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_refresh_notes_list
 * DESCRIPTION
 *  RefreshNotesList (old name)
 *  Update position and image of note list to be displayed
 * PARAMETERS
 *  TotalNotes          [IN]        Total number of notes to be displyed
 *  psDisplayInfo       [IN]        List of display information
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_refresh_notes_list(U16 TotalNotes, DisplayInfo *psDisplayInfo)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    DisplayInfo *ptmpDisplayInfo = NULL;
    S32 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!psDisplayInfo)
    {
        return;
    }

    for (index = 0; index < NUM_NOTES_IN_STAVE; index++)
    {
        g_rngc_eng_cntx->ImageList[index] = NULL;
    }

    ptmpDisplayInfo = psDisplayInfo;

    for (index = 0; index < TotalNotes; index++)
    {
        g_rngc_eng_cntx->YPos[index] = ptmpDisplayInfo->nYPos;
        g_rngc_eng_cntx->ImageList[index] = (PU8) GetImage(ptmpDisplayInfo->nImageId);
        ptmpDisplayInfo++;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_show_note
 * DESCRIPTION
 *  ShowNote (old name) 
 *  Display current modified note
 * PARAMETERS
 *  nNote       [IN]        Musical note
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_show_note(U16 nNote)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nImageId = 0;
    U16 nYPos = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetIndexInList(nNote, &nImageId, &nYPos);

    g_rngc_eng_cntx->YPos[g_rngc_eng_cntx->CurrUIPos] = nYPos;
    /* flag_shown[g_rngc_eng_cntx->CurrUIPos] = SHOW_IMG; */
    g_rngc_eng_cntx->ImageList[g_rngc_eng_cntx->CurrUIPos] = (PU8) GetImage(nImageId);
    mmi_rngc_redraw_stave();
#if defined(__MMI_MAINLCD_320X240__)
    mmi_rngc_redraw_remaining_notes();
#endif
}


#ifdef RNGC_HAS_INST_RECTANGLE
/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_instrument_menu_clear_background_callback
 * DESCRIPTION
 *  used by horizontal select to clear the background.
 * PARAMETERS
 *  x1  [IN]    the leftmost x coordinate
 *  y1  [IN]    the topmost y coordinate
 *  x2  [IN]    the rightmost x coordinate
 *  y2  [IN]    the bottom y coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_instrument_menu_clear_background_callback(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gui_draw_filled_area(
        x1,
        y1,
        x2,
        y2,
        (UI_filled_area*)&rngc_instrument_select_background);
    gui_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_initialize_instrument_select_menu_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x                       [IN]        
 *  y                       [IN]        
 *  width                   [IN]        
 *  height                  [IN]        
 *  list_of_items           [IN]        
 *  highlighted_item        [?]         
 *  f                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_initialize_instrument_select_menu_items(
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        U8 **list_of_items,
        S32 *highlighted_item,
        void (*f) (S32 item_index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < ENUM_TOTAL_INSTR; i++)
    {
        MMI_rngc_instrument_select_items[i].text = (UI_string_type) list_of_items[i];
    }
#if (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_320X240__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X480__))

#ifdef __MMI_TOUCH_RING_COMPOSER__
    MMI_rngc_instrument_select_theme.left_arrow_image =(PU8)GetImage(IMG_RING_INSTRU_LEFT_ARROW_UP);
    MMI_rngc_instrument_select_theme.left_arrow_clicked_image = (PU8)GetImage(IMG_RING_INSTRU_LEFT_ARROW_UP);
    MMI_rngc_instrument_select_theme.right_arrow_image = (PU8)GetImage(IMG_RING_INSTRU_RIGHT_ARROW_UP);
    MMI_rngc_instrument_select_theme.right_arrow_clicked_image = (PU8)GetImage(IMG_RING_INSTRU_RIGHT_ARROW_UP);
#else

    MMI_rngc_instrument_select_theme.left_arrow_image = NULL;
    MMI_rngc_instrument_select_theme.left_arrow_clicked_image = NULL;
    MMI_rngc_instrument_select_theme.right_arrow_image = NULL;
    MMI_rngc_instrument_select_theme.right_arrow_clicked_image = NULL;
#endif/*__MMI_TOUCH_RING_COMPOSER__*/

#endif

    gui_horizontal_select_create(
        &MMI_rngc_instrument_select_menu, 
        x, 
        y, 
        width,
        height,
        UI_HORIZONTAL_SELECT_FOCUSED_STATE | UI_HORIZONTAL_SELECT_LOOP,
        *highlighted_item,
        f,
        MMI_rngc_instrument_select_items,
        ENUM_TOTAL_INSTR);
    gui_horizontal_select_set_theme(&MMI_rngc_instrument_select_menu, &MMI_rngc_instrument_select_theme);
    
    gui_horizontal_select_register_hide_callback(
        &MMI_rngc_instrument_select_menu, 
        mmi_rngc_instrument_menu_clear_background_callback);
}
#endif /*RNGC_HAS_INST_RECTANGLE */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_change_instrument
 * DESCRIPTION
 *   Changes the instrument name 
 * PARAMETERS
 *  selected_instrument     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_change_instrument(S32 selected_instrument)    /* PMT MANISH   20050616 */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 current_instrument = GetCurrIndexCompRingToneInst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT((RNGC_PREVIOUS_INSTR == selected_instrument) || (RNGC_NEXT_INSTR == selected_instrument));

    if (RNGC_PREVIOUS_INSTR == selected_instrument)
    {
        if (RNGC_DEFAULT_FIRST_INSTR == CurrentInstrument[current_instrument])
        {
            current_instrument = ENUM_TOTAL_INSTR - 1;
        }
        else
        {
            current_instrument--;
        }
    }
    else if (RNGC_NEXT_INSTR == selected_instrument)
    {
        if ((ENUM_TOTAL_INSTR - 1) == current_instrument)
        {
            current_instrument = 0;
        }
        else
        {
            current_instrument++;
        }
    }
    g_rngc_cntx.CurrInstr = CurrentInstrument[current_instrument];
    mmi_rngc_redraw_instrument();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_select_previous_instrument
 * DESCRIPTION
 *  Selects the previous instrument on pressing the volume up button 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_previous_instrument(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
   /* gui_horizontal_select_goto_previous_item(&MMI_rngc_instrument_select_menu);*/
    mmi_rngc_change_instrument(RNGC_PREVIOUS_INSTR);
    gui_horizontal_select_show(&MMI_rngc_instrument_select_menu);
    gui_BLT_double_buffer(
        MMI_rngc_instrument_select_menu.x,
        MMI_rngc_instrument_select_menu.y,
        MMI_rngc_instrument_select_menu.x + MMI_rngc_instrument_select_menu.width - 1,
        MMI_rngc_instrument_select_menu.y + MMI_rngc_instrument_select_menu.height - 1);
#else/*RNGC_HAS_INST_RECTANGLE*/
    mmi_rngc_change_instrument(RNGC_PREVIOUS_INSTR);
#endif/*RNGC_HAS_INST_RECTANGLE*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_select_previous_instrument_down
 * DESCRIPTION
 *  Selects the previous instrument on pressing the volume up button 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_previous_instrument_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
    gui_horizontal_select_struct *m = &MMI_rngc_instrument_select_menu;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_horizontal_select_left_key_down_handler(m);
#endif/*RNGC_HAS_INST_RECTANGLE*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_select_next_instrument_down
 * DESCRIPTION
 *  Selects the previous instrument on pressing the volume up button 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_next_instrument_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
    gui_horizontal_select_struct *m = &MMI_rngc_instrument_select_menu;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_horizontal_select_right_key_down_handler(m);
#endif/*RNGC_HAS_INST_RECTANGLE*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_select_previous_instrument_up
 * DESCRIPTION
 *  Selects the previous instrument on pressing the volume up button 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_previous_instrument_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
    gui_horizontal_select_struct *m = &MMI_rngc_instrument_select_menu;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   if(mmi_frm_scrn_get_active_id()!= SCR_COMPOSER_ENGINE)
   {
	return;
   }
    gui_horizontal_select_left_key_up_handler(m);
#endif/*RNGC_HAS_INST_RECTANGLE*/
    mmi_rngc_select_previous_instrument();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_select_next_instrument_up
 * DESCRIPTION
 *  Selects the previous instrument on pressing the volume up button 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_next_instrument_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
    gui_horizontal_select_struct *m = &MMI_rngc_instrument_select_menu;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     if(mmi_frm_scrn_get_active_id()!= SCR_COMPOSER_ENGINE)
     {
	return;
     }
    gui_horizontal_select_right_key_up_handler(m);
#endif/*RNGC_HAS_INST_RECTANGLE*/
    mmi_rngc_select_next_instrument();
}


/*****************************************************************************
 * FUNCTION
 *  rngc_select_next_instrument
 * DESCRIPTION
 *  Selects the next instrument on pressing the volume down button  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_select_next_instrument(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef RNGC_HAS_INST_RECTANGLE
  /* gui_horizontal_select_goto_next_item(&MMI_rngc_instrument_select_menu);*/
    mmi_rngc_change_instrument(RNGC_NEXT_INSTR);
    gui_horizontal_select_show(&MMI_rngc_instrument_select_menu);
    gui_BLT_double_buffer(
        MMI_rngc_instrument_select_menu.x,
        MMI_rngc_instrument_select_menu.y,
        MMI_rngc_instrument_select_menu.x + MMI_rngc_instrument_select_menu.width - 1,
        MMI_rngc_instrument_select_menu.y + MMI_rngc_instrument_select_menu.height - 1);
#else /*RNGC_HAS_INST_RECTANGLE*/
    mmi_rngc_change_instrument(RNGC_NEXT_INSTR);
#endif /*RNGC_HAS_INST_RECTANGLE*/
}


#ifdef RNGC_STATUS_BAR_TRANSPANT_BG
/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_redraw_statusbar_bg_callback
 * DESCRIPTION
 *    
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_redraw_statusbar_bg_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1 = 0, y1 = 0;
    S32 x2 = 0, y2 = 0; 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
    gdi_layer_pop_clip();
}
#endif /*RNGC_STATUS_BAR_TRANSPANT_BG*/


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_set_ring_composer
 * DESCRIPTION
 *  Initialize defalut UI variables of stave
 * PARAMETERS
 *  title_id                [IN]        String id of title
 *  left_softkey            [IN]        String id if LSK
 *  left_softkey_icon       [IN]        Image id of LSK
 *  right_softkey           [IN]        String id of RSK
 *  right_softkey_icon      [IN]        Image id of RSK
 *  instru_type             [IN]        Instrument index
 *  value                   [IN]        Number of remaining notes
 *  history_buffer          [IN]        Pointer of history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_set_ring_composer(
        U16 title_id,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    clear_category_screen_key_handlers();

    for (i = 0; i < NUM_NOTES_IN_STAVE; i++)
    {
        g_rngc_eng_cntx->YPos[i] = 0;
        g_rngc_eng_cntx->ImageList[i] = NULL;
    }

    if (g_rngc_eng_cntx->TotalNotes == 0)   /* start vijay 20050707...new change */
    {
        memset(g_rngc_eng_cntx->NotesList, 0xFFFF, MAX_NOTES * sizeof(g_rngc_eng_cntx->NotesList[0]));
    }

#ifdef __MMI_TOUCH_RING_COMPOSER__
    mmi_touch_rngc_setup(&touch_rngc_context);
    mmi_pen_register_down_handler(mmi_rngc_pen_down_hdlr);
    mmi_pen_register_up_handler(mmi_rngc_pen_up_hdlr);
    mmi_pen_register_move_handler(mmi_rngc_pen_move_hdlr);
    mmi_pen_register_repeat_handler(mmi_rngc_pen_repeat_hdlr);
    mmi_pen_register_long_tap_handler(mmi_rngc_pen_longtap_hdlr);
#endif /* __MMI_TOUCH_RING_COMPOSER__ */ 


    /* Instrument toolbar */
#ifdef RNGC_HAS_INST_RECTANGLE
    {
        U8 *ItemList[ENUM_TOTAL_INSTR];     
        U16 StringList[ENUM_TOTAL_INSTR];   
        S32 img_height, img_width, instrument;
        PU8 ring_comp_icon;
        
        GetSequenceStringIds(MENU_COMP_RINGTONE_COMP_SEL_INST, StringList);
        for (i = 0; i < ENUM_TOTAL_INSTR; i++)
        {
            ItemList[i] = (U8*) GetString(StringList[i]);   
        }
        
        for (instrument = 0; instrument < ENUM_TOTAL_INSTR; instrument++)
        {
            if ((U8) g_rngc_cntx.CurrInstr == CurrentInstrument[instrument])
            {
                break;
            }
        }
        MMI_DBG_ASSERT(instrument < ENUM_TOTAL_INSTR);
        
        /* get image size */
        ring_comp_icon = (PU8) get_image(GetInstrumentImage(g_rngc_cntx.CurrInstr));
        gui_measure_image(ring_comp_icon, (S32*) & img_width, (S32*) & img_height);
        mmi_rngc_initialize_instrument_select_menu_items(
            RNGC_INSTR_SELECT_X_OFFSET * 3 + img_width,
            g_rngc_skin_layout.instr_sel_rect_y1,
#if (defined(__MMI_MAINLCD_320X480__))
            (UI_device_width - 2 * img_width - RNGC_INSTR_SELECT_X_OFFSET * 3),
#else
            (UI_device_width - 2 * img_width - RNGC_INSTR_SELECT_X_OFFSET),
#endif
            MMI_RNGC_INSTRUMENT_SELECT_HEIGHT,
            ItemList,
            &instrument,
            UI_dummy_function_s32);
        
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
#endif 
    }
#endif /*RNGC_HAS_INST_RECTANGLE*/

    /* Initialization of the softkeys */
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();

    RedrawCategoryFunction = mmi_rngc_show_composer;
}

#ifdef __MMI_TOUCH_RING_COMPOSER__
/*****************************************************************************
 * FUNCTION
 *  mmi_touch_rngc_setup
 * DESCRIPTION
 *  Sets the default values to the context structure
 *  Sets the play mode to  RNGC_PLAY
 * PARAMETERS
 *  touch_rngc_context      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_touch_rngc_setup(touch_rngc_struct *touch_rngc_context)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    touch_rngc_context->flag = 0;
    touch_rngc_context->flag |= RNGC_SELECTION_AREA_REDRAW;
    touch_rngc_context->mode = GUI_RNGC_VIEW;
    if (touch_rngc_context->play_mode != RNGC_PAUSE)
    {
        selection_area_context = &normal_toolbar_layout;
        touch_rngc_context->area_type = GUI_RNGC_NORMAL_TOOLBAR;
    }
    touch_rngc_context->play_mode = RNGC_PLAY;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_finish_insert_editing
 * DESCRIPTION
 *  Sets mode to insert and changes the image to down
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_finish_insert_editing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, index = 0, y1 = 0, y2 = 0, imgw = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    touch_rngc_context.mode = GUI_RNGC_INSERT;
    selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image = IMG_TOUCH_RING_DOWN;
    show_touch_rngc_selection_area();
    mmi_rngc_redraw_stave();    
#if defined(__MMI_MAINLCD_320X240__)
    mmi_rngc_redraw_remaining_notes();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  show_touch_rngc_selection_area
 * DESCRIPTION
 *  Resets the flag from SELECTION_AREA_REDRAW 
 *  Shows the touch panel of the melody composer, normal toolbar and note selection
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_touch_rngc_selection_area(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //static S32 note_x1, note_y1, note_x2, note_y2;
    S32 n_matrix_keys, n_custom_keys;
    S32 matrix_key_width, matrix_key_height;
    S32 n_matrix_rows, n_matrix_columns;
    S32 width, height;
    S32 horizontal_gap, vertical_gap;
    S32 x1, y1, x2, y2;
    S32 i, j;
    S32 key_x, key_y;
    S32 current_key_x, current_key_y, temp_x, temp_y;   /* [~PMT  MANISH   20050616 */
    S32 custom_key_x, custom_key_y;
    S32 custom_key_width, custom_key_height;
    MMI_ID_TYPE image_id;
    MMI_ID_TYPE *key_image;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    touch_rngc_context.flag &= ~RNGC_SELECTION_AREA_REDRAW;
    n_matrix_keys = selection_area_context->n_matrix_keys;
    n_custom_keys = selection_area_context->n_custom_keys;
    n_matrix_rows = selection_area_context->matrix_layout->n_matrix_rows;
    n_matrix_columns = selection_area_context->matrix_layout->n_matrix_columns;
    matrix_key_width = selection_area_context->matrix_layout->key_width;
    matrix_key_height = selection_area_context->matrix_layout->key_height;
    horizontal_gap = selection_area_context->horizontal_gap;
    vertical_gap = selection_area_context->vertical_gap;
    image_id = selection_area_context->imageid;
    gui_measure_image(get_image(image_id), &width, &height);
    x1 = selection_area_context->image_x;
    y1 = selection_area_context->image_y;
    x2 = x1 + width - 1;
    y2 = y1 + height - 1;

    gui_push_clip();
    gui_set_clip(0, g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT, UI_device_width - 1, g_rngc_skin_layout.main_bg_img_area_y2 - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(0, g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    }
#else 
    gdi_image_draw(0, 0, (PU8)GetImage(g_rngc_skin_layout.main_bg_img_id));
#endif

    gui_show_image(x1, y1, get_image(image_id));
    if (n_matrix_keys)
    {
        key_x = selection_area_context->image_x + selection_area_context->matrix_layout->matrix_x;
        key_y = selection_area_context->image_y + selection_area_context->matrix_layout->matrix_y;
        current_key_x = key_x;
        current_key_y = key_y;
        for (i = 0; i < n_matrix_rows; i++)
        {
            key_image = selection_area_context->matrix_layout->key_image[i];
            for (j = 0; j < n_matrix_columns; j++)
            {
                image_id = key_image[j];
                gui_measure_image(get_image(image_id), &width, &height);
                temp_x = current_key_x + ((matrix_key_width - width) >> 1);     /* PMT MANISH   20050614 */
                temp_y = current_key_y + ((matrix_key_height - height) >> 1);   /* PMT MANISH   20050614 */
                gui_show_image(temp_x, temp_y, get_image(image_id));    /* PMT MANISH   20050614 */
                current_key_x = current_key_x + matrix_key_width + horizontal_gap;
            }
            current_key_x = key_x;
            current_key_y = key_y + matrix_key_height + vertical_gap;
        }
    }
    for (i = 0; i < n_custom_keys; i++)
    {
        custom_key_x = selection_area_context->custom_keys[i].x;
        custom_key_y = selection_area_context->custom_keys[i].y;
        custom_key_width = selection_area_context->custom_keys[i].key_width;
        custom_key_height = selection_area_context->custom_keys[i].key_height;

        image_id = selection_area_context->custom_keys[i].key_image;

    #ifndef __MMI_RNGC_ENABLE_INS_LED_NOTE__
        if (IMG_RING_EVENTLED_ON == image_id || IMG_RING_EVENTLED_OFF == image_id)
        {
            continue;
        }
    #endif /* __MMI_RNGC_ENABLE_INS_LED_NOTE__ */
        gui_measure_image(get_image(image_id), &width, &height);
        custom_key_x = custom_key_x + ((custom_key_width >> 1) - (width >> 1));
        custom_key_y = custom_key_y + ((custom_key_height >> 1) - (height >> 1));
        gui_show_image(custom_key_x, custom_key_y, get_image(image_id));
    }
    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(
        0, g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT, UI_device_width - 1, UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_down_selection_area
 * DESCRIPTION
 *  Notifies the touch screen button pressed on the selection area (normal or note selection)
 * PARAMETERS
 *  touch_rngc_context      [?]         
 *  pos                     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_rngc_pen_down_selection_area(touch_rngc_struct *touch_rngc_context, mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 n_matrix_keys, n_custom_keys;
    S32 matrix_layout_x, matrix_layout_y;
    S32 matrix_width, matrix_height;
    S32 matrix_key_width, matrix_key_height;
    S32 n_matrix_rows, n_matrix_cloumns;
    S32 vertical_gap, horizontal_gap;
    S32 total_matrix_width = 0, total_matrix_height = 0;
    S32 current_key_x, current_key_y;
    S32 current_key_width, current_key_height;
    S32 i, j;
    MMI_BOOL ret = FALSE;   /* new */
    S32 pos_x, pos_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    pos_x = pos.x;
    pos_y = pos.y;

    n_matrix_keys = selection_area_context->n_matrix_keys;
    n_custom_keys = selection_area_context->n_custom_keys;

    if (n_matrix_keys)
    {
        matrix_layout_x = selection_area_context->image_x + selection_area_context->matrix_layout->matrix_x;
        matrix_layout_y = selection_area_context->image_y + selection_area_context->matrix_layout->matrix_y;
        matrix_width = selection_area_context->matrix_layout->matrix_width;
        matrix_height = selection_area_context->matrix_layout->matrix_height;
        n_matrix_rows = selection_area_context->matrix_layout->n_matrix_rows;
        n_matrix_cloumns = selection_area_context->matrix_layout->n_matrix_columns;
        matrix_key_width = selection_area_context->matrix_layout->key_width;
        matrix_key_height = selection_area_context->matrix_layout->key_height;
        horizontal_gap = selection_area_context->horizontal_gap;
        vertical_gap = selection_area_context->vertical_gap;
        total_matrix_height = matrix_layout_y;
        total_matrix_width = matrix_layout_x;
        if (pos_x >= matrix_layout_x && pos_x <= (matrix_layout_x + matrix_width - 1) && pos_y >= matrix_layout_y &&
            pos_y <= (matrix_layout_y + matrix_height - 1))
        {
            for (i = 0; i < n_matrix_rows; i++)
            {
                total_matrix_height += matrix_key_height;
                if (total_matrix_height > pos_y)
                {
                    total_matrix_width = matrix_layout_x;
                    for (j = 0; j < n_matrix_cloumns; j++)
                    {
                        total_matrix_width += matrix_key_width;
                        if (total_matrix_width > pos_x)
                        {
                            touch_rngc_context->key_note_type = selection_area_context->matrix_layout->key_note[i][j];
                            touch_rngc_context->selected_key_x =
                                matrix_layout_x + j * (matrix_key_width + horizontal_gap);
                            touch_rngc_context->selected_key_y =
                                matrix_layout_y + i * (matrix_key_height + vertical_gap);
                            touch_rngc_context->key_width = selection_area_context->matrix_layout->key_width;
                            touch_rngc_context->key_height = selection_area_context->matrix_layout->key_height;
                            touch_rngc_context->selected_key_image =
                                selection_area_context->matrix_layout->key_image[i][j];
                            ret = TRUE;
                            break;
                        }
                        else
                        {
                            total_matrix_width += horizontal_gap;
                            if (total_matrix_width > pos_x)
                            {
                                ret = FALSE;
                                return ret;
                            }
                        }
                    }
                    break;
                }
                else
                {
                    total_matrix_height += vertical_gap;
                    if (total_matrix_height > pos_y)
                    {
                        ret = FALSE;
                        return ret;
                    }
                }
            }
        }
    }
    for (i = 0; i < n_custom_keys; i++)
    {
        current_key_x = selection_area_context->custom_keys[i].x;
        current_key_y = selection_area_context->custom_keys[i].y;
        current_key_width = selection_area_context->custom_keys[i].key_width;
        current_key_height = selection_area_context->custom_keys[i].key_height;
        if (pos_x >= current_key_x && pos_x <= (current_key_x + current_key_width - 1) && pos_y >= current_key_y &&
            pos_y <= (current_key_y + current_key_height - 1))
        {
        #ifndef __MMI_RNGC_ENABLE_INS_LED_NOTE__
            if (selection_area_context->custom_keys[i].key_note == NOTE_LED_ON)
            {
                ret = FALSE;
                return ret;
            }
        #endif /* __MMI_RNGC_ENABLE_INS_LED_NOTE__ */ 
            touch_rngc_context->key_note_type = selection_area_context->custom_keys[i].key_note;
            touch_rngc_context->selected_key_x = current_key_x;
            touch_rngc_context->selected_key_y = current_key_y;
            touch_rngc_context->key_width = current_key_width;
            touch_rngc_context->key_height = current_key_height;
            touch_rngc_context->selected_key_image = selection_area_context->custom_keys[i].key_image;
            ret = TRUE;
            break;
        }
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_down_on_stave
 * DESCRIPTION
 *  Checks the position of the pen on the stave
 * PARAMETERS
 *  pos             [IN]        
 *  item_index      [?]         
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_rngc_pen_down_on_stave(mmi_pen_point_struct pos, S32 *item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    S32 i;
    S32 total_width = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *item_index = 0;
    x1 = RNGC_X_POS_BASED;
    y1 = g_rngc_skin_layout.stave_rectangle_y1;
    x2 = x1 + NUM_NOTES_IN_STAVE * RNGC_X_POS_OFFSET;
    y2 = g_rngc_skin_layout.stave_rectangle_y2;

    if (pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2)
    {
        total_width = x1;
        for (i = 0; i < NUM_NOTES_IN_STAVE; i++)
        {
            total_width += RNGC_X_POS_OFFSET;
            if (total_width >= pos.x)
            {
                *item_index = i;
                break;
            }
        }
        return TRUE;
    }
    else if (pos.x > x2 && pos.y >= y1 && pos.y <= y2 && *item_index <= NUM_NOTES_IN_STAVE)
    {
        *item_index = g_rngc_eng_cntx->CurrUIPos + 1;
    }
    else if (pos.x < x1 && pos.y >= y1 && pos.y <= y2)
    {
        *item_index = -1;
    }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_down_on_MOVE_area
 * DESCRIPTION
 *  Checls the position of the pen on the stave area
 * PARAMETERS
 *  pos             [IN]        
 *  item_index      [?]         
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_rngc_pen_down_on_MOVE_area(mmi_pen_point_struct pos, S32 *item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    y1 = g_rngc_skin_layout.stave_rectangle_y1;
    x2 = RNGC_X_POS_BASED;
    y2 = g_rngc_skin_layout.stave_rectangle_y2;
    
    if (pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2)
    {
        *item_index = RNGC_PEN_LEFT_MOVE_AREA;
        return TRUE;
    }

    x1 = RNGC_X_POS_BASED + NUM_NOTES_IN_STAVE * RNGC_X_POS_OFFSET;
    x2 = UI_device_width - 1;

    if (pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2)
    {
        *item_index = RNGC_PEN_RIGHT_MOVE_AREA;
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_down_instrument
 * DESCRIPTION
 *  Checks whether the instrument bar has been pressed
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_rngc_pen_down_instrument(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x, pos_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    pos_x = pos.x;
    pos_y = pos.y;
    if (PEN_CHECK_BOUND
        (pos_x, pos_y, RNGC_INSTRUMENT_X, RNGC_INSTRUMENT_Y, RNGC_INSTRUMENT_WIDTH, RNGC_INSTRUMENT_HEIGHT))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_set_note_type
 * DESCRIPTION
 *  Sets the note type
 * PARAMETERS
 *  note_type_to_set        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_set_note_type(S32 note_type_to_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 nValue;
    U32 nNoteType;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_rngc_eng_cntx->TotalNotes > MAX_NOTES)
    {
        return;
    }

    if (g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] == 0xFFFF)
    {
        return;
    }
    StopTimer(NOTE_MULTITAP_TIMER);
    nValue = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTE_MASK;
    nNoteType = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTETYPE_MASK;

    switch (nValue)
    {
        case NOTE_C:
        case NOTE_F:
            if (nNoteType == NORMAL && note_type_to_set == SHARP)
                SetNoteType(SHARP)
                else
            if (nNoteType == SHARP && note_type_to_set == SHARP)
                SetNoteType(NORMAL) break;
        case NOTE_D:
        case NOTE_G:
        case NOTE_A:
            if (nNoteType == NORMAL)
                SetNoteType(note_type_to_set)
                else
            if (nNoteType == FLAT && note_type_to_set == FLAT)
                SetNoteType(NORMAL)
                else
            if (nNoteType == SHARP && note_type_to_set == SHARP)
                SetNoteType(NORMAL) break;
        case NOTE_B:
        case NOTE_E:
            if (nNoteType == NORMAL && note_type_to_set == FLAT)
                SetNoteType(FLAT)
                else
            if (note_type_to_set == FLAT)
                SetNoteType(NORMAL) break;

        case NOTE_VIBRATION_ON:
        case NOTE_VIBRATION_OFF:
        case NOTE_LED_ON:
        case NOTE_LED_OFF:
        case NOTE_BACKLIGHT_ON:
        case NOTE_BACKLIGHT_OFF:
            /* don't vib/led/backlight if adjusting sharp/flat on a vibration note */            
            if (note_type_to_set == FLAT || note_type_to_set == SHARP)
            {
                return;
            }        
            
        default:    /* other notes, pound key does not effect */
            break;
    }
    if (nValue |= 0 && nNoteType != 0)
    {
        PlayCurrentNode();
        mmi_rngc_show_note(g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex]);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_set_note_beat
 * DESCRIPTION
 *  Sets the note beat
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_set_note_beat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 nValue;
    S32 nDuration;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_rngc_eng_cntx->TotalNotes > MAX_NOTES)
    {
        return;
    }
    /* highlighted on empty position */
    if (g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] == 0xFFFF)
    {
        return;
    }
    StopTimer(NOTE_MULTITAP_TIMER);

    nValue = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTE_MASK;
    if (nValue >= NOTE_VIBRATION_ON && nValue <= NOTE_BACKLIGHT_OFF)
	{
	    return;     /* don't vib/led/backlight if it's a vib/led/backlight note */
	}	    
    nDuration = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & DURATION_MASK;
    switch (nDuration)
    {
        case DURATION_3BY2:
            IncrementNoteBeat();
            break;
        case DURATION_1:
            TouchRngcDecrementNoteBeat();
            break;
        case DURATION_3BY4:
            IncrementNoteBeat();
            break;
        case DURATION_1BY2:
            TouchRngcDecrementNoteBeat();
            break;
        case DURATION_3BY8:
            IncrementNoteBeat();
            break;
        case DURATION_1BY4:
            TouchRngcDecrementNoteBeat();
            break;
        case DURATION_3BY16:
            IncrementNoteBeat();
            break;
        case DURATION_1BY8:
            TouchRngcDecrementNoteBeat();
            break;
        case DURATION_3BY32:
            IncrementNoteBeat();
            break;
        case DURATION_1BY16:
            TouchRngcDecrementNoteBeat();
            break;
        default:
            break;
    }

    if (nValue |= 0 && nDuration != 0)
    {
        PlayCurrentNode();
        mmi_rngc_show_note(g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex]);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_key_select
 * DESCRIPTION
 *  Effect on pressing the key down on the touch screen
 * PARAMETERS
 *  touch_rngc_context      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_key_select(touch_rngc_struct *touch_rngc_context)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    S32 width, height;
    MMI_ID_TYPE image_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    touch_rngc_context->flag &= ~RNGC_PEN_EVENT_UP;
    gui_lock_double_buffer();
    x1 = touch_rngc_context->selected_key_x;
    y1 = touch_rngc_context->selected_key_y;

    x2 = x1 + touch_rngc_context->key_width - 1;
    y2 = y1 + touch_rngc_context->key_height - 1;
    if (touch_rngc_context->selected_key_bitmap.buf_ptr)
    {
        mmi_frm_scrmem_free((void*)touch_rngc_context->selected_key_bitmap.buf_ptr);
        touch_rngc_context->selected_key_bitmap.buf_ptr = NULL;
    }
    touch_rngc_context->selected_key_bitmap.buf_ptr = (U8*) mmi_frm_scrmem_alloc(touch_ring_comp_mem);
    memset(
        touch_rngc_context->selected_key_bitmap.buf_ptr,
        0,
        (touch_rngc_context->key_width) * (touch_rngc_context->key_height) * 2);
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gdi_image_cache_bmp_get(x1, y1, x2, y2, &touch_rngc_context->selected_key_bitmap);
    gdi_layer_pop_clip();

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2 - 1, y2 - 1);
    {
        gui_draw_filled_area(x1 + 1, y1 + 1, x2 - 1, y2 - 1, (UI_filled_area*)&touch_rngc_color_key_filler);
        image_id = touch_rngc_context->selected_key_image;
    }
    gui_measure_image(get_image(image_id), &width, &height);
    x1 = x1 + ((touch_rngc_context->key_width >> 1) - (width >> 1));
    y1 = y1 + ((touch_rngc_context->key_height >> 1) - (height >> 1));
    gui_show_image(x1, y1, get_image(image_id));
    gdi_layer_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT, UI_device_width - 1, UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_key_unselect
 * DESCRIPTION
 *  Releases the pressed down effect
 * PARAMETERS
 *  touch_rngc_context      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_key_unselect(touch_rngc_struct *touch_rngc_context)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 x1, x2, y1, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (touch_rngc_context->flag & RNGC_PEN_EVENT_UP)
    {
        return;
    }

    gui_lock_double_buffer();
    x1 = touch_rngc_context->selected_key_x;
    y1 = touch_rngc_context->selected_key_y;
    x2 = x1 + touch_rngc_context->key_width - 1;
    y2 = y1 + touch_rngc_context->key_height - 1;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    if (touch_rngc_context->selected_key_bitmap.buf_ptr)
    {
        gdi_image_cache_bmp_draw(x1, y1, &touch_rngc_context->selected_key_bitmap);
        mmi_frm_scrmem_free((void*)touch_rngc_context->selected_key_bitmap.buf_ptr);
        touch_rngc_context->selected_key_bitmap.buf_ptr = NULL;
    }
    gdi_layer_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, g_rngc_skin_layout.main_bg_img_area_y2 - NOTE_SELECTION_HEIGHT, UI_device_width - 1, UI_device_height - MMI_BUTTON_BAR_HEIGHT - 1);
    touch_rngc_context->selected_key_x = 0;
    touch_rngc_context->selected_key_y = 0;
    touch_rngc_context->key_width = 0;
    touch_rngc_context->key_height = 0;
    touch_rngc_context->flag |= RNGC_PEN_EVENT_UP;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_change_stave_notes
 * DESCRIPTION
 *  Changes the notes, move to the right or to the left
 * PARAMETERS
 *  touch_rngc_context      [?]         
 *  item_index              [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_change_stave_notes(touch_rngc_struct *touch_rngc_context, S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 current_notes_in_stave = 100;
    U16 nImageId = 0;
    U16 nYPos = 0;
    U16 original_UI_pos = 0;
    U16 original_note_index = 0;
    S16 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_rngc_eng_cntx->CurrUIPos == item_index)
    {
        return;
    }
    if (item_index <= current_notes_in_stave /* || item_index<=g_rngc_eng_cntx->TotalNotes */ )
    {
        original_note_index = g_rngc_eng_cntx->CurrNoteIndex;
        original_UI_pos = g_rngc_eng_cntx->CurrUIPos;
        touch_rngc_context->original_key_note = g_rngc_eng_cntx->NotesList[original_note_index];
        offset = original_UI_pos - item_index;
        g_rngc_eng_cntx->CurrUIPos = item_index;
        g_rngc_eng_cntx->CurrNoteIndex = original_note_index - offset;  /* g_rngc_eng_cntx->TotalNotes-(current_notes_in_stave-item_index); */
        if (g_rngc_eng_cntx->CurrNoteIndex >= g_rngc_eng_cntx->TotalNotes)
        {
            g_rngc_eng_cntx->CurrUIPos -= (g_rngc_eng_cntx->CurrNoteIndex - g_rngc_eng_cntx->TotalNotes);
            g_rngc_eng_cntx->CurrNoteIndex = g_rngc_eng_cntx->TotalNotes;
        }
        GetIndexInList(touch_rngc_context->original_key_note, &nImageId, &nYPos);
        g_rngc_eng_cntx->NotesList[original_note_index] = touch_rngc_context->original_key_note;
        g_rngc_eng_cntx->ImageList[original_UI_pos] = (PU8) GetImage(nImageId);
        if (item_index >= g_rngc_eng_cntx->CurrUIPos && 
            (touch_rngc_context->mode == GUI_RNGC_EDIT) && 
            (g_rngc_eng_cntx->CurrNoteIndex >= g_rngc_eng_cntx->TotalNotes))
        {
             mmi_rngc_reset_toolbar();
        }
        else
        {
            if ((touch_rngc_context->mode == GUI_RNGC_INSERT_EDIT) &&
                (original_note_index != g_rngc_eng_cntx->CurrNoteIndex))
            {
                touch_rngc_context->mode = GUI_RNGC_INSERT;
            }

        }
        mmi_rngc_redraw_stave();
#if defined(__MMI_MAINLCD_320X240__)
    mmi_rngc_redraw_remaining_notes();
#endif
    }
    /* start vijay 20050617..changes done to vanish the note selection area on cliking outside note are */
    else
    {
        HandleKey_RIGHT();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_normal_toolbar
 * DESCRIPTION
 *  Selection of normal toolbar buttons
 * PARAMETERS
 *  touch_rngc_context      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_normal_toolbar(touch_rngc_struct *touch_rngc_context)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (touch_rngc_context->key_note_type == GUI_RNGC_KEY_EDIT
        || touch_rngc_context->key_note_type == GUI_RNGC_KEY_PLAY
        || touch_rngc_context->key_note_type == GUI_RNGC_KEY_NEXT
        || touch_rngc_context->key_note_type == GUI_RNGC_KEY_PREV)
    {
        /*when the last note press NEXT key*/
        if((touch_rngc_context->key_note_type == GUI_RNGC_KEY_NEXT))
        {
            if ((g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] == 0xFFFF) 
                ||(g_rngc_eng_cntx->CurrNoteIndex + 1 >= MAX_NOTES))
            {
                rngc_pen_event_on_object = RNGC_PEN_NONE;
                return;
            }
        }
        /*the last empty note press EDIT key*/
        if((touch_rngc_context->key_note_type == GUI_RNGC_KEY_EDIT)
            && (g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] == 0xFFFF))
        {
            rngc_pen_event_on_object = RNGC_PEN_NONE;
            return;
        }
        /*the first note when press PREV key*/
        if((touch_rngc_context->key_note_type == GUI_RNGC_KEY_PREV)
            && (g_rngc_eng_cntx->CurrNoteIndex == 0))
        {
            rngc_pen_event_on_object = RNGC_PEN_NONE;
            return;
        }
        
        if (g_rngc_eng_cntx->TotalNotes > 0)
        {
            mmi_rngc_key_select(touch_rngc_context);
            rngc_pen_event_on_object = RNGC_PEN_NORMAL_TOOLBAR;
        }
        else
        {
            rngc_pen_event_on_object = RNGC_PEN_NONE;
        }
    }
    else
    {
        if (touch_rngc_context->key_note_type == GUI_RNGC_KEY_INSERT)
    {
        if (g_rngc_eng_cntx->TotalNotes >= MAX_NOTES)
        {
            rngc_pen_event_on_object = RNGC_PEN_NONE;
            return;
        }
    }
        mmi_rngc_key_select(touch_rngc_context);
        rngc_pen_event_on_object = RNGC_PEN_NORMAL_TOOLBAR;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_note_selection
 * DESCRIPTION
 *  Selection of note selection buttons
 * PARAMETERS
 *  touch_rngc_context      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_note_selection(touch_rngc_struct *touch_rngc_context)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_note_val = 0, current_octave_val = 0, prev_note_val = 0;
    U16 current_note_duration = 0, current_note = 0, current_note_type = 0;
#ifdef __MMI_RING_COMPOSER_REPEAT__
    U16 current_repeat_val = 0;	
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_RNGC_ENABLE_INS_LED_NOTE__
    if (touch_rngc_context->key_note_type == NOTE_LED_ON)
    {
        return;
    }
#endif /* __MMI_RNGC_ENABLE_INS_LED_NOTE__ */ 
    current_note_val = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTE_MASK;
    current_octave_val = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & OCTAVE_MASK;
#ifdef __MMI_RING_COMPOSER_REPEAT__
    current_repeat_val = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & REPEAT_MASK;
#endif
    current_note = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex];

    mmi_rngc_key_select(touch_rngc_context);
    switch (touch_rngc_context->key_note_type)
    {
        case GUI_RNGC_KEY_SHARP:
            if (touch_rngc_context->mode != GUI_RNGC_INSERT)
            {
                mmi_rngc_set_note_type(GUI_RNGC_KEY_SHARP);
            }
            break;

        case GUI_RNGC_KEY_FLAT:
            if (touch_rngc_context->mode != GUI_RNGC_INSERT)
            {
                mmi_rngc_set_note_type(GUI_RNGC_KEY_FLAT);
            }
            break;

        case GUI_RNGC_KEY_DOT:
            if (touch_rngc_context->mode != GUI_RNGC_INSERT)
            {
                mmi_rngc_set_note_beat();
            }
            break;

        case GUI_RNGC_OCTAVE_UP:
            if ((touch_rngc_context->mode != GUI_RNGC_INSERT)
                && (g_rngc_eng_cntx->CurrNoteIndex < g_rngc_eng_cntx->TotalNotes))
            {
        #ifdef __MMI_RING_COMPOSER_REPEAT__
                if (current_repeat_val)
                {
                    IncrementRepeatCount();
                    mmi_rngc_show_note(g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex]);
                }
                else 
        #endif                
                if (current_note_val > NOTE_B)
                {
                    return;
                }
                else if (current_note_val == NOTE_B)
                {
                    switch (current_note_val)
                    {
                        case NOTE_B:
                            if (current_octave_val == OCTAVE_3)
                            {
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_C;
                                SetOctave(OCTAVE_4);
                            }
                            else if (current_octave_val == OCTAVE_4)
                            {
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_C;
                                SetOctave(OCTAVE_5);
                            }
                            else if (current_octave_val == OCTAVE_5)
                            {
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_C;;
                                SetOctave(OCTAVE_3);
                            }
                            break;
                    }
                }
                else
                {
                    ++current_note_val;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= current_note_val;
                }
                if (current_note_val != 0)
                {
                    current_note_type = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTETYPE_MASK;
                    SetNoteType(NORMAL) mmi_rngc_set_note_type(current_note_type);
                }
            }
            break;

        case GUI_RNGC_OCTAVE_DOWN:
            if ((touch_rngc_context->mode != GUI_RNGC_INSERT)
                && (g_rngc_eng_cntx->CurrNoteIndex < g_rngc_eng_cntx->TotalNotes))
            {
        #ifdef __MMI_RING_COMPOSER_REPEAT__
                if (current_repeat_val)
                {
                    DecrementRepeatCount();
                    mmi_rngc_show_note(g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex]);
                }
                else 
        #endif                
                if (current_note_val > NOTE_B)
                {
                    return;
                }
                else if (current_note_val == NOTE_C || current_note_val > NOTE_B)       /* last note */
                {
                    switch (current_note_val)
                    {
                        case NOTE_C:
                        {
                            if (current_octave_val == OCTAVE_3)
                            {
                                SetOctave(OCTAVE_5);
                                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_B;
                            }
                            else if (current_octave_val == OCTAVE_4)
                            {
                                SetOctave(OCTAVE_3);
                                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_B;
                            }
                            else if (current_octave_val == OCTAVE_5)
                            {
                                SetOctave(OCTAVE_4);
                                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                                g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= NOTE_B;
                            }
                            break;
                        }
                        default:
                            break;
                    }
                }
                else if (current_note_val != 0)
                {
                    --current_note_val;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= current_note_val;
                }

                if (current_note_val != 0)
                {
                    current_note_type = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTETYPE_MASK;
                    SetNoteType(NORMAL) mmi_rngc_set_note_type(current_note_type);
                }
            }
            break;
        case GUI_RNGC_KEY_OK:
            break;

        default:
            if ((current_note != 0xFFFF) &&
                (touch_rngc_context->mode == GUI_RNGC_EDIT || touch_rngc_context->mode == GUI_RNGC_INSERT_EDIT))
            {
              /*  if (current_note_val == NOTE_REST || current_note == 0 ||
                    (touch_rngc_context->key_note_type & NOTE_MASK) == NOTE_REST)
                {
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] = touch_rngc_context->key_note_type;
                }
                else
                {
                    /*current_note_duration = touch_rngc_context->key_note_type & DURATION_MASK;
                    current_note_type = touch_rngc_context->key_note_type & NOTETYPE_MASK;
                    prev_note_val = g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] & NOTE_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_DURATION_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTE_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] &= CLEAR_NOTETYPE_MASK;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= current_note_duration;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= current_note_type;
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] |= prev_note_val;
                    if (current_octave_val)
                    {
                        SetOctave(current_octave_val);
                    }*/
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] = touch_rngc_context->key_note_type;
               /* }
        #ifdef __MMI_RING_COMPOSER_REPEAT__
                if (current_note >= REPEAT_START && current_note <= REPEAT_END)
                {
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] = touch_rngc_context->key_note_type;
                }
        #endif*/
                switch (current_note)
                {
                    case NOTE_LED_OFF:
                    #ifdef __MMI_RNGC_ENABLE_INS_LED_NOTE__
                        if (touch_rngc_context->key_note_type == NOTE_LED_ON)
                        {
                            SetLEDOn();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                    #endif /* __MMI_RNGC_ENABLE_INS_LED_NOTE__ */
                        break;
                    case NOTE_BACKLIGHT_OFF:
                        if (touch_rngc_context->key_note_type == NOTE_BACKLIGHT_ON)
                        {
                            SetBackLightOn();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                        break;
                    case NOTE_VIBRATION_OFF:
                        if (touch_rngc_context->key_note_type == NOTE_VIBRATION_ON)
                        {
                            SetVibrationOn();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                        break;
                    case NOTE_LED_ON:
                    #ifdef __MMI_RNGC_ENABLE_INS_LED_NOTE__
                        if (touch_rngc_context->key_note_type == NOTE_LED_ON)
                        {
                            SetLEDOff();
                            PlayCurrentNode();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                    #endif /* __MMI_RNGC_ENABLE_INS_LED_NOTE__ */
                        break;
                    case NOTE_BACKLIGHT_ON:
                        if (touch_rngc_context->key_note_type == NOTE_BACKLIGHT_ON)
                        {
                            SetBackLightOff();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                        break;
                    case NOTE_VIBRATION_ON:
                        if (touch_rngc_context->key_note_type == NOTE_VIBRATION_ON)
                        {
                            SetVibrationOff();
                        }
                        else
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                        break;
                    case 0xFFFF:
                        break;
                    default:
                        if (touch_rngc_context->key_note_type == NOTE_VIBRATION_ON ||
                            touch_rngc_context->key_note_type == NOTE_BACKLIGHT_ON ||
                            touch_rngc_context->key_note_type == NOTE_LED_ON
                        #ifdef __MMI_RING_COMPOSER_REPEAT__
                             ||(touch_rngc_context->key_note_type >= REPEAT_START &&
                            touch_rngc_context->key_note_type <= REPEAT_END)
                        #endif
                            )
                        {
                            g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] =
                                touch_rngc_context->key_note_type;
                        }
                        break;
                }
                PlayCurrentNode();
                mmi_rngc_show_note(g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex]);
            }
            else if (touch_rngc_context->mode == GUI_RNGC_INSERT)
            {
                if (g_rngc_eng_cntx->TotalNotes < MAX_NOTES)
                {
                    touch_rngc_context->mode = GUI_RNGC_INSERT_EDIT;
                    InsertNote(touch_rngc_context->key_note_type);
                    selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image = IMG_TOUCH_RING_OK;
                    show_touch_rngc_selection_area();
                }
            }
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_down_hdlr
 * DESCRIPTION
 *  Handler for the pen down event
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_index;
    gui_button_pen_enum button_event;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
#ifdef RNGC_HAS_INST_RECTANGLE
    {
        gui_horizontal_select_pen_enum select_event; 
        ret = gui_horizontal_select_translate_pen_event(
            &MMI_rngc_instrument_select_menu,
            MMI_PEN_EVENT_DOWN,
            pos.x,
            pos.y,
            &select_event);
        if (ret)
        {
            rngc_pen_event_on_object = RNGC_PEN_INSTRUMENT;
            return;
        }
    }    
#else /*RNGC_HAS_INST_RECTANGLE*/
    ret = mmi_rngc_pen_down_instrument(pos);
    if (ret)
    {
        rngc_pen_event_on_object = RNGC_PEN_INSTRUMENT;   
        mmi_rngc_change_instrument(RNGC_NEXT_INSTR);    
        return;
    }
#endif /*RNGC_HAS_INST_RECTANGLE*/

    ret = mmi_rngc_pen_down_on_stave(pos, &item_index);
    if (ret) 
    {
        rngc_pen_event_on_object = RNGC_PEN_STAVE;
        if (g_rngc_eng_cntx->CurrUIPos != item_index)
        {
            mmi_rngc_change_stave_notes(&touch_rngc_context, item_index);
            if (selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image == IMG_TOUCH_RING_OK)
            {
                selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image = IMG_TOUCH_RING_DOWN;
                show_touch_rngc_selection_area();
            }
        }
        return;
    }
    ret = mmi_rngc_pen_down_selection_area(&touch_rngc_context, pos);
    if (ret)
    {
        switch (touch_rngc_context.area_type)
        {
            case GUI_RNGC_NORMAL_TOOLBAR:
                mmi_rngc_normal_toolbar(&touch_rngc_context);
                break;
            case GUI_RNGC_NOTE_SELECTION:
                rngc_pen_event_on_object = RNGC_PEN_NOTE_SELECTION;
                mmi_rngc_note_selection(&touch_rngc_context);
                break;
            default:
                break;
        }
        return;
    }

    if (touch_rngc_context.area_type != GUI_RNGC_NOTE_SELECTION)
    {
        #if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_lock_double_buffer();
        #endif 
        ret = translate_softkey_pen_event(MMI_LEFT_SOFTKEY, MMI_PEN_EVENT_DOWN, pos.x, pos.y, &button_event);
        #if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_unlock_double_buffer();
        #endif 
        if (ret)
        {
            rngc_pen_event_on_object = TOUCH_RNGC_PEN_LSK;
            if (button_event == GUI_BUTTON_PEN_DOWN && touch_rngc_context.area_type == GUI_RNGC_NORMAL_TOOLBAR)
            {
                RngcComposerLSKDownHandler();
            }
            return;
        }
    }
    #if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
    #endif 
    ret = translate_softkey_pen_event(MMI_RIGHT_SOFTKEY, MMI_PEN_EVENT_DOWN, pos.x, pos.y, &button_event);
    #if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    #endif 
    if (ret)
    {
        rngc_pen_event_on_object = TOUCH_RNGC_PEN_RSK;
        if (button_event == GUI_BUTTON_PEN_DOWN)
        {
            RngcComposerRSKDownHandler();
        }
        return;
    }

    switch (touch_rngc_context.area_type)
    {
        case GUI_RNGC_NORMAL_TOOLBAR:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, NORMAL_TOOLBAR_IMAGE_X, NORMAL_TOOLBAR_IMAGE_Y, NORMAL_TOOLBAR_WIDTH,
                 NORMAL_TOOLBAR_HEIGHT))
            {
                return;
            }
            break;
        case GUI_RNGC_NOTE_SELECTION:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, NOTE_SELECTION_IMAGE_X, NOTE_SELECTION_IMAGE_Y, NOTE_SELECTION_WIDTH,
                 NOTE_SELECTION_HEIGHT))
            {
                return;
            }
            break;
    }
    /*If touch leftmost or rightmost, handle move the cursor*/
    ret = mmi_rngc_pen_down_on_MOVE_area(pos, &item_index);
    if(ret)
    {
        rngc_pen_event_on_object = RNGC_PEN_NONE;
        if(RNGC_PEN_LEFT_MOVE_AREA == item_index)
        {
            HandleKey_LEFT();
        }
        else if(RNGC_PEN_RIGHT_MOVE_AREA == item_index)
        {
            HandleKey_RIGHT();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_longtap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_pen_longtap_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_button_pen_enum button_event;
    MMI_BOOL ret = MMI_FALSE;
    S32 item_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (rngc_pen_event_on_object == RNGC_PEN_STAVE)
    {
        mmi_rngc_pen_down_on_stave(pos, &item_index);
        if (item_index > g_rngc_eng_cntx->CurrUIPos)
        {
            HandleKey_RIGHT();
        }
        else if (item_index == -1)
        {
            if (g_rngc_eng_cntx->CurrNoteIndex > 0)
            {
                HandleKey_LEFT();
            }
        }
    }
    ret = translate_softkey_pen_event(MMI_RIGHT_SOFTKEY, MMI_PEN_EVENT_LONG_TAP, pos.x, pos.y, &button_event);

    if (ret)
    {
        if (button_event == GUI_BUTTON_PEN_LONGTAP && rngc_pen_event_on_object == TOUCH_RNGC_PEN_RSK)
        {
            if (g_rngc_eng_cntx->IsRskLP == RSK_DOWN)
            {
                rngc_pen_event_on_object = RNGC_PEN_NONE;
                HandleKey_CLEARLONG();
                mmi_rngc_redraw_RSK(0);
            }
        }
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_repeat_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_pen_repeat_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*gui_button_pen_enum button_event;
    MMI_BOOL ret = MMI_FALSE;*/
    S32 item_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (rngc_pen_event_on_object == RNGC_PEN_STAVE)
    {
        mmi_rngc_pen_down_on_stave(pos, &item_index);
        if (item_index > g_rngc_eng_cntx->CurrUIPos)
        {
        //    HandleKey_RIGHT();
        }
        else if (item_index == -1)
        {
            if (g_rngc_eng_cntx->CurrNoteIndex >= 0)
            {
                HandleKey_LEFT();
            }
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_up_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_button_pen_enum button_event;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (rngc_pen_event_on_object)
    {
        case TOUCH_RNGC_PEN_LSK:
            #if(UI_DOUBLE_BUFFER_SUPPORT)
            gui_lock_double_buffer();
            #endif 
            ret = translate_softkey_pen_event(MMI_LEFT_SOFTKEY, MMI_PEN_EVENT_UP, pos.x, pos.y, &button_event);
            #if(UI_DOUBLE_BUFFER_SUPPORT)
            gui_unlock_double_buffer();
            #endif
            if (button_event == GUI_BUTTON_PEN_UP_INSIDE && touch_rngc_context.area_type == GUI_RNGC_NORMAL_TOOLBAR)
            {
                mmi_rngc_redraw_LSK(0);
                EntryRngcCompToneOptList();
                touch_rngc_context.play_mode = RNGC_PAUSE;
            }
            break;
        case TOUCH_RNGC_PEN_RSK:
            #if(UI_DOUBLE_BUFFER_SUPPORT)
            gui_lock_double_buffer();
            #endif 
            translate_softkey_pen_event(MMI_RIGHT_SOFTKEY, MMI_PEN_EVENT_UP, pos.x, pos.y, &button_event);
            #if(UI_DOUBLE_BUFFER_SUPPORT)
            gui_unlock_double_buffer();
            #endif
            if (button_event == GUI_BUTTON_PEN_UP_INSIDE)
            {
                mmi_rngc_redraw_RSK(0);
                RngcComposerRSKUpHandler();
                if (touch_rngc_context.mode == GUI_RNGC_INSERT_EDIT)
                {
                    touch_rngc_context.mode = GUI_RNGC_INSERT;
                }
            }
            break;
        case RNGC_PEN_INSTRUMENT:
#ifdef RNGC_HAS_INST_RECTANGLE
            {
                gui_horizontal_select_pen_enum select_event;
                
                ret = gui_horizontal_select_translate_pen_event(
                    &MMI_rngc_instrument_select_menu,
                    MMI_PEN_EVENT_UP,
                    pos.x,
                    pos.y,
                    &select_event);
                if (ret)
                { 
                    switch (select_event)
                    {
                    case GUI_HORIZONTAL_SELECT_PEN_NONE:
                        /* Do nothing */
                        break;
                    case GUI_HORIZONTAL_SELECT_PEN_PREV:
                        mmi_rngc_select_previous_instrument();
                        break;
                    case GUI_HORIZONTAL_SELECT_PEN_NEXT:
                        mmi_rngc_select_next_instrument();
                        break;
                    default:
                        MMI_DBG_ASSERT(0);
                    }
                }
            }
#endif /*RNGC_HAS_INST_RECTANGLE*/
            break;
        case RNGC_PEN_STAVE:
            break;
        case RNGC_PEN_NORMAL_TOOLBAR:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, touch_rngc_context.selected_key_x, touch_rngc_context.selected_key_y,
                 touch_rngc_context.key_width, touch_rngc_context.key_height))
                switch (touch_rngc_context.key_note_type)
                {
                    case GUI_RNGC_KEY_EDIT:
                        if (g_rngc_eng_cntx->TotalNotes > 0)
                        {
                            if (touch_rngc_context.play_mode != RNGC_PAUSE)
                            {
                                mmi_rngc_key_unselect(&touch_rngc_context);
                                touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                                if (g_rngc_eng_cntx->CurrNoteIndex < g_rngc_eng_cntx->TotalNotes)
                                {
                                    touch_rngc_context.area_type = GUI_RNGC_NOTE_SELECTION;
                                    selection_area_context =
                                        (rngc_selection_area_layout_struct*) & note_selection_layout;
                                    touch_rngc_context.mode = GUI_RNGC_EDIT;
                                    touch_rngc_context.play_mode = RNGC_PAUSE;
                                    touch_rngc_context.flag &= ~RNGC_NOTE_SELECTION_FINAL;
                                    touch_rngc_context.flag |= RNGC_SELECTION_AREA_REDRAW;
                                    show_touch_rngc_selection_area();
                                    mmi_rngc_redraw_stave();
                                #if defined(__MMI_MAINLCD_320X240__)
                                    mmi_rngc_redraw_remaining_notes();
                                #endif
									clear_softkey_handler(MMI_LEFT_SOFTKEY);
                                    mmi_rngc_redraw_SK(0, MMI_LEFT_SOFTKEY, 0);
				    g_current_insert_mode = MMI_TRUE;
                                }
                            }
                        }
                        break;
                    case GUI_RNGC_KEY_INSERT:
                        if (touch_rngc_context.play_mode != RNGC_PAUSE && g_rngc_eng_cntx->TotalNotes <= MAX_NOTES)
                        {
                            mmi_rngc_key_unselect(&touch_rngc_context);
                            touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                            touch_rngc_context.area_type = GUI_RNGC_NOTE_SELECTION;
                            selection_area_context = (rngc_selection_area_layout_struct*) & note_selection_layout;
                            touch_rngc_context.mode = GUI_RNGC_INSERT;
                            touch_rngc_context.play_mode = RNGC_PAUSE;
                            touch_rngc_context.flag &= ~RNGC_NOTE_SELECTION_FINAL;
                            touch_rngc_context.flag |= RNGC_SELECTION_AREA_REDRAW;
                            show_touch_rngc_selection_area();
                            clear_softkey_handler(MMI_LEFT_SOFTKEY);
                            mmi_rngc_redraw_SK(0, MMI_LEFT_SOFTKEY, 0);
			    g_current_insert_mode = MMI_TRUE;
                        }
                        break;
                    case GUI_RNGC_KEY_PLAY:
                        if (g_rngc_eng_cntx->TotalNotes > 0)
                        {
                            if (touch_rngc_context.play_mode == RNGC_PLAY)
                            {
                                g_rngc_cntx.CurrHiliteItem = ENUM_ADD_TONE_OPT_PLAY;
                                mmi_rngc_key_unselect(&touch_rngc_context);
                                RngcGotoSelectedCompToneOpt(ENUM_ADD_TONE_OPT_PLAY);
                                touch_rngc_context.play_mode = RNGC_PAUSE;
                            }
                            else if (touch_rngc_context.play_mode == RNGC_PAUSE)
                            {
                                ExitRngcPlayTone();
                                /* stop the playing melody */
                                touch_rngc_context.play_mode = RNGC_PLAY;
                            }
                        }
                        break;
                    case GUI_RNGC_KEY_NEXT:
                        if (g_rngc_eng_cntx->TotalNotes > 0)
                        {
                            if (touch_rngc_context.play_mode != RNGC_PAUSE)
                            {
                                mmi_rngc_key_unselect(&touch_rngc_context);
                                touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                                HandleKey_RIGHT();
                            }
                        }
                        break;
                    case GUI_RNGC_KEY_PREV:
                        if (g_rngc_eng_cntx->TotalNotes > 0)
                        {
                            if (touch_rngc_context.play_mode != RNGC_PAUSE)
                            {
                                mmi_rngc_key_unselect(&touch_rngc_context);
                                touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                                HandleKey_LEFT();
                            }
                        }
                        break;
                }
            break;
        case RNGC_PEN_NOTE_SELECTION:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, touch_rngc_context.selected_key_x, touch_rngc_context.selected_key_y,
                 touch_rngc_context.key_width, touch_rngc_context.key_height))
            {
                mmi_rngc_key_unselect(&touch_rngc_context);
                touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                if (touch_rngc_context.key_note_type == GUI_RNGC_KEY_OK)
                {
                    if (selection_area_context->custom_keys[selection_area_context->n_custom_keys-1].key_image == IMG_TOUCH_RING_DOWN)
                    {
                        if (touch_rngc_context.mode == GUI_RNGC_INSERT_EDIT ||
                            touch_rngc_context.mode == GUI_RNGC_INSERT || touch_rngc_context.mode == GUI_RNGC_EDIT)
                        {
                            touch_rngc_context.area_type = GUI_RNGC_NORMAL_TOOLBAR;
                            selection_area_context = &normal_toolbar_layout;
                            touch_rngc_context.mode = GUI_RNGC_VIEW;
                            touch_rngc_context.play_mode = RNGC_PLAY;
                            touch_rngc_context.flag |= RNGC_SELECTION_AREA_REDRAW;
                            mmi_rngc_redraw_stave();
                        #if defined(__MMI_MAINLCD_320X240__)
                            mmi_rngc_redraw_remaining_notes();
                        #endif

                            show_touch_rngc_selection_area();
                            rngc_pen_event_on_object = RNGC_PEN_NONE;
			    if(g_current_insert_mode)
			        g_current_insert_mode = MMI_FALSE;

                            SetKeyHandler(RngcComposerLSKDownHandler, KEY_LSK, KEY_EVENT_DOWN);
                            SetKeyHandler(RngcComposerLSKUpHandler, KEY_LSK, KEY_EVENT_UP);
                            mmi_rngc_redraw_LSK(0);
                        }
                        return;
                    }

                    if (touch_rngc_context.mode == GUI_RNGC_INSERT_EDIT)
                    {
                        mmi_rngc_finish_insert_editing();
                    }
                }
            }
            else
            {
                mmi_rngc_key_unselect(&touch_rngc_context);
            }
            break;
    }
    rngc_pen_event_on_object = RNGC_PEN_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_pen_move_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_button_pen_enum button_event;
    S32 item_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (rngc_pen_event_on_object)
    {
        case RNGC_PEN_INSTRUMENT:
#ifdef RNGC_HAS_INST_RECTANGLE
            {
                gui_horizontal_select_pen_enum select_event;
                
                gui_horizontal_select_translate_pen_event(
                    &MMI_rngc_instrument_select_menu,
                    MMI_PEN_EVENT_MOVE,
                    pos.x,
                    pos.y,
                    &select_event);
            }
#endif /*RNGC_HAS_INST_RECTANGLE*/
            break;
        case RNGC_PEN_STAVE:
            if (mmi_rngc_pen_down_on_stave(pos, &item_index))
            {
                if (item_index > g_rngc_eng_cntx->CurrUIPos && 
                    g_rngc_eng_cntx->NotesList[g_rngc_eng_cntx->CurrNoteIndex] != 0xFFFF)
                {
                        HandleKey_RIGHT();
                }
                else if (item_index == -1)
                {
                    if (g_rngc_eng_cntx->CurrNoteIndex > 0)
                    {
                        HandleKey_LEFT();
                    }
                }
                else if (item_index < g_rngc_eng_cntx->CurrUIPos)
                {
                    /* mmi_rngc_change_stave_notes(&touch_rngc_context, item_index);*/
                    HandleKey_LEFT();
                }
                if (touch_rngc_context.mode == GUI_RNGC_INSERT_EDIT && item_index != g_rngc_eng_cntx->CurrUIPos)
                {
                    mmi_rngc_finish_insert_editing();
                }
            }
            break;

        case RNGC_PEN_NORMAL_TOOLBAR:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, selection_area_context->image_x + selection_area_context->matrix_layout->matrix_x,
                 selection_area_context->image_y + selection_area_context->matrix_layout->matrix_y,
                 NORMAL_TOOLBAR_WIDTH, NORMAL_TOOLBAR_HEIGHT))
            {
                if ((!PEN_CHECK_BOUND
                     (pos.x, pos.y, touch_rngc_context.selected_key_x, touch_rngc_context.selected_key_y,
                      touch_rngc_context.key_width - 1, touch_rngc_context.key_height - 1)))
                {
                    if (touch_rngc_context.key_note_type == GUI_RNGC_KEY_PLAY)
                    {
                        if (g_rngc_eng_cntx->TotalNotes > 0)
                        {
                            mmi_rngc_key_unselect(&touch_rngc_context);
                        }
                    }
                    else
                    {
                        mmi_rngc_key_unselect(&touch_rngc_context);
                    }
                    touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                }
            }
            /* START VIJAY PMT 20050719 */
            else    /* move outside note selection bar */
            {
                mmi_rngc_key_unselect(&touch_rngc_context);
            }
            /* END VIJAY */
            break;
        case RNGC_PEN_NOTE_SELECTION:
            if (PEN_CHECK_BOUND
                (pos.x, pos.y, selection_area_context->image_x + selection_area_context->matrix_layout->matrix_x,
                 selection_area_context->image_y + selection_area_context->matrix_layout->matrix_y,
                 NOTE_SELECTION_WIDTH, NOTE_SELECTION_HEIGHT))
            {
                if ((!PEN_CHECK_BOUND
                     (pos.x, pos.y, touch_rngc_context.selected_key_x, touch_rngc_context.selected_key_y,
                      touch_rngc_context.key_width, touch_rngc_context.key_height)))
                {
                    mmi_rngc_key_unselect(&touch_rngc_context);
                    touch_rngc_context.flag |= RNGC_PEN_EVENT_UP;
                }
            }
            else    /* move outside note selection bar */
            {
                mmi_rngc_key_unselect(&touch_rngc_context);
            }
            break;
        case TOUCH_RNGC_PEN_LSK:
            translate_softkey_pen_event(MMI_LEFT_SOFTKEY, MMI_PEN_EVENT_MOVE, pos.x, pos.y, &button_event);
            if (mmi_pen_check_inside_polygon(&SK_area, pos))
            {
                mmi_rngc_redraw_LSK(1);
            }
            else
            {
                mmi_rngc_redraw_LSK(0);
            }
            break;
        case TOUCH_RNGC_PEN_RSK:
            translate_softkey_pen_event(MMI_RIGHT_SOFTKEY, MMI_PEN_EVENT_MOVE, pos.x, pos.y, &button_event);
            if (mmi_pen_check_inside_polygon(&SK_area, pos))
            {
                mmi_rngc_redraw_RSK(1);
            }
            else
            {
                mmi_rngc_redraw_RSK(0);
            }
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rngc_reset_toolbar
 * DESCRIPTION
 *  Exported to ComposeRingtoneEngine 
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rngc_reset_toolbar(void)
{
        touch_rngc_context.area_type = GUI_RNGC_NORMAL_TOOLBAR;
        selection_area_context = &normal_toolbar_layout;
        touch_rngc_context.mode = GUI_RNGC_VIEW;
        touch_rngc_context.play_mode = RNGC_PLAY;
        touch_rngc_context.flag |= RNGC_SELECTION_AREA_REDRAW;
        mmi_rngc_redraw_stave();
#if defined(__MMI_MAINLCD_320X240__)
    mmi_rngc_redraw_remaining_notes();
#endif
    mmi_rngc_redraw_LSK(0);
    SetKeyHandler(RngcComposerLSKDownHandler, KEY_LSK, KEY_EVENT_DOWN);
    SetKeyHandler(EntryRngcCompToneOptList, KEY_LSK, KEY_EVENT_UP);
    show_touch_rngc_selection_area();
}
#endif /* __MMI_TOUCH_RING_COMPOSER__ */

#endif /* __MMI_RING_COMPOSER__ */ 


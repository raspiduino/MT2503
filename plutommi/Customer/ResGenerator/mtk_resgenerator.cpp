/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  mtk_resgenerator.cpp
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   To Generator Resource C files.
 *
 * Author:
 * -------
 * -------
 *
*==============================================================================
 *              HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/


#include <stdio.h>
#include <stdlib.h>

#include "MMIDataType.h"

extern "C" {
#include "CustDataRes.h"
#include "CustMenuRes.h"
#include "CustResDef.h"
#include "mmi_features.h"
#include "WriteResUtil.h"
#include "LegacyResPopService.h"
#include "str_merge_public.h"
#include "ExternalCMDManagerCAPI.h"
#include "ResgenLogCAPI.h"
}
////////////////////////////////////////////
// Offilne Generator Headers
////////////////////////////////////////////
#ifdef __RESGEN_INTERNAL_OFFLINE__
#include "stdafx.h"
#include <vector>
#include <string>

#include "OfflineResParam.h"
#include "OfflineResDAO.h"
#include "OfflineResParamModel.h"
#include "OfflineResHelper.h"
#include "OfflineResPopAdaptor.h"
#include "CatResGenerator.h"
#endif // __RESGEN_INTERNAL_OFFLINE__
////////////////////////////////////////////

#include "ResCompressConfig.h"
#include "ResgenCatConfig.h"
#include "ResgenCrashHandlingServ.h"
#include "ResgenConfigurator.h"
#include "ImageGroupCreator.h"

#ifdef __REGEN_INTERNAL_BATCHED__
#include "BinaryModeResGen.h"
#endif

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

#include <time.h>

/* Enable roud-robin image split method */
#define RESGEN_IMG_SPLIT_OUTPUT_ROUND_ROBIN

/* buffer size for shell command */
#define SHELL_CMD_BUFLEN    (MAX_FILENAME_LEN + 100)
/* buffer size for unzip command */
#define UNZIP_CMD_BUFLEN    256

#define RESGEN_TAG        "MTK_RESGENERATOR"

#define RESGEN_LOG_D(format, args...) RES_LOG_D((RESGEN_TAG), (format) , ##args)
#define RESGEN_LOG_V(format, args...) RES_LOG_V((RESGEN_TAG), (format) , ##args)
#define RESGEN_LOG_W(format, args...) RES_LOG_W((RESGEN_TAG), (format) , ##args)
#define RESGEN_LOG_E(format, args...) RES_LOG_E((RESGEN_TAG), (format) , ##args)

#define RESGEN_WLOG_D(format, args...) RES_WLOG_D((RESGEN_TAG), (format) , ##args)
#define RESGEN_WLOG_V(format, args...) RES_WLOG_V((RESGEN_TAG), (format) , ##args)
#define RESGEN_WLOG_W(format, args...) RES_WLOG_W((RESGEN_TAG), (format) , ##args)
#define RESGEN_WLOG_E(format, args...) RES_WLOG_E((RESGEN_TAG), (format) , ##args)




/* buffer size of cust pack error log */
#define CUSTPACK_LOG_BUFLEN 256
#define CUSTPACL_LOG_FILE_NAME "resgen_custpack.log"

#ifdef __CAT_SUPPORT__
    #define STR_COMPRESS_CMD_OPTION_STR_PADDING MMIRESOURCE_CAT_STR_COMPRESS_RESERVED_MARGIN_SIZE_BYTE
#else
    #define STR_COMPRESS_CMD_OPTION_STR_PADDING 0
#endif //__CAT_SUPPORT__


/* type definition */
typedef struct
{
    U16 Num;
} CUSTOM_ID_MAP;

typedef struct
{
    U16 minId;
    U16 maxId;
    U16 index;
} CUSTOM_ID_SEARCH_MAP;

typedef struct
{
    S8 filename[MAX_FILENAME_LEN];
} CUSTOM_NAME_LIST;


/* Extern variable */
extern "C" CUSTOM_IMAGE_MAP            ImageIdMap[];
extern "C" CUSTOM_IMAGE_SEARCH_MAP     ImageIdSearchMap[];
extern "C" IMAGENAME_LIST              ImageNameList[];

extern "C" CUSTOM_IMAGE_MAP            ImageIdMapEXT[];
extern "C" CUSTOM_IMAGE_SEARCH_MAP     ImageIdSearchMapEXT[];
extern "C" IMAGENAME_LIST              ImageNameListEXT[];

extern "C" CUSTOM_FONT_MAP            FontIdMapEXT[];
extern "C" CUSTOM_FONT_SEARCH_MAP     FontIdSearchMapEXT[];
extern "C" FONTNAME_LIST              FontNameListEXT[];



extern "C" CUSTOM_AUDIO_MAP         AudioIdMap[];
extern "C" CUSTOM_AUDIO_SEARCH_MAP  AudioIdSearchMap[];
extern "C" AUDIONAME_LIST           AudioNameList[];

extern "C" CUSTOM_AUDIO_MAP         AudioIdMapEXT[];
extern "C" CUSTOM_AUDIO_SEARCH_MAP  AudioIdSearchMapEXT[];
extern "C" AUDIONAME_LIST           AudioNameListEXT[];

extern "C" CUSTOM_MENU              nCustMenus[];
extern "C" unsigned short           CurrMaxMenuItemIndex;   //Max menu Ids

extern "C" unsigned short           CurrMaxImageId;         //Max String Ids
extern "C" unsigned short           CurrMaxSearchImageId;   //Max String Ids
extern "C" unsigned short           CurrMaxImageNum;        //Max Number Ids

extern "C" unsigned short           CurrMaxImageIdEXT;
extern "C" unsigned short           CurrMaxSearchImageIdEXT;
extern "C" unsigned short           CurrMaxImageNumEXT;

extern "C" unsigned short           CurrMaxFontIdEXT;
extern "C" unsigned short           CurrMaxSearchFontIdEXT;
extern "C" unsigned short           CurrMaxFontNumEXT;


extern "C" unsigned short           CurrMaxAudioId;         //Max String Ids
extern "C" unsigned short           CurrMaxSearchAudioId;   //Max String Ids
extern "C" unsigned short           CurrMaxAudioNum;        //Max Number Ids

extern "C" unsigned short           CurrMaxAudioIdEXT;
extern "C" unsigned short           CurrMaxSearchAudioIdEXT;
extern "C" unsigned short           CurrMaxAudioNumEXT;


extern "C" FILE*                    dest_file;
extern "C" int                      toolFlag;
extern "C" int                      resultFailFlag;
extern "C" MMI_BOOL                 g_is_log;
MMI_BOOL                            g_is_clean = MMI_FALSE;


extern "C" unsigned short           CurrMaxENFBAssociatedIDNum;
extern "C" CUSTOM_ENFB_STR          ENFBAssociatedIDList[];

extern "C" ENFB_Font_Res_Info       ENFBFontResInfo[];


/* Menuitem reduce memory, move registe hilite handlers to resgen */
extern "C" S32 HiliteHdlrCount;
extern "C" S32 HintHdlrCount;
extern "C" RESGEN_MENU_HILITE_HANDLER   nMenuHiliteHandlers[];
extern "C" RESGEN_MENU_HINT_HANDLER     nMenuHintHandlers[];

/* Extern functions */
extern "C" void InitStrPopulate();
extern "C" MMI_BOOL Fload(S8 *string, PU16 pType);

/*****************************************************************************
* FUNCTION
*  GenerateENFBAssociatedIDFile
* DESCRIPTION
*  generate ENFB associated ID map file
* PARAMETERS
*  void
* RETURNS
*  MMI_BOOL
*****************************************************************************/
static MMI_BOOL GenerateENFBAssociatedIDFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *fp;
    CUSTOM_ENFB_STR *enfb;
    int i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateENFBAssociatedIDFile(): File output: CustENFBImgMap.c");
    /* open file */
    fp = fopen(ENFB_DATA_FILENAME, "w");
    if(fp == NULL)
    {
        return MMI_FALSE;
    }

    /* print copyright */
    fprintf(fp, "/**\n *	Copyright Notice\n *	?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,\n *	Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.\n *  (It is illegal to remove this copyright notice from this software or any\n *  portion of it)\n */\n");
    fprintf(fp, "\n/************************************************************** \n FILENAME\t: CustENFBAssociatedMap.c \n PURPOSE\t: ENFB associated list file. \n REMARKS\t: nil \n AUTHOR\t\t: Customization Tool \n DATE\t\t: . \n **************************************************************/\n");

    /* print include file */
    fprintf(fp, "#include \"CustDataRes.h\"\n\n");

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */

    /* print list count */
    fprintf(fp, "const U32 CurrMaxENFBAssociatedIDNum = %d;\n\n", CurrMaxENFBAssociatedIDNum + 1);

    /* dump ID list */
    for (i = 1; i <= (int)CurrMaxENFBAssociatedIDNum; i++)
    {
        enfb = (CUSTOM_ENFB_STR *)&ENFBAssociatedIDList[i];
        fprintf(fp, "const U16 Associated_IDs_%d[] = {", i);
        for (j = 0; j < (int)enfb->count - 1; j++)
        {
            fprintf(fp, "%d, ", enfb->IDs[j]);
        }
        fprintf(fp, "%d};\n", enfb->IDs[enfb->count - 1]);
    }
    fprintf(fp, "\n");

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */

    /* dump CUSTOM_ENFB list */
    fprintf(fp, "const CUSTOM_ENFB AssociatedID_map[] = \n{\n");
    if (CurrMaxENFBAssociatedIDNum > 0)
    {
#if 0
/* under construction !*/
#endif /* 0 */
        fprintf(fp, "\t{0, 0},\n");
    }
    else
    {
#if 0
/* under construction !*/
#endif /* 0 */
        fprintf(fp, "\t{0, 0}\n");
    }
    if (CurrMaxENFBAssociatedIDNum > 0)
    {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */
        for (i = 1; i < (int)CurrMaxENFBAssociatedIDNum; i++)
        {
            enfb = (CUSTOM_ENFB_STR *)&ENFBAssociatedIDList[i];
            fprintf(fp, "\t{%d, (U16 *)&Associated_IDs_%d},\n", enfb->count, i);
        }
        fprintf(fp, "\t{%d, (U16 *)&Associated_IDs_%d}\n",
            ENFBAssociatedIDList[CurrMaxENFBAssociatedIDNum].count,
            CurrMaxENFBAssociatedIDNum);
    }
    fprintf(fp, "};\n");

    /* free memory */
    for (i = 1; i <= (int)CurrMaxENFBAssociatedIDNum; i++)
    {
        enfb = (CUSTOM_ENFB_STR *)&ENFBAssociatedIDList[i];
        free(enfb->IDs);
        for (j = 0; j < (int)enfb->count; j++)
        {
            free(enfb->Ptr[j]);
        }
        free(enfb->Ptr);
    }

    fprintf(stderr, "Output CustENFBImgMap.c... done\n");

    fclose(fp);
    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*  UnzipImage
* DESCRIPTION
*  unzip image to the destination folder
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void UnzipImage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    char tempCommand[UNZIP_CMD_BUFLEN];

    WIN32_FIND_DATA file_data;
    WIN32_FIND_DATA folder_data;
    HANDLE search = NULL;
    BOOL is_need_unzip = TRUE;

    FILE *zip_time_file = NULL;
    S32 wsize;
    FILETIME zip_time_prev;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("[UnzipImage] start");

    sprintf(tempCommand, "%s\\image.zip", CUST_IMG_PATH_ROOT);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\n", tempCommand);
    search = FindFirstFile(tempCommand, &file_data);
    if (search == INVALID_HANDLE_VALUE)
    {
        RESGEN_LOG_E("Didn't find MAINLCD's image.zip please check. ret=[%d] path=[%s]", GetLastError(), tempCommand);
        exit(2);
    }
    FindClose(search);

    sprintf(tempCommand, "%s\\\\image_zip_time_log", CUST_IMG_PATH_ROOT);
    zip_time_file = fopen(tempCommand, "rb");
    if (zip_time_file != NULL)
    {
        wsize = fread(&(zip_time_prev), sizeof(zip_time_prev), 1, zip_time_file);
        fclose(zip_time_file);
        if (wsize != 1)
        {
            RESGEN_LOG_E("Can't read [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
            exit(2);
        }

        if (CompareFileTime(&(file_data.ftLastWriteTime), &(zip_time_prev)) == 0)
        {
            is_need_unzip = FALSE;
            RESGEN_LOG_V("MAINLCD's image.zip is not changed, skip Unzip process...");
            fprintf(stderr, "MAINLCD's image.zip is not changed, skip Unzip process...\n");
        }
    }

    zip_time_file = fopen(tempCommand, "wb");
    if (zip_time_file == NULL)
    {
        RESGEN_LOG_E("[%s] could not open!", tempCommand);
        exit(2);
    }

    wsize = fwrite(&(file_data.ftLastWriteTime), sizeof(file_data.ftLastWriteTime), 1, zip_time_file);
    fclose(zip_time_file);
    if (wsize != 1)
    {
        RESGEN_LOG_E("Can't write [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
        exit(2);
    }


    if (is_need_unzip || g_is_clean)
    {
        fprintf(stderr, "Start Unzip images ...output 3rd_tool.log\n");

        sprintf(tempCommand,"rd /S/Q %s\\mainlcd\\ 2>> .\\debug\\3rd_tool.log", CUST_IMG_PATH_ROOT);
        execute_ext_command(tempCommand);

        sprintf(tempCommand,"rd /S/Q .\\AutoAnalysis 2>> .\\debug\\3rd_tool.log");
        execute_ext_command(tempCommand);

        sprintf(tempCommand, "7za.exe x -y %s\\image.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_IMG_PATH_ROOT, CUST_IMG_PATH_ROOT);
        execute_ext_command(tempCommand);
    }

#ifndef __OPTR_NONE__
    sprintf(tempCommand, "7za.exe x -y %s\\operator_image.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_OPERATOR_IMG_PATH, CUST_IMG_PATH_ROOT);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\\operator_image.zip\n", CUST_OPERATOR_IMG_PATH);
    execute_ext_command(tempCommand);
#endif /* __OPTR_NONE__ */



#if defined(CUST_SUBLCD_PATH)

    sprintf(tempCommand, "%s\\image.zip", CUST_SUBLCD_PATH);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\n", tempCommand);
    search = FindFirstFile(tempCommand, &file_data);
    if (search == INVALID_HANDLE_VALUE)
    {
        RESGEN_LOG_E("Didn't find SUBLCD's image.zip please check. ret=[%d]", GetLastError());
        exit(2);
    }
    FindClose(search);

    sprintf(tempCommand, "%s\\\\image_sub_zip_time_log", CUST_IMG_PATH_ROOT);
    zip_time_file = fopen(tempCommand, "rb");
    if (zip_time_file != NULL)
    {
        wsize = fread(&(zip_time_prev), sizeof(zip_time_prev), 1, zip_time_file);
        fclose(zip_time_file);
        if (wsize != 1)
        {
            RESGEN_LOG_E("Can't read [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
            exit(2);
        }

        if (CompareFileTime(&(file_data.ftLastWriteTime), &(zip_time_prev)) == 0)
        {
            is_need_unzip = FALSE;
            fprintf(stderr, "SUBLCD's image.zip is not changed, skip Unzip process...\n");
        }
    }

    zip_time_file = fopen(tempCommand, "wb");
    if (zip_time_file == NULL)
    {
        RESGEN_LOG_E("[%s] could not open!", tempCommand);
        exit(2);
    }

    wsize = fwrite(&(file_data.ftLastWriteTime), sizeof(file_data.ftLastWriteTime), 1, zip_time_file);
    fclose(zip_time_file);
    if (wsize != 1)
    {
        RESGEN_LOG_E("Can't write [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
        exit(2);
    }


    if (is_need_unzip || g_is_clean)
    {
        fprintf(stderr, "Start Unzip SUBLCD images ...output 3rd_tool.log\n");

        sprintf(tempCommand,"rd /S/Q %s\\sublcd\\ 2>> .\\debug\\3rd_tool.log", CUST_IMG_PATH_ROOT);
        execute_ext_command(tempCommand);

        sprintf(tempCommand, "7za.exe x -y %s\\image.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_SUBLCD_PATH, CUST_IMG_PATH_ROOT);
        execute_ext_command(tempCommand);
    }

#ifndef __OPTR_NONE__
    sprintf(tempCommand, "7za.exe x -y %s\\operator_image.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_OPERATOR_SUBLCD_PATH, CUST_IMG_PATH_ROOT);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\\operator_image.zip\n", CUST_OPERATOR_SUBLCD_PATH);
    execute_ext_command(tempCommand);
#endif /* __OPTR_NONE__ */

#endif /* defined (CUST_SUBLCD_PATH) */

    RESGEN_LOG_V("[UnzipImage] end");
}


/*****************************************************************************
* FUNCTION
*  UnzipAudio
* DESCRIPTION
*  unzip audio to the destination folder
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void UnzipAudio(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    char tempCommand[UNZIP_CMD_BUFLEN];

    WIN32_FIND_DATA file_data;
    WIN32_FIND_DATA folder_data;
    HANDLE search = NULL;
    BOOL is_need_unzip = TRUE;

    FILE *zip_time_file = NULL;
    S32 wsize;
    FILETIME zip_time_prev;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("[UnzipAudio] start");
    sprintf(tempCommand, "%s\\audio.zip", CUST_ADO_PATH);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\n", tempCommand);
    search = FindFirstFile(tempCommand, &file_data);
    if (search == INVALID_HANDLE_VALUE)
    {
        RESGEN_LOG_E("Didn't find audio.zip please check. ret=[%d] path=[%s]", GetLastError(), tempCommand);
        exit(2);
    }
    FindClose(search);

    sprintf(tempCommand, "%s\\\\audio_time_log", CUST_ADO_PATH);
    zip_time_file = fopen(tempCommand, "rb");
    if (zip_time_file != NULL)
    {
        wsize = fread(&(zip_time_prev), sizeof(zip_time_prev), 1, zip_time_file);
        fclose(zip_time_file);
        if (wsize != 1)
        {
            RESGEN_LOG_E("Can't read [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
            exit(2);
        }

        if (CompareFileTime(&(file_data.ftLastWriteTime), &(zip_time_prev)) == 0)
        {
            is_need_unzip = FALSE;
            RESGEN_LOG_V("AUDIO's audio.zip is not changed, skip Unzip process...");
            fprintf(stderr, "AUDIO's audio.zip is not changed, skip Unzip process...\n");
        }
    }

    zip_time_file = fopen(tempCommand, "wb");
    if (zip_time_file == NULL)
    {
        RESGEN_LOG_E("[%s] could not open!", tempCommand);
        exit(2);
    }

    wsize = fwrite(&(file_data.ftLastWriteTime), sizeof(file_data.ftLastWriteTime), 1, zip_time_file);
    fclose(zip_time_file);
    if (wsize != 1)
    {
        RESGEN_LOG_E("Can't write [%s][%d][%d]", tempCommand, wsize, sizeof(file_data.ftLastWriteTime));
        exit(2);
    }


    if (is_need_unzip || g_is_clean)
    {
        fprintf(stderr, "Start Unzip audios ...output 3rd_tool.log\n");

        sprintf(tempCommand, "7za.exe x -y %s\\audio.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_ADO_PATH, CUST_ADO_PATH);
        execute_ext_command(tempCommand);
    }
#ifndef __OPTR_NONE__
    sprintf(tempCommand, "7za.exe x -y %s\\operator_audio.zip -o%s\\ 2>> .\\debug\\3rd_tool.log", CUST_OPERATOR_ADO_PATH, CUST_ADO_PATH);
    RESGEN_LOG_V("[Dependency] plutommi\\Customer\\ResGenerator\\%s\\operator_audio.zip\n", CUST_OPERATOR_ADO_PATH);
    execute_ext_command(tempCommand);
#endif /* __OPTR_NONE__ */

    RESGEN_LOG_V("[UnzipAudio] end");
}


/*****************************************************************************
* FUNCTION
*  Trace
* DESCRIPTION
*
* PARAMETERS
*  fmt     [IN]
* RETURNS
*  void
*****************************************************************************/
extern "C" void MtkResgenTrace(char *fmt,...)
{
    return;
#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif    
}


/*****************************************************************************
* FUNCTION
*  PopulateSearchMap_Ext
* DESCRIPTION
*  populate search map
* PARAMETERS
*  pIdMap              [IN]    ID map
*  pIdSearchMap        [OUT]   ID search map
*  pCurrMaxId          [OUT]   current max ID
*  pCurrMaxSearchId    [OUT]   current max search ID
*  MaxIdSize           [IN]    max ID
* RETURNS
*  void
*****************************************************************************/
static void PopulateSearchMap_Ext(
                                  CUSTOM_ID_MAP *pIdMap,
                                  CUSTOM_ID_SEARCH_MAP *pIdSearchMap,
                                  unsigned short *pCurrMaxId,
                                  unsigned short *pCurrMaxSearchId,
                                  U16 MaxIdSize)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i = 0, j = 0;
    U16 index = 0, start = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Filed the min ID and max Id for search map structure */
    for (i = 0; i < MaxIdSize; i++)
    {
        if (pIdMap[i].Num != ((U16) - 1))
        {
            if (!start)
            {
                pIdSearchMap[j].minId = pIdSearchMap[j].maxId = i;
                pIdSearchMap[j].index = index;
                index++;
                start = 1;
            }
            else
            {
                pIdSearchMap[j].maxId = i;
                index++;
            }
        }
        else
        {
            if (start)
            {
                j++;
                start = 0;
            }
        }
    }

    /* Find current max id */
    *pCurrMaxSearchId = j;
    j = 0;
    /* Move the pIdMap[n] so that the ID MAP items are continous  */
    for (i = 0; i < MaxIdSize; i++)
    {
        if (pIdMap[i].Num != (U16)-1)
        {
            if (i != j)
            {

                pIdMap[j].Num = pIdMap[i].Num;
                pIdMap[i].Num = -1;
            }
            j++;
        }
    }

    *pCurrMaxId = j;
}


/*****************************************************************************
* FUNCTION
*  PopulateImageSearch
* DESCRIPTION
*  populate image search map
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void PopulateImageSearch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("PopulateImageSearch(): Filled ID map and search map tables");
    PopulateSearchMap_Ext(
        (CUSTOM_ID_MAP *)ImageIdMap,
        (CUSTOM_ID_SEARCH_MAP *)ImageIdSearchMap,
        (unsigned short *)&CurrMaxImageId,
        (unsigned short *)&CurrMaxSearchImageId,
        MAX_IMAGE_IDS_SIZE);
    PopulateSearchMap_Ext(
        (CUSTOM_ID_MAP *)ImageIdMapEXT,
        (CUSTOM_ID_SEARCH_MAP *)ImageIdSearchMapEXT,
        (unsigned short *)&CurrMaxImageIdEXT,
        (unsigned short *)&CurrMaxSearchImageIdEXT,
        MAX_IMAGE_IDS_SIZE);
}


/*****************************************************************************
* FUNCTION
*  PopulateAudioSearch
* DESCRIPTION
*  populate audio search map
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void PopulateAudioSearch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("PopulateAudioSearch(): Filled ID map and search map tables");

    PopulateSearchMap_Ext(
        (CUSTOM_ID_MAP *)AudioIdMap,
        (CUSTOM_ID_SEARCH_MAP *)AudioIdSearchMap,
        (unsigned short *)&CurrMaxAudioId,
        (unsigned short *)&CurrMaxSearchAudioId,
        MAX_AUDIO_IDS_SIZE);
    PopulateSearchMap_Ext(
        (CUSTOM_ID_MAP *)AudioIdMapEXT,
        (CUSTOM_ID_SEARCH_MAP *)AudioIdSearchMapEXT,
        (unsigned short *)&CurrMaxAudioIdEXT,
        (unsigned short *)&CurrMaxSearchAudioIdEXT,
        MAX_AUDIO_IDS_SIZE);
}


/*****************************************************************************
* FUNCTION
*  PopulateFontSearch
* DESCRIPTION
*  populate Font search map
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void PopulateFontSearch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("PopulateFontSearch(): Filled ID map and search map tabls");

    PopulateSearchMap_Ext(
        (CUSTOM_ID_MAP *)FontIdMapEXT,
        (CUSTOM_ID_SEARCH_MAP *)FontIdSearchMapEXT,
        (unsigned short *)&CurrMaxFontIdEXT,
        (unsigned short *)&CurrMaxSearchFontIdEXT,
        MAX_FONT_IDS_SIZE);
}

/*****************************************************************************
* FUNCTION
*  GenerateResFile_Ext
* DESCRIPTION
*  generate resource file
* PARAMETERS
*  flag                [IN]    CustPack or not
*  type                [IN]    image or audio
*  pName               [IN]    resource name list
*  nSize               [IN]    size
*  str_CustDataHW      [IN]    output header name
*  str_mtk_CurrMaxNum  [IN]    output variable name
*  str_CurrMaxNum      [IN]    output variable name
*  str_mtk_nCustNames  [IN]    output variable name
*  str_nCustNames      [IN]    output variable name
*  str_NameList        [IN]    output variable name
*  str_CustType        [IN]    output type name
*  curr_data_filename  [IN]    output file name
* RETURNS
*  void
*****************************************************************************/
static void GenerateResFile_Ext(
                                BOOL flag,
                                RESOURCE_TYPE_LIST type,
                                CUSTOM_NAME_LIST *pName,
                                U16 nSize,
                                char *str_CustDataHW,
                                char *str_mtk_CurrMaxNum,
                                char *str_CurrMaxNum,
                                char *str_mtk_nCustNames,
                                char *str_nCustNames,
                                char *str_NameList,
                                char *str_CustType,
                                char *curr_data_filename,
                                U32 extFlag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *pFile;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pFile = fopen(curr_data_filename, "w"))
    {
        fprintf(pFile, "/**\n *	Copyright Notice\n *	?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,\n *	Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.\n *  (It is illegal to remove this copyright notice from this software or any\n *  portion of it)\n */\n");
        fprintf(pFile, "\n/************************************************************** \n FILENAME	:  \n PURPOSE		: Resource file. \n REMARKS		: nil \n AUTHOR		: Customization Tool \n DATE		: . \n **************************************************************/\n");
        fprintf(pFile, "#include \"CustDataRes.h\"\n");
        fprintf(pFile, "#include \"CustResDef.h\"\n\n");

#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
        if(type == RES_FONT)
        {
            fprintf(pFile, "#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__\n");
            fprintf(pFile, "#include \"GlobalResDef.h\"\n");
            fprintf(pFile, "#endif\n");
        }
#endif
        if(type == RES_FONT)
        {
            fprintf(pFile, "extern CUSTOM_FONT_MAP mtk_CustFontMapEXT[];\n");
            fprintf(pFile, "extern CUSTOM_FONT_SEARCH_MAP mtk_CustFontSearchMapEXT[];\n");
        }
        else if(type == RES_IMAGE)
        {
            if(flag == FALSE)
            {
                fprintf(pFile, "const S8 CustImgPath[]=CUST_IMG_PATH;\n");
            }
            else
            {
                fprintf(pFile, "\/\/const S8 CustImgPath[]=CUST_IMG_PATH;\n");
// Append a dummy image for CAT reserved space only when __CAT_SUPPORT__ is defined
#if defined(__CAT_SUPPORT__) && defined(MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE) && (MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE > 0)
                fprintf(pFile, "extern const U8 cat_reserved_space[];\n");
#endif
            }
        }
        else if(type == RES_AUDIO)
        {
            if(flag == FALSE)
            {
                fprintf(pFile, "const S8 CustAdoPath[]=CUST_ADO_PATH;\n");
            }
            else
            {
                fprintf(pFile, "\/\/const S8 CustAdoPath[]=CUST_ADO_PATH;\n");
            }
        }
        else if(type == RES_BINARY)
        {
            fprintf(pFile, "const S8 CustBinaryPath[]=CUST_BINARY_PATH;\n");
        }

#ifdef __MULTI_BIN_LOAD__
        fprintf(pFile, "const unsigned short  %s=%d;\n", str_mtk_CurrMaxNum, nSize);
#else
        fprintf(pFile, "unsigned short  %s=%d;\n", str_CurrMaxNum, nSize);
#endif

        if((type == RES_IMAGE) && (flag == FALSE))
        {
        
            fputs("\n#include \"ResCompressConfig.h\"\n\n", pFile);
            fprintf( pFile, "#include \"CustGameDataHW.h\"\n");
            fprintf( pFile, "#if !defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n");
            fprintf( pFile, "#include \"%s\"\n", str_CustDataHW);
        }else{
            fprintf(pFile, "#include \"%s\"\n", str_CustDataHW);	        
        }


        /* writing the image filename inside the file. */
        if(nSize)
        {
            int i = 0;

#ifdef __MULTI_BIN_LOAD__
            fprintf(pFile, "const %s	%s[]={\n", str_CustType, str_mtk_nCustNames);
#else
            fprintf(pFile, "const %s	%s[]={\n", str_CustType, str_nCustNames);
#endif

            for(i = 0; i < nSize; i++)
            {
                S8 pBuffName[512];

                Extract_Name(pBuffName, pName[i].filename, extFlag);
                #ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
                if(type == RES_FONT)
                    fprintf(pFile, "(U8*)NULL,\n");
                else
                #endif
                fprintf(pFile, "(U8*)&%s,\n", pBuffName);
            }

#if defined(__CAT_SUPPORT__) && defined(MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE) && (MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE > 0)
            /* Add reserved space for CAT tool to image RES regions*/
            if(type == RES_IMAGE && flag != FALSE){
                fprintf(pFile, "(U8*)&cat_reserved_space,\n");
            }
#endif
            fprintf(pFile, "};\n\n\n\n");
        }
        else
        {
#ifdef __MULTI_BIN_LOAD__
            fprintf(pFile, "const %s	%s[1] = {NULL};\n", str_CustType, str_mtk_nCustNames);
#else
            fprintf(pFile, "const %s	%s[1] = {NULL};\n", str_CustType, str_nCustNames);
#endif
        }

        if(flag == TRUE)
        {
            if(type == RES_IMAGE)
            {
#ifdef __MULTI_BIN_LOAD__
                fprintf(pFile, "const CUSTPACK_IMAGE_HEADER mtk_image_header={%d, (%s *)%s};", nSize, str_CustType, str_mtk_nCustNames);
#else
                fprintf(pFile, "const CUSTPACK_IMAGE_HEADER mtk_image_header={%d, (%s *)%s};", nSize, str_CustType, str_nCustNames);
#endif
            }

            if(type == RES_AUDIO)
            {
#ifdef __MULTI_BIN_LOAD__
                fprintf(pFile, "const CUSTPACK_AUDIO_HEADER mtk_audio_header={%d, (%s *)%s};", nSize, str_CustType, str_mtk_nCustNames);
#else
                fprintf(pFile, "const CUSTPACK_AUDIO_HEADER mtk_audio_header={%d, (%s *)%s};", nSize, str_CustType, str_nCustNames);
#endif
            }

            if(type == RES_BINARY)
            {
                fprintf(pFile, "const CUSTPACK_BINARY_HEADER mtk_binary_header={%d, (%s *)%s};", nSize, str_CustType, str_nCustNames);
            }

            if(type == RES_FONT)
            {
                int i = 0;
				
#ifdef __MULTI_BIN_LOAD__
                fprintf(pFile, "const CUSTPACK_FONT_HEADER mtk_font_header={%d, %d, (%s *)%s, mtk_CustFontMapEXT, mtk_CustFontSearchMapEXT};", nSize, CurrMaxSearchFontIdEXT, str_CustType, str_mtk_nCustNames);
#else
                fprintf(pFile, "const CUSTPACK_FONT_HEADER mtk_font_header={%d, %d, (%s *)%s, mtk_CustFontMapEXT, mtk_CustFontSearchMapEXT};", nSize, CurrMaxSearchFontIdEXT, str_CustType, str_nCustNames);
#endif
                #ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
                fprintf(pFile, "\n\n#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__\n");
                fprintf(pFile, "ENFB_Font_Res_Info ENFBFontResInfo[] = {\n");
                for(i = 0; i < nSize; i++)
                {
                    fprintf(pFile, "{%s%d, 0x%x, 0x%x},\n", "IMG_GLOBAL_FONT_", ENFBFontResInfo[i].res_id, ENFBFontResInfo[i].offset, ENFBFontResInfo[i].size);
                }
                fprintf(pFile, "};\n");
                fprintf(pFile, "#endif\n");
                #endif
            }

        }else{
            if((type == RES_IMAGE))
	    {
	        fprintf( pFile, "#endif//!__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__ || __MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__\n");
            }
        }
        fclose(pFile);
    }
}



/*****************************************************************************
* FUNCTION
*  GenerateImageResFile
* DESCRIPTION
*  generate image resource file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateImageResFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateImageResFile(): File output: CustImgDataHW.h CustImgDataHWExt.h");
    // create group image meta file
    ImageGroupMappingMetaCreator * metaCreator = new ImageGroupMappingMetaCreator();
    for(int i =0; i< CurrMaxImageNum; i++ ){
        S8 pBuffName[512];
        Extract_Name(pBuffName, ImageNameList[i].filename, SYSTEM_IMAGE);
        metaCreator->addImage(pBuffName);
    }
    metaCreator->generateMetaFile("..\\..\\Customer\\CustResource\\CustImgMapMeta.txt");
    delete metaCreator;
	
    GenerateResFile_Ext(
        FALSE,
        RES_IMAGE,
        (CUSTOM_NAME_LIST *)ImageNameList,
        CurrMaxImageNum,
        "CustImgDataHW.h",
        "mtk_CurrMaxImageNum",
        "CurrMaxImageNum",
        "mtk_nCustImageNames",
        "nCustImageNames",
        "ImageNameList",
        "CUSTOM_IMAGE",
        IMG_DATA_FILENAME,
        SYSTEM_IMAGE);
    GenerateResFile_Ext(
        TRUE,
        RES_IMAGE,
        (CUSTOM_NAME_LIST *)ImageNameListEXT,
        CurrMaxImageNumEXT,
        "CustImgDataHWExt.h",
        "mtk_CurrMaxImageNumEXT",
        "CurrMaxImageNumEXT",
        "mtk_nCustImageNamesEXT",
        "nCustImageNamesEXT",
        "ImageNameListEXT",
        "CUSTOM_IMAGE",
        IMG_DATA_FILENAME_EXT,
        EXT_IMAGE);
}


/*****************************************************************************
* FUNCTION
*  GenerateAudioResFile
* DESCRIPTION
*  generate aurio resource file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateAudioResFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateAudioResFile(): File output: CustAdoDataHW.h CustAdoDataHWExt.h");
    GenerateResFile_Ext(
        FALSE,
        RES_AUDIO,
        (CUSTOM_NAME_LIST *)AudioNameList,
        CurrMaxAudioNum,
        "CustAdoDataHW.h",
        "mtk_CurrMaxAudioNum",
        "CurrMaxAudioNum",
        "mtk_nCustAudioNames",
        "nCustAudioNames",
        "AudioNameList",
        "CUSTOM_AUDIO",
        ADO_DATA_FILENAME,
        FALSE);
    GenerateResFile_Ext(
        TRUE,
        RES_AUDIO,
        (CUSTOM_NAME_LIST *)AudioNameListEXT,
        CurrMaxAudioNumEXT,
        "CustAdoDataHWExt.h",
        "mtk_CurrMaxAudioNumEXT",
        "CurrMaxAudioNumEXT",
        "mtk_nCustAudioNamesEXT",
        "nCustAudioNamesEXT",
        "AudioNameListEXT",
        "CUSTOM_AUDIO",
        ADO_DATA_FILENAME_EXT,
        TRUE);
}



/*****************************************************************************
* FUNCTION
*  GenerateFontResFile
* DESCRIPTION
*  generate Font resource file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateFontResFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateFontResFile(): File output: CustFontRes.c CustFontResExt.c");

    GenerateResFile_Ext(
        TRUE,
        RES_FONT,
        (CUSTOM_NAME_LIST *)FontNameListEXT,
        CurrMaxFontNumEXT,
        "CustFontDataHW.h",
        "mtk_CurrMaxFontNumEXT",
        "CurrMaxFontNumEXT",
        "mtk_nCustFontNamesEXT",
        "nCustFontNamesEXT",
        "FontNameListEXT",
        "CUSTOM_FONT",
        FONT_DATA_FILENAME_EXT,
        EXT_FONT);
}


/*****************************************************************************
* FUNCTION
*  GenerateMapFile_Ext
* DESCRIPTION
*  generate ID map file
* PARAMETERS
*  pMap                [IN]    ID map
*  nSize               [IN]    size
*  str_IdMap           [IN]    output variable name
*  str_CustMap         [IN]    output variable name
*  str_CurrMaxId       [IN]    output variable name
*  str_CustType        [IN]    output variable name
*  curr_map_filename   [IN]    output file name
* RETURNS
*  void
*****************************************************************************/
static void GenerateMapFile_Ext(
                                CUSTOM_ID_MAP *pMap,
                                U16 nSize,
                                char *str_IdMap,
                                char *str_CustMap,
                                char *str_CurrMaxId,
                                char *str_CustType,
                                char *curr_map_filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *pFile;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pFile = fopen(curr_map_filename, "w"))
    {
        fprintf(pFile, "/**\n *	Copyright Notice\n *	?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,\n *	Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.\n *  (It is illegal to remove this copyright notice from this software or any\n *  portion of it)\n */\n");
        fprintf(pFile, "\n/************************************************************** \n FILENAME	: %s \n PURPOSE		: Resource Map file. \n REMARKS		: nil \n AUTHOR		: Customization Tool \n DATE		: . \n **************************************************************/\n", str_CustMap);
        fprintf(pFile, "#include \"CustDataRes.h\"\n\n\n");
        fprintf(pFile, "unsigned short %s=%d;\n", str_CurrMaxId, nSize);

        /* writing the map array inside the file. */
        if(nSize)
        {
            int i;

            fprintf(pFile, "const %s %s[]={\n", str_CustType, str_IdMap);
            for(i = 0; i < nSize; i++)
            {
                fprintf(pFile,"\t{%d},\n", pMap[i].Num);
            }
            fprintf(pFile, "};\n\n\n\n");
        }
        else
        {
            fprintf(pFile, "const %s %s[1];\n", str_CustType, str_IdMap);
        }
        fclose(pFile);
    }
}


/*****************************************************************************
* FUNCTION
*  GenerateImageMapFile
* DESCRIPTION
*  generate image ID map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateImageMapFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateImageMapFile(): File output: CustImageMap.c CustImageMapExt.c");
    GenerateMapFile_Ext(
        (CUSTOM_ID_MAP *)ImageIdMap,
        CurrMaxImageId,
        "ImageIdMap",
        "CustImageMap.c",
        "CurrMaxImageId",
        "CUSTOM_IMAGE_MAP",
        IMG_MAP_FILENAME);
    GenerateMapFile_Ext(
        (CUSTOM_ID_MAP *)ImageIdMapEXT,
        CurrMaxImageIdEXT,
        "ImageIdMapEXT",
        "CustImageMapExt.c",
        "CurrMaxImageIdEXT",
        "CUSTOM_IMAGE_MAP",
        IMG_MAP_FILENAME_EXT);
}


/*****************************************************************************
* FUNCTION
*  GenerateAudioMapFile
* DESCRIPTION
*  generate audio ID map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateAudioMapFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateAudioMapFile(): File output: CustAdoMap.c CustAdoMapExt.c");

    GenerateMapFile_Ext(
        (CUSTOM_ID_MAP *)AudioIdMap,
        CurrMaxAudioId,
        "AudioIdMap",
        "CustAudioMap.c",
        "CurrMaxAudioId",
        "CUSTOM_AUDIO_MAP",
        ADO_MAP_FILENAME);
    GenerateMapFile_Ext(
        (CUSTOM_ID_MAP *)AudioIdMapEXT,
        CurrMaxAudioIdEXT,
        "AudioIdMapEXT",
        "CustAudioMapExt.c",
        "CurrMaxAudioIdEXT",
        "CUSTOM_AUDIO_MAP",
        ADO_MAP_FILENAME_EXT);
}



/*****************************************************************************
* FUNCTION
*  GenerateFontMapFile
* DESCRIPTION
*  generate Font ID map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateFontMapFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateFontMapFile(): File output: CustFontMap.c CustFontMapExt.c");

    GenerateMapFile_Ext(
        (CUSTOM_ID_MAP *)FontIdMapEXT,
        CurrMaxFontIdEXT,
        "mtk_CustFontMapEXT",
        "CustFontMapExt.c",
        "mtk_CurrMaxFontIdEXT",
        "CUSTOM_FONT_MAP",
        FONT_MAP_FILENAME_EXT);
}

/*****************************************************************************
* FUNCTION
*  GenerateMapSearchFile_Ext
* DESCRIPTION
*  generate ID search map file
* PARAMETERS
*  pMap                [IN]    ID search map
*  nSize               [IN]    size
*  str_CurrMaxSearchId [IN]    output variable name
*  str_IdSearchMap     [IN]    output variable name
*  str_CustType        [IN]    output variable name
*  curr_map_filename   [IN]    output file name
* RETURNS
*  void
*****************************************************************************/
static void GenerateMapSearchFile_Ext(
                                      CUSTOM_ID_SEARCH_MAP *pMap,
                                      U16 nSize,
                                      char *str_CurrMaxSearchId,
                                      char *str_IdSearchMap,
                                      char *str_CustType,
                                      char *curr_map_filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *pFile;
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pFile = fopen(curr_map_filename, "a"))
    {
        fprintf(pFile, "const unsigned short %s=%d;\n", str_CurrMaxSearchId, nSize);

        /* writing the search map array inside the file. */
        if(nSize)
        {
            fprintf(pFile, "const %s %s[]={\n", str_CustType, str_IdSearchMap);
            for(i = 0; i < nSize; i++)
            {
                fprintf(pFile, "\t{%d,%d,%d},\n", pMap[i].minId, pMap[i].maxId, pMap[i].index);
            }
            fprintf(pFile, "};\n\n\n\n");
        }
        else
        {
            fprintf(pFile, "%s %s[1];", str_CustType, str_IdSearchMap);
        }
        fclose(pFile);
    }
}


/*****************************************************************************
* FUNCTION
*  GenerateImageMapSearchFile
* DESCRIPTION
*  generate image search map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateImageMapSearchFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateImageMapSearchFile(): File output: CustImgMap.c CustImgMapExt.c");

    GenerateMapSearchFile_Ext(
        (CUSTOM_ID_SEARCH_MAP *)ImageIdSearchMap,
        CurrMaxSearchImageId,
        "CurrMaxSearchImageId",
        "ImageIdSearchMap",
        "CUSTOM_IMAGE_SEARCH_MAP",
        IMG_MAP_FILENAME);
    GenerateMapSearchFile_Ext(
        (CUSTOM_ID_SEARCH_MAP *)ImageIdSearchMapEXT,
        CurrMaxSearchImageIdEXT,
        "CurrMaxSearchImageIdEXT",
        "ImageIdSearchMapEXT",
        "CUSTOM_IMAGE_SEARCH_MAP",
        IMG_MAP_FILENAME_EXT);
}


/*****************************************************************************
* FUNCTION
*  GenerateAudioMapSearchFile
* DESCRIPTION
*  generate audio search map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateAudioMapSearchFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateAudioMapSearchFile(): File output: CustAdoMap.c CustAdoMapExt.c");

    GenerateMapSearchFile_Ext(
        (CUSTOM_ID_SEARCH_MAP *)AudioIdSearchMap,
        CurrMaxSearchAudioId,
        "CurrMaxSearchAudioId",
        "AudioIdSearchMap",
        "CUSTOM_AUDIO_SEARCH_MAP",
        ADO_MAP_FILENAME);
    GenerateMapSearchFile_Ext(
        (CUSTOM_ID_SEARCH_MAP *)AudioIdSearchMapEXT,
        CurrMaxSearchAudioIdEXT,
        "CurrMaxSearchAudioIdEXT",
        "AudioIdSearchMapEXT",
        "CUSTOM_AUDIO_SEARCH_MAP",
        ADO_MAP_FILENAME_EXT);
}



#if defined(__MMI_RESOURCE_AUDIO_COMPRESS__) || defined(__MMI_RESOURCE_IMAGE_COMPRESS__)
/*****************************************************************************
* FUNCTION
*  GenerateAudioZipList
* DESCRIPTION
*  generate Zip list structure
* PARAMETERS
*  pMap                [IN]    ID map
*  nSize               [IN]    size
*  str_IdMap           [IN]    output variable name
*  str_CustMap         [IN]    output variable name
*  str_CurrMaxId       [IN]    output variable name
*  str_CustType        [IN]    output variable name
*  curr_map_filename   [IN]    output file name
* RETURNS
*  void
*****************************************************************************/
static void GenerateZipList(
                            res_compress_struct *pCompress,
                            U16 nSize,
                            char *str_zip_count,
                            char *str_zip_struct,
                            char *str_zip_type,
                            char *curr_map_filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *pFile;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pFile = fopen(curr_map_filename, "a"))
    {

        /* Write extern of array */
        for(i = 0; i < nSize; i++)
        {
            fprintf(pFile, "extern __align(4) U8 %s[];\n", pCompress[i].zi_name);
            fprintf(pFile, "extern __align(4) const U8 %s[];\n", pCompress[i].ro_name);
        }


        fprintf(pFile, "const unsigned short %s=%d;\n", str_zip_count, nSize);

        /* writing the search map array inside the file. */
        if(nSize != 0)
        {
            fprintf(pFile, "const %s %s[]={\n", str_zip_type, str_zip_struct);
            for(i = 0; i < nSize; i++)
            {
                fprintf(pFile, "\t{(U8*)&%s, %d, (U8*)&%s, %d},\n",
                    pCompress[i].zi_name,
                    pCompress[i].zi_len,
                    pCompress[i].ro_name,
                    pCompress[i].ro_len);
            }
            fprintf(pFile, "};\n\n\n\n");
        }
        else
        {
            fprintf(pFile, "%s %s[1];", str_zip_type, str_zip_struct);
        }
        fclose(pFile);
    }
}

#endif /* define(__MMI_RESOURCE_AUDIO_COMPRESS__) || defined(__MMI_RESOURCE_IMAGE_COMPRESS__) */


#if defined(__MMI_RESOURCE_AUDIO_COMPRESS__)

extern res_compress_struct res_compress_data[];
extern U32 res_compress_count;

static void GenerateAudioZipList(void)
{
    RESGEN_LOG_V("GenerateImageZipList(): File output: Append zipped image table to CustAdoRes.c CustAdoResExt.c");

    GenerateZipList(
        res_compress_data,
        res_compress_count,
        "mmi_res_zip_aud_count",
        "mmi_res_zip_aud_struct",
        "res_compress_list_struct",
        ADO_DATA_FILENAME);
}

#endif

#if defined(__MMI_RESOURCE_IMAGE_COMPRESS__)

extern res_compress_struct g_res_compress_data_image[];
extern U32 g_res_compress_count_image;

static void GenerateImageZipList(void)
{
    RESGEN_LOG_V("GenerateImageZipList(): File output: Append zipped image table to CustImgRes.c CustImgResExt.c");
    GenerateZipList(
        g_res_compress_data_image,
        g_res_compress_count_image,
        "mmi_res_zip_img_count",
        "mmi_res_zip_img_struct",
        "res_compress_list_struct",
        IMG_DATA_FILENAME);
}

#endif



/*****************************************************************************
* FUNCTION
*  GenerateFontMapSearchFile
* DESCRIPTION
*  generate Font search map file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void GenerateFontMapSearchFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateFontMapSearchFile(): File output: CustFontMap.c CustFontMapExt.c");

    GenerateMapSearchFile_Ext(
        (CUSTOM_ID_SEARCH_MAP *)FontIdSearchMapEXT,
        CurrMaxSearchFontIdEXT,
        "mtk_CurrMaxSearchFontIdEXT",
        "mtk_CustFontSearchMapEXT",
        "CUSTOM_FONT_SEARCH_MAP",
        FONT_MAP_FILENAME_EXT);
}



/*****************************************************************************
* FUNCTION
*  GenerateMenuFile
* DESCRIPTION
*  generate menu resource file
* PARAMETERS
*  nSize       [IN]    size
* RETURNS
*  int
*****************************************************************************/
static int GenerateMenuFile(U16 nSize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE* pFile;
    CUSTOM_MENU* pCustMenu = (CUSTOM_MENU*)nCustMenus;
    S8 nItemData[100];      /* Assumed ..*/
    S8 MenuItemString[500]; /* Assumed ..*/
    int i,j;
    int start = 0, index = 0, num_map_search = 0;
    int min_id = 0, max_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RESGEN_LOG_V("GenerateMenuFile(): nSize = %d",nSize);

    if(pFile = fopen(MENU_DATA_FILENAME, "w"))
    {
        fprintf(pFile, "/**\n *	Copyright Notice\n *	?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,\n *	Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.\n *  (It is illegal to remove this copyright notice from this software or any\n *  portion of it)\n */\n");
        fprintf(pFile, "\n/************************************************************** \n FILENAME	: CustMenuRes.c \n PURPOSE		: Menu Resource file. \n REMARKS		: nil \n AUTHOR		: Customization Tool \n DATE		: . \n **************************************************************/\n");

        /* put the headers needed here */
        fprintf(pFile, "#include \"CustMenuRes.h\"\n\n\n");
        fprintf(pFile, "unsigned short  CurrMaxMenuItemIndex=%d;\n", nSize);

        /* writing the string array inside the file. */
        if(nSize)
        {
            for(i = 0; i < nSize; i++)
            {
                if(pCustMenu[i].nNumofMenuItem)
                {
                    sprintf(MenuItemString, "const U16 nOrderMenuItem_%d[]={", i);
                    for(j = 0; j < (pCustMenu[i].nNumofMenuItem - 1); j++)
                    {
                        sprintf(nItemData, "%d,", pCustMenu[i].nOrderMenuItemId[j]);
                        strcat(MenuItemString, nItemData);
                    }
                    sprintf(nItemData, "%d};", pCustMenu[i].nOrderMenuItemId[j]);
                    strcat(MenuItemString, nItemData);
                    fprintf(pFile, "%s\n", MenuItemString);
                }

            }
            fprintf(pFile, "\n const CUSTOM_MENU		mtk_nCustMenus[]={\n");
            /* write a dummy entry at index 0 */
            fprintf(pFile, "{0, 0, 0, 0, 0, 0, (U16 *)0},\n");
            for(i = 0; i < nSize; i++)
            {
                if(pCustMenu[i].nParentId < MAX_MENU_ITEMS)
                {
                    if(pCustMenu[i].nNumofMenuItem)
                        sprintf(MenuItemString, "{%d,%d,%d,%d,%d,%d,(U16 *)nOrderMenuItem_%d},",  pCustMenu[i].nParentId, pCustMenu[i].nNumofMenuItem, pCustMenu[i].nFlags, pCustMenu[i].nDispAttribute, pCustMenu[i].nStrId, pCustMenu[i].nImageId, i);
                    else
                        sprintf(MenuItemString, "{%d,%d,%d,%d,%d,%d,(U16 *)0},", pCustMenu[i].nParentId, pCustMenu[i].nNumofMenuItem, pCustMenu[i].nFlags, pCustMenu[i].nDispAttribute, pCustMenu[i].nStrId, pCustMenu[i].nImageId);
                    fprintf(pFile, "%s\n", MenuItemString);
                }
            }
            fprintf(pFile, "};\n");

            fprintf(pFile, "\n\n#ifdef __MULTIPLE_BINARY_FILES__\n");
            fprintf(pFile, "    /* we give more 50% ram for multiple bin, if Menus more than this, will be assert. */\n");
            fprintf(pFile, "    #define AV_TOTAL_MENU_ITEM ((sizeof(mtk_nCustMenus)/sizeof(CUSTOM_MENU))*1.5)\n");
            fprintf(pFile, "#else\n");
            fprintf(pFile, "    #define AV_TOTAL_MENU_ITEM (sizeof(mtk_nCustMenus)/sizeof(CUSTOM_MENU))\n");
            fprintf(pFile, "#endif\n\n");
            fprintf(pFile, "const S32 mtk_gAv_total_menuitem = ((U32)AV_TOTAL_MENU_ITEM);\n");
            fprintf(pFile, "/* Hide menu item mask */\nU8 MenuItemMask[(((U32)AV_TOTAL_MENU_ITEM) / 8) + 1];\n");
            fprintf(pFile, "/* Disable (dimmed) menu item mask */\nU8 g_menuitem_disable_mask[(((U32)AV_TOTAL_MENU_ITEM) / 8) + 1];\n\n\n");

            fprintf(pFile, "\n const CUSTOM_MENU_SEARCH_MAP		CustMenuSearchMap[]={\n");
            for(i = 0; i < nSize; i++)
            {
                if(pCustMenu[i].nParentId < MAX_MENU_ITEMS)
                {
                    if (!start)
                    {
                        min_id = max_id = i + 1;
                        start = 1;
                    }
                    else
                    {
                        max_id++;
                    }
                }
                else
                {
                    if (start)
                    {
                        fprintf(pFile, "\t{%d, %d, %d},\n", min_id, max_id, index + 1); /* index + 1 for the leading dummy entry */
                        index += max_id - min_id + 1;
                        num_map_search++;
                        start = 0;
                    }
                }
            }

            fprintf(pFile, "};\n");
            fprintf(pFile, "const CUSTOM_MENU_RES_ENTRY mtk_gMenuResEntry = {(CUSTOM_MENU*)mtk_nCustMenus, (CUSTOM_MENU_SEARCH_MAP*)CustMenuSearchMap, %d};\n", num_map_search);
        }
        else
        {
            fprintf(pFile, "const CUSTOM_MENU		nCustMenus[1];");
        }
        fclose(pFile);
    }
    else
    {
        return 0;
    }

    /* Menuitem reduce memory, move registe hilite handlers to resgen */
    if(pFile = fopen(MENU_HANDLER_FILENAME, "w"))
    {
        /* Output to head file MENU_HANDLER_FILENAME */
        /* File Header */
        fprintf(pFile, "/*****************************************************************************\n*  Copyright Statement:\n*  --------------------\n*  This software is protected by Copyright and the information contained\n*  herein is confidential. The software may not be copied and the information\n*  contained herein may not be used or disclosed except with the written\n*  permission of MediaTek Inc. (C) 2005\n*\n*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES\n*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS (\"MEDIATEK SOFTWARE\")\n*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON\n*  AN \"AS-IS\" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,\n*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF\n*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.\n*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE\n*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR\n*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH\n*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO\n*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S\n*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.\n*\n*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE\n*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,\n*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,\n*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO\n*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. \n*\n*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE\n*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF\n*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND\n*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER\n*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).\n*\n*****************************************************************************/\n\n");
        fprintf(pFile, "/*******************************************************************************\n * Filename:\n * ---------\n *  mmi_menu_handlers.h\n *\n * Project:\n * --------\n *   MAUI\n *\n * Description:\n * ------------\n *   Hilite handlers and Hint handlers of menuitems\n *\n * Author:\n * -------\n *  Resource Generator\n *\n*==============================================================================\n *              HISTORY\n * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! \n *------------------------------------------------------------------------------\n * $Log$\n *\n *\n *------------------------------------------------------------------------------\n * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! \n *============================================================================== \n *******************************************************************************/\n");
        /* Define Extern and Include */
        fprintf(pFile, "\n#ifndef _MENUHANDLER_H\n#define _MENUHANDLER_H\n");
        fprintf(pFile, "\n/* need typedef void (*FuncPtr) (void); before include this file */\n\n");
        fprintf(pFile, "/* #define MENU_HILITE_HANDLER_COUNT   %d; */\n/* #define MENU_HINT_HANDLER_COUNT     %d; */\n\n", HiliteHdlrCount, HintHdlrCount);

        fprintf(pFile, "#include \"mmi_rp_all_defs.h\"\n");
        /* Extern of handler functions */
        fprintf(pFile, "/* Extern functions of Hilite Handler */\n");
        for (i=0; i<MAX_MENU_ITEMS; i++)
        {
            if (nMenuHiliteHandlers[i].nMenuItemId != 0)
            {
                fprintf(pFile, "extern void %s(void);\n", nMenuHiliteHandlers[i].HiliteFuncName);
            }
        }
        fprintf(pFile, "\n\n/* Extern functions of Hint Handler */\n");
        for (i=0; i<MAX_MENU_ITEMS; i++)
        {
            if (nMenuHintHandlers[i].nMenuItemId != 0)
            {
                fprintf(pFile, "extern void %s(U16);\n", nMenuHintHandlers[i].HintFuncName);
            }
        }
        /* MenuHiliteHandlers Array */
        if (HiliteHdlrCount != 0)
        {
            fprintf(pFile, "\nconst mmi_frm_hilite_hdlr_struct mmi_frm_const_hilite_hdlr_table[] = {\n");
            for (i=0; i<MAX_MENU_ITEMS; i++)
            {
                if (nMenuHiliteHandlers[i].nMenuItemId != 0)
                {
                    fprintf(pFile, "    {%s, %s},\n", nMenuHiliteHandlers[i].MenuItemIdEnum, nMenuHiliteHandlers[i].HiliteFuncName);
                }
            }
            fprintf(pFile, "};\n");
        }
        else
        {
            fprintf(pFile, "\nconst mmi_frm_hilite_hdlr_struct mmi_frm_const_hilite_hdlr_table[1] = {{0, NULL}};\n");
        }

        /* MenuHintHandlers Array */
        if (HintHdlrCount != 0)
        {
            fprintf(pFile, "\nconst mmi_frm_hint_hdlr_struct mmi_frm_const_hint_hdlr_table[] = {\n");
            for (i=0; i<MAX_MENU_ITEMS; i++)
            {
                if (nMenuHintHandlers[i].nMenuItemId != 0)
                {
                    fprintf(pFile, "    {%s, %s},\n", nMenuHintHandlers[i].MenuItemIdEnum, nMenuHintHandlers[i].HintFuncName);
                }
            }
            fprintf(pFile, "};\n");
        }
        else
        {
            fprintf(pFile, "\nconst mmi_frm_hint_hdlr_struct mmi_frm_const_hint_hdlr_table[1] = {{0, NULL}};\n");
        }
        /* endif */
        fprintf(pFile, "\n#endif /* _MENUHANDLER_H */ \n");

        fclose(pFile);
    }
    else
    {
        return 0;
    }
    return 1;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* start split image data */

const char HEADER[] = "__align(4)";
const char REP_HEADER[] =  ("extern ");
#define START_FLAG    ('{')
#define END_FLAG      ('}')
#define AVERAGE_IMG_NUMBER    (2000)

#define CUST_RES_FILE_COUNT    (4)
const char *output_file_name[CUST_RES_FILE_COUNT] = {
    "..\\..\\customer\\custresource\\CustImgDataRes_0.c",
    "..\\..\\customer\\custresource\\CustImgDataRes_1.c",
    "..\\..\\customer\\custresource\\CustImgDataRes_2.c",
    "..\\..\\customer\\custresource\\CustImgDataRes_3.c",
};

#ifdef __RESOURCE_GEN_
#define CUST_IMG_DATA_PATH    "..\\..\\customer\\custresource"
#define CUST_IMG_DATA_FILE    "..\\..\\customer\\custresource\\custimgdatahw.h"
#define CUST_IMG_DATA_O_FILE    "..\\..\\customer\\custresource\\custimgdatahwBak.h"
#define CUST_IMG_HEADER_FILE  "..\\..\\customer\\custresource\\tmp_imgdata.h"
#else
#define CUST_IMG_DATA_PATH    ".\\"
#define CUST_IMG_DATA_FILE    ".\\custimgdatahw.h"
#endif

typedef char(* BUFFER_HEADER)[1024];


/*
* here we supporse the line content as following three lines:
* __align(4) const U8 __MAINLCD__ACTIVE__POWERONOFF__LOGO_BMP_[] =
* const U8 __MAINLCD__ACTIVE__POWERONOFF__LOGO_BMP_[] =
* other content without '=' and "__align(4)"
*/
char *process_line_buffer(char *buffer)
{
    char *tmp_buff = NULL;
    static bool bjump = false;
    int len = strlen(REP_HEADER);

    if(buffer != NULL)
    {
        if(!bjump)
        {
            if(strchr(buffer, START_FLAG) != NULL)
            {
                bjump = true;
            }
            if(!bjump)
            {
                tmp_buff = strchr(buffer, '=');
                if(tmp_buff != NULL) /* this line have '=', and we will change '=' to ';' */
                {
                    *tmp_buff = ';';

                    /* in this line maybe have "__align(4)", so we will check it at the following part */
                    tmp_buff = strstr(buffer, HEADER);
                    if(tmp_buff == NULL) /* this line do not have "__align(4)" */
                        tmp_buff = buffer;
                    else /* remove header: "__align(4)" */
                        tmp_buff = tmp_buff + strlen(HEADER) + 1;

                    tmp_buff = tmp_buff - len;
                    for(int i = 0; i < len; ++i)
                    {
                        tmp_buff[i] = REP_HEADER[i];
                    }
                }
                else
                {
                    tmp_buff = buffer;
                }

                /* we will return buffer pointer after this line is processed */
                return tmp_buff;
            }
        }
        else
        {
            if(strchr(buffer, END_FLAG) != NULL)
            {
                bjump = false;
            }
        }
    }
    return NULL;
}


/*************************************************************************
* FUNCTION
*  get_file_headers
*
* DESCRIPTION
*   get file header of data.h, we supporse that before "U8" line will be the
*   header line
*
* PARAMETERS
*   sourc           :[IN]      one line data of data.h
*   dest            :[OTU]     we will put the header data in this array
*   num             :[IN/OUT]  this if total line numbers of header 
*
* RETURNS
*   TRUE means current line is header line, FALSE means current line is not header line
*
*************************************************************************/
bool get_file_headers(char *sourc, BUFFER_HEADER *dest, int *num)
{
    static bool bjump = false;

    if(!bjump)
    {
        if(sourc != NULL)
        {
            if(strstr(sourc, "U8") != NULL)
            {
                bjump = true;
            }
            else
            {
                if(*num < 32)
                {
                    strcpy((*dest)[*num], sourc);
                    *num += 1;
                }
            }
        }
    }

    return bjump;
}

/*************************************************************************
* FUNCTION
*  generate_img_data_file
*
* DESCRIPTION
*   get file header of data.h, we supporse that before "U8" line will be the
*   header line
*
* PARAMETERS
*   fp             :[IN]  one line data of data.h
*   header         :[IN]  we will put the header data in this array
*   header_count   :[IN]  this if total line numbers of header 
*   img_count      :[IN]  this if total line numbers of header 
*
* RETURNS
*   TRUE means current line is header line, FALSE means current line is not header line
*
*************************************************************************/
#ifndef RESGEN_IMG_SPLIT_OUTPUT_ROUND_ROBIN
bool generate_img_data_file(FILE* fp, BUFFER_HEADER header, int header_count, int img_count)
{
    static int count = 0;
    char buffer[2048];
    char *tmp_buff = NULL;
    FILE *out_fp = NULL;
    int fc = img_count/CUST_RES_FILE_COUNT + 1;

    if(fp == NULL)
    {
        return false;
    }

    for(int i = 0; i < header_count; ++i)
    {
        if(fgets(buffer, 2048, fp) == NULL)
        {
            RESGEN_LOG_E("generate file failed.");
            return false;
        }
    }

    while(!feof(fp))
    {

        if(fgets(buffer, 2048, fp) != NULL)
        {
            if(count % fc/*AVERAGE_IMG_NUMBER*/ == 0 && out_fp == NULL)
            {
                /* 
                * create output file, if create failed,
                * we will return directly else we will write data into it
                */
                out_fp = fopen(output_file_name[count/fc/*AVERAGE_IMG_NUMBER*/], "w");
                if(out_fp == NULL)
                {
                    RESGEN_LOG_E("create data file \"%s\" failed.", output_file_name[count/fc/*AVERAGE_IMG_NUMBER*/]);
                    return false;
                }

                fputs("#include \"CustDataRes.h\"\n", out_fp);
                fputs("n#include \"ResCompressConfig.h\"\n\n", out_fp);
                fputs("#if !defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", out_fp);
                /* write header information to new file */
                for(int i = 0; i < header_count; ++i)
                {
                    fputs(header[i], out_fp);
                }
            }
            /* write data into dest file */
            fputs(buffer, out_fp);

            /* get count of image data*/
            if(strstr(buffer, "}") != NULL)
            {
                count++;
                if(count % fc/*AVERAGE_IMG_NUMBER*/ == 0)
                {
                    /* reset the file handler */
                    if(out_fp != NULL)
                    {
                        fclose(out_fp);
                        out_fp = NULL;
                    }

                }
            }
        }
        else
        {
            if(!feof(fp))
            {
                RESGEN_LOG_E("read source file error.");
                if(out_fp != NULL)
                {
                    fclose(out_fp);
                    out_fp = NULL;
                }
                return false;
            }
        }
    }

    /* close the last file */
    if(out_fp != NULL)
    {
        fputs("#endif //!defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", out_file[i]);
        fclose(out_fp);
        out_fp = NULL;
    }

    return true;
}
#else //RESGEN_IMG_SPLIT_OUTPUT_ROUND_ROBIN
bool generate_img_data_file(FILE* fp, BUFFER_HEADER header, int header_count, int img_count)
{
    static int count = 0;
    char buffer[2048];
    char *tmp_buff = NULL;
    FILE * out_file[CUST_RES_FILE_COUNT];
    FILE *out_fp = NULL;
    int fc = img_count/CUST_RES_FILE_COUNT + 1;
    bool result = true;

    if(fp == NULL)
    {
        return false;
    }

    // Check Header
    for(int i = 0; i < header_count; ++i)
    {
        if(fgets(buffer, 2048, fp) == NULL)
        {
            RESGEN_LOG_E("generate file failed.");
            return false;
        }
    }

    // Write Header if this is the first input for this file.
    for(int i = 0 ;i < CUST_RES_FILE_COUNT ;i++){
        out_fp = fopen(output_file_name[i], "w");
        fputs("#include \"CustDataRes.h\"\n", out_fp);
        fputs("\n#include \"ResCompressConfig.h\"\n\n", out_fp);
        fputs("#if !defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", out_fp);

        if(out_fp != NULL){
            for(int j = 0; j < header_count; j++){
                fputs(header[j], out_fp);
            }
            // Save the file descriptor 
            out_file[i] = out_fp; 
        }else{
            RESGEN_LOG_E("create data file \"%s\" failed.", output_file_name[i]);
            result = false;
        }
    }

    while(!feof(fp) && result != false)
    {
        out_fp = out_file[count % CUST_RES_FILE_COUNT];

        if(fgets(buffer, 2048, fp) != NULL)
        {
            /* write data into dest file */
            fputs(buffer, out_fp);

            /* get count of image data*/
            if(strstr(buffer, "}") != NULL)
            {
                count++;
            }
        }
        else
        {
            if(!feof(fp))
            {
                RESGEN_LOG_E("read source file error.");
                result= false;
                break;
            }
        }
    }

    for(int i = 0; i< CUST_RES_FILE_COUNT; i++){
        /* close the files */
        if( out_file[i] != NULL)
        {
            fputs("#endif //!defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", out_file[i]);
            fclose( out_file[i]);
        }
    }

    return result;
}
#endif ////RESGEN_IMG_SPLIT_OUTPUT_ROUND_ROBIN

int get_img_count(FILE *fp)
{
    char buffer[1024];
    static int const_num = 0;

    if(fp == NULL)
        return -1;

    while(!feof(fp))
    {
        if((fgets(buffer, 1024, fp) != NULL))
        {
            if(strstr(buffer, "U8") != NULL)
            {
                const_num++;
            }
        }
        else
        {
            fprintf(stderr, "get image count failed, L=%d\n", __LINE__);
            return -1;
        }

    }

    return const_num;
}

bool split_img_data_file()
{   
    FILE *fp = NULL;
    FILE *wfp = NULL;
    int header_num = 0;
    char buffer[2048];
    char *tmp_buff = NULL;
    int len = strlen(REP_HEADER);
    int img_count = -1;

    bool bjump = false;

    /* record header of split file:datahw.h */
    BUFFER_HEADER hp = NULL;
    RESGEN_LOG_V("split_img_data_file(): split custimgdatahw.h into CustImgDataRes_[0..3]");
    hp = (char(*)[1024]) malloc(32 * sizeof(char) * 1024);

    fp = fopen(CUST_IMG_DATA_FILE, "r");
    if(fp == NULL)
    {
        fprintf(stderr, "SPLIT:can not open file: custimgdatahw.h\n");
        return false;
    }

    wfp = fopen(CUST_IMG_HEADER_FILE, "w+");
    if(wfp == NULL)
    {
        fprintf(stderr, "SPLIT:can not open file: tmp_imgdata.h\n");
        fclose(fp);
        return false;
    }

    /* add include guard */
    fputs("#ifndef __CUST_IMG_DATA_HW_H_\n", wfp);
    fputs("#define __CUST_IMG_DATA_HW_H_\n", wfp);
    fputs("#include \"CustDataRes.h\"\n#include \"ResCompressConfig.h\"\n\n", wfp);
    fputs("#if !defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", wfp);
			
    char *cache = buffer + len + 1;
    while(!feof(fp))
    {
        tmp_buff = fgets(/*buffer + len + 1*/cache, 2048, fp);

        /* get data from the original data header file */
        if(!bjump)
        {
            bjump = get_file_headers(tmp_buff, &hp, &header_num);
        }

        /* process data and generate new header */
        tmp_buff = process_line_buffer(tmp_buff);
        if(tmp_buff != NULL)
        {
            fputs(tmp_buff, wfp);
        }
    }

    fputs("#endif // !defined(__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__) || defined(__MMI_RESOURCE_UT_UNCOMPRESSED_IMAGE_SUPPORT__) \n", wfp);
    fputs("#endif /* __CUST_IMG_DATA_HW_H_ */", wfp);

    /* get the image total count */
    rewind(wfp);
    img_count = get_img_count(wfp); /* get image count */
    /* error process */
    if(img_count == -1)
        fprintf(stderr, "split file failed, Line=%d", __LINE__);

    /* generate data file of image */
    rewind(fp);
    if(generate_img_data_file(fp, hp, header_num, img_count))
    {
        fprintf(stderr, "split file successfully!!\n");
    }
    else
    {
        fprintf(stderr, "generate image data file failed. %d", __LINE__);
    }

    fclose(fp);
    fp = NULL;

    fclose(wfp);
    wfp = NULL;

    fp = fopen(CUST_IMG_DATA_O_FILE, "r");
    if(fp != NULL)
    {
        fclose(fp);
        fp = 0;
        memset(buffer, 0, 2048);
        sprintf(buffer, "del %s", CUST_IMG_DATA_O_FILE);
        execute_ext_command(buffer);
    }

    memset(buffer, 0, 2048);
    sprintf(buffer, "rename %s custimgdatahwBak.h", CUST_IMG_DATA_FILE);
    execute_ext_command(buffer);

    /* generate new extern data file */
    memset(buffer, 0, 2048);
    sprintf(buffer, "rename %s custimgdatahw.h", CUST_IMG_HEADER_FILE);
    execute_ext_command(buffer);

    return true;
}

/* end split image data */

extern "C" void ToolPopulateInitial(void);
extern "C" void ToolPopulateDone(void);
extern "C" MMI_BOOL Aload(S8 *string, U16* pType);

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
extern "C" int disableENFB;
#endif


static S32 g_error = -1;

static void launch_resgen_services(){
    int debugLevelCfg = RES_LOG_LEVEL_VERBOSE;

    // Start Resgen Log service
    reslog_adaptor_start_service();

    // Load configuration
    ResgenConfigurator *configObj = ResgenConfigurator::getInstance();
    if(configObj!=NULL){
        configObj->loadConfiguration(ResgenConfigurator::DEFAULT_CONFIG_FILE);
        debugLevelCfg = configObj->getDebugLevel();
    }

    // Set default log level
    reslog_adaptor_set_max_level(debugLevelCfg);

    // Create crush handling serice
    ResgenCrashHandlingService * crashHandlingObj = ResgenCrashHandlingService::getInstance();

    // Start the service to catch regen crush exceptions
    crashHandlingObj->start();
}

// function handle_regen_errors will be phased not
// after all moudule are using resgen log framework API
static int handle_regen_errors(){
    wchar_t * err_msg = NULL;
    int err_code = 0;
    /* Check error in each module */
    if (mtk_resgen_has_error() )
    {
        RESGEN_LOG_E("mtk_resgenerator.exe fail!");
        fprintf(stderr, "mtk_resgenerator.exe failed, the error flag was set.\n");
        return 1;
    }

    err_code = str_merge_get_err(&err_msg);

    if(err_code == STRMERGE_LOAD_REF_LIST_ERR)
    {
        // Output to log file
        RESGEN_WLOG_E(L"Please check plutommi\\Customer\\CustResource\\ref_list.txt for this error ! MSG=[ %ls ]",err_msg);
        // Show message in console
        fprintf(stderr,"\n--------------- REF LIST ERROR -------------------\n");
        fprintf(stderr,"Please check plutommi\\Customer\\CustResource\\ref_list.txt for this error !\n");
        fwprintf(stderr, L"%ls\n",err_msg);
        fprintf(stderr,"\n--------------------------------------------------\n");
        return 1;
    }

    if(err_code == STRMERGE_LOAD_SSC_ERR)
    {
        // Output to log file
        RESGEN_WLOG_E(L"Please check plutommi\\Customer\\CustResource\\PLUTO_MMI\\ref_list\\ref_list_translation.txt for this error ! MSG=[ %ls ]",err_msg);
        // Show message in console
        fprintf(stderr,"\n--------------- REF LIST ERROR -------------------\n");
        fprintf(stderr,"Please check plutommi\\Customer\\CustResource\\PLUTO_MMI\\ref_list\\ref_list_translation.txt for this error ! !\n");
        fwprintf(stderr, L"%ls\n",err_msg);
        fprintf(stderr,"\n--------------------------------------------------\n");
        return 1;
    }
    return 0;
}


static int check_fatal_errors(){
    int hasPendingFatalError = reslog_adaptor_has_pending_fatal_error();
    if(hasPendingFatalError){
        reslog_adaptor_flush_pending_fatal_error();
    }
    hasPendingFatalError |= handle_regen_errors();
    return hasPendingFatalError;
}

static void stop_resgen_services(){
    ResgenCrashHandlingService * crashHandlingObj = ResgenCrashHandlingService::getInstance();
    crashHandlingObj->stop();
    ResgenConfigurator::release();
    reslog_adaptor_stop_service();
}


/*****************************************************************************
* FUNCTION
*  on_exit
* DESCRIPTION
*  program exit function
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void resgen_on_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fflush(stdout);

    int regenHasError = check_fatal_errors();

    if (g_error != -1 && regenHasError==0 )  // normal exit
    {
        RESGEN_LOG_V("mtk_resgenerator.exe execute successfully.");
        fprintf(stderr, "mtk_resgenerator.exe execute successfully.\n");
        stop_resgen_services();
        _exit(1);
    }
    else                // abnormal exit
    {
        stop_resgen_services();
        _exit(2);
    }
}

static void writeLogToFile(char * fileName, char *msg,int append)
{
    FILE * logfile = NULL;
    if(append)
    {
        logfile = fopen(fileName,"w");
    }else{
        logfile= fopen(fileName,"a");
    }

    if(logfile!=NULL)
    {
        fputs (msg,logfile);
        fclose(logfile);
    }
}

///////////////////////////////////////////////////////////////////////////////
// CAT Resource Generation
///////////////////////////////////////////////////////////////////////////////

static void CATResourceGeneration(){
#if defined(__CAT_SUPPORT__) && defined(MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE) && (MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE > 0)
    int reserveSize = MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE;
    CATResGenerator * catObj = new CATResGenerator();
    catObj->setReservedSymbolName("cat_reserved_space");
    catObj->setReservedSymbolFile("..\\..\\Customer\\CustResource\\CustCATReserved.c");
    catObj->setCatSectionName(MMIRESOURCE_CAT_RES_SECTION_NAME_IMG);
    catObj->generate(MMIRESOURCE_CAT_IMG_RESERVED_SIZE_BYTE);
    delete catObj;
#endif
}


#ifdef  __RESGEN_INTERNAL_OFFLINE__

///////////////////////////////////////////////////////////////////////////////
// Resgen 1.5 (Offline Resgen)
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Binary Population Adaptor
//////////////////////////////////////////////////////
class OfflineResPopBinaryAdaptor:public OfflineResPopAdaptor{
protected:
    virtual int issueLecacyPopulation(ResPopParam * param)
    {
        char * path = NULL;
        char * enumString = NULL;
        BinaryResParam * binaryParam = (BinaryResParam*)param;
        if(param == NULL){
            cout<<"[ERROR][issueLecacyPopulation] binaryParam can't be NULL"<<endl;
            return -1;
        }
        //         string debugStr("");
        //         binaryParam->toString(&debugStr);
        //         cout<<debugStr<<endl;
        path = new char[binaryParam->getBinaryFilePath()->size()+1];
        enumString = new char[binaryParam->getIdEnumString()->size()+1];
        strcpy(path, binaryParam->getBinaryFilePath()->c_str());
        strcpy(enumString, binaryParam->getIdEnumString()->c_str());	

        //cout<<"Populate"<<path<<endl;
        SetBinaryWithBuffer(binaryParam->getIdEnumValue(), path, enumString,(_binary_type_enum)binaryParam->getBinaryType());  
        delete [] path;
        delete [] enumString;
        return 0;
    };
};
///////////////////////////////////////////////////////
// Audio Population Adaptor
///////////////////////////////////////////////////////
class OfflineResPopAudioAdaptor:public OfflineResPopAdaptor{
protected:
    virtual int issueLecacyPopulation(ResPopParam * param)
    {
        char * audioPath = NULL;
        char * enumString = NULL;
        AudioResParam * audioParam = (AudioResParam*)param;
        if(param == NULL){
            cout<<"ERROR!! _audioParam can't be NULL"<<endl;
            return -1;
        }
        //string debugStr("");
        //audioParam->toString(&debugStr);
        //cout<<debugStr<<endl;
        audioPath = new char[audioParam->getAudioFilePath()->size()+1];
        enumString = new char[audioParam->getIdEnumString()->size()+1];
        strcpy(audioPath, audioParam->getAudioFilePath()->c_str());
        strcpy(enumString, audioParam->getIdEnumString()->c_str());	

        if(audioParam->getForceType() >= OFFLINE_RESGEN_NO_FORCE_TYPE){
            //cout<<"Populate"<<audioPath<<endl;
            SetAudioWithBuffer(audioParam->getIdEnumValue(), audioPath, enumString, audioParam->getIsMultipleBin());  
        }else{
            //cout<<"Populate"<<audioPath<<endl;
            SetAudioWithBufferForceType(audioParam->getIdEnumValue(), audioPath, enumString, audioParam->getIsMultipleBin(), audioParam->getForceType());  
        }
        delete [] audioPath;
        delete [] enumString;
        return 0;
    };
};

///////////////////////////////////////////////////////
// Image Population Adaptor
///////////////////////////////////////////////////////
class OfflineResPopImageAdaptor:public OfflineResPopAdaptor{
public:
    static int IMAGE_REPLACEBALE_SUPPORT_ENABLE;
    static int IMAGE_REPLACEBALE_SUPPORT_DISABLE;
    
    OfflineResPopImageAdaptor(int replacePoolSupport){
        this->replacePoolSupport = replacePoolSupport;
    }
protected:
    int replacePoolSupport;
    
    virtual int issueLecacyPopulation(ResPopParam * param){
        char * imagePath = NULL;
        char * enumString = NULL;
        int isReplacable = IMAGE_REPLACEBALE_SUPPORT_DISABLE;
        
        ImageResParam * imageParam = (ImageResParam*)param;
        if(imageParam == NULL){
            cout<<"[ERROR] imageParam can't be NULL"<<endl;
            return -1;
        }
        //string debugStr("");
        //imageParam->toString(&debugStr);
        //cout<<debugStr<<endl;
        imagePath = new char[imageParam->getImageFilePath()->size()+1];
        enumString = new char[imageParam->getIdEnumString()->size()+1];
        strcpy(imagePath, imageParam->getImageFilePath()->c_str());
        strcpy(enumString, imageParam->getIdEnumString()->c_str());	

        if(this->replacePoolSupport == IMAGE_REPLACEBALE_SUPPORT_ENABLE){
            isReplacable = imageParam->getIsMultipleBin();
        }else{
            isReplacable = IMAGE_REPLACEBALE_SUPPORT_DISABLE;
        }

        if(imageParam->getForceType() >= OFFLINE_RESGEN_NO_FORCE_TYPE){
            //cout<<"Populate"<<imagePath<<endl;
            SetImageQWithBuffer(imageParam->getIdEnumValue(), imagePath, enumString, isReplacable,imageParam->getQuality());
        }else{
            //cout<<"Populate"<<imagePath<<endl;
            SetImageQWithBufferForceType(imageParam->getIdEnumValue(), imagePath, enumString, isReplacable, imageParam->getForceType(),imageParam->getQuality());
        }
        delete [] imagePath;
        delete [] enumString;
        return 0;
    };
};

int OfflineResPopImageAdaptor::IMAGE_REPLACEBALE_SUPPORT_DISABLE = 0;
int OfflineResPopImageAdaptor::IMAGE_REPLACEBALE_SUPPORT_ENABLE = 1;

///////////////////////////////////////////////////////
// String Population Adaptor
///////////////////////////////////////////////////////
class OfflineResPopStringAdaptor:public OfflineResPopAdaptor{
protected:
    virtual int issueLecacyPopulation(ResPopParam * param){
        if(param == NULL){
            return -1;
        }
        StringResParam* item =(StringResParam*)param;
        char * defaultString = new char[item->getDefaultString()->size()+1];
        strcpy(defaultString, item->getDefaultString()->c_str());
        char * enumString = new char[item->getIdEnumString()->size()+1];
        strcpy(enumString, item->getIdEnumString()->c_str());	
        //cout<<item->getIdEnumValue() << defaultString<< enumString<<endl;
        SetString(item->getIdEnumValue(),defaultString,enumString);
        delete [] defaultString;
        delete [] enumString;
        return 0;
    };
};

class OfflineResPopService{
private:
    void populateResource(ResParamModel* modelObj, char * dbFile, ParamTextFileDAO * daoObj, OfflineResPopulator * resPopulator){
        modelObj->setRepositoryFileName(dbFile);
        modelObj->loadFromRepository(daoObj);
        resPopulator->setResPopModel(modelObj);
        resPopulator->populate();
    };

public:
    void populateBinaryResource(char * dbFile){
        ResParamModel * paramModel = new ResParamModel();
        // Enable redundant population for 3D binary resgen
        paramModel->setRedundantAllowed(ResParamModel::REDUNDANT_ALLOWDED_ENABLE);

        BinaryParamTextFileDAO * daoObj = new BinaryParamTextFileDAO();
        OfflineResPopulator * resPopulator = new OfflineResPopBinaryAdaptor();

        populateResource(paramModel,dbFile,daoObj,resPopulator);

        delete paramModel;
        delete resPopulator;
        delete daoObj;
    }


    void populateAudioResource(char * dbFile){
        ResParamModel * paramModel = new ResParamModel();
        AudioParamTextFileDAO * daoObj = new AudioParamTextFileDAO();
        OfflineResPopulator * resPopulator = new OfflineResPopAudioAdaptor();

        populateResource(paramModel,dbFile,daoObj,resPopulator);

        delete paramModel;
        delete resPopulator;
        delete daoObj;
    }



    void populateImageResource(char * dbFile){
        ResParamModel * paramModel = new ResParamModel();
        ImageParamTextFileDAO * daoObj = new ImageParamTextFileDAO();
        int isReplacePoolSupport = OfflineResPopImageAdaptor::IMAGE_REPLACEBALE_SUPPORT_DISABLE;
#if defined(__NFB_THIRD_ROM_SUPPORT__) && !defined( __MULTIPLE_BINARY_FILES__) && !defined(__CAT_SUPPORT__)
        isReplacePoolSupport = OfflineResPopImageAdaptor::IMAGE_REPLACEBALE_SUPPORT_DISABLE;
#else
        isReplacePoolSupport = OfflineResPopImageAdaptor::IMAGE_REPLACEBALE_SUPPORT_ENABLE;
#endif //__NFB_THIRD_ROM_SUPPORT__ && !( __MULTIPLE_BINARY_FILES__) && !(__CAT_SUPPORT__)
        
        OfflineResPopulator * resPopulator = new OfflineResPopImageAdaptor(isReplacePoolSupport);

        populateResource(paramModel,dbFile,daoObj,resPopulator);

        delete paramModel;
        delete resPopulator;
        delete daoObj;
    }



    void populateStringResource(char * dbFile){
        ResParamModel * paramModel = new ResParamModel();
        StringParamTextFileDAO * daoObj = new StringParamTextFileDAO();
        OfflineResPopulator * resPopulator = new OfflineResPopStringAdaptor();

        populateResource(paramModel,dbFile,daoObj,resPopulator);

        delete paramModel;
        delete resPopulator;
        delete daoObj;
    }


};

//////////////////////////////////////////////////////////////////////////////
// Controller function of Offline Res Population
//////////////////////////////////////////////////////////////////////////////

static void OfflineResPopController(){
    RESGEN_LOG_V("OfflineResPopController: save the population actions of legacy resource to resource repository");

    // Open Param DB for legacy resources	
#ifndef __POPULATE_NO_STRING_DATA__
    StringAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_PRE_XML_LEGACY_STRING_DB);
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    ImageAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_PRE_XML_LEGACY_IMAGE_DB);
#endif
    AudioAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_PRE_XML_LEGACY_AUDIO_DB);
    BinaryAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_PRE_XML_LEGACY_BINARY_DB);

    // Start Legacy native resoruce Popualtion
    ResPopInitAll();

    RESGEN_LOG_V("OfflineResPopController: save the population actions declared by legacy population APIs (Order: before XML resource)");
    RESGEN_LOG_V("OfflineResPopController: populate resource which can't be populated offline. (Order: before XML resource)");

    PopulateResDataPreXML();
#ifndef __POPULATE_NO_STRING_DATA__
    StringAdaptorStopOfflinePopulation();
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    ImageAdaptorStopOfflinePopulation();
#endif
    AudioAdaptorStopOfflinePopulation();
    BinaryAdaptorStopOfflinePopulation();

    RESGEN_LOG_V("OfflineResPopController: populate XML resource which can't be populated online.");
    // Start XML native resource Population
    PopulateResDataXML();

    // Start Legacy native resoruce Popualtion (for thos resource must be populated after XML resource population)
#ifndef __POPULATE_NO_STRING_DATA__
    StringAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_POST_XML_LEGACY_STRING_DB);
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    ImageAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_POST_XML_LEGACY_IMAGE_DB);
#endif
    AudioAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_POST_XML_LEGACY_AUDIO_DB);
    BinaryAdaptorStartOfflinePopulation(DEFAULT_OFFLINE_POST_XML_LEGACY_BINARY_DB);

    RESGEN_LOG_V("OfflineResPopController: save the population actions declared by legacy population APIs. (Order: after XML resource)");
    RESGEN_LOG_V("OfflineResPopController: populate resource which can't be populated offline. (Order: after XML resource)");
    PopulateResDataPostXML();

#ifndef __POPULATE_NO_STRING_DATA__
    StringAdaptorStopOfflinePopulation();
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    ImageAdaptorStopOfflinePopulation();
#endif
    AudioAdaptorStopOfflinePopulation();
    BinaryAdaptorStopOfflinePopulation();


    // Do Offline Population with OfflineResPopService objects
    OfflineResPopService * offlineResPopService= new OfflineResPopService();

    RESGEN_LOG_V("OfflineResPopController: populate offline legacy resource. (Order: after XML resource)");

    //Note: Binary resource population has been moved to python scripts.

    // Native resourc population
#ifndef __POPULATE_NO_STRING_DATA__
    offlineResPopService->populateStringResource(DEFAULT_OFFLINE_PRE_XML_LEGACY_STRING_DB);
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    offlineResPopService->populateImageResource(DEFAULT_OFFLINE_PRE_XML_LEGACY_IMAGE_DB);
#endif
    offlineResPopService->populateAudioResource(DEFAULT_OFFLINE_PRE_XML_LEGACY_AUDIO_DB);

    RESGEN_LOG_V("OfflineResPopController: populate offline XML resource.");

    // XML resource population
#ifndef __POPULATE_NO_STRING_DATA__
    offlineResPopService->populateStringResource(DEFAULT_OFFLINE_XML_STRING_DB);
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    offlineResPopService->populateImageResource(DEFAULT_OFFLINE_XML_IMAGE_DB);
#endif
    offlineResPopService->populateAudioResource(DEFAULT_OFFLINE_XML_AUDIO_DB);

    RESGEN_LOG_V("OfflineResPopController: populate offline legacy resource. (Order: after XML resource)");
    // Native resource population (for thos resource must be populated after XML resource population)
#ifndef __POPULATE_NO_STRING_DATA__
    offlineResPopService->populateStringResource(DEFAULT_OFFLINE_POST_XML_LEGACY_STRING_DB);
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    offlineResPopService->populateImageResource(DEFAULT_OFFLINE_POST_XML_LEGACY_IMAGE_DB);
#endif
    offlineResPopService->populateAudioResource(DEFAULT_OFFLINE_POST_XML_LEGACY_AUDIO_DB);

    // Stop Legacy native resoruce Popualtion
    ResPopDeinitAll();

    delete offlineResPopService;
}

#endif //#ifdef  __RESGEN_INTERNAL_OFFLINE__


#ifdef __REGEN_INTERNAL_BATCHED__ 

///////////////////////////////////////////////////////
// Batched Resource File Generation Service
///////////////////////////////////////////////////////

class BatchedResFileGenService{

private:
    // Open dest file
    int initResFileOutput(char * destFileName){
        int resultFailFlag = 0;

        dest_file = fopen(destFileName, "wb");
        if (dest_file == NULL){
            resultFailFlag = -1;
            cout<<"dest_file could not open!\n"<<endl;
        }

        toolFlag = 1;
        ToolPopulateInitial();
        return resultFailFlag;
    }
    // Close dest file
    int deInitResFileOutput(){
        if(dest_file != NULL)
        {
            fclose(dest_file);
        }
        dest_file = NULL;
        return 0;
    }

public:
    // Read bached resgen source and destination file from the path batchedFileName
    // and generate resrouces 
    int generateResource(char * batchedFileName){
        int result = 0;
        ResFileGenParamModel * model = new ResFileGenParamModel();
        model->setRepositoryFileName(batchedFileName);
        ResFileGenParamTextFileDAO * dao = new ResFileGenParamTextFileDAO();
        model->loadFromRepository(dao);
        vector<ResFileGenParam *> * params = model->getAllResFileGenParam();

        for(unsigned int i=0;i<params->size();i++){
            ResFileGenParam * item = (*(params))[i];
            if(item != NULL){
                char * srcPath = new char[item->getSrcPath()->size()+1];
                strcpy(srcPath, item->getSrcPath()->c_str());
                char * destPath = new char[item->getDestPath()->size()+1];
                strcpy(destPath, item->getDestPath()->c_str());	 
                int type = item->getType();
                if(type == ResFileGenParam::IMAGE_TYPE){
                    if(generateImageRes(srcPath,destPath)!=0){
                        RESGEN_LOG_E("[IMAGE] File mode: %s, %s", srcPath, destPath);
                        result = -1;

                    }
                }else if (type == ResFileGenParam::FONT_TYPE){
                    if(generateFontRes(srcPath,destPath)!=0){
                        RESGEN_LOG_E("[Font] File mode: %s, %s", srcPath, destPath);
                        result = -1;
                    }
                }else if (type ==ResFileGenParam::AUDIO_TYPE){
                    if(generateAudioRes(srcPath,destPath)!=0){
                        RESGEN_LOG_E("[Audio] File mode: %s, %s", srcPath, destPath);
                        result = -1;
                    }
                }

                delete srcPath;
                delete destPath;

            }

        }
        model->clear();	
        delete model;
        delete dao;
        return result;
    }

    int generateAudioRes(char * srcFileFileName, char * destFileName){
        int resourceLoadResult = 0;
        U16 nType;
        char upperFileName[MAX_FILENAME_LEN];

        strncpy(upperFileName, srcFileFileName, MAX_FILENAME_LEN);
        str_upper(upperFileName, MAX_FILENAME_LEN);

        if(initResFileOutput(destFileName)!=0){
            resourceLoadResult = -1;
        }
        if(Aload(upperFileName, &nType)!= MMI_TRUE){
            resourceLoadResult = -1;
        }

        if(deInitResFileOutput()!=0){
            resourceLoadResult = -1;
        }

        return resourceLoadResult;
    }

    int generateFontRes(char * srcFileFileName, char * destFileName){
        int resourceLoadResult = 0;
        U16 nType;
        char upperFileName[MAX_FILENAME_LEN];

        strncpy(upperFileName, srcFileFileName, MAX_FILENAME_LEN);
        str_upper(upperFileName, MAX_FILENAME_LEN);

        if(initResFileOutput(destFileName)!=0){
            resourceLoadResult = -1;
        }

        if(Fload(upperFileName, &nType)!= MMI_TRUE){
            resourceLoadResult = -1;
        }
        if(deInitResFileOutput()!=0){
            resourceLoadResult = -1;
        }
        return resourceLoadResult;

    }
    int generateImageRes(char * srcFileFileName, char * destFileName){
        int resourceLoadResult = 0;
        U16 nType;
        char upperFileName[MAX_FILENAME_LEN];

        strncpy(upperFileName, srcFileFileName, MAX_FILENAME_LEN);
        str_upper(upperFileName, MAX_FILENAME_LEN);

        if(initResFileOutput(destFileName)!=0){
            resourceLoadResult = -1;
        }

        SetImageProcessData processData;
        initImageProcessData(&processData);
        ResgenImageOutStream * outstream;
        ImageOutStreamInit(&outstream);
        processData.outstream = outstream;

        if(Iload(upperFileName, SYSTEM_IMAGE, AUTO_TYPE, &processData) == MMI_TRUE)
        {

            char *curr_output_data_filename = "temp_image";
            FILE *output_data_file = NULL;
            output_data_file = fopen(curr_output_data_filename, "ab");
            while (output_data_file == NULL)
            {
                Sleep(50);
                output_data_file = fopen(curr_output_data_filename, "ab");
            }

            ImageOutStreamOutputFile(outstream, output_data_file);
            ImageOutStreamDeinit(&outstream);
            MYFCLOSE(output_data_file);
        }
        else
        {
            resourceLoadResult = -1;
            ImageOutStreamDeinit(&outstream); 				  
        }

        if(deInitResFileOutput()!=0){
            resourceLoadResult = -1;
        }
        return resourceLoadResult;
    }
};

#endif //__REGEN_INTERNAL_BATCHED__


static void prepare3DMetaPopulation(){
#ifdef __RESGEN_INTERNAL_3D_META_RESGEN_AUTO__
    // Populate the 3D meta resource so that APP developer don't need to add the res declaration to APP res
    // manually.
#ifdef __COSMOS_MMI__
    RESGEN_LOG_V("resgen_xml_3d_meta_handle.py : Populate 3D meta data, Root = " RES_THEME_ROOT);
    if(0 != execute_ext_command("..\\..\\..\\" "tools\\python25\\python" " resgen_xml_3d_meta_handle.py " RES_THEME_ROOT))
#else
    RESGEN_LOG_V("resgen_xml_3d_meta_handle.py : Populate 3D meta data, Root = " CUST_IMG_PATH "\\MainLCD");
    if(0 != execute_ext_command("..\\..\\..\\" "tools\\python25\\python" " resgen_xml_3d_meta_handle.py " CUST_IMG_PATH"\\MainLCD"))
#endif // RES_THEME_ROOT
    {
        mtk_resgen_set_error();
        RESGEN_LOG_E("Error!! Meta resource for Binary 3D population failed!! External python script resgen_xml_3d_meta_handle.py return error.");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Error!! Meta resource for Binary 3D population failed!!","External python script resgen_xml_3d_meta_handle return error.","Please check the error message of the tag Py-RESGEN_XML_3D_META_HANDLE in this log file");
        fprintf(stderr, "\n** External python script resgen_xml_3d_meta_handle.py return error. \n** Meta resource for Binary 3D population failed!! \n** Please check the error message of the tag Py-RESGEN_XML_3D_META_HANDLE in resgen_mtk_resgenerator_run.log\n");

    }
#endif //__RESGEN_INTERNAL_3D_META_RESGEN_AUTO__
}



// Do Post Code Generations:
// (1) Third ROM image/string resource
// (2) Compressed image/string resource

#if !defined (__CAT_SUPPORT__) && !defined(__MBA_LANG_ONLY__) 
    #define IMG_GROUP_CMD_OPTION_THIRD_ROM_BINS "all"
#else //__CAT_SUPPORT__
// When CAT 2.0 or MBA's langpack is enabled, string resouce is put into CAT region and langpack, not in 3rd ROM
    #define IMG_GROUP_CMD_OPTION_THIRD_ROM_BINS "no_str"
#endif //__CAT_SUPPORT__

static void PostRegenOperations(){

    char cmdBuf[SHELL_CMD_BUFLEN] = "";
    int exeResult = 1;
#ifndef __POPULATE_NO_STRING_DATA__
    // Generate 3rd ROM and string compresssion source codes
    sprintf(cmdBuf, "..\\..\\..\\tools\\python25\\python .\\resgen_str_compress.py -p %d > debug\\resgen_str_compress.log", STR_COMPRESS_CMD_OPTION_STR_PADDING);
    exeResult = execute_ext_command(cmdBuf);
    if( exeResult!= 0){
        RESGEN_LOG_E("Error!! String Resource Code generation failed, please check plutommi\\customer\\resgenerator\\debug\\resgen_str_compress.log");
        fprintf(stderr, "\n** Error!! String Resource Code generation failed!!\n** External python script resgen_str_compress.py\n** please check plutommi\\customer\\resgenerator\\debug\\resgen_str_compress.log for the detail\n");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Error!! String Resource Code generation failed!!","External python script resgen_str_compress.py","please check plutommi\\customer\\resgenerator\\debug\\resgen_str_compress.log for the detail");
    }
#endif

#ifndef __POPULATE_NO_IMAGE_DATA__
    // Check N-group image configuration here   
    RESGEN_LOG_V("ON-DEMOND IMAGE CACHE SIZE: %d",MMI_RESOURCE_IMAGE_CACHE_SIZE);
#ifndef __MMI_RESOURCE_6261_SLIM__
    if(RES_SINGLE_IMG_GROUP_MAX_SIZE > ((MMI_RESOURCE_IMAGE_CACHE_SIZE- 4 * RES_MULTI_IMG_GROUP_MAX_SIZE)/2) ){
        RESGEN_LOG_E("Image group configurtion error!! RES_SINGLE_IMG_GROUP_MAX_SIZE must < MMI_RESOURCE_IMAGE_CACHE_SIZE/2, please check your configurtion in ResCompressConfig.h");
        fprintf(stderr, "\n** Image group configurtion error!!\n** RES_SINGLE_IMG_GROUP_MAX_SIZE must < ((MMI_RESOURCE_IMAGE_CACHE_SIZE- 4 * RES_MULTI_IMG_GROUP_MAX_SIZE)/2)\n** please check your configurtion in ResCompressConfig.h\n");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Image group configurtion error!!","Doesn't support your configuration","RES_SINGLE_IMG_GROUP_MAX_SIZE must < ((MMI_RESOURCE_IMAGE_CACHE_SIZE- 4 * RES_MULTI_IMG_GROUP_MAX_SIZE)/2), please adjust your configurtion in plutommi\\mmi\\resource\\inc\\ResCompressConfig.h");

    }
    
    if(RES_BOOT_IMG_GROUP_MAX_SIZE > (MMI_RESOURCE_IMAGE_CACHE_SIZE - 4* RES_MULTI_IMG_GROUP_MAX_SIZE) ){
        RESGEN_LOG_E("Image group configurtion error!! RES_BOOT_IMG_GROUP_MAX_SIZE must < MMI_RESOURCE_IMAGE_CACHE_SIZE - 4* RES_MULTI_IMG_GROUP_MAX_SIZE), please check ResCompressConfig.h");
        fprintf(stderr,"\n** Image group configurtion error!! RES_BOOT_IMG_GROUP_MAX_SIZE must < MMI_RESOURCE_IMAGE_CACHE_SIZE - 4* RES_MULTI_IMG_GROUP_MAX_SIZE)\n** please check plutommi\\mmi\\resource\\inc\\ResCompressConfig.h\n");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Image group configurtion error!!","Doesn't support you configuration","RES_BOOT_IMG_GROUP_MAX_SIZE and RES_BOOT_IMG_GROUP_MAX_SIZE must euqel to RES_SINGLE_IMG_GROUP_MAX_SIZE when __MMI_RESOURCE_LZMA_IMAGE_GROUP_COMPRESS__ is enabled, please adjust your configurtion in plutommi\\mmi\\resource\\inc\\ResCompressConfig.h");
    }
#else //__MMI_RESOURCE_6261_SLIM__
/*
	if(MMI_RESOURCE_IMAGE_CACHE_SIZE < 3 * RES_MULTI_IMG_GROUP_MAX_SIZE){
		RESGEN_LOG_E("Image group configurtion error!! MMI_RESOURCE_IMAGE_CACHE_SIZE must >= 3 * RES_MULTI_IMG_GROUP_MAX_SIZE, please check your configurtion in ResCompressConfig.h");
		fprintf(stderr, "\n** Image group configurtion error!!\n** MMI_RESOURCE_IMAGE_CACHE_SIZE must >= 3 * RES_MULTI_IMG_GROUP_MAX_SIZE\n** please check your configurtion in ResCompressConfig.h\n");
		RES_LOG_PENDING_FATAL(RESGEN_TAG, "Image group configurtion error!!","Doesn't support your configuration","MMI_RESOURCE_IMAGE_CACHE_SIZE must >= 3 * RES_MULTI_IMG_GROUP_MAX_SIZE, please adjust your configurtion in plutommi\\mmi\\resource\\inc\\ResCompressConfig.h");
    
	}
*/
#endif //__MMI_RESOURCE_6261_SLIM__
#ifdef __MMI_RESOURCE_LZMA_IMAGE_GROUP_COMPRESS__
    if(RES_SINGLE_IMG_GROUP_MAX_SIZE != RES_MULTI_IMG_GROUP_MAX_SIZE || RES_MULTI_IMG_GROUP_MAX_SIZE!= RES_BOOT_IMG_GROUP_MAX_SIZE){ 
        RESGEN_LOG_E("Image group configurtion error!! RES_SINGLE_IMG_GROUP_MAX_SIZE and RES_BOOT_IMG_GROUP_MAX_SIZE must euqel to RES_MULTI_IMG_GROUP_MAX_SIZE when __MMI_RESOURCE_LZMA_IMAGE_GROUP_COMPRESS__ is enabled, please check ResCompressConfig.h");
        fprintf(stderr,"\n** Image group configurtion error!! \n** RES_SINGLE_IMG_GROUP_MAX_SIZE and RES_BOOT_IMG_GROUP_MAX_SIZE must euqel to RES_MULTI_IMG_GROUP_MAX_SIZE when __MMI_RESOURCE_LZMA_IMAGE_GROUP_COMPRESS__ is enabled\n** please check plutommi\\mmi\\resource\\inc\\ResCompressConfig.h\n");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Image group configurtion error", "Doesn't support you configuration","RES_SINGLE_IMG_GROUP_MAX_SIZE and RES_BOOT_IMG_GROUP_MAX_SIZE must euqel to RES_MULTI_IMG_GROUP_MAX_SIZE when __MMI_RESOURCE_LZMA_IMAGE_GROUP_COMPRESS__ is enabled, please adjust your configurtion in plutommi\\mmi\\resource\\inc\\ResCompressConfig.h");
    }   
#endif
    
    // Generate 3rd ROM and Image compression source codes
#ifdef RES_BOOT_IMG_GROUPD_ID_CONFIG
    sprintf(cmdBuf, "..\\..\\..\\tools\\python25\\python .\\resgen_img_group_compress.py --mg=%d --sg=%d --bg=%d --bgid=%s -m %s -i %d > debug\\resgen_img_group_compress.log", 
            RES_MULTI_IMG_GROUP_MAX_SIZE, RES_SINGLE_IMG_GROUP_MAX_SIZE, RES_BOOT_IMG_GROUP_MAX_SIZE, RES_BOOT_IMG_GROUPD_ID_CONFIG, IMG_GROUP_CMD_OPTION_THIRD_ROM_BINS, IMAGE_HANDL_OFFSET_LENGTH);
#else //RES_BOOT_IMG_GROUPD_ID_CONFIG
    sprintf(cmdBuf, "..\\..\\..\\tools\\python25\\python .\\resgen_img_group_compress.py --mg=%d --sg=%d -m %s -i %d > debug\\resgen_img_group_compress.log", 
            RES_MULTI_IMG_GROUP_MAX_SIZE, RES_SINGLE_IMG_GROUP_MAX_SIZE, IMG_GROUP_CMD_OPTION_THIRD_ROM_BINS, IMAGE_HANDL_OFFSET_LENGTH);
#endif //RES_BOOT_IMG_GROUPD_ID_CONFIG

    exeResult = execute_ext_command(cmdBuf);
    if( exeResult!= 0){
        RESGEN_LOG_E("Error!! Image Resoruce Code generation failed, please check plutommi\\customer\\resgenerator\\debug\\resgen_img_group_compress.log");
        fprintf(stderr,"\n** Error!! Image Resoruce Code generation failed!! \n** External python script resgen_img_group_compress.py return error\n** please check plutommi\\customer\\resgenerator\\debug\\resgen_img_group_compress.log for the detail\n");
        RES_LOG_PENDING_FATAL(RESGEN_TAG, "Error!! Image Resoruce Code generation failed!!", "External python script resgen_img_group_compress.py return error.","please check plutommi\\customer\\resgenerator\\debug\\resgen_img_group_compress.log for the detail");
    }
#endif
}

/*****************************************************************************
* FUNCTION
*  main
* DESCRIPTION
*  main function of mtk_resgenerator
* PARAMETERS
*
* RETURNS
*  int
*****************************************************************************/
int main(int argc, char *argv[])
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    char tempCommand[SHELL_CMD_BUFLEN];
    MMI_BOOL resourceLoadResult = MMI_FALSE;
    char custpaclLog[CUSTPACK_LOG_BUFLEN]="";

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    launch_resgen_services();

    {
        int i;
        RESGEN_LOG_V("argc = %d", argc);
        for(i=0;i<argc;i++)
            RESGEN_LOG_V("argv[%d] = %s", i, argv[i]);
    }

    if(argc == 5)   //Check if run by CustPack tool
    {

        remove(CUSTPACL_LOG_FILE_NAME);//Delete cust error log file
        if(strcmp(argv[1], "-f")==0 && (strcmp(argv[2], "-i")==0 || strcmp(argv[2], "-a")==0 || strcmp(argv[2], "-F")==0))//-i: image, -a: audio
        {
            U16 nType;
            S8 upperFileName[MAX_FILENAME_LEN];

            dest_file = fopen(argv[4], "wb");
            if (dest_file == NULL){
                resultFailFlag = 1;
                RESGEN_LOG_V("dest_file could not open!");
            }

            toolFlag = 1;
            ToolPopulateInitial();

            strncpy(upperFileName, argv[3], MAX_FILENAME_LEN);
            str_upper(upperFileName, MAX_FILENAME_LEN);

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
            disableENFB = 1;
#endif
            if(strcmp(argv[2], "-i")==0)
            {
                SetImageProcessData processData;
                initImageProcessData(&processData);
                ResgenImageOutStream * outstream;
                ImageOutStreamInit(&outstream);
                processData.outstream = outstream;

                if(Iload(upperFileName, SYSTEM_IMAGE, AUTO_TYPE, &processData) == MMI_TRUE)
                {
                    resourceLoadResult = MMI_TRUE;
                    char *curr_output_data_filename = "temp_image";
                    FILE *output_data_file = NULL;
                    output_data_file = fopen(curr_output_data_filename, "ab");
                    while (output_data_file == NULL)
                    {
                        Sleep(50);
                        output_data_file = fopen(curr_output_data_filename, "ab");
                    }

                    ImageOutStreamOutputFile(outstream, output_data_file);
                    ImageOutStreamDeinit(&outstream);
                    MYFCLOSE(output_data_file);
                }
                else
                {
                    resourceLoadResult = MMI_FALSE;
                    ImageOutStreamDeinit(&outstream);					
                }
            }
            else if(strcmp(argv[2], "-a")==0)
            {
                resourceLoadResult = Aload(upperFileName, &nType);
            }
            else if(strcmp(argv[2], "-F")==0)
            {
                resourceLoadResult = Fload(upperFileName, &nType);
            }
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
            disableENFB = 0;
#endif
            //ToolPopulateDone();

            if(dest_file != NULL)
            {
                fclose(dest_file);
            }

            if(resultFailFlag==1 || resourceLoadResult != MMI_TRUE)
            {
                if (strlen(argv[4]) > (SHELL_CMD_BUFLEN - 8))
                {
                    RESGEN_LOG_E("mtk_resgenerator.exe paramater error");
                    sprintf(custpaclLog,"[ERR] mtk_resgenerator.exe paramater error\n");

                }
                else
                {
                    //sprintf(tempCommand, "del -F %s", argv[4]);
                    //system(tempCommand);
                    if(argv[2]!=NULL && argv[3]!=NULL && argv[3]!=NULL)
                    {
                        RESGEN_LOG_E("mtk_resgenerator.exe %s failed, can't load %s, no output to %s",argv[2],argv[3],argv[4]);
                        sprintf(custpaclLog,"[ERR] mtk_resgenerator.exe %s failed, can't load %s, no output to %s\n",argv[2],argv[3],argv[4]);
                    }
                    else
                    {
                        RESGEN_LOG_E("mtk_resgenerator.exe can't indentify the parameter, please check if the ImageFilename and OutputFilename is valid.");
                        sprintf(custpaclLog,"[ERR] mtk_resgenerator.exe can't indentify the parameter, please check if the ImageFilename and OutputFilename is valid.\n");
                    }
                }
                writeLogToFile(CUSTPACL_LOG_FILE_NAME,custpaclLog,0);
                exit(2);
            }
        }
        else
        {
            RESGEN_LOG_E("Usage: mtk_resgenerator.exe -f [-i or -a] ImageFilename OutputFilename");
        }

        return 1;
    }

    if(argc==3 || argc==4)
    {
        if(strcmp(argv[1], "-g")==0 && strcmp(argv[2], "-x")==0)
        {
            if(argc==4 && strcmp(argv[3], "-c")==0)
            {
                /* -c is mean: clean unzip file anyway */
                g_is_clean = MMI_TRUE;
            }
            TRACETIME;
		#ifndef __POPULATE_NO_IMAGE_DATA__
            UnzipImage();
		#endif
            UnzipAudio();
            TRACETIME;
        }
#ifdef __REGEN_INTERNAL_BATCHED__
        else if(argc==3 && strcmp(argv[1], "-b")==0 ){
            if(argv[2]!=NULL){
                int batchedResgenResult = 0;
                BatchedResFileGenService *batchedResFileGenerator = new BatchedResFileGenService();
                batchedResgenResult=batchedResFileGenerator->generateResource(argv[2]);
                delete batchedResFileGenerator; 

                if(batchedResgenResult==0){
                    RESGEN_LOG_V("Batched Resgen finished successfully");
                    g_error = 1;
                    return 1;
                }else{
                    RESGEN_LOG_E("Batched Resgen failed");
                    return 2;
                }
            }else{
                fprintf(stderr, "Usage: mtk_resgenerator.exe -b [filename]\n");
                return 0;
            }
        }

#endif //__REGEN_INTERNAL_BATCHED__
        else
        {
            RESGEN_LOG_E("Usage: mtk_resgenerator.exe -g -x");
            return 0;
        }
    }

    if((argc==2 || argc==3 || argc==4) && strcmp(argv[1], "-g")==0)
    {
        /* Set program exit */
        atexit(resgen_on_exit);


        RESGEN_LOG_V("MediaTek Resource Generate System 0.1");

        if(!CreateDirectory("debug", 0))
        {
            RESGEN_LOG_V("'debug' directory already exists! ret=[%d]", GetLastError());
        }
        else
        {
            RESGEN_LOG_V("'debug' directory is created!");            
        }

        if(argc==4 && strcmp(argv[3], "-r")==0)
        {
            /* -r is mean: remake resource */
            g_is_log = MMI_FALSE;
        }



        /* ID Range Check */
        fprintf(stderr, "Resource ID range check old_last_menu=[%d], res_first=[%d] res_last=[%d].\n", MENU_ITEM_END, RESOURCE_BASE_FIRST_VALUE, RESOURCE_BASE_END_END);
        RESGEN_LOG_V("Resource ID range check old_last_menu=[%d], res_first=[%d] res_last=[%d].", MENU_ITEM_END, RESOURCE_BASE_FIRST_VALUE, RESOURCE_BASE_END_END);
        if (MENU_ITEM_END > RESOURCE_BASE_FIRST_VALUE)
        {
            fprintf(stderr, "Old menu ID more than RESOURCE_BASE_FIRST_VALUE, Please modify the number in MMIDataType.h.\n");
            RESGEN_LOG_E("Old menu ID more than RESOURCE_BASE_FIRST_VALUE, Please modify the number in MMIDataType.h.");
            exit(2);
        }
        if (RESOURCE_BASE_END_END > 0xFFFF)
        {
            fprintf(stderr, " RESOURCE_BASE total range overflow, more than 16bit. Please adjust the range in MMIDataType.h.\n");
            RESGEN_LOG_E(" RESOURCE_BASE total range overflow, more than 16bit, Please adjust the range in MMIDataType.h.");
            exit(2);
        }

        TRACETIME;

        prepare3DMetaPopulation();
#ifndef __POPULATE_NO_STRING_DATA__
        InitStrPopulate();
#endif
        /* Resource population */
        RESGEN_LOG_V("Start resource population");

#ifndef  __RESGEN_INTERNAL_OFFLINE__
        LegcayResPopController();
#else
        OfflineResPopController();
#endif
        /* Image resource generation */
#ifndef __POPULATE_NO_IMAGE_DATA__

        PopulateImageSearch();		
        GenerateImageResFile();
#ifdef __MMI_RESOURCE_IMAGE_COMPRESS__
        GenerateImageZipList();
#endif /* (__MMI_RESOURCE_IMAGE_COMPRESS__) */

        GenerateImageMapFile();
        GenerateImageMapSearchFile();
#endif //__POPULATE_NO_IMAGE_DATA__

        /* Audio resource generation */
        PopulateAudioSearch();
        GenerateAudioResFile();
#ifdef __MMI_RESOURCE_AUDIO_COMPRESS__
        GenerateAudioZipList();
#endif /* (__MMI_RESOURCE_AUDIO_COMPRESS__) */
        GenerateAudioMapFile();
        GenerateAudioMapSearchFile();

        /* Menu resource generation */
        GenerateMenuFile(CurrMaxMenuItemIndex);

        /* Font resource generation */
        PopulateFontSearch();
        GenerateFontResFile();
        GenerateFontMapFile();
        GenerateFontMapSearchFile();

        /* ENFB resource generation */
        GenerateENFBAssociatedIDFile();

#ifndef __POPULATE_NO_STRING_DATA__
        /* String resource generation */
        if (MergeStrRes() == 0)
        {
            RESGEN_LOG_V("GenerateStrResFile(): REF_LIST.txt created successfully");
            if (GenerateStrResFile() ==0){
                RESGEN_LOG_V("GenerateStrResFile(): Output: CustStrMap.c CustStrRes.c");
            }else{
                RESGEN_LOG_E("GenerateStrResFile(): Failed to generate: CustStrMap.c CustStrRes.c");
            }
			
        }else{
            RESGEN_LOG_E("GenerateStrResFile(): REF_LIST.txt creation failure");
        }
#endif //__POPULATE_NO_STRING_DATA__

#ifndef __POPULATE_NO_IMAGE_DATA__
        /* Image resource files sepatation */
        if(!split_img_data_file())
        {
            RESGEN_LOG_E("mtk_resgenerator.exe split custimgdatahw.h failed.");
            fprintf(stderr, "mtk_resgenerator.exe split custimgdatahw.h failed.\n");
        }

        CATResourceGeneration();
#endif //__POPULATE_NO_IMAGE_DATA__
        PostRegenOperations()
        TRACETIME;

        g_error = 1;
        return 1;
    }

    RESGEN_LOG_E("Usage: mtk_resgenerator.exe -g");
    return 0;
}

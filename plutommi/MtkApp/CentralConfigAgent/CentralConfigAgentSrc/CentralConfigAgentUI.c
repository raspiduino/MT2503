/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  CentralConfigAgentUI.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  CCA UI Related Codes
 *
 * Author:
 * -------
 * -------
 *                      
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*----------------------------------------------------------------------------*/
/* Include                                                                    */
/*----------------------------------------------------------------------------*/
#include "MMI_features.h"

#ifdef __MMI_CCA_SUPPORT__
#include "MMI_include.h"

#include "string.h"

#include "kal_general_types.h"
#include "kal_trace.h"
#include "stack_config.h"
#include "kal_public_api.h"
#include "kal_release.h"


#include "MMIDataType.h"
#include "GlobalResDef.h"
#include "GlobalConstants.h"
#include "DebugInitDef_Int.h"

#include "CustDataRes.h"
#include "Unicodexdcl.h"

#include "gui_data_types.h"
#include "wgui_categories_popup.h"
#include "wgui_categories_util.h"
#include "wgui_categories_text_viewer.h"
#include "wgui_inline_edit.h"
#include "CommonScreensResDef.h"
#include "MMI_inet_app_trc.h"


#include "custom_events_notify.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_frm_history_gprot.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_input_gprot.h"


//#include "AlarmFrameworkProt.h"
#include "AlertScreen.h"
//#include "IdleAppProt.h"
#include "IdleAppResDef.h"
#include "mmi_rp_app_idle_def.h"
#include "mmi_rp_srv_status_icons_def.h"

//#include "UcmSrvGprot.h"
//#include "UcmGprot.h"
#include "ModeSwitchSrvGprot.h"
#include "SimCtrlSrvGprot.h"
#include "NotificationGprot.h"
#include "ImeGprot.h"
#include "ProfilesSrvGProt.h"
#include "NetSetSrvGprot.h"
#include "NetSetAppGprot.h"

#include "IdleNotificationManagerGprot.h"


#include "UcmSrvGprot.h"


#ifdef __MMI_PROV_MESSAGE_SUPPORT__
#include "ProvBoxSrvGprot.h"
#endif 
#ifdef __MMI_NCENTER_SUPPORT__
#include "Vsrv_ncenter.h"
#endif


#ifdef __DM_LAWMO_SUPPORT__
#include "DMSrvGprot.h"
#endif

#include "CcaSrvGprot.h"
#include "CcaSrvIProt.h"

#include "mmi_rp_app_cca_def.h"
#include "CentralConfigAgentGprot.h"
#include "CentralConfigAgentProt.h"


/*----------------------------------------------------------------------------*/
/* Macro define                                                               */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Constant                                                                   */
/*----------------------------------------------------------------------------*/
#define  MMI_CCA_SETTING_INFO_PRE_HEAD       L"\n * "
#define MMI_CCA_SETTING_INFO_FIELD_END       L"\n  "
#define MMI_CCA_SETTING_INFO_VALUE_END       L"\n\n"




/*----------------------------------------------------------------------------*/
/* Enum                                                                       */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Typedef                                                                    */
/*----------------------------------------------------------------------------*/
typedef void (*mmi_cca_confirm_result_hdlr) (void);
static void mmi_cca_nmgr_notify_new_msg(void);

/*----------------------------------------------------------------------------*/
/* Structure                                                                  */
/*----------------------------------------------------------------------------*/
static const mmi_event_notify_enum g_cca_notify_event[] =
{
#if (MMI_MAX_SIM_NUM == 1)
    MMI_EVENT_SMS,
#endif
#if (MMI_MAX_SIM_NUM >= 2)
    MMI_EVENT_SIM1_SMS,
    MMI_EVENT_SIM2_SMS,
#endif
#if (MMI_MAX_SIM_NUM >= 3)
    MMI_EVENT_SIM3_SMS,
#endif
#if (MMI_MAX_SIM_NUM >= 4)
    MMI_EVENT_SIM4_SMS
#endif
};

/*----------------------------------------------------------------------------*/
/* Static API declaration                                                     */
/*----------------------------------------------------------------------------*/
/* Event handler */
static MMI_RET mmi_cca_srv_evt_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_notify_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_recv_invalid_msg_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_recv_new_msg_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_verify_pin_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_pre_install_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_post_install_hdlr(mmi_event_struct *event);
static MMI_RET mmi_cca_srv_evt_install_finished_hdlr(mmi_event_struct *event);


/*Progress Screen */
static void mmi_cca_ui_entry_progressing(void);
static void mmi_cca_ui_entry_progressing_int(void);
static void mmi_cca_ui_show_abort(void (*abort_cb) (void));

/* Setting Info screen */
static void mmi_cca_ui_show_settings_info_screen_int(void);
static MMI_RET mmi_cca_ui_setting_info_leave_proc(mmi_event_struct *param);
static void mmi_cca_ui_handle_settings_info_lsk(void);
static void mmi_cca_ui_handle_settings_info_rsk(void);
static void mmi_cca_ui_handle_settings_info_abort(void);

/* Authentication Screen */
static void mmi_cca_ui_entry_auth_screen_int(void);
static MMI_RET mmi_cca_ui_handle_auth_leave_proc(mmi_event_struct *param);
static void mmi_cca_ui_handle_auth_lsk(void);
static void mmi_cca_ui_handle_auth_rsk(void);
static void mmi_cca_ui_handle_auth_abort(void);

/* Summar Report Screen */
static void mmi_cca_ui_show_summary_report_screen(void);
static void mmi_cca_ui_show_summary_report_screen_int(void);
static MMI_RET mmi_cca_ui_handle_summary_report_leave_proc(mmi_event_struct *param);
static void mmi_cca_ui_handle_summary_report_lsk(void);

/* Setting Info */

static WCHAR *mmi_cca_generate_setting_info(U16 *buf_size, MMI_BOOL is_post, srv_cca_app_config_result_struct *app_cfg_result, S32 app_num);
static void mmi_cca_ui_show_settings_info_screen(mmi_cca_cntx_struct *cntx, srv_cca_evt_pre_install_struct *evt);

static srv_cca_status_enum mmi_cca_generate_setting_preinfo(U16 *buf, U16 *buf_size,
                            srv_cca_app_config_result_struct *app_cfg_result, S32 app_num);
static srv_cca_status_enum mmi_cca_generate_setting_postinfo(void *buf, U16 *buf_size,
                            srv_cca_app_config_result_struct *app_cfg_result, S32 app_num);

/* NMGR */
static void mmi_cca_nmgr_enter(void *user_data);


/* Group */
static void mmi_cca_enter_root_group(void);
static MMI_RET mmi_cca_group_proc(mmi_event_struct *param);
static void mmi_cca_show_confirm(MMI_ID gid, WCHAR* string, mmi_cca_confirm_result_hdlr yes_hdlr, mmi_cca_confirm_result_hdlr no_hdlr);
static S32 mmi_cca_forbidden_show(void);

#ifdef __MMI_NCENTER_SUPPORT__
#define MMI_CCA_NCENTER_TEXT_MAX_LEN 32
static vsrv_ngroup_handle mmi_cca_ncenter_get_group(void);
static void mmi_cca_ncenter_intent_callback(vsrv_notification_handle nid, vsrv_nintent intent, void* userData, U32 userDataSize);
static vsrv_notification_handle mmi_cca_ncenter_get_notification(vsrv_ngroup_handle gid);
static void mmi_cca_ncenter_notify_new_msg(void);
#endif

static void mmi_cca_installing_popup(void);

/*----------------------------------------------------------------------------*/
/* Extern API declaration                                                     */
/*----------------------------------------------------------------------------*/
extern MMI_ID mmi_provbox_scrn_group_get_id(void); //temp solution

/*----------------------------------------------------------------------------*/
/* Static global variable                                                     */
/*----------------------------------------------------------------------------*/
static mmi_cca_cntx_struct g_mmi_cca_cntx;
static mmi_cca_cntx_struct *mmi_cca_cntx_p;

static mmi_cca_confirm_result_hdlr g_mmi_cca_yes_hdlr;
static mmi_cca_confirm_result_hdlr g_mmi_cca_no_hdlr;





/*----------------------------------------------------------------------------*/
/* End                                                                        */
/*----------------------------------------------------------------------------*/

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_get_notify_event
 *
 * DESCRIPTION
 *  this function is to provide the notify event by sim index
 *
 * PARAMETERS
 *  U32       [IN]
 *  sim_idx: indicate which sim notify event is
 *
 * RETURNS
 *  mmi_event_notify_enum
 *****************************************************************************/
mmi_event_notify_enum mmi_cca_get_notify_event(U32 sim_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_cca_notify_event[sim_idx];
}



/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
MMI_RET mmi_cca_init(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_cntx_p = &g_mmi_cca_cntx;

#ifdef __MMI_NCENTER_SUPPORT__
    for(i = 0; i < MMI_CCA_INST_MAX_NUM; i++)
    {
        mmi_cca_cntx_p->inst_tbl[i].ncenter_gid = (vsrv_ngroup_handle)VSRV_NGROUP_INVALID_ID;
        mmi_cca_cntx_p->inst_tbl[i].ncenter_nid = (vsrv_notification_handle)VSRV_NOTIFICATION_INVALID_ID;
    }
#endif
	srv_cca_init(evt);

    srv_cca_set_event_proc(SRV_CCA_INVALID_HANDLE, mmi_cca_srv_evt_hdlr, mmi_cca_cntx_p);
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
mmi_cca_cntx_struct *mmi_cca_get_cntx(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_cca_cntx_p;
}

/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
extern mmi_cca_inst_struct *mmi_cca_get_inst(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &mmi_cca_get_cntx()->inst_tbl[0];
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_RET ret = MMI_RET_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(event->evt_id)
    {
        case EVT_ID_SRV_CCA_NOTIFY:
            ret = mmi_cca_srv_evt_notify_hdlr(event);
            break;
        
        case EVT_ID_SRV_CCA_RECV_INVALID_MSG:
            ret = mmi_cca_srv_evt_recv_invalid_msg_hdlr(event);
            break;

        case EVT_ID_SRV_CCA_RECV_NEW_MSG:
            ret = mmi_cca_srv_evt_recv_new_msg_hdlr(event);
            break;

        case EVT_ID_SRV_CCA_VERIFY_PIN:
            ret = mmi_cca_srv_evt_verify_pin_hdlr(event);
            break;

        case EVT_ID_SRV_CCA_PRE_INSTALL:
            ret = mmi_cca_srv_evt_pre_install_hdlr(event);
            break;

        case EVT_ID_SRV_CCA_POST_INSTALL:
            ret = mmi_cca_srv_evt_post_install_hdlr(event);
            break;

        case EVT_ID_SRV_CCA_INSTALL_FINISHED:
            ret = mmi_cca_srv_evt_install_finished_hdlr(event);
            break;
        default:
            break;
    }
	return ret;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_notify_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_evt_notify_struct *evt = (srv_cca_evt_notify_struct*)event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(evt->type)
    {
        case SRV_CCA_NOTIFY_TYPE_MEM_FULL:
            mmi_cca_ui_handle_memfull();
            break;

        case SRV_CCA_NOTIFY_TYPE_INVALID_SETTING:
            mmi_cca_ui_show_popup(STR_ID_CCA_INVALID_SETTING, (U8) MMI_EVENT_FAILURE);
            mmi_cca_ui_close_progressing();
            break;

        case SRV_CCA_NOTIFY_TYPE_NO_APP_SUPPORT:
            mmi_cca_ui_show_popup(STR_ID_CCA_NOAPP, (U8) MMI_EVENT_FAILURE);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
            break;

        case SRV_CCA_NOTIFY_TYPE_NOT_AVAILABLE:
            mmi_cca_ui_show_popup(STR_GLOBAL_NOT_AVAILABLE, (U8) MMI_EVENT_FAILURE);
            break;
            
        default:
            break;
    }
    return MMI_RET_OK;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_cca_srv_evt_recv_invalid_msg_hdlr
 * DESCRIPTION
 *  If it's an invalid new message, or some error due to CS can not handle it
 *  and sends CCA some error message, just only need to show popup.
 *  If current messsage is invalid or CS meets some error, need to do:
 *  1. Show popup 
 *  2. Stop current messsage installing and close all related screen which is progress only now.
 *  3. This can only occure dur the period that after user input right PIN and before 
 *     show "Setting info" screen.
 *
 * PARAMETERS
 *  strid       [IN]        
 *  type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_recv_invalid_msg_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_evt_recv_invalid_msg_struct *evt = (srv_cca_evt_recv_invalid_msg_struct*)event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    if (mmi_cca_forbidden_show())
        return MMI_RET_OK;

    mmi_cca_show_invalid_popup(evt->status);

    /* If it's a new one,just show error popup, if it's current one being installed, should stop it. */
    if (!evt->is_new_msg)
    {
        mmi_cca_ui_close_progressing();
        mmi_cca_free_setting_info();
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_recv_new_msg_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_NCENTER_SUPPORT__
    mmi_cca_ncenter_notify_new_msg();
#endif
    /* New NMGR*/
    //mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_CCA, MMI_EVENT_SMS, 
    //    (WCHAR *)get_string(STR_ID_CCA_NEW_SETTING));
    mmi_cca_nmgr_notify_new_msg();
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_verify_pin_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_evt_verify_pin_struct *evt = (srv_cca_evt_verify_pin_struct*)event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->status)
    {
        case SRV_CCA_VERIFY_PIN_STATUS_REQ:
            if (mmi_cca_forbidden_show()) 
            {
                mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
                mmi_frm_group_close(inst->self_gid);
                srv_cca_apply_action(evt->h_cca, SRV_CCA_ACTION_TYPE_PIN_ABORT, NULL, 0);
                break;
            }
            mmi_cca_reset_pin_buffer();

            /* for provbox case */
            if (!mmi_frm_scrn_is_present(inst->self_gid, SCR_ID_CCA_PROGRESS, MMI_FRM_NODE_ALL_FLAG))
                mmi_cca_ui_entry_progressing();

            mmi_cca_ui_entry_auth_screen();

            mmi_cca_notify_group_entered();
            break;
                
        case SRV_CCA_VERIFY_PIN_STATUS_MEM_FULL:
            mmi_cca_ui_handle_memfull();
            mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_AUTH);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
            break;
            
        case SRV_CCA_VERIFY_PIN_STATUS_ABORT:
            mmi_cca_ui_show_popup(STR_ID_CCA_AUTH_FAILED, (U8) MMI_EVENT_FAILURE);
            mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_AUTH);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
            break;
            
        case SRV_CCA_VERIFY_PIN_STATUS_RETRY:
            mmi_cca_reset_pin_buffer();
            mmi_cca_ui_show_popup(STR_ID_CCA_PIN_RETRY, (U8) MMI_EVENT_FAILURE);
            mmi_frm_scrn_clean_gui_buf(inst->self_gid, SCR_ID_CCA_AUTH);
            break;
            
        case SRV_CCA_VERIFY_PIN_STATUS_FAIL:
            mmi_cca_ui_show_popup(STR_ID_CCA_AUTH_FAILED, (U8) MMI_EVENT_FAILURE);
            mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_AUTH);
            mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
            break;
            
        case SRV_CCA_VERIFY_PIN_STATUS_PASS:
            mmi_cca_auth_verify_pass();
            break;
            
        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_pre_install_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_cca_cntx_struct *cntx = mmi_cca_get_cntx();
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_evt_pre_install_struct *evt = (srv_cca_evt_pre_install_struct*)event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_free_setting_info();
    inst->setting_info = mmi_cca_generate_setting_info(&inst->info_size, evt->has_config_result,
                                evt->app_config_result, evt->config_num);

    if (inst->setting_info == NULL)
    {
        mmi_cca_ui_handle_memfull();
        
        srv_cca_apply_action(evt->h_cca, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);
        return MMI_RET_OK;
    }
    if (evt->is_msg_from_box)
        MMI_CCA_SET_FLAG(inst->flags, MMI_CCA_INST_FLAG_IS_MSG_FROM_BOX);
   
    mmi_cca_ui_show_settings_info_screen(cntx, evt);
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_post_install_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_evt_post_install_struct *evt = (srv_cca_evt_post_install_struct*)event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_free_setting_info();
    inst->setting_info = mmi_cca_generate_setting_info(&inst->info_size, MMI_TRUE,
        evt->app_config_result, evt->config_num);

    if (inst->setting_info == NULL)
    {
        mmi_cca_ui_handle_memfull();
        
        srv_cca_apply_action(evt->h_cca, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);
        return MMI_RET_OK;
    }
    mmi_cca_ui_entry_summary_report(); 
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_cca_srv_evt_install_finished_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_ui_close_progressing();
    mmi_cca_free_setting_info();
#ifdef __MMI_NCENTER_SUPPORT__
    mmi_cca_ncenter_notify_new_msg();
#endif

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_popup
 * DESCRIPTION
 *  Show popup
 * PARAMETERS
 *  strid       [IN]        
 *  type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_show_popup(U16 strid, U8 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cca_forbidden_show())
        return;

    mmi_popup_display_simple((WCHAR*)GetString(strid), (mmi_event_notify_enum) type, mmi_cca_get_root_group(), NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_show_invalid_popup
 * DESCRIPTION
 *  show invalid setting message pop up
 * PARAMETERS
 *  status      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_show_invalid_popup(srv_cca_status_enum status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 strid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (status)
    {
        case SRV_CCA_STATUS_FAIL:
        case SRV_CCA_STATUS_UNSUPPORTED_SETTING:
            strid = STR_ID_CCA_INVALID_SETTING;
            break;

        case SRV_CCA_STATUS_CORRUPTED_SETTING:
            strid = STR_ID_CCA_CORRUPTED_SETTING;
            break;

        case SRV_CCA_STATUS_MISSING_DATA:
            strid = STR_ID_CCA_MISSING_DATA;
            break;

        case SRV_CCA_STATUS_AUTH_FAILED:
            strid = STR_ID_CCA_AUTH_FAILED;
            break;

        case SRV_CCA_STATUS_MEMFULL:
            strid = STR_GLOBAL_INSUFFICIENT_MEMORY;
            break;

    #ifdef __MMI_PROV_MESSAGE_SUPPORT__
        case SRV_CCA_STATUS_GET_MSG_FAILED:
            strid = STR_ID_CCA_GET_MSG_FAILED;
            break;
    #endif /* __MMI_PROV_MESSAGE_SUPPORT__ */ 

        default:
            strid = STR_ID_CCA_INVALID_SETTING;
            break;
    }

    mmi_cca_ui_show_popup(strid, (U8) MMI_EVENT_FAILURE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_memfull
 * DESCRIPTION
 *  Handle memory full scenario (ie, show MemFull popup)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_handle_memfull(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_ui_show_popup(STR_GLOBAL_INSUFFICIENT_MEMORY, (U8) MMI_EVENT_FAILURE);
    mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_entry_progressing
 * DESCRIPTION
 *  Entry Progressing screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_entry_progressing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_enter_root_group();
    mmi_cca_ui_entry_progressing_int();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_entry_progressing_int
 * DESCRIPTION
 *  Entry Progressing screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_entry_progressing_int(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guibuff;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(inst->self_gid, SCR_ID_CCA_PROGRESS, NULL, mmi_cca_ui_entry_progressing_int, MMI_FRM_UNKNOW_SCRN))
        return;
    
    guibuff = mmi_frm_scrn_get_gui_buf (inst->self_gid, SCR_ID_CCA_PROGRESS);

    ShowCategory66Screen(
        STR_ID_CCA_NEW_SETTING,
        IMG_ID_CCA_MAIN_ICON,
        0,
        0,
        0,
        0,
        (U8*) get_string(STR_ID_CCA_PROGRESS_CONTENT),
        mmi_get_event_based_image(MMI_EVENT_PROGRESS),
        guibuff);

    ClearAllKeyHandler();
    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_close_progressing
 * DESCRIPTION
 *  Entry Settings Info (construct info)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_close_progressing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_common_cancel_with_sg
 * DESCRIPTION
 *  Show abort/cancel confirmation screen with text specified by text_str_id
 *  function triggers cancel_cb when dialog's LSK has been pressed
 * PARAMETERS
 *  text_str_id     [IN]        
 *  cancel_cb       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_common_cancel_with_sg(MMI_ID parent_id, U16 text_str_id, void (*cancel_cb) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_CCA_CHECK_FLAG(inst->flags, MMI_CCA_INST_FLAG_IS_MSG_FROM_BOX))
    {
        if (cancel_cb)
            cancel_cb();
        return;
    }
    
    if (mmi_cca_forbidden_show())
    {
        return;
    }

    mmi_cca_show_confirm(parent_id, (WCHAR*)GetString(text_str_id), 
        cancel_cb, mmi_frm_scrn_close_active_id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_abort
 * DESCRIPTION
 *  Show abort confirmation screen
 * PARAMETERS
 *  abort_cb        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_show_abort(void (*abort_cb) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_cca_ui_common_cancel_with_sg(mmi_cca_get_root_group(), STR_ID_CCA_ABORT_ASK, abort_cb);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_settings_info_screen
 * DESCRIPTION
 *  Show Settings Info screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_show_settings_info_screen(mmi_cca_cntx_struct *cntx, srv_cca_evt_pre_install_struct *evt)
{
    mmi_cca_enter_root_group();
    mmi_cca_ui_show_settings_info_screen_int();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_settings_info_screen
 * DESCRIPTION
 *  Show Settings Info screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_show_settings_info_screen_int(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guibuff;
    U16 rsk_label = STR_GLOBAL_CANCEL;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cca_forbidden_show())
    {
        return;
    }

    if (MMI_CCA_CHECK_FLAG(inst->flags, MMI_CCA_INST_FLAG_IS_MSG_FROM_BOX))
        rsk_label = STR_GLOBAL_BACK;

    if (!mmi_frm_scrn_enter(inst->self_gid, SCR_ID_CCA_PRE_INFO, NULL, mmi_cca_ui_show_settings_info_screen_int, MMI_FRM_UNKNOW_SCRN))
        return;

    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_PRE_INFO, mmi_cca_ui_setting_info_leave_proc);
    
    guibuff = mmi_frm_scrn_get_gui_buf (inst->self_gid, SCR_ID_CCA_PRE_INFO);

    ShowCategory74Screen(
        STR_ID_CCA_SETTING_INFO,
        IMG_ID_CCA_MAIN_ICON,
        STR_GLOBAL_INSTALL,
        IMG_GLOBAL_OK,
        rsk_label,
        IMG_GLOBAL_BACK,
        (U8*) inst->setting_info,
        (S32) inst->info_size,
        guibuff);

    SetRightSoftkeyFunction(mmi_cca_ui_handle_settings_info_rsk, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(mmi_cca_ui_handle_settings_info_lsk, KEY_EVENT_UP);

	ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
	SetCenterSoftkeyFunction(mmi_cca_ui_handle_settings_info_lsk, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_setting_info_leave_proc
 * DESCRIPTION
 *  Show Settings Info screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_cca_ui_setting_info_leave_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_PRE_INFO, NULL);
    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);
    return MMI_RET_ALLOW_CLOSE; 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_settings_info_lsk
 * DESCRIPTION
 *  Settings Info LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_settings_info_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    srv_cca_act_para_start_install_struct act_para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_PRE_INFO, NULL);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0

    mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PRE_INFO);
    mmi_cca_free_setting_info();

    act_para.h_cca = SRV_CCA_INVALID_HANDLE;
    act_para.has_selected = MMI_FALSE;
    
    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_START_INSTALL, (void*)&act_para, sizeof(srv_cca_act_para_start_install_struct));
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_settings_info_rsk
 * DESCRIPTION
 *  Settings Info RSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_settings_info_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_ui_show_abort(mmi_cca_ui_handle_settings_info_abort);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_settings_info_abort
 * DESCRIPTION
 *  Settings Info RSK ABORT handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_settings_info_abort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_PRE_INFO, NULL);

    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);

    mmi_frm_group_close(inst->self_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_entry_auth_screen
 * DESCRIPTION
 *  Entry PIN authentication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_entry_auth_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_enter_root_group();
    mmi_cca_ui_entry_auth_screen_int();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_entry_auth_screen_int
 * DESCRIPTION
 *  Entry PIN authentication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_entry_auth_screen_int(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cca_forbidden_show())
        return;

    if (!mmi_frm_scrn_enter(inst->self_gid, SCR_ID_CCA_AUTH, NULL, mmi_cca_ui_entry_auth_screen_int, MMI_FRM_UNKNOW_SCRN))
        return;
    
    guiBuffer = mmi_frm_scrn_get_gui_buf (inst->self_gid, SCR_ID_CCA_AUTH);

    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, mmi_cca_ui_handle_auth_leave_proc);
    
    ShowCategory111Screen(STR_GLOBAL_OK,
        0, 
        STR_GLOBAL_CANCEL, 
        0, 
        STR_ID_CCA_AUTH_CONTENT, 
        IMM_INPUT_TYPE_NUMERIC_PASSWORD, 
        (U8*) inst->pin_code, 
        SRV_CCA_MAX_PIN_CHARS + 1, 
        NULL, 
        guiBuffer);

    SetLeftSoftkeyFunction(mmi_cca_ui_handle_auth_lsk, KEY_EVENT_UP);
    SetCategory111RightSoftkeyFunction(mmi_cca_ui_handle_auth_rsk, KEY_EVENT_UP);
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetCenterSoftkeyFunction(mmi_cca_ui_handle_auth_lsk, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_auth_leave_proc
 * DESCRIPTION
 *  Handle PIN authentication screen LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_cca_ui_handle_auth_leave_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
    
    srv_cca_apply_action(0, SRV_CCA_ACTION_TYPE_PIN_ABORT, NULL, 0);
    return MMI_RET_ALLOW_CLOSE; 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_auth_lsk
 * DESCRIPTION
 *  Handle PIN authentication screen LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_auth_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->pin_code[0] == '\0')
    {
        mmi_cca_ui_show_popup(STR_ID_CCA_PIN_EMPTY, (U8) MMI_EVENT_FAILURE);
        return;
    }

    srv_cca_apply_action(0, SRV_CCA_ACTION_TYPE_PIN_INPUT, (void *)inst->pin_code, (SRV_CCA_MAX_PIN_CHARS + 1) * ENCODING_LENGTH);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_auth_rsk
 * DESCRIPTION
 *  Handle PIN authentication screen RSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_auth_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_ui_show_abort(mmi_cca_ui_handle_auth_abort);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_auth_abort
 * DESCRIPTION
 *  Handle abort auth screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_auth_abort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);

    srv_cca_apply_action(0, SRV_CCA_ACTION_TYPE_PIN_ABORT, NULL, 0);

    mmi_frm_group_close(inst->self_gid);
}   
    

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_auth_verify_pass
 * DESCRIPTION
 *  Handle abort auth screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_auth_verify_pass(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_AUTH, NULL);
    mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_AUTH);
}
    

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_reset_pin_buffer
 * DESCRIPTION
 *  Entry Summary Report screen (construct info)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_reset_pin_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    memset(inst->pin_code, 0x0, (SRV_CCA_MAX_PIN_CHARS + 1) * ENCODING_LENGTH);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_entry_summary_report
 * DESCRIPTION
 *  Entry Summary Report screen (construct info)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_ui_entry_summary_report(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_ui_show_summary_report_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_summary_report_screen
 * DESCRIPTION
 *  Show Summary Report screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_show_summary_report_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_enter_root_group();
    mmi_cca_ui_show_summary_report_screen_int();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_show_summary_report_screen_int
 * DESCRIPTION
 *  Show Summary Report screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_show_summary_report_screen_int(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guibuff;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cca_forbidden_show())
    {
        return;
    }

    if (!mmi_frm_scrn_enter(inst->self_gid, SCR_ID_CCA_POST_INFO, NULL, mmi_cca_ui_show_summary_report_screen_int, MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_POST_INFO, mmi_cca_ui_handle_summary_report_leave_proc);
    
    guibuff = mmi_frm_scrn_get_gui_buf (inst->self_gid, SCR_ID_CCA_POST_INFO);


    ShowCategory74Screen(
        STR_ID_CCA_POSTINFO_TITLE,
        IMG_ID_CCA_MAIN_ICON,
        STR_GLOBAL_OK,
        STR_GLOBAL_OK,
        0,
        0,
        (U8*) inst->setting_info,
        (S32) inst->info_size,
        guibuff);

    mmi_frm_scrn_close(inst->self_gid, SCR_ID_CCA_PROGRESS);

    /* According BD team's conclusion and sync to COSMOS UE, should set OK to LSK instead of set BACK to RSK */
    SetLeftSoftkeyFunction(mmi_cca_ui_handle_summary_report_lsk, KEY_EVENT_UP);
    
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetCenterSoftkeyFunction(mmi_cca_ui_handle_summary_report_lsk, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_summary_report_leave_proc
 * DESCRIPTION
 *  Handle Summary Report screen LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_cca_ui_handle_summary_report_leave_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_POST_INFO, NULL);

    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);

    return MMI_RET_ALLOW_CLOSE; 
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_ui_handle_summary_report_lsk
 * DESCRIPTION
 *  Handle Summary Report screen LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_ui_handle_summary_report_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_set_leave_proc(inst->self_gid, SCR_ID_CCA_POST_INFO, NULL);

    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_INSTALL_COMPLETE, NULL, 0);

    mmi_frm_group_close(inst->self_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_generate_setting_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  buf_size        [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
static WCHAR *mmi_cca_generate_setting_info(U16 *buf_size, MMI_BOOL has_cfg_result, 
                                    srv_cca_app_config_result_struct *app_cfg_result, S32 app_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    WCHAR *buf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buf_size == NULL)
        return NULL;

    if (!has_cfg_result)
        mmi_cca_generate_setting_preinfo(NULL, buf_size, app_cfg_result, app_num);
    else
        mmi_cca_generate_setting_postinfo(NULL, buf_size, app_cfg_result, app_num);
 
    buf = (WCHAR*)OslMalloc((U32) * buf_size);
    if (buf == NULL)
    {
        *buf_size = 0;
        return NULL;
    }
    if (!has_cfg_result)
        mmi_cca_generate_setting_preinfo(buf, buf_size, app_cfg_result, app_num);
    else
        mmi_cca_generate_setting_postinfo(buf, buf_size, app_cfg_result, app_num);
    return buf;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_generate_setting_preinfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  buf             [OUT]       
 *  buf_size        [OUT]       
 * RETURNS
 *  
 *****************************************************************************/
static srv_cca_status_enum mmi_cca_generate_setting_preinfo(U16 *buf, U16 *buf_size,
                            srv_cca_app_config_result_struct *app_cfg_result, S32 app_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    S32 info_len = 0;
    U8 *pre_str;
    U8 *app_name;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buf_size == NULL)
        return SRV_CCA_STATUS_FAIL;

    /* First to check buffer size */
    pre_str = (U8*) get_string(STR_ID_CCA_PREINFO_CONTENT);
    info_len += mmi_ucs2strlen((const CHAR*)pre_str);

    for (i = 0; i < app_num; i++)
    {
        app_name = (U8*) get_string(mmi_cca_get_app_names(app_cfg_result[i].config_id, MMI_FALSE));
		if (!app_name)
			continue;
        info_len += mmi_ucs2strlen((const CHAR*)app_name);
        info_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_PRE_HEAD);
    }
    if (buf == NULL || *buf_size < (info_len + 1) * ENCODING_LENGTH)
    {
        *buf_size = (info_len + 1) * ENCODING_LENGTH;
        return SRV_CCA_STATUS_FAIL;
    }

    if (buf == NULL)
        return SRV_CCA_STATUS_FAIL;

    /* then to */
    info_len = 0;
    pre_str = (U8*) get_string(STR_ID_CCA_PREINFO_CONTENT);
    info_len += mmi_ucs2strlen((const CHAR*)pre_str);
    mmi_ucs2cpy((CHAR*) buf, (const CHAR*)pre_str);

    for (i = 0; i < app_num; i++)
    {
        app_name = (U8*) get_string(mmi_cca_get_app_names(app_cfg_result[i].config_id, MMI_FALSE));
		if (!app_name)
			continue;

		mmi_ucs2cpy((CHAR*) buf + ((info_len) * 2), (const CHAR*)MMI_CCA_SETTING_INFO_PRE_HEAD);
        info_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_PRE_HEAD);

        mmi_ucs2cpy((CHAR*) buf + ((info_len) * 2), (const CHAR*)app_name);
        info_len += mmi_ucs2strlen((const CHAR*)app_name);
    }
    return SRV_CCA_STATUS_OK;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_generate_setting_postinfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  buf             [OUT]       
 *  buf_size        [OUT]       
 * RETURNS
 *  
 *****************************************************************************/
static srv_cca_status_enum mmi_cca_generate_setting_postinfo(void *buf, U16 *buf_size,
            srv_cca_app_config_result_struct *app_cfg_result, S32 app_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
	S32 skip_count = 0;
    S32 report_len;
    U8 *crtAppName;
    U8 *strDone;
    U8 *strInvalid;
    U8 *strSkipped;
    U8 *strUpdated;
    U8 *strFailed;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (buf_size == NULL)
        return SRV_CCA_STATUS_FAIL;

    strDone = (U8*) get_string(STR_ID_CCA_CONFIGURED);
    strInvalid = (U8*) get_string(STR_ID_CCA_INVALID_SETTING);
    strSkipped = (U8*) get_string(STR_ID_CCA_SETTING_SKIPPED);
    strUpdated = (U8*) get_string(STR_ID_CCA_UPDATED);
    strFailed = (U8*)get_string(STR_ID_CCA_FAILED);
    
    report_len = 0;
    for (i = 0; i < app_num; i++)
    {
        crtAppName = (U8*) get_string(mmi_cca_get_app_names(app_cfg_result[i].config_id, MMI_TRUE));
		if (!crtAppName)
		{
			skip_count++;
			continue;
		}
        report_len += mmi_ucs2strlen((const CHAR*)crtAppName);
        report_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_FIELD_END);

        switch (app_cfg_result[i].result)
        {
            case SRV_CCA_STATUS_OK:
                report_len += mmi_ucs2strlen((const CHAR*)strDone);
                break;

            case SRV_CCA_STATUS_FAIL:
                report_len += mmi_ucs2strlen((const CHAR*)strFailed);
                break;

            case SRV_CCA_STATUS_INVALID_SETTING:
                report_len += mmi_ucs2strlen((const CHAR*)strInvalid);
                break;

            case SRV_CCA_STATUS_SETTING_UPDATED:
                report_len += mmi_ucs2strlen((const CHAR*)strUpdated);
                break;

            case SRV_CCA_STATUS_SETTING_SKIPPED:
            default:
                report_len += mmi_ucs2strlen((const CHAR*)strSkipped);
                break;
        }

        if (i < app_num - 1 - skip_count)
        {
            report_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_VALUE_END);
        }
    }
    if (*buf_size < (report_len + 1) * ENCODING_LENGTH)
    {
        *buf_size = (report_len + 1) * ENCODING_LENGTH;
        return SRV_CCA_STATUS_FAIL;
    }

    report_len = 0;
    for (i = 0; i < app_num; i++)
    {
        crtAppName = (U8*) get_string(mmi_cca_get_app_names(app_cfg_result[i].config_id, MMI_TRUE));
		if (!crtAppName)
			continue;

        mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)crtAppName);
        report_len += mmi_ucs2strlen((const CHAR*)crtAppName);

        mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)MMI_CCA_SETTING_INFO_FIELD_END);
        report_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_FIELD_END);

        switch (app_cfg_result[i].result)
        {
            case SRV_CCA_STATUS_OK:
                mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)strDone);
                report_len += mmi_ucs2strlen((const CHAR*)strDone);
                break;

            case SRV_CCA_STATUS_FAIL:
                mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)strFailed);
                report_len += mmi_ucs2strlen((const CHAR*)strFailed);
                break;

            case SRV_CCA_STATUS_INVALID_SETTING:
                mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)strInvalid);
                report_len += mmi_ucs2strlen((const CHAR*)strInvalid);
                break;

            case SRV_CCA_STATUS_SETTING_UPDATED:
                mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)strUpdated);
                report_len += mmi_ucs2strlen((const CHAR*)strUpdated);
                break;

            case SRV_CCA_STATUS_SETTING_SKIPPED:
            default:
                mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)strSkipped);
                report_len += mmi_ucs2strlen((const CHAR*)strSkipped);
                break;
        }

        if (i < app_num - 1 - skip_count)
        {
            mmi_ucs2cpy((CHAR*) buf + (report_len * 2), (const CHAR*)MMI_CCA_SETTING_INFO_VALUE_END);
            report_len += mmi_ucs2strlen((const CHAR*)MMI_CCA_SETTING_INFO_VALUE_END);
        }
    }
    return SRV_CCA_STATUS_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_free_setting_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_free_setting_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->setting_info)
    {
        OslMfree(inst->setting_info);
        inst->setting_info = NULL;
        inst->info_size = 0;
    }
}

static void mmi_cca_installing_popup(void)
{
        //mmi_cca_ui_show_popup(STR_ID_CCA_INSTALLING_RETRY, (U8) MMI_EVENT_INFO);
	    /* MAUI_03197978 : We can't use cca group as we have to show this popup in every screen */
		mmi_popup_display_simple((WCHAR*)GetString(STR_ID_CCA_INSTALLING_RETRY), (mmi_event_notify_enum) MMI_EVENT_INFO, GRP_ID_ROOT, NULL);
    /* MAUI_03194171 : now we will draw cell in ncenter because notificaiton is cleared but new message remain in queue(hence queue full) */
#ifdef __MMI_NCENTER_SUPPORT__
      mmi_cca_ncenter_notify_new_msg();
#endif
}

#ifdef __MMI_NCENTER_SUPPORT__

static vsrv_ngroup_handle mmi_cca_ncenter_get_group(void)
{
    vsrv_ngroup_handle gid;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    //if (inst->ncenter_gid != (vsrv_ngroup_handle)VSRV_NGROUP_INVALID_ID)
    //    return inst->ncenter_gid;
    //else
    {
        gid = vsrv_ncenter_create_ngroup(VSRV_NGROUP_TYPE_SINGLE_TITLE, APP_CCA);
        vsrv_ncenter_set_ngroup_title_str(gid, (WCHAR *)get_string(STR_ID_CCA_SETTINGS_MESSAGE));
        inst->ncenter_gid = gid;
        return gid;
    }
}

static void mmi_cca_ncenter_intent_callback(vsrv_notification_handle nid, vsrv_nintent intent, void* userData, U32 userDataSize)
{
	WCHAR notify[MMI_CCA_NCENTER_TEXT_MAX_LEN + 1] = {0};
	U32 unread_num;
	U32 sim_num_list[MMI_SIM_TOTAL];
	mmi_sim_enum first_sim_id;  
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_ENTER);

    if (intent.type == VSRV_NINTENT_TYPE_LAUNCH)
    {
        if (inst->self_gid != GRP_ID_INVALID)
        {
            StartTimer(TIMER_ID_CCA_NMGR_POPUP, 0, mmi_cca_installing_popup);
        }
        else
        {
            mmi_cca_ui_entry_progressing();
            srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_VIEW_NEW_MSG, NULL, 0);
            if (inst->hnmgr)
            	mmi_frm_nmgr_alert_cancel(inst->hnmgr);
        }
    }
    else if (intent.type == VSRV_NINTENT_TYPE_CLEAR)
    {
        mmi_cca_inst_struct *inst = mmi_cca_get_inst();
        srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_CANCEL_NEW_MSG, NULL, 0);
        inst->ncenter_nid = (vsrv_notification_handle)VSRV_NOTIFICATION_INVALID_ID;
        if (inst->hnmgr)
            mmi_frm_nmgr_alert_cancel(inst->hnmgr);
    }
    else if (intent.type == VSRV_NINTENT_TYPE_LANGUAGE_CHANGED)
    {
		inst->ncenter_gid = vsrv_ncenter_query_ngroup(APP_CCA);
		if(inst->ncenter_gid == NULL);	     
		        mmi_cca_ncenter_get_group();
		 vsrv_ncenter_set_ngroup_title_str(inst->ncenter_gid, (WCHAR *)get_string(STR_ID_CCA_SETTINGS_MESSAGE));
		 vsrv_ncenter_set_notification_maintext_str(nid, (WCHAR *)get_string(STR_ID_CCA_SETTINGS_MESSAGE));
		 unread_num = srv_cca_get_unread_msg_num(sim_num_list, MMI_SIM_TOTAL, &first_sim_id);
		 if (!unread_num)
				return;
		 kal_wsprintf(notify, "%d %w", unread_num, get_string(STR_ID_CCA_NEW_SETTING));
         vsrv_ncenter_set_notification_subtext_str(nid, (WCHAR*)notify);
		 vsrv_ncenter_notify_notification(nid); 
    }
}

static void mmi_cca_ncenter_clear_notification(void)
{
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    if (inst->ncenter_nid != (vsrv_notification_handle)VSRV_NOTIFICATION_INVALID_ID)
        vsrv_ncenter_close_notification(inst->ncenter_nid);
    inst->ncenter_nid = (vsrv_notification_handle)VSRV_NOTIFICATION_INVALID_ID;
}

static vsrv_notification_handle mmi_cca_ncenter_get_notification(vsrv_ngroup_handle gid)
{
    vsrv_notification_handle nid;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    //if (inst->ncenter_nid != (vsrv_notification_handle)VSRV_NOTIFICATION_INVALID_ID)
    //    return inst->ncenter_nid;
    nid  = 
        vsrv_ncenter_create_notification(VSRV_NOTIFICATION_TYPE_EVENT, gid, 0);
    
    inst->ncenter_nid = nid;
    vsrv_ncenter_set_notification_maintext_str(nid, (WCHAR *)get_string(STR_ID_CCA_SETTINGS_MESSAGE));
    vsrv_ncenter_set_notification_intent_callback(nid, mmi_cca_ncenter_intent_callback, NULL, 0);
    
    return nid;
}



static void mmi_cca_ncenter_notify_new_msg(void)
{
    vsrv_ngroup_handle gid;
    vsrv_notification_handle nid;
    WCHAR notify[MMI_CCA_NCENTER_TEXT_MAX_LEN + 1] = {0};
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    U32 unread_num;
    mmi_sim_enum first_sim_id;  
    U32 sim_num_list[MMI_SIM_TOTAL];

    unread_num = srv_cca_get_unread_msg_num(sim_num_list, MMI_SIM_TOTAL, &first_sim_id);
    if (!unread_num)
        return;
    
    gid = mmi_cca_ncenter_get_group();
    nid = mmi_cca_ncenter_get_notification(gid);

    kal_wsprintf(notify, "%d %w", unread_num, get_string(STR_ID_CCA_NEW_SETTING));

    vsrv_ncenter_set_notification_subtext_str(nid, (WCHAR*)notify);
    vsrv_ncenter_notify_notification(nid); 
}

#endif

/* New NMGR*/
static mmi_ret mmi_cca_nmgr_proc(mmi_event_struct *evt)
{
	 mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    if(evt->evt_id == EVT_ID_NMGR_TEXT_PREVIEW_APP_LAUNCH ||
       evt->evt_id == EVT_ID_NMGR_POPUP_APP_LAUNCH)
    {
			if (inst->self_gid != GRP_ID_INVALID)
			{
				StartTimer(TIMER_ID_CCA_NMGR_POPUP, 0, mmi_cca_installing_popup);
			}
			else
			{
                                mmi_cca_nmgr_enter(NULL);
                        }
    }
#ifndef __MMI_NCENTER_SUPPORT__
    else if(evt->evt_id == EVT_ID_NMGR_ALERT_END)
    {
        mmi_cca_nmgr_cancel();
    }
#endif
    return MMI_TRUE;
}

static void mmi_cca_nmgr_notify_new_msg(void)
{
	WCHAR temp_buf[128];
    mmi_frm_nmgr_alert_struct alert_info;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    U8 i,unread_num;
    mmi_sim_enum sim_id;
    U32 notify_sim = 0;
    U32 sim_num_list[MMI_SIM_TOTAL];

    unread_num = srv_cca_get_unread_msg_num(sim_num_list, MMI_SIM_TOTAL, &sim_id);   
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        if (MMI_CCA_IDX2BIT(i) == sim_id)
        {
            notify_sim = i;
            break;
        }
    }
    kal_wsprintf(temp_buf, "%d %w", unread_num, get_string(STR_ID_CCA_NEW_SETTING));
  
    memset(&alert_info, 0, sizeof(mmi_frm_nmgr_alert_struct)); 

    alert_info.app_id = APP_CCA;
    alert_info.scen_id = MMI_SCENARIO_ID_CCA;
    alert_info.event_type = mmi_cca_get_notify_event(notify_sim);
    /*fill in the notification information, if your app's notification can be controlled by NSS, your UI mask must include icon, status bar and popup*/
    alert_info.ui_mask = MMI_FRM_NMGR_UI_STATUS_ICON_MASK|MMI_FRM_NMGR_UI_STATUS_BAR_MASK|MMI_FRM_NMGR_UI_POPUP_MASK;
    /*Once the NSS is not support , NMGR will take the behavior mask as its behavior guildline*/
#ifndef __MMI_NCENTER_SUPPORT__
    alert_info.behavior_mask = FORCE_POPUP;
#else
    alert_info.behavior_mask = PREFER_POPUP; // or PREFER_STATUS_BAR. PREFER_ICON_ONLY
#endif
    /*fill in the status bar information*/
    alert_info.status_bar_para.status_bar_type = MMI_FRM_NMGR_ALERT_ST_PREVIEW_TYPE;
    /*the image icon is used for text preview, can be different from popup*/
    //alert_info.status_bar_para.app_type = NATIVE_APP_TYPE;
    alert_info.status_bar_para.image_type = MMI_NMGR_IMG_RES_ID;
	#ifndef __MMI_STATUS_ICON_BAR_SLIM__
    alert_info.status_bar_para.image.id = IMG_SI_PROVMSG;
	#else
		alert_info.status_bar_para.image.id = IMG_SI_SMS_INDICATOR;
	#endif
    alert_info.status_bar_para.display_string = (WCHAR *)temp_buf;
    /*fill in the popup information*/    
    alert_info.popup_para.popup_type = MMI_FRM_NMGR_ALERT_POPUP_TWO_BUTTON_TYPE;
    /*the image icon is used for popup, can be different from text preview*/
    //alert_info.popup_para.app_type = NATIVE_APP_TYPE;
    alert_info.popup_para.image_type = MMI_NMGR_IMG_RES_ID;
    alert_info.popup_para.image.id = IMG_ID_CCA_NEW_SETTING_IDLE;
    alert_info.popup_para.popup_string = (WCHAR *)temp_buf;
    alert_info.popup_para.popup_button_string = (WCHAR*)get_string(STR_GLOBAL_INSTALL);
    /*fill in the status bar icon information*/
    #ifndef __MMI_STATUS_ICON_BAR_SLIM__
    alert_info.status_bar_icon_para.icon_id = STATUS_ICON_PROVMSG_STATE;
    #else
        alert_info.status_bar_icon_para.icon_id = STATUS_ICON_INCOMING_SMS;
    #endif
    /*fill in the app launch callback*/
    alert_info.app_proc_para.scrn_group_proc = &mmi_cca_nmgr_proc;
    alert_info.app_proc_para.user_data = NULL;	
    alert_info.app_proc_para.data_size = 0;
    inst->hnmgr = mmi_frm_nmgr_alert(&alert_info);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_nmgr_notify
 * DESCRIPTION
 *  Show accept New Setting confirmation screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__
void mmi_cca_nmgr_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_nmgr_query
 * DESCRIPTION
 *  Return new settings info to NMGR
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_nmgr_query(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    WCHAR temp_buf[128];
    U32 unread_num;
    U32 sim_num_list[MMI_SIM_TOTAL];
    mmi_sim_enum first_sim_id;    
    mmi_nmgr_info_struct nmgr_info;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    MMI_STR_ID first_str_id = STR_ID_CCA_NEW_SETTING;
    static const MMI_STR_ID new_msg_str_tbl [] = 
    {
#if (MMI_MAX_SIM_NUM == 1)
        STR_ID_CCA_NEW_SETTING
#else  /* MMI_MAX_SIM_NUM == 1 */

        STR_ID_CCA_NEW_SIM1_SETTING,
        STR_ID_CCA_NEW_SIM2_SETTING,

#if (MMI_MAX_SIM_NUM >= 3)
        STR_ID_CCA_NEW_SIM3_SETTING,
#endif

#if (MMI_MAX_SIM_NUM >= 4)
        STR_ID_CCA_NEW_SIM4_SETTING,
#endif
#endif /* __MMI_DUAL_SIM__ */
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&nmgr_info, 0x0, sizeof(mmi_nmgr_info_struct));
    unread_num = srv_cca_get_unread_msg_num(sim_num_list, MMI_SIM_TOTAL, &first_sim_id);
    if (/* srv_cca_is_busy() || */ !unread_num)
    {
        MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_QUERY, srv_cca_is_busy(), unread_num);

        mmi_nmgr_answer(MMI_NMGR_APP_CCA, MMI_NMGR_RESULT_OK, &nmgr_info, NULL);
        return;
    } 
    
    /* Generate the first string on the new message notification category screen */
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        if (MMI_CCA_IDX2BIT(i) == first_sim_id)
        {
            first_str_id = new_msg_str_tbl[i];
            break;
        }
    }

    /* Generate the second string on the new message notification category screen */
    kal_wsprintf(temp_buf, "%d %w", unread_num, get_string(STR_ID_CCA_NEW_SETTING));
    
    nmgr_info.idle_text1 = (CHAR*)get_string(first_str_id);
    nmgr_info.idle_text2 = (CHAR*)temp_buf;
    nmgr_info.image = (U16) IMG_ID_CCA_NEW_SETTING_IDLE;
    nmgr_info.left_softkey = STR_GLOBAL_INSTALL;
    nmgr_info.user_data = inst;

    nmgr_info.total_num = unread_num;
    
    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_QUERY, srv_cca_is_busy(), unread_num);

    mmi_nmgr_answer(MMI_NMGR_APP_CCA, MMI_NMGR_RESULT_OK, &nmgr_info, mmi_cca_nmgr_enter);
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_nmgr_check
 * DESCRIPTION
 *  check if CCA has any pending "new" job, it can be call not only on idle screen
 *  but when NMGR need to refresh the notifcation screen such as back to idle or another 
 *  new message is received.
 *  another function of this API is to handle cancel indeed here.
 * PARAMETERS
 *  void
 * RETURNS
 *  U8
 *****************************************************************************/
MMI_BOOL mmi_cca_nmgr_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 unread_num;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cca_forbidden_show())
    {
        MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_CHECK, -1);
        return MMI_FALSE;
    }
    
    unread_num = srv_cca_get_unread_msg_num(NULL, 0, NULL);

    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_CHECK, unread_num, (unread_num != 0));

    return (MMI_BOOL)(unread_num != 0);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_nmgr_enter
 * DESCRIPTION
 *  New setting is handled
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_nmgr_enter(void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
     mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//   mmi_cca_enter_root_group(); //can not enter group as it will cause NMGR error

    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NMGR_ENTER);

    mmi_cca_ui_entry_progressing();
    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_VIEW_NEW_MSG, NULL, 0);
    if (inst->hnmgr)
        mmi_frm_nmgr_alert_cancel(inst->hnmgr);
#ifdef __MMI_NCENTER_SUPPORT__
    if (!mmi_cca_nmgr_check())
        mmi_cca_ncenter_clear_notification();
#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_nmgr_cancel
 * DESCRIPTION
 *  Don't show idle notify again
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_nmgr_cancel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_cca_apply_action(SRV_CCA_INVALID_HANDLE, SRV_CCA_ACTION_TYPE_CANCEL_NEW_MSG, NULL, 0);
    if (inst->hnmgr)
        mmi_frm_nmgr_alert_cancel(inst->hnmgr);
#ifdef __MMI_NCENTER_SUPPORT__
        mmi_cca_ncenter_clear_notification();
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_cca_get_root_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_ID mmi_cca_get_root_group(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_cca_enter_root_group();
    
    if (inst->self_gid == GRP_ID_INVALID)
    {
        MMI_CCA_ASSERT(0);
        return GRP_ID_ROOT;
    }
    else
    {
        return inst->self_gid ;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_enter_root_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_enter_root_group(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    MMI_ID pid;

    mmi_cca_inst_struct *inst = mmi_cca_get_inst();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (inst->self_gid != GRP_ID_INVALID)
    {
        MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_ENTER_ROOT_GROUP, inst->self_gid, 0);
        return;
    }

    pid = GRP_ID_ROOT;
#ifdef __MMI_PROV_MESSAGE_SUPPORT__
    pid = mmi_provbox_scrn_group_get_id();
    if (pid == GRP_ID_INVALID)
    {
        //MMI_CCA_ASSERT(0);
        pid = GRP_ID_ROOT;
    }
#endif
    
    gid = mmi_frm_group_create(pid, GRP_ID_CCA, mmi_cca_group_proc, NULL);
    mmi_frm_group_enter(gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    inst->self_gid = gid;

    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_ENTER_ROOT_GROUP, inst->self_gid, 1);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_group_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_cca_group_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *alert;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    switch(param->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
            inst->self_gid = GRP_ID_INVALID;
            break;

        case EVT_ID_ALERT_QUIT:
            alert = (mmi_alert_result_evt_struct*)param;
            switch(alert->result)
            	{
            	case MMI_ALERT_NORMAL_EXIT:
		    g_mmi_cca_yes_hdlr = NULL;
		    g_mmi_cca_no_hdlr = NULL;
		    break;
			
            	case MMI_ALERT_CNFM_YES:
                  if (g_mmi_cca_yes_hdlr)
                  {
                      g_mmi_cca_yes_hdlr();
                  }
		    
		    break;
			
		case MMI_ALERT_CNFM_NO:
		    if (g_mmi_cca_no_hdlr)
                  {
                      g_mmi_cca_no_hdlr();
                  }
		    break;
            	}
            break;

        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_show_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_cca_show_confirm(MMI_ID gid, WCHAR* string, mmi_cca_confirm_result_hdlr yes_hdlr, mmi_cca_confirm_result_hdlr no_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = gid;
    arg.callback = mmi_cca_group_proc;

    g_mmi_cca_yes_hdlr = yes_hdlr;
    g_mmi_cca_no_hdlr = no_hdlr;
	
    mmi_confirm_display(string, MMI_EVENT_QUERY, &arg);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_notify_group_entered
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_cca_notify_group_entered(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_group_event_struct evt;
    mmi_cca_inst_struct *inst = mmi_cca_get_inst();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (inst->self_gid == GRP_ID_INVALID)
		return;

    MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_NOTIFY_GROUP_ENTERER, inst->self_gid);

	MMI_FRM_INIT_GROUP_EVENT(&evt, EVT_ID_CCA_GROUP_ENTER_NOTIFY, inst->self_gid);
	mmi_frm_group_post_to_parent(inst->self_gid, &evt);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cca_forbidden_show
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

static S32 mmi_cca_forbidden_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __DM_LAWMO_SUPPORT__
    if (srv_dm_lawmo_is_locked())
    {
        MMI_TRACE(MMI_CCA_TRC_INFO, TRC_MMI_CCA_FORBIDDEN_SHOW_WITHOUT_SIM_CHECK, 3);
        return MMI_TRUE;
    }
#endif /* __DM_LAWMO_SUPPORT__ */
    

	return MMI_FALSE;
}





#endif /* __MMI_CCA_SUPPORT__ */ 


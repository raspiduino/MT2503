/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   VdoPlyApp.c
 *
 * Project:
 * -------- 
 *   MAUI
 *
 * Description:
 * ------------
 *   Video Player Applcation.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_include.h"
#ifdef __MMI_VIDEO_PLAYER__

#include "lcd_sw_rnd.h"
#include "MMI_features_video.h" /* features */

/* compile option combination testing */
/******************************************************/
//#undef __VDOPLY_FEATURE_FULLSCREEN__
//#undef __VDOPLY_FEATURE_SPEED__
//#undef __VDOPLY_FEATURE_SNAPSHOT__
//#undef __VDOPLY_FEATURE_TOUCH_SCREEN__
//#undef __MMI_VIDEO_STREAM__
//#undef __MMI_VIDEO_PDL__
//#undef __MMI_BT_SUPPORT__ 

//#define __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
//#define __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__
/*****************************************************/
#include "MMIDataType.h"
#include "stdio.h"
#include "Unicodexdcl.h"
#include "FileMgrType.h"
#include "FileMgrSrvGProt.h"
#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "kal_non_specific_general_types.h"
#include "mmi_frm_nvram_gprot.h"
#include "custom_mmi_default_value.h"
#include "CommonScreensResDef.h"
#include "l4c_nw_cmd.h"
#include "gui_fixed_menuitems.h"
#include "browser_api.h"

#include "GpioSrvGprot.h"            /* LED */
#include "SettingDefs.h"        /* popup sound */
#include "CommonScreens.h"      /* Popup */
#include "MainMenuDef.h"        /* Multi-media icon */
#include "Conversions.h"        /* char set conversion */
#include "PhoneSetupGprots.h"   /* PhnsetGetDefEncodingType() */

#include "med_api.h"            /* media task */
#include "med_main.h"           /* media task */

#include "gui_themes.h"             /* for MMI_medium_font */

#include "lcd_sw_rnd.h"
#include "lcd_if.h"

#include "mdi_datatype.h"
#include "mdi_audio.h"          /* audio lib */
#include "mdi_video.h"          /* video lib */
#include "mdi_camera.h"         /* camera lib */
#include "CameraApp.h"
#include "mdi_include.h"

#include "SettingProfile.h"     /* warning tone */
#include "FileManagerGProt.h"   /* file path / file error  */
#include "FileManagerDef.h"     /* error string id */
//#include "FileMgr.h"
#ifdef __MMI_USB_SUPPORT__
#include "USBDeviceGprot.h"
#include "USBSrvGProt.h"
#endif
#include "DataAccountGprot.h"
#include "FileMgrGProt.h"
#include "common_nvram_editor_data_item.h"
#include "FilemgrResDef.h"

#include "resource_video_skins.h"       /* UI custom config */
#include "VdoRecResDef.h"
//#include "VdoPlyResDef.h"
#include "mmi_rp_app_vdoply_def.h"
#include "mmi_rp_app_uiframework_def.h"

//#include "VdoRecApp.h" // del by Ham
#include "VdoRecGProt.h"
#include "VdoPlyApp.h"
#include "VdoPlyGProt.h"

#include "ImageViewerGprot.h"

#include "rtc_sw.h"
#include "app_mine.h"           /* mine type */
#include "custom_data_account.h"
#include "gui_font_size.h"

#ifdef __DRM_SUPPORT__
#include "Drm_gprot.h"          /* DRM support */
#include "RightsMgrGprot.h"     /* Right Mgr */
#endif /* __DRM_SUPPORT__ */ 

#if defined(__VDOPLY_FEATURE_BT__)
#include "BTMMIScrGprots.h"
#include "av_bt.h"
#include "app_str.h"
#include "AudioPlayerProt.h"
#include "BTMMIA2DPScr.h"
#endif /* __VDOPLY_FEATURE_BT__ */

#if defined(__MMI_AVRCP_SUPPORT__)
#include "BtcmSrvGprot.h"
#include "BTMMIAVRCPGProt.h"
#endif /* __MMI_AVRCP_SUPPORT__ */ 

#if defined(__MMI_FTS_SUPPORT__)
#include "BtcmSrvGprot.h"
#include "BTMMIFtpGprots.h"
#endif /* __MMI_FTS_SUPPORT__ */ 

#if defined(__MMI_OPP_SUPPORT__)
#include "BtcmSrvGprot.h"
#include "BTMMIOppGprots.h"
#endif /* __MMI_OPP_SUPPORT__ */ 

#ifdef MMS_SUPPORT
#include "wapadp.h"
#endif

#include "ConnectManageGProt.h"

#ifdef __MMI_URI_AGENT__    
#include "UriAgentSrvGprot.h"
#endif /* __MMI_URI_AGENT__ */

#ifdef __MMI_CAMCORDER__
#include "mmi_features_camcorder.h"
#include "CamcorderGprot.h"
#endif /* __MMI_CAMCORDER__ */

#ifdef GDI_USING_2D_ENGINE_V3
#include "gdi_2d_engine.h"
#endif

#if defined(__MMI_UCM__) || defined(__MMI_BACKGROUND_CALL__)
#include "UCMGProt.h"
#endif
#include "UcmSrvGprot.h"

#ifdef __MMI_VIDEO_STREAM__
#include "app_url.h"
#include "cbm_api.h"
#endif
#include "Dataaccountcuigprot.h"
#include "Dtcntsrvgprot.h"


// cui header file
#include "FilemgrCuiGprot.h"
#include "menucuigprot.h"
#include "fseditorcuigprot.h"
#include "inlinecuigprot.h"

#include "ProfilesSrvGprot.h"
#include "wgui_include.h"
#include "Wgui_categories_util.h"

#ifdef __MMI_VIDEO_STREAM__
#include "CbmSrvGprot.h"
#include "SimCtrlSrvGprot.h"
#endif

 #ifdef __MMI_SCREEN_LOCK_ANY_TIME__
 #include "ScrLockerGprot.h"
 #include "mmi_rp_app_scr_locker_def.h"
 #endif

#if defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__)
#include "VdoRecApp.h" //for share function
extern void mmi_vdorec_draw_panel_timer_ext(void *timer_ptr, U32 time, MMI_BOOL is_record_timer);//share function with video recorder
#endif

#if defined(__MMI_A2DP_SUPPORT__) && defined(__BT_SPEAKER_SUPPORT__)
#include "mmi_rp_srv_a2dp_def.h"
#endif  //defined(__MMI_A2DP_SUPPORT__) && defined(__BT_SPEAKER_SUPPORT__)

#include "MMI_ap_dcm_config.h"
/***************************************************************************** 
* Define
*****************************************************************************/
#define VDOPLY_OSD_FADE_OUT_TIME            (3*1000) /* 3 sec */
#define VDOPLY_OSD_FADE_OUT_VALUE           (32)     /* fade 32/256 */

#define VDOPLY_VOL_ADJUST_TIME_DUR          (200)    /* 200ms */
#define VDOPLY_REPEAT_DUR_TH                (200)    /* 200ms */
#define MMI_VDOPLY_QUERY_BEARER_TIMER       (250)
#define is_digit(c)        ((c >= '0') && (c <= '9'))

#ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__

#define MMI_VDOPLY_BG_COLOR                 gdi_act_color_from_rgb(255, 248, 248, 248)
#define MMI_VDOPLY_OPEN_ANI_ID      0
#define MMI_VDOPLY_SNAPSHOT_ANI_ID  0
#ifdef __MMI_VIDEO_STREAM__
    #define MMI_VDOPLY_CONNECT_ANI_ID   0
#endif
#ifdef __VDOPLY_FEATURE_BT__
    #define MMI_VDOPLY_BT_CONNECTING_ANI_ID 0
#endif

#else /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */

#define MMI_VDOPLY_BG_COLOR                 GDI_COLOR_BLACK
#define MMI_VDOPLY_OPEN_ANI_ID       IMG_ID_VDOPLY_OSD_OPENING
#define MMI_VDOPLY_SNAPSHOT_ANI_ID   IMG_ID_VDOPLY_OSD_SNAPSHOTING
#ifdef __MMI_VIDEO_STREAM__
#define MMI_VDOPLY_CONNECT_ANI_ID    IMG_ID_VDOPLY_OSD_CONNECTING
#endif
#ifdef __VDOPLY_FEATURE_BT__
#define MMI_VDOPLY_BT_CONNECTING_ANI_ID IMG_ID_VDOPLY_OSD_BT_CONNECTING
#endif

#endif /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */

#if defined(__MMI_FTE_SUPPORT__) || defined(__VDOPLY_FEATURE_SLIM_IMG_RES__)
#define MMI_VDOPLY_RSK_EXIT
#endif


/***************************************************************************
 *Flags 
 ***************************************************************************/
#define MMI_VDOPLY_HAS_NON_BLOCK_SEEKING    0x000000001
#define MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE   0x000000002
#define MMI_VDOPLY_HAS_FROM_HISTORY         0x000000004
#define MMI_VDOPLY_HAS_OPTION_STORAGE       0x000000008
#define MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE  0x000000010
#define MMI_VDOPLY_HAS_DA_SDP_FILE          0x000000020
#define MMI_VDOPLY_HAS_STREAM_OPENED        0x000000040
#define MMI_VDOPLY_HAS_STREAM_INIT          0x000000080
#define MMI_VDOPLY_HAS_SOURCE_OPENED        0x000000100
#define MMI_VDOPLY_HAS_PAUSE_WHEN_LEAVE     0x000000200
#define MMI_VDOPLY_HAS_SEEKING_UI           0x000000400
#define MMI_VDOPLY_HAS_BEARER_PAUSE         0x000000800
#define MMI_VDOPLY_HAS_2D_MODE              0x000001000
#define MMI_VDOPLY_HAS_3D_MODE              0x000002000
#define MMI_VDOPLY_HAS_CONTINUE_PLAY        0x000004000

#define VDOPLY_SET_FLAG(x)    (g_vdoply_cntx.flags |= (x))
#define VDOPLY_CLEAR_FLAG(x)  (g_vdoply_cntx.flags &= (~(x)))
#define VDOPLY_CHECK_FLAG(x)  ((g_vdoply_cntx.flags & (x)) ? MMI_TRUE : MMI_FALSE)

/***************************************************************************** 
* Typedef 
*****************************************************************************/
typedef enum
{
    VDOPLY_PLAY_FROM_FILE = 0,
    VDOPLY_PLAY_FROM_ID,
    VDOPLY_PLAY_FROM_STREAMING_RTSP,
    VDOPLY_PLAY_FROM_STREAMING_RAM,    
    VDOPLY_PLAY_FROM_STREAMING_SDP,  
    VDOPLY_PLAY_FROM_PROGRESSIVE_DL   
} vdoply_play_src_enum;

typedef enum
{
    VDOPLY_ADJ_BRIGHTNESS,
    VDOPLY_ADJ_CONTRAST,
    VDOPLY_ADJ_REPEAT,

    /* count */
    VDOPLY_ADJ_TOTAL
} vdoply_adjust_item_enum;

typedef enum
{
    VDOPLY_REPEAT_OFF,
    VDOPLY_REPEAT_ON,

    /* count */
    VDOPLY_REPEAT_TOTAL
} vdoply_repeat_type_enum;

typedef enum
{
    VDOPLY_VOL_1 = LEVEL1,
    VDOPLY_VOL_2,
    VDOPLY_VOL_3,
    VDOPLY_VOL_4,
    VDOPLY_VOL_5,
    VDOPLY_VOL_6,
    VDOPLY_VOL_7,
    VDOPLY_VOL_8,
    VDOPLY_VOL_9,
    VDOPLY_VOL_10,
    VDOPLY_VOL_11,
    VDOPLY_VOL_12,
    VDOPLY_VOL_13,    
    VDOPLY_VOL_14,
    VDOPLY_VOL_15,
    VDOPLY_VOL_16,
    VDOPLY_VOL_MUTE
} vdoply_aud_vol_enum;

typedef enum
{
#if defined(__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__) 
    VIDEO_BRIGHTNESS_TYPE_CAPTION   = 0, 
    VIDEO_BRIGHTNESS_TYPE_SELECT,
    VIDEO_CONTRAST_TYPE_CAPTION,
    VIDEO_CONTRAST_TYPE_SELECT,
#endif /* __VDOPLY_FEATURE_VIDEO_ADJUSTMENT__*/
#ifdef MMI_VDOPLY_3D_ANAGLYPH
    VIDEO_PLAY_MODE_TYPE_CAPTION, 
    VIDEO_PLAY_MODE_TYPE_SELECT,
#endif
#ifdef __VDOPLY_FEATURE_LSK_OPTION__
    VIDEO_REPEAT_TYPE_CAPTION, 
    VIDEO_REPEAT_TYPE_SELECT,
#endif /* __VDOPLY_FEATURE_LSK_OPTION__ */
    VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_END,
    VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_NUM = (VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_END - 0)
} mmi_vdoply_settings_video_inline_item_enum;
typedef enum
{
    PROFILE_NAME_TYPE_CAPTION   = 0, 
    PROFILE_NAME_TYPE_FULLSCREEN_EDIT,
    DATA_ACCOUNT_TYPE_CAPTION,
    DATA_ACCOUNT_TYPE_DISPLAY_ONLY,
    USE_PROXY_TYPE_CAPTION, 
    USE_PROXY_TYPE_SELECT,
    PROXY_SERVER_TYPE_CAPTION, 
    PROXY_SERVER_TYPE_FULLSCREEN_EDIT,
    PROXY_PORT_TYPE_CAPTION, 
    PROXY_PORT_TYPE_TEXT_EDIT,
    LOWEST_UDP_TYPE_CAPTION, 
    LOWEST_UDP_TYPE_TEXT_EDIT,
    HIGHEST_UDP_TYPE_CAPTION, 
    HIGHST_UDP_TYPE_TEXT_EDIT,
    VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_END,
    VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_NUM = (VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_END - 0)
} mmi_vdoply_settings_profile_inline_item_enum;

typedef enum{
    TOUCH_FEEDBACK_DOWN = 0,
    TOUCH_FEEDBACK_HOLD,
    TOUCH_FEEDBACK_TOTAL
}mmi_vdoply_touch_feedback_enum;
/***************************************************************************** 
* Global Variable
*****************************************************************************/
extern S32 MMI_softkey_height;

/***************************************************************************** 
* Global Function
*****************************************************************************/

/***************************************************************************** 
* Local Variable
*****************************************************************************/
static kal_uint32 lastPressSeekKeyTime;
static kal_bool isFirstSeek;
static kal_bool isInvalidSeek;

#if defined(__MMI_BT_MUSIC__) || defined(__MMI_AUDIO_PLAYER_BT__)
static MMI_BOOL g_is_short;
static CHAR* g_filename;
#endif

vdoply_context_struct g_vdoply_cntx;

#ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__
static const vdoply_ui_touch_struct* g_touch_obj_tb[MMI_VDOPLY_BTN_TOTAL]=
{
	&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY],
	&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP],
	&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC],
	&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC],
	&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN]
};
#endif

#ifdef __MMI_VIDEO_STREAM__
static const cui_inline_item_caption_struct settings_profile_inline_caption_profile_name = 
{
    STR_ID_VDOPLY_NETWORK_PROFILE_NAME
};

static const cui_inline_item_fullscreen_edit_struct settings_profile_inline_fullscreen_edit_profile_name =
{
    0,          /* string id */
    0,    /*default text string id*/
    STR_ID_VDOPLY_NETWORK_PROFILE_NAME,              /* title string id */
    0,         /* title icon id */
    IMM_INPUT_TYPE_SENTENCE,   /* input extended type */
    IMM_INPUT_TYPE_SENTENCE,         /* input type */
    VIDEO_MAX_PROFILE_NAME_LEN + 1,        /* string count */
    NULL
};
static const cui_inline_item_caption_struct settings_profile_inline_caption_data_account = 
{
    STR_GLOBAL_DATA_ACCOUNT
};
static const cui_inline_item_caption_struct settings_profile_inline_caption_use_proxy = 
{
    STR_ID_VDOPLY_PROXY_USE_PROXY
};
static const U16 settings_profile_use_proxys_item_str[] =
{
    STR_GLOBAL_OFF, 
    STR_GLOBAL_ON
};
static const cui_inline_item_select_struct settings_profile_inline_select_use_proxy = 
{
    2, 0, (U16 *)&settings_profile_use_proxys_item_str[0]
};
static const cui_inline_item_caption_struct settings_profile_inline_caption_proxy_server = 
{
    STR_ID_VDOPLY_PROXY_ADDR
};

static const cui_inline_item_fullscreen_edit_struct settings_profile_inline_fullscreen_edit_proxy_server =
{
    0,          /* string id */
    0,    /*default text string id*/
    STR_ID_VDOPLY_PROXY_ADDR,              /* title string id */
    0,         /* title icon id */
    INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL | INPUT_TYPE_EXT_ASCII_ENCODING_BASE_LENGTH,  /* input extended type */
    IMM_INPUT_TYPE_URL,         /* input type */
    VIDEO_MAX_PROXY_ADDR_LEN + 1,        /* string count */
    NULL
};


static const cui_inline_item_caption_struct settings_profile_inline_caption_proxy_port = 
{
    STR_ID_VDOPLY_PROXY_PORT
};
static const cui_inline_item_text_edit_struct settings_profile_inline_text_edit_proxy_port =
{
    0,  /* string id */
    0,    /*default text string id*/
    VDOPLY_MAX_PORT_LEN,    /* string count */
    IMM_INPUT_TYPE_NUMERIC, /* input type */
    IMM_INPUT_TYPE_NUMERIC,    /* input extended type */
    NULL   /* required input mode */
};
static const cui_inline_item_caption_struct settings_profile_inline_caption_lowest_udp = 
{
    STR_ID_VDOPLY_LOWEST_UDP_PORT
};
static const cui_inline_item_text_edit_struct settings_profile_inline_text_edit_lowest_udp =
{
    0,  /* string id */
    0,    /*default text string id*/
    VDOPLY_MAX_PORT_LEN,    /* string count */
    IMM_INPUT_TYPE_NUMERIC, /* input type */
    IMM_INPUT_TYPE_NUMERIC,    /* input extended type */
    NULL   /* required input mode */
};
static const cui_inline_item_caption_struct settings_profile_inline_caption_highest_udp = 
{
    STR_ID_VDOPLY_HIGHEST_UDP_PORT
};
static const cui_inline_item_text_edit_struct settings_profile_inline_text_edit_highest_udp =
{
    0,  /* string id */
    0,    /*default text string id*/
    VDOPLY_MAX_PORT_LEN,    /* string count */
    IMM_INPUT_TYPE_NUMERIC, /* input type */
    IMM_INPUT_TYPE_NUMERIC,    /* input extended type */
    NULL   /* required input mode */
};
static const cui_inline_set_item_struct mmi_vdoply_settings_profile_inline_item[] = 
{
    {CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_CAPTION,           CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_profile_name},
    {CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_FULLSCREEN_EDIT,   CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT,   0,      (void*)&settings_profile_inline_fullscreen_edit_profile_name},
    {CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_CAPTION,           CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_data_account},
    {CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_DISPLAY_ONLY,      CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY,      0,      NULL},
    {CUI_INLINE_ITEM_ID_BASE + USE_PROXY_TYPE_CAPTION,              CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_use_proxy},
    {CUI_INLINE_ITEM_ID_BASE + USE_PROXY_TYPE_SELECT,               CUI_INLINE_ITEM_TYPE_SELECT,            0,      (void*)&settings_profile_inline_select_use_proxy},
    {CUI_INLINE_ITEM_ID_BASE + PROXY_SERVER_TYPE_CAPTION,           CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_proxy_server},
    {CUI_INLINE_ITEM_ID_BASE + PROXY_SERVER_TYPE_FULLSCREEN_EDIT,   CUI_INLINE_ITEM_TYPE_FULLSCREEN_EDIT,               0,      (void*)&settings_profile_inline_fullscreen_edit_proxy_server},
    {CUI_INLINE_ITEM_ID_BASE + PROXY_PORT_TYPE_CAPTION,             CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_proxy_port},
    {CUI_INLINE_ITEM_ID_BASE + PROXY_PORT_TYPE_TEXT_EDIT,           CUI_INLINE_ITEM_TYPE_TEXT_EDIT,         0,      (void*)&settings_profile_inline_text_edit_proxy_port},
    {CUI_INLINE_ITEM_ID_BASE + LOWEST_UDP_TYPE_CAPTION,             CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_lowest_udp},
    {CUI_INLINE_ITEM_ID_BASE + LOWEST_UDP_TYPE_TEXT_EDIT,           CUI_INLINE_ITEM_TYPE_TEXT_EDIT,         0,      (void*)&settings_profile_inline_text_edit_lowest_udp},
    {CUI_INLINE_ITEM_ID_BASE + HIGHEST_UDP_TYPE_CAPTION,            CUI_INLINE_ITEM_TYPE_CAPTION,           0,      (void*)&settings_profile_inline_caption_highest_udp},
    {CUI_INLINE_ITEM_ID_BASE + HIGHST_UDP_TYPE_TEXT_EDIT,           CUI_INLINE_ITEM_TYPE_TEXT_EDIT,         0,      (void*)&settings_profile_inline_text_edit_highest_udp}
};
static cui_inline_item_softkey_struct mmi_vdoply_settings_profile_inline_softkey = 
{
    {
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},       /*MMI_LEFT_SOFTKEY*/
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},       /*MMI_RIGHT_SOFTKEY*/
        {0, CUI_INLINE_SOFTKEY_DEFAULT_VALUE}        /*MMI_CENTER_SOFTKEY*/
    }
};
static const cui_inline_struct mmi_vdoply_settings_profile_inline_screen = 
{
    VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_NUM,
    STR_GLOBAL_EDIT,
    0,
    CUI_INLINE_SCREEN_LOOP, 
    &mmi_vdoply_settings_profile_inline_softkey, 
    mmi_vdoply_settings_profile_inline_item 
};
#endif

#if defined(__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__)
static const U16 settings_video_adjust_item_str[] =
{
    STR_ID_VDOPLY_ADJUST_N5,
    STR_ID_VDOPLY_ADJUST_N4,
    STR_ID_VDOPLY_ADJUST_N3,
    STR_ID_VDOPLY_ADJUST_N2,
    STR_ID_VDOPLY_ADJUST_N1,
    STR_ID_VDOPLY_ADJUST_0,
    STR_ID_VDOPLY_ADJUST_P1,
    STR_ID_VDOPLY_ADJUST_P2,
    STR_ID_VDOPLY_ADJUST_P3,
    STR_ID_VDOPLY_ADJUST_P4,
    STR_ID_VDOPLY_ADJUST_P5
};
static const cui_inline_item_caption_struct settings_video_inline_caption_brightness = 
{
    STR_ID_VDOPLY_BRIGHTNESS
};
static const cui_inline_item_select_struct settings_video_inline_select_brightness = 
{
    VDOPLY_BRIGHTNESS_ADJ_LEVEL_COUNT, 0, (U16 *)&settings_video_adjust_item_str[0]
};
static const cui_inline_item_caption_struct settings_video_inline_caption_contrast = 
{
    STR_ID_VDOPLY_CONTRAST
};
static const cui_inline_item_select_struct settings_video_inline_select_contrast = 
{
    VDOPLY_CONTRAST_ADJ_LEVEL_COUNT, 0, (U16 *)&settings_video_adjust_item_str[0]
};
#endif
#ifdef __VDOPLY_FEATURE_LSK_OPTION__
static const cui_inline_item_caption_struct settings_video_inline_caption_repeat = 
{
    STR_ID_VDOPLY_AUTO_REPEAT
};
static const U16 settings_video_repeat_item_str[] =
{
    STR_GLOBAL_OFF,
    STR_GLOBAL_ON
};
static const cui_inline_item_select_struct settings_video_inline_select_repeat = 
{
    VDOPLY_REPEAT_ADJ_COUNT, 0, (U16 *)&settings_video_repeat_item_str[0]
};
#endif /* __VDOPLY_FEATURE_LSK_OPTION__ */

#ifdef MMI_VDOPLY_3D_ANAGLYPH
static const cui_inline_item_caption_struct settings_video_inline_caption_play_mode = 
{
    STR_ID_VDOPLY_PLAY_MODE
};
static const U16 settings_video_play_mode_item_str[] =
{
    STR_GLOBAL_OFF,
    STR_GLOBAL_ON
};
static const cui_inline_item_select_struct settings_video_inline_select_play_mode = 
{
    VDOPLY_PLAY_MODE_COUNT, 0, (U16 *)&settings_video_play_mode_item_str[0]
};
#endif


#ifdef __VDOPLY_FEATURE_LSK_OPTION__
static const cui_inline_set_item_struct mmi_vdoply_settings_video_inline_item[] = 
{
#if defined(__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__)
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_BRIGHTNESS_TYPE_CAPTION,   CUI_INLINE_ITEM_TYPE_CAPTION,       0,      (void*)&settings_video_inline_caption_brightness},
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_BRIGHTNESS_TYPE_SELECT,    CUI_INLINE_ITEM_TYPE_SELECT,        0,      (void*)&settings_video_inline_select_brightness},
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_CONTRAST_TYPE_CAPTION,     CUI_INLINE_ITEM_TYPE_CAPTION,       0,      (void*)&settings_video_inline_caption_contrast},
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_CONTRAST_TYPE_SELECT,      CUI_INLINE_ITEM_TYPE_SELECT,        0,      (void*)&settings_video_inline_select_contrast},
#endif
#ifdef MMI_VDOPLY_3D_ANAGLYPH
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_PLAY_MODE_TYPE_CAPTION,     CUI_INLINE_ITEM_TYPE_CAPTION,       0,      (void*)&settings_video_inline_caption_play_mode},
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_PLAY_MODE_TYPE_SELECT,      CUI_INLINE_ITEM_TYPE_SELECT,        0,      (void*)&settings_video_inline_select_play_mode},
#endif
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_REPEAT_TYPE_CAPTION,        CUI_INLINE_ITEM_TYPE_CAPTION,       0,      (void*)&settings_video_inline_caption_repeat},
    {CUI_INLINE_ITEM_ID_BASE + VIDEO_REPEAT_TYPE_SELECT,         CUI_INLINE_ITEM_TYPE_SELECT,        0,      (void*)&settings_video_inline_select_repeat}

};
#endif /* __VDOPLY_FEATURE_LSK_OPTION__ */

static cui_inline_item_softkey_struct mmi_vdoply_settings_video_inline_softkey = 
{
    {
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},       /*MMI_LEFT_SOFTKEY*/
        {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0},       /*MMI_RIGHT_SOFTKEY*/
        {0, CUI_INLINE_SOFTKEY_DEFAULT_VALUE}        /*MMI_CENTER_SOFTKEY*/
    }
};
#ifdef __VDOPLY_FEATURE_LSK_OPTION__
static const cui_inline_struct mmi_vdoply_settings_video_inline_screen = 
{
    VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_NUM,
    STR_ID_VDOPLY_OPTION_VIDEO_SETTING,
    0,
    CUI_INLINE_SCREEN_LOOP, 
    &mmi_vdoply_settings_video_inline_softkey, 
#ifdef __VDOPLY_FEATURE_LSK_OPTION__    
    mmi_vdoply_settings_video_inline_item 
#else
    NULL
#endif
};
#endif
/***************************************************************************** 
* Local Function
*****************************************************************************/
	static MMI_RET mmi_vdoply_app_launch_proc(mmi_event_struct *evt);
	
	#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
	static void mmi_vdoply_entry_player_screen_from_browser(CHAR* filename, MMI_BOOL is_short, MMI_BOOL is_complete);
	#endif
	MMI_ID mmi_frm_app_launch(MMI_ID app_id, MMI_ID caller_id, MMI_ID base_id, mmi_proc_func proc, void *user_data, U32 option);
	void mmi_frm_app_close(MMI_ID app_id);

#if (!defined(MMI_VDOPLY_HIDE_STORAGE_SCREEN) || defined(MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE) || defined(__MMI_VIDEO_STREAM__) ||defined(__MMI_VIDEO_PDL__))
	static void mmi_vdoply_display_popup_confirm(MMI_ID parent_id,MMI_ID_TYPE str_id, mmi_proc_func confirm_done, mmi_confirm_type_enum type,  mmi_event_notify_enum event_type);
#endif

	
#if defined(__MMI_VIDEO_STREAM__)
	static void mmi_vdoply_enter_grp_network_profile(void);
	static mmi_ret mmi_vdoply_network_profile_proc(mmi_event_struct *evt);
	static mmi_ret mmi_vdoply_streaming_url_proc(mmi_event_struct *evt);
#endif
	
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
	static mmi_ret mmi_vdoply_storage_change_confirm_cb(mmi_event_struct *evt);
#endif
	static mmi_ret mmi_vdoply_player_proc(mmi_event_struct *evt);
	static mmi_ret mmi_vdoply_app_proc(mmi_event_struct *evt);
	static mmi_ret mmi_vdoply_single_player_proc(mmi_event_struct *evt);
	static void mmi_vdoply_enter_grp_settings(void);
	static mmi_ret mmi_vdoply_settings_proc(mmi_event_struct *evt);
	
#if defined(__VDOPLY_FEATURE_BT__)
	static srv_bt_cm_bt_addr *mmi_vdoply_get_bt_headset(void);
	static void mmi_vdoply_bt_open_callback(S32 result);
#endif
	
	static MMI_BOOL mmi_vdoply_is_output_to_bt(void);
	static void mmi_vdoply_connect_bt(void);
	static void mmi_vdoply_disconnect_bt(void);
	static void mmi_vdoply_bt_close_codec(void);
	static void mmi_vdoply_null_key_event(void); 
	static void mmi_vdoply_blt_screen(void);
	static MMI_BOOL mmi_vdoply_is_background_call(void);
	static void mmi_vdoply_display_not_available_popup(mmi_id parent_id);
	static void mmi_vdoply_display_popup(mmi_id parent_id,MMI_ID_TYPE str_id, mmi_event_notify_enum type);
	static MMI_BOOL mmi_vdoply_check_and_display_error_popup(MDI_RESULT result);
	
#ifdef __VDOPLY_FEATURE_SPEED__
	static U16 mmi_vdoply_get_speed_image(void);
#endif
	
	static void mmi_vdoply_del_screen_hdlr(void);
	
    static void mmi_vdoply_entry_player_screen_internal(void* guiBuffer, MMI_BOOL is_redraw);
    static void mmi_vdoply_get_video_play_params(GDI_HANDLE* play_layer_handle, U32 *play_layer, U32 *blt_layer, U16 *rotate);
	static MDI_RESULT mmi_vdoply_update_layer_pause(void);
	static MDI_RESULT mmi_vdoply_update_layer_resume(void);
	static MDI_RESULT mmi_vdoply_play_video(void);
	static MDI_RESULT mmi_vdoply_stop_video(void);
	
	
#if defined(__MMI_VIDEO_STREAM__)
	static void mmi_vdoply_resume_stream_video(void);
#endif
	
    
	
    
#ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__
    static void mmi_vdoply_draw_panel_ctrl_button_by_idx(mmi_vdoply_pannel_icon_enum idx);
#ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__
    static void mmi_vdoply_draw_play_region_bg_internal(GDI_HANDLE play_layer, video_rect_struct *bbox_rect_p);
    static void mmi_vdoply_draw_softkey_internal(
                U16 sk_str_id,
                video_style_text_struct *style_txt,
                S32 layer_offset_x,
                S32 layer_offset_y,
                WGUI_SOFTKEY_ENUM type,
                MMI_BOOL is_pressed);
#else
    static void mmi_vdoply_draw_softkey_internal(
            S32 layer_offset_x,
            S32 layer_offset_y,
            S32 sk_offset_x,
            S32 sk_offset_y,
            U16 image_id,
            vdoply_ui_touch_struct* touch_p);
#endif

#endif
	
	static void mmi_vdoply_draw_aud_only_anim(void);
	static void mmi_vdoply_draw_play_region_bg(void);
	static void mmi_vdoply_clear_aud_only_anim(void);
	static void mmi_vdoply_redraw_normal(void);
	static void mmi_vdoply_draw_bg(void);
    #ifdef __VDOPLY_FEATURE_FTE20__
    static void mmi_vdoply_draw_region_bg(gdi_handle region_layer_hdl);
    #endif
	static void mmi_vdoply_draw_title(void);
	#if !(defined(__VDOPLY_FEATURE_FTE20__) && !defined(__VDOPLY_FEATURE_SNAPSHOT__))
	static void mmi_vdoply_draw_panel_state(void);
	#endif
	static void mmi_vdoply_draw_panel_progress(void);
	static void mmi_vdoply_draw_panel_timer(void);
	static void mmi_vdoply_draw_panel_ctrl_button(void);
	static void mmi_vdoply_draw_panel_speed(void);
	static void mmi_vdoply_draw_panel_volume(void);
	#ifndef __VDOPLY_FEATURE_FTE20__
	static void mmi_vdoply_draw_style_text(CHAR* str, S32 offset_x, S32 offset_y, S32 truncate_width, video_style_text_struct *style_txt);
	#endif
	static void mmi_vdoply_draw_softkey(void);
	static void mmi_vdoply_draw_panel(void);

    static void mmi_vdoply_start_animation(U32 ani_id, MMI_BOOL is_full);
    static void mmi_vdoply_stop_animation(void);
#if defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__)
    static void mmi_vdoply_draw_loading(S32 percentage, MMI_BOOL draw_bg, MMI_BOOL is_full);
#endif

#if defined(__VDOPLY_FEATURE_BT__)
	static void mmi_vdoply_draw_bt_connecting_anim(void);
#endif


	static void mmi_vdoply_init_ui(void);
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	static void mmi_vdoply_draw_fullscr_aud_only_anim(void);
	static void mmi_vdoply_draw_fullscr_play_region_bg(void);
	static void mmi_vdoply_clear_fullscr_aud_only_anim(void);
	
	
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
	
#ifdef __VDOPLY_FEATURE_SNAPSHOT__
	static void mmi_vdoply_player_snapshot(void);
	static void mmi_vdoply_player_snapshot_key_press(void);
	static void mmi_vdoply_player_snapshot_key_release(void);
#endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 
	
	static void mmi_vdoply_player_timer_cyclic(void);
#ifndef __VDOPLY_FEATURE_CROSS_LAYEROUT__
	static void mmi_vdoply_set_softkey(CHAR* lsk_str_ptr, CHAR* rsk_str_ptr, U16 lsk_img_id, U16 rsk_img_id, U16 ck_img_id);
#endif
	static void mmi_vdoply_lsk_release(void);
	static void mmi_vdoply_rsk_release(void);
	
#ifdef __VDOPLY_FEATURE_VOLUME__
	static void mmi_vdoply_vol_up_cyclic(void);
	static void mmi_vdoply_vol_up_key_press(void);
	static void mmi_vdoply_vol_up_key_release(void);
	static void mmi_vdoply_vol_down_cyclic(void);
	static void mmi_vdoply_vol_down_key_press(void);
	static void mmi_vdoply_vol_down_key_release(void);
#endif /* __VDOPLY_FEATURE_VOLUME__ */ 
	
#ifdef __VDOPLY_FEATURE_SPEED__
	static void mmi_vdoply_speed_inc_key_press(void);
	static void mmi_vdoply_speed_inc_key_release(void);
	static void mmi_vdoply_speed_dec_key_press(void);
	static void mmi_vdoply_speed_dec_key_release(void);
#endif /* __VDOPLY_FEATURE_SPEED__ */
	
	static void mmi_vdoply_seek_result_hdlr(MDI_RESULT result, void *user_data);
	static void mmi_vdoply_seek_key_release(void);
	static MMI_BOOL mmi_vdoply_seek_foward(MMI_BOOL first_in);
	static void mmi_vdoply_seek_foward_key_press_cyclic(void);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	static void mmi_vdoply_right_arrow_key_press(void);
	static void mmi_vdoply_fastforward(void);
	static void mmi_vdoply_right_arrow_key_release(void);
	#else
	static void mmi_vdoply_seek_foward_key_press(void);
	static void mmi_vdoply_seek_foward_key_release(void);
	#endif
	static MMI_BOOL mmi_vdoply_seek_backward(MMI_BOOL first_in);
	static void mmi_vdoply_seek_backward_key_press_cyclic(void);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	static void mmi_vdoply_left_arrow_key_press(void);
	static void mmi_vdoply_rewind(void);
	static void mmi_vdoply_left_arrow_key_release(void);
	#else
	static void mmi_vdoply_seek_backward_key_press(void);
	static void mmi_vdoply_seek_backward_key_release(void);
	#endif
	static void mmi_vdoply_lsk_press(void);
	static void mmi_vdoply_rsk_press(void);
	static void mmi_vdoply_ck_press(void);
	static void mmi_vdoply_ck_release(void);
	
#ifdef __DRM_SUPPORT__
	static void mmi_vdoply_file_request_right_callback(MMI_BOOL result);
#endif /* __DRM_SUPPORT__ */
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	static void mmi_vdoply_toggle_fullscreen_key_press(void);
	static void mmi_vdoply_toggle_fullscreen_key_release(void);
	static void mmi_vdoply_toggle_fullscreen_display(void);	
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
	
#ifdef MMI_VDOPLY_3D_ANAGLYPH
    static void mmi_vdoply_toggle_display_mode(void);
    static void mmi_vdoply_toggle_mode_key_press(void);
    static void mmi_vdoply_toggle_mode_key_release(void);
#endif

	static void mmi_vdoply_set_state_key_event(U16 state);
	static void mmi_vdoply_set_state_layer_config(U16 state);
	static void mmi_vdoply_clear_key_event(void);
	static void mmi_vdoply_set_state_softkey(U16 state);
	static void mmi_vdoply_calc_progress_ratio(void);
	static void mmi_vdoply_enter_general_state(U16 state);
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	static void mmi_vdoply_enter_fullscr_state(U16 state);
#endif
	
#ifdef __MMI_VIDEO_STREAM__
	static void mmi_vdoply_enter_stream_state(U16 state);
#endif
	
#ifdef __MMI_VIDEO_PDL__
	static void mmi_vdoply_enter_progressive_state(U16 state);
#endif
	
	static void mmi_vdoply_enter_state(U16 state);
	static void mmi_vdoply_player_play_finish_hdlr(MDI_RESULT result, void *user_data);
	static void mmi_vdoply_player_open_done_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data);
	static void mmi_vdoply_exit_player_screen_internal(void);
	static void mmi_vdoply_close_file(void);
	static S16 mmi_vdoply_get_speed_factor(void);
	
#ifdef __MMI_VIDEO_STREAM__
    static void mmi_vdoply_bear_event_disconnect(void);
    static void mmi_vdoply_bear_event_reconnect(void);
    static mmi_ret mmi_vdoply_bear_event_callback_hdlr(mmi_event_struct* evt);
    static mmi_ret mmi_vdoply_register_bear_event_callback_hdlr(void);
    static mmi_ret mmi_vdoply_deregister_bear_event_callback_hdlr(void);
#endif

	
#ifdef __MMI_SUBLCD__
	static void mmi_vdoply_draw_sublcd_icon(void);
	static void mmi_vdoply_entry_sublcd_screen(void);
	static void mmi_vdoply_exit_sublcd_screen(void);
#endif
	
#if defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__)
	static void mmi_vdoply_uri_lauch_streaming(void);
	static mmi_ret mmi_vdoply_uri_lauch_streaming_confirm_cb(mmi_event_struct* evt);
	static void mmi_vdoply_uri_scheme_handler(srv_uriagent_appid_enum ura_appid, char *url, char *param, srv_uriagent_options_enum options, srv_uriagent_uri_request_hdlr_cb uri_agent_cb);
#endif
	
	static void mmi_vdoply_pre_entry_app(void);	
        static void mmi_vdoply_entry_file_list_screen(MMI_BOOL is_redraw);
	static mmi_ret mmi_vdoply_file_list_screen_proc(mmi_event_struct* evt);
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
	static void mmi_vdoply_get_drive_callback(CHAR drv_letter);
	static void mmi_vdoply_storage_select_cb(S32 drv_letter);
	static void mmi_vdoply_entry_set_app_storage_screen(void);
	static void mmi_vdoply_entry_set_storage_screen(void);
	static void mmi_vdoply_entry_set_storage_screen_internal(void);
#endif
	
#if defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__)
	static void mmi_vdoply_touch_scr_pen_down_hdlr(mmi_pen_point_struct pos);
	static void mmi_vdoply_touch_scr_pen_up_hdlr(mmi_pen_point_struct pos);
	static void mmi_vdoply_touch_scr_pen_log_tap_hdlr(mmi_pen_point_struct pos);
	static void mmi_vdoply_touch_scr_pen_move_hdlr(mmi_pen_point_struct pos);
    static void mmi_vdoply_touch_scr_pen_abort_hdlr(mmi_pen_point_struct pos);
	static BOOL mmi_vdoply_touch_scr_hit_test(S32 pos_x, S32 pos_y, vdoply_ui_touch_struct *touch_obj);
	static BOOL mmi_vdoply_touch_scr_hit_test_with_border(S32 pos_x, S32 pos_y, vdoply_ui_touch_struct *touch_obj, S32 border_x, S32 border_y);
	static void mmi_vdoply_touch_feedback_play(mmi_vdoply_touch_feedback_enum type);
#endif
	
#ifdef __MMI_VIDEO_STREAM__
	static void mmi_vdoply_settings_inline_set_item_value(cui_event_inline_common_struct *inline_evt);
#endif
	
	static void mmi_vdoply_settings_inline_focus_change(cui_event_inline_notify_struct *inline_evt);
	
#if defined(__VDOPLY_FEATURE_LSK_OPTION__)
	static void mmi_vdoply_settings_video_init_item_value(MMI_ID inline_id);
	static void mmi_vdoply_entry_adjust_option_scr(void);
	static void mmi_vdoply_adjust_option_lsk_hdlr(void);
#endif
	
#ifdef __VDOPLY_FEATURE_ENHNACE_OPTION__
	static void mmi_vdoply_entry_option_scr(void);
#endif
	
#if defined(__MMI_VIDEO_STREAM__)
	static void mmi_vdoply_save_stream_file(void);
	static mmi_ret mmi_vdoply_save_file_confirm_cb(mmi_event_struct* evt);
	static void mmi_vdoply_check_filename_and_save(void);
	static void mmi_vdoply_entry_stream_editor_scr(void);
#endif
	
#if defined(__MMI_VIDEO_STREAM__) 
	static void mmi_vdoply_check_url_and_enter(void);
	static void mmi_vdoply_entry_url_editor_scr(void);
	static void mmi_vdoply_network_profile_hilite_hdlr(S32 index);
	static void mmi_vdoply_network_profile_hilite_hdlr(S32 index);
	static void mmi_vdoply_entry_network_profile_scr(void);
	static mmi_ret mmi_vdoply_network_profile_screen_proc(mmi_event_struct* evt);
	static void mmi_vdoply_entry_network_profile_scr_internal(void* gui_buffer);
	static void mmi_vdoply_entry_network_profile_option_scr(void);
	static void mmi_vdoply_profile_edit_init_item_value(MMI_ID inline_id);
	static void mmi_vdoply_entry_network_profile_edit_scr(void);
	static MMI_BOOL mmi_vdoply_is_network_profile_changed(void);
	static mmi_ret mmi_vdoply_network_profile_save_confirm_cb(mmi_event_struct *evt);
	static void mmi_vdoply_network_profile_save_confirm_yes(void);
	static void mmi_vdoply_network_profile_active_hdlr(void);
	static srv_dtcnt_sim_type_enum mmi_vdoply_network_get_data_account_sim_type(void);
	
	static mmi_ret mmi_vdoply_dtcnt_cui_proc(mmi_event_struct *evt);
	static void mmi_vdoply_entry_network_data_account_cui(void);
	static void mmi_vdoply_entry_network_data_account_scr(void);

    static void mmi_vdoply_get_data_account_id(U32 *data_account_id);
    static MMI_BOOL mmi_vdoply_set_data_account(U32 data_account);
    static mmi_ret mmi_vdoply_entry_predefined_url_screen_proc(mmi_event_struct* evt);
	static void mmi_vdoply_entry_predefined_url_scr(void* gui_buffer);
	static void mmi_vdoply_predefined_url_lsk_hdlr(void);
	
#ifdef __MMI_TOUCH_SCREEN__
	static void mmi_vdoply_history_tap_callback(mmi_tap_type_enum type, S32 index);
#endif
	static mmi_ret mmi_vdoply_history_url_screen_proc(mmi_event_struct* evt);
	static void mmi_vdoply_entry_history_url_scr(void* gui_buffer);
	static void mmi_vdoply_entry_history_option_scr(void);
	static void mmi_vdoply_history_play_url(void);
	static MMI_BOOL mmi_vdoply_is_history_file_need_sync(void);
	static mmi_ret mmi_vdoply_history_remove_confirm_cb(mmi_event_struct* evt);
	static mmi_ret mmi_vdoply_history_remove_all_confirm_cb(mmi_event_struct* evt);
	static void mmi_vdoply_history_remove_url(void);
	static void mmi_vdoply_history_remove_all_url(void);
	static void mmi_vdoply_history_insert_url(CHAR* url_p, CHAR* name_p);
	static void mmi_vdoply_history_sync_sdp_file(void);
	static void mmi_vdoply_url_highlight_hdlr(S32 index);
	
#endif
	
#ifdef __MMI_VIDEO_STREAM__
	
#ifdef __DRM_SUPPORT__
	static void mmi_vdoply_stream_request_right_callback(MMI_BOOL result);
#endif 
	
	static void mmi_vdoply_stream_connect_result_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data);
	static void mmi_vdoply_stream_buffering_cyclic(void);
	
#if defined(__VDOPLY_FEATURE_FULLSCREEN__)
	static void mmi_vdoply_stream_fullscr_buffering_cyclic(void);
#endif
	
	static void mmi_vdoply_stream_stop_buffering(void);
	static void mmi_vdoply_stream_start_buffering(void);
	static void mmi_vdoply_stream_buffering_done_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data);
	
	static void mmi_vdoply_rtsp_url_hdlr(void *msg_ptr);
#endif /* __MMI_VIDEO_STREAM__ */
	
#ifdef __MMI_VIDEO_PDL__
	static mmi_ret mmi_vdoply_pdl_terminate_confirm_cb(mmi_event_struct *evt);
	static void mmi_vdoply_entry_pdl_teminate_confirm_scr(void);
	static void mmi_vdoply_pdl_teminate_confirm_yes(void);
	static void mmi_vdoply_pdl_buffering_cyclic(void);
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	static void mmi_vdoply_pdl_fullscr_buffering_cyclic(void);
#endif
	
	static void mmi_vdoply_pdl_draw_progressbar_cyclic(void);
	static void mmi_vdoply_display_pdl_err_popup(void);
	
#if defined __MMI_DOWNLOAD_AGENT__
	static void mmi_vdoply_pdl_da_report_hdlr(S32 session_id, S32 status, S32 cause, U32 seq_num, U32 acc_size, U32 total_size);
	static BOOL mmi_vdoply_pdl_da_filepath_hdlr(S32 session_id, S32 mime_type, S32 mime_subtype, PU16 filepath);
#endif /* __MMI_DOWNLOAD_AGENT__ */
	
#endif /* __MMI_VIDEO_PDL__ */
	
#ifdef __MMI_AVRCP_SUPPORT__
	static U8 mmi_vdoply_bt_avrcp_cmd_hdlr(U8 command, mmi_avrcp_key_events event);
#endif /* __MMI_AVRCP_SUPPORT__ */
	
#if defined(__BT_SPK_VOL_CONTROL__)
	static MMI_BOOL mmi_vdoply_hfp_vol_hdlr(U8 volume, MMI_BOOL is_mute);
#endif
	
#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
	static void mmi_vdoply_redraw_status_bar_background_hdlr(void);
#endif
	
#ifdef MMI_VDOPLY_RSK_EXIT
	static void mmi_vdoply_ctrl_button_pressed(U32 mark);
	static void mmi_vdoply_ctrl_button_released(U32 mark);
#endif
	
	static void mmi_vdoply_start_non_block_seeking(void);
	static void mmi_vdoply_stop_non_block_seeking(void);
	
#if (defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__)) || defined(MMI_VDOPLY_RSK_EXIT)
	static void mmi_vdoply_play_button_worked(void);
	static void mmi_vdoply_stop_button_worked(void);
#endif
	
#ifdef MMI_VDOPLY_RSK_EXIT
	static void mmi_vdoply_play_button_pressed(void);
	static void mmi_vdoply_play_button_released(void);
	static void mmi_vdoply_stop_button_pressed(void);
	static void mmi_vdoply_stop_button_released(void);
#endif
	
	static void cui_vdoply_evt_exit(MMI_BOOL is_with_popup, MMI_ID_TYPE error_str);
	static void cui_vdoply_exit_button_worked(void);


#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	static void mmi_vdoply_play_prev_next_file_worked(MMI_BOOL);
	static void mmi_vdoply_play_prev_next_file_worked_ext(MMI_BOOL);
	static void mmi_vdoply_play_next_file_worked(void);
	static void mmi_vdoply_play_prev_file_worked(void);
#else
	static void mmi_vdoply_play_next_file_worked(void);
	static void mmi_vdoply_play_next_file_worked_ext(void);
	static void mmi_vdoply_play_prev_file_worked(void);
	static void mmi_vdoply_play_prev_file_worked_ext(void);
#endif
#endif

#if defined(__MMI_A2DP_SUPPORT__) && defined(__BT_SPEAKER_SUPPORT__)
mmi_ret mmi_vdoply_a2dp_connect_callback_hdlr(mmi_event_struct *event);
#endif

#if defined(__MMI_BT_MUSIC__) || defined(__MMI_AUDIO_PLAYER_BT__)
static void mmi_vdoply_bt_music_disconnect_callback(MMI_BOOL result);
static void mmi_vdoply_app_bt_music_disconnect_callback(MMI_BOOL result);
#endif


/*****************************************************************************
*
*	Following area is DCM region which for compressing rodata and code
*	As pragma will link APIs that not be called, we place APIs which you want to compress together.
*	if you want to add another APIs, place those here too.
*	
*****************************************************************************/
#ifdef __MMI_AP_DCM_VDOPLY__
#pragma arm section rodata = "DYNAMIC_CODE_VDOREC_RODATA", code = "DYNAMIC_CODE_VDOREC_ROCODE"
#endif

static void mmi_vdoply_draw_softkey_and_blt(void)
{
	mmi_vdoply_draw_softkey();
	mmi_vdoply_blt_screen();
}

static void mmi_vdoply_layer_clear(gdi_handle *layer_handle_ptr)
{
	gdi_layer_push_and_set_active(*layer_handle_ptr);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
}

static void mmi_vdoply_init_touch_obj(vdoply_ui_touch_struct *touch_p, mmi_vdoply_pannel_icon_enum btn_id, U16 image_id)
{
	touch_p->offset_x = g_vdoply_osd_cntx.panel.button[btn_id].offset_x;                                  
	touch_p->offset_y = g_vdoply_osd_cntx.panel.button[btn_id].offset_y;                                  
	touch_p->is_press = MMI_FALSE;                                                                       
	gdi_image_get_dimension_id(image_id, &touch_p->width, &touch_p->height);
}
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
static void mmi_vdoply_key_press_to_do(vdoply_touch_enum touch_obj_enum, vdoply_full_touch_enum full_touch_obj_enum)
{
    if(MMI_VDOPLY_TOUCH_PROGRESS_INC==touch_obj_enum||MMI_VDOPLY_TOUCH_PROGRESS_DEC==touch_obj_enum||
		 MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC==full_touch_obj_enum||MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC==full_touch_obj_enum)
    {
    	if(g_vdoply_cntx.touch_obj[touch_obj_enum].is_press)
        {
            return;
        }  
    }
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
		g_vdoply_cntx.touch_obj[touch_obj_enum].is_press = MMI_TRUE;
	}
	else
	{
		g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press = MMI_TRUE;
	}
	switch(touch_obj_enum)
	{
        case MMI_VDOPLY_TOUCH_CK:
		case MMI_VDOPLY_TOUCH_LSK:
		case MMI_VDOPLY_TOUCH_RSK:
			mmi_vdoply_draw_softkey_and_blt();
			break;
		case MMI_VDOPLY_TOUCH_FULLSCREEN:
			if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    		{
       			mmi_vdoply_draw_panel();
				mmi_vdoply_draw_softkey_and_blt();
    		}
			break;
		case MMI_VDOPLY_TOUCH_VOLUME_INC:
		case MMI_VDOPLY_TOUCH_VOLUME_DEC:
			if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    		{
				mmi_vdoply_draw_panel_volume();
       			mmi_vdoply_blt_screen();
       		}
			break;
		case MMI_VDOPLY_TOUCH_PROGRESS_INC:
		case MMI_VDOPLY_TOUCH_PROGRESS_DEC:
				break;
		default:
			break;		
	}
}
static void mmi_vdoply_key_release_to_do(vdoply_touch_enum touch_obj_enum, vdoply_full_touch_enum full_touch_obj_enum)
{
   if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(!g_vdoply_cntx.touch_obj[touch_obj_enum].is_press)
   		{
		return;
   		}
		g_vdoply_cntx.touch_obj[touch_obj_enum].is_press = MMI_FALSE;
	}
	else
	{
	    if(!g_vdoply_cntx.full_touch_obj[touch_obj_enum].is_press)
   		{
			return;
   		}
		g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press = MMI_FALSE;
	}
   switch(touch_obj_enum)
   	{
   		case MMI_VDOPLY_TOUCH_CK:
		case MMI_VDOPLY_TOUCH_LSK:
		case MMI_VDOPLY_TOUCH_RSK:
		case MMI_VDOPLY_TOUCH_FULLSCREEN:
    		gui_cancel_timer(mmi_vdoply_seek_key_release);
			#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
			gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
			gui_cancel_timer(mmi_vdoply_play_next_file_worked);
			#endif	
			g_vdoply_cntx.is_seeking = MMI_FALSE;
    		MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__); 
			break;
		case MMI_VDOPLY_TOUCH_VOLUME_DEC:
		case MMI_VDOPLY_TOUCH_VOLUME_INC:
			if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    		{
				mmi_vdoply_draw_panel_volume();
        		mmi_vdoply_blt_screen();
        	}
			break;
		case MMI_VDOPLY_TOUCH_PROGRESS_DEC:
		case MMI_VDOPLY_TOUCH_PROGRESS_INC:
			break;
		default:
			break;								
   	}
}
#else

static void mmi_vdoply_sk_press_to_do(vdoply_touch_enum touch_obj_enum, vdoply_full_touch_enum full_touch_obj_enum)
{
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        g_vdoply_cntx.touch_obj[touch_obj_enum].is_press = MMI_TRUE;        
		//mmi_vdoply_draw_softkey();
		//mmi_vdoply_blt_screen();
		
		mmi_vdoply_draw_softkey_and_blt();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press = MMI_TRUE;            
        mmi_vdoply_blt_screen();
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }
}


static void mmi_vdoply_vol_cyclic_update_ui(vdoply_touch_enum touch_obj_enum, vdoply_full_touch_enum full_touch_obj_enum)
{
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
       g_vdoply_cntx.touch_obj[touch_obj_enum].is_press = MMI_TRUE;
       mmi_vdoply_draw_panel_volume();
       mmi_vdoply_blt_screen();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press = MMI_TRUE;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    }
    else
    {
        MMI_ASSERT(0);
    }
}

static void mmi_vdoply_vol_key_release_to_do(vdoply_touch_enum touch_obj_enum, vdoply_full_touch_enum full_touch_obj_enum)
{	    
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
		if(!g_vdoply_cntx.touch_obj[touch_obj_enum].is_press)
        {
            return;
        }
        
		g_vdoply_cntx.touch_obj[touch_obj_enum].is_press = MMI_FALSE;
        mmi_vdoply_draw_panel_volume();
        mmi_vdoply_blt_screen();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
	#ifdef __VDOPLY_FEATURE_FULLSCREEN__
		if(!g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press)
        {
            return;
        }
        
		g_vdoply_cntx.full_touch_obj[full_touch_obj_enum].is_press = MMI_FALSE;
	#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    }
    else
    {
        MMI_ASSERT(0);
    }
}
#endif

#ifdef MMI_VDOPLY_CODE_LOGIC_SLIM
static void mmi_vdoply_seek_key_press_to_do(MMI_BOOL is_seek_foward)
{
	gui_cancel_timer(mmi_vdoply_seek_key_release);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	gui_cancel_timer(mmi_vdoply_play_next_file_worked);
	gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
	#endif
	
	switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_PLAY:
            if (MDI_RES_VDOPLY_ALREADY_FINISHED == mmi_vdoply_stop_video() &&
                MMI_FALSE == g_vdoply_cntx.repeat)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
                return;
            }
            break;

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);                 
            mmi_vdoply_disconnect_bt();
            break;
        #endif
        case VDOPLY_STATE_IDLE:
			if(is_seek_foward)
	            g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
            /* stop previous seeking action */
            mmi_vdoply_stop_non_block_seeking();
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_FULLSCR_PLAY:
            mmi_vdoply_stop_video();
            mmi_vdoply_blt_screen();
            break;

        #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_PAUSE:
        case VDOPLY_STATE_FULLSCR_IDLE:
            mmi_vdoply_blt_screen();            
            break;
		#endif

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_FULLSCR_SEEKING);  
            
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_blt_screen();
            break;
		#endif

        #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_SEEKING:
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
            /* stop previous seeking action */
            mmi_vdoply_stop_non_block_seeking();

            mmi_vdoply_blt_screen();
            break;
        #endif
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    
    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_PLAY:
            mmi_vdoply_stop_video();
            break;

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);  
            
            mmi_vdoply_disconnect_bt();
            break;

        case VDOPLY_STATE_STREAM_BUFFERING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);  
            
            mmi_vdoply_stream_stop_buffering();
            break;
            
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_stop_video();
            mmi_vdoply_blt_screen();
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_FULLSCR_SEEKING);  
            
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_blt_screen();
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_blt_screen();
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            /* hide process layer */
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_FULLSCR_SEEKING);  
            
            mmi_vdoply_stream_stop_buffering(); 
            mmi_vdoply_blt_screen();
            break;            
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:            
            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:            
            gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);
            mmi_vdoply_set_state_layer_config(VDOPLY_STATE_FULLSCR_SEEKING);
            mmi_vdoply_blt_screen();          
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_PDL__ */
    
    }

    if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);
		#ifdef __MAIN_LCM_SCANLINE_ROTATION_270__ 
		mdi_video_ply_seek_and_get_frame(g_vdoply_cntx.cur_status.play_time,g_vdoply_cntx.play_wnd_layer_handle);
		#endif
		mmi_vdoply_draw_panel();
		mmi_vdoply_draw_softkey_and_blt();
    }

    g_vdoply_cntx.is_seeking = MMI_TRUE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);       
}

static void mmi_vdoply_seek_key_release_to_do(void)
{
	mmi_vdoply_stop_non_block_seeking();
	
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        ClearInputEventHandler(MMI_DEVICE_KEY);
		SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
        SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);

        mmi_vdoply_draw_panel_progress();
        mmi_vdoply_blt_screen();
    }
    else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        ClearInputEventHandler(MMI_DEVICE_KEY);
		SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
        SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);

        mmi_vdoply_blt_screen();
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    }
}

static void mmi_vdoply_setting_do_quit(mmi_event_struct *evt)
{
    mmi_alert_result_evt_struct *confirm = (mmi_alert_result_evt_struct *)evt;
    switch (confirm->result)
    {
        case MMI_ALERT_CNFM_OK:  
        case MMI_ALERT_CNFM_YES:         
        {
            ((FuncPtr)confirm->user_tag)();
            break;
        }
        case MMI_ALERT_CNFM_NO:         
        case MMI_ALERT_CNFM_CANCEL:      
        {
            mmi_alert_dismiss(confirm->alert_id);
            break;
        }
        default:
            break;
    }	
}

static void mmi_vdoply_set_volume_key_event()
{
	SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
	SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
	SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
	SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
	SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_POUND);
	SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_POUND);
	SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_STAR);
	SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_STAR);
}

static void mmi_vdoply_ctrl_button_do_action(U32 mark, MMI_BOOL is_press)
{
	if(mark == VDOPLY_TOUCH_PLAY)
	{
		g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = is_press;
	}
	else if(mark == VDOPLY_TOUCH_STOP)
	{
		g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press = is_press;
	}
	else
	{
		return;
	}

	mmi_vdoply_draw_panel_ctrl_button();
	mmi_vdoply_blt_screen();
}


#endif


#if (!defined(MMI_VDOPLY_HIDE_STORAGE_SCREEN) || defined(MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE) || defined(__MMI_VIDEO_STREAM__) ||defined(__MMI_VIDEO_PDL__))
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_display_popup_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_display_popup_confirm(MMI_ID parent_id, MMI_ID_TYPE str_id, mmi_proc_func confirm_done, mmi_confirm_type_enum type,  mmi_event_notify_enum event_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct property;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  	
    mmi_confirm_property_init(&property, type);
	
    property.parent_id  = parent_id;
    property.callback   = confirm_done;
    property.user_tag   = (void*)parent_id;
	
    mmi_confirm_display_ext(str_id, event_type, &property);
}
#endif


#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_storage_change_confirm_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_storage_change_confirm_cb(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 storage = SRV_FMGR_PUBLIC_DRV;
    SRV_FMGR_DRVLIST_HANDLE drv_list;
    mmi_alert_result_evt_struct* alert_evt = (mmi_alert_result_evt_struct*)evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
        case MMI_ALERT_CNFM_YES:
            drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
            storage = srv_fmgr_drivelist_get_drv_letter(drv_list, 0);
            srv_fmgr_drivelist_destroy(drv_list);
            mmi_vdoply_set_storage(storage);
            #ifdef __MMI_IMAGE_VIEWER__
            mmi_imgview_set_storage(g_vdoply_cntx.storage);
            #endif
            #ifdef __MMI_CAMCORDER__
            mmi_camco_set_storage(g_vdoply_cntx.storage);
            #endif
            mmi_vdoply_entry_app();
            break;
		case MMI_ALERT_NORMAL_EXIT:
		    break;
        default:
            mmi_frm_group_close(GRP_ID_VDOPLY_APP); 
		#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
            break;
        }
    }
    return MMI_RET_OK;
    
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_player_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
    {
        case EVT_VDOPLY_EXIT_WITH_POPUP:
		{
			cui_vdoply_exit_evt_struct *vdoply_evt = (cui_vdoply_exit_evt_struct *)evt;
			if(vdoply_evt->with_popup)
			{
                mmi_vdoply_display_popup(
					GRP_ID_VDOPLY_PLAYER, 
					vdoply_evt->error_str_id, 
					MMI_EVENT_FAILURE);
			}
			cui_vdoply_close(GRP_ID_VDOPLY_SINGLE_PLAYER);
			break;
		}
		default:
		    break;
    }
	return MMI_RET_OK;
}

#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
static mmi_ret mmi_vdoply_get_total_files(void)
{
	SRV_FMGR_FILELIST_HANDLE hlist;
	S32 cur_index;
	S32 ret;

	ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
	if(ret == 0)
	{
		g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		return MMI_RET_OK;
	}
	else
	{
		return MMI_RET_ERR;
	}
}
#endif

#ifdef MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE
static void mmi_vdoply_change_to_memory_card_confirm_cb_ext(CHAR drv_letter)
{
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 create_result;
    U16 prev_storage;
    MMI_ID_TYPE err_strid;
    mmi_event_notify_enum popup_type;
    
    if (drv_letter != 0)
    {
        prev_storage = g_vdoply_cntx.storage;
        g_vdoply_cntx.storage = (U16)drv_letter;
            
        mmi_vdoply_get_storage_file_path(buf_filepath);
        create_result = mmi_vdoply_create_file_dir(buf_filepath);
        
        if (create_result != FS_NO_ERROR)
        {
            err_strid = srv_fmgr_fs_error_get_string(create_result);
            popup_type = (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(create_result);
            mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, err_strid, popup_type); 
            g_vdoply_cntx.prev_storage = g_vdoply_cntx.storage;
            g_vdoply_cntx.storage = prev_storage;    
            return;            
        }
        else
        {
            mmi_vdoply_store_setting();
        #ifdef __MMI_CAMCORDER__
            mmi_camco_set_storage(g_vdoply_cntx.storage);
        #endif
        #ifdef __MMI_IMAGE_VIEWER__
            mmi_imgview_set_storage(g_vdoply_cntx.storage);
        #endif
   
	        mmi_frm_scrn_close_active_id();
	        cui_folder_browser_close(g_vdoply_cntx.fmgr_scr_id); 
                
            return;
        }

    }
    else
    {
		mmi_frm_group_close(GRP_ID_VDOPLY_APP);
		#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
    }
}


static mmi_ret mmi_vdoply_change_to_memory_card_confirm_cb(mmi_event_struct *evt)
{
	U8 storage = SRV_FMGR_PUBLIC_DRV;
	SRV_FMGR_DRVLIST_HANDLE drv_list;
	mmi_alert_result_evt_struct* alert_evt = (mmi_alert_result_evt_struct*)evt;

	if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
	{
		switch (alert_evt->result)
		{
		case MMI_ALERT_CNFM_OK:
		case MMI_ALERT_CNFM_YES:
			drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
			storage = srv_fmgr_drivelist_get_drv_letter(drv_list, 1);
			srv_fmgr_drivelist_destroy(drv_list);
			mmi_vdoply_change_to_memory_card_confirm_cb_ext((CHAR)storage);
		#if 0
/* under construction !*/
		#ifdef __MMI_IMAGE_VIEWER__
/* under construction !*/
		#endif
		#ifdef __MMI_CAMCORDER__
/* under construction !*/
		#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif
			break;
		case MMI_ALERT_CNFM_NO:
		case MMI_ALERT_CNFM_CANCEL:
			mmi_frm_scrn_close_active_id();
			break;
		default:
			break;
		}
	}
	return MMI_RET_OK;
}


static void mmi_vdoply_change_storage_to_memory_card(void)
{
	SRV_FMGR_DRVLIST_HANDLE drv_list;
	U8  total_drv_num;

	drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
    total_drv_num = (U8)srv_fmgr_drivelist_count(drv_list);
    srv_fmgr_drivelist_destroy(drv_list);

	if(total_drv_num == 0)
	{
		mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_INSERT_MEMORY_CARD,MMI_EVENT_FAILURE);
        mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
	}
	else if(total_drv_num == 1)
	{
		return;
	}
	else
	{
		mmi_vdoply_display_popup_confirm(GRP_ID_VDOPLY_APP,
									STR_ID_VDOPLY_NOTIFY_CHANGE_STORAGE_TO_MEMORY_CARD,
									mmi_vdoply_change_to_memory_card_confirm_cb,
									CNFM_TYPE_YESNO,
									MMI_EVENT_QUERY); 
	}
}


#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_single_player_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_single_player_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_ALERT_QUIT:
        {
			mmi_vdoply_setting_do_quit(evt);
            break;
        }         
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_grp_settings
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_enter_grp_settings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    gid = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_SINGLE_PLAYER, 
                    GRP_ID_VDOPLY_SETTINGS, 
                    mmi_vdoply_settings_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);

    if (GRP_ID_INVALID == gid)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
        return;
    }
#ifdef __VDOPLY_FEATURE_ENHNACE_OPTION__
    mmi_vdoply_entry_option_scr();
#else
    mmi_vdoply_entry_adjust_option_scr();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_settings_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_settings_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
         case EVT_ID_CUI_MENU_ITEM_SELECT:
		 case EVT_ID_CUI_MENU_ITEM_CSK_SELECT:
		 {
            cui_menu_event_struct *menu_evt = (cui_menu_event_struct *)evt;
            if ( menu_evt->parent_menu_id == MENU_ID_VDOPLY_OPTION 
                || menu_evt->parent_menu_id == MENU_ID_VDOPLY_OPTION_STREAMING)
            {
                switch(menu_evt->highlighted_menu_id)
                {
                #if defined(__VDOPLY_FEATURE_BT__) && !defined(__MMI_A2DP_HIDE_BT_SETTINGS__)  
                    case MENU_ID_VDOPLY_BLUETOOTH_SETTING:
                        mmi_a2dp_entry_bluetooth_settings();
                        break;
                #endif
				
                #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                    case MENU_ID_VDOPLY_OPTION_VIDEO_SETTING:
                        mmi_vdoply_entry_adjust_option_scr();
                        break;
                #endif
				
                #if defined(__MMI_VIDEO_STREAM__)
                    case MENU_ID_VDOPLY_OPTION_SAVE_CONNECTION:
                        mmi_vdoply_entry_stream_editor_scr();
                        break;
                #endif
                }
            }
			 break;
         }
             
        case EVT_ID_CUI_MENU_CLOSE_REQUEST: 
		{
            cui_menu_event_struct *menu_evt = (cui_menu_event_struct *)evt;
            cui_menu_close(menu_evt->sender_id); 
            break;
		}
		
        case EVT_ID_CUI_FILENAME_EDITOR_RESULT:
        {
            cui_filename_editor_result_event_struct *editor_ret = (cui_filename_editor_result_event_struct *) evt;
            if (editor_ret->result > 0)/*user complete*/
            {   
            #if defined(__MMI_VIDEO_STREAM__)
                mmi_vdoply_check_filename_and_save();
            #endif    
            }
            else if (editor_ret->result == 0)/*user cancel*/
            {
                cui_filename_editor_close(editor_ret->sender_id);
            }
            else/*editor_ret->result < 0 error happens*/
            {
                MMI_ID_TYPE error_str;
                error_str = srv_fmgr_fs_error_get_string(editor_ret->result);
                mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, error_str, MMI_EVENT_FAILURE);
            }
            break;
        }

        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_event_inline_notify_struct *inline_evt = (cui_event_inline_notify_struct *)evt;
            switch(inline_evt->event_type)
            {
                case CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED:
                {
                    mmi_vdoply_settings_inline_focus_change(inline_evt);
                    break;
                }
                default:
                    break;
            }
            break;
        }
			
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            mmi_vdoply_adjust_option_lsk_hdlr();
            break;
        }
		
        case EVT_ID_CUI_INLINE_ABORT:
        {
            cui_event_inline_abort_struct *inline_evt = (cui_event_inline_abort_struct*)evt;
            cui_inline_close(inline_evt->sender_id);
            break;
        }

        case EVT_ID_ALERT_QUIT:
        {
            mmi_vdoply_setting_do_quit(evt);
            break;
        } 
		
		default:
              break;
    }
    return MMI_RET_OK;
	
}


/*****************************************************************************
*
* Bluetooth related usage                                                        
*
*****************************************************************************/
#if defined(__VDOPLY_FEATURE_BT__)

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_bt_headset
 * DESCRIPTION
 *  retrieve the user selected bt headset
 * PARAMETERS
 *  void
 * RETURNS
 *  srv_bt_cm_bt_addr*
 *****************************************************************************/
static srv_bt_cm_bt_addr *mmi_vdoply_get_bt_headset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/      
    return mmi_a2dp_get_bt_headset();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bt_open_callback
 * DESCRIPTION
 *  a callback function invoked by av_bt_open apis
 * PARAMETERS
 *  result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_bt_open_callback(S32 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/      
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_BT_OPEN_CALLBACK, result);       
    
    gui_cancel_timer(mmi_vdoply_draw_bt_connecting_anim);
    mmi_vdoply_stop_animation();
    
    switch (result)
    {
        case AV_BT_CALLBACK_EVENT_OPEN_OK:
            /* 
             *  NOTICE: even after receive EVENT_OPEN_FAILED or EVENT_OPEN_STOPPED,
             *          bt driver may still send EVENT_OPEN_OK, this is due to driver 
             *          has retry mechanism.
             */
            
            if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING)
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);                   
                av_bt_open_codec(KAL_FALSE);                
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }    
            else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_BT_CONNECTING)
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);                   
                av_bt_open_codec(KAL_FALSE);                
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }            
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);   
                av_bt_open_codec(KAL_FALSE);                
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);                   
                av_bt_open_codec(KAL_FALSE);                
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING ||
                     g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING)
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);                   
                av_bt_open_codec(KAL_FALSE);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY ||
                     g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY ||
                     g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY ||
                     g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
            {
                /* 
                 * since it is already play, we may set TRUE, which will directly
                 * change output to BT 
                 */
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_CODEC, __LINE__);                    
                av_bt_open_codec(KAL_TRUE);
            }            
            else
            {
				/* maybe should do some handling later */
            }
            break;

        case AV_BT_CALLBACK_EVENT_OPEN_FAILED:
        case AV_BT_CALLBACK_EVENT_OPEN_STOPPED:
#ifdef __MMI_BT_AUDIO_VIA_SCO__
        case AV_BT_CALLBACK_EVENT_OPEN_SCO:
#endif
            if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING)
            {
                 mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_BT_CONNECTING)
            {
                 mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }            
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }
            else
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_CLOSE_CODEC, __LINE__);                   
                av_bt_close_codec();
            }
            break;
        case AV_BT_CALLBACK_EVENT_OPEN_CANCELED:
            break;
        case AV_BT_CALLBACK_EVENT_STREAM_ABORT_IND:
        case AV_BT_CALLBACK_EVENT_STREAM_CLOSE_IND:
        case AV_BT_CALLBACK_EVENT_STREAM_SUSPEND_IND:
        case AV_BT_CALLBACK_EVENT_UNEXPECTED_DISCONNECT_IND:
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_CLOSE_CODEC, __LINE__);   
            av_bt_close_codec();
            if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING)
            {
                 /* connect failed - play the video */
                 mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_BT_CONNECTING)
            {
                 /* connect failed - play the video */
                 mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }            
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
            {
                 /* connect failed - start buffering */
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
            {
                 /* connect failed - start buffering */
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }
            else 
			{
				/* maybe should do some handling later */
            }         
            break;
        
        case AV_BT_CALLBACK_EVENT_STREAM_START_IND:
        case AV_BT_CALLBACK_EVENT_INQUIRY_START_IND:        
        case AV_BT_CALLBACK_EVENT_INQUIRY_STOP_IND:        
            /* ignore */
            break;

        default:
            MMI_ASSERT(0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bt_connecting
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_bt_connecting_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        mmi_vdoply_start_animation(MMI_VDOPLY_BT_CONNECTING_ANI_ID, MMI_FALSE);
    }
    else
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        mmi_vdoply_start_animation(MMI_VDOPLY_BT_CONNECTING_ANI_ID, MMI_TRUE);
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */    
    }
    mmi_vdoply_blt_screen();

}

#endif /* __VDOPLY_FEATURE_BT__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_is_output_to_bt
 * DESCRIPTION
 *  a callback function invoked by av_bt_open apis
 * PARAMETERS
 *  result
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_is_output_to_bt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_IS_OUTPUT_TO_BT);      
   
#if defined(__VDOPLY_FEATURE_BT__)

    if (mmi_a2dp_is_output_to_bt() &&
        (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
         g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY))
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RET, MMI_TRUE);          
        return MMI_TRUE;
    }
    else
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RET, MMI_FALSE);           
        return MMI_FALSE;
    }

#else
    return MMI_FALSE;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_connect_bt
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_connect_bt(void)
{
#if defined(__VDOPLY_FEATURE_BT__)        
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_stereo;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CONNECT_BT);     
    
    if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING || 
        g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_BT_CONNECTING || 
        g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING ||        
        g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
    {
        if (mmi_vdoply_is_output_to_bt())
        {
            /* if connecting is not start in 600ms, we will show bt connecting anim */
            gui_start_timer(600, mmi_vdoply_draw_bt_connecting_anim);
            
        #ifdef __MMI_VIDEO_STREAM__
            if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING ||
                g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
            {
                /* get audio channel and sampling rate when first time buffering */
                if (g_vdoply_cntx.video_info.aud_channel_no == 0 &&
                    g_vdoply_cntx.video_info.aud_sample_rate == 0)
                {
                    mdi_video_stream_get_audio_info(&(g_vdoply_cntx.video_info.aud_channel_no),
                                                    &(g_vdoply_cntx.video_info.aud_sample_rate));
                }
            }
        #endif /* __MMI_VIDEO_STREAM__ */
        
            if (g_vdoply_cntx.video_info.aud_channel_no == 2)
            {
                is_stereo = MMI_TRUE;
            }
            else
            {
                is_stereo = MMI_FALSE;
            }

            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_OPEN_EX, __LINE__);  

            av_bt_open_ex(
                mmi_vdoply_get_bt_headset(),
                g_vdoply_cntx.video_info.aud_sample_rate,
                (kal_bool)is_stereo,
                mmi_vdoply_bt_open_callback,
                KAL_TRUE);   

            return;
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }
    }
    else
    {
        MMI_ASSERT(0);
    }
#else
    MMI_ASSERT(0);
#endif /* __VDOPLY_FEATURE_BT__ */


}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_disconnect_bt
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_disconnect_bt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_DISCONNECT_BT);      

    
#if defined(__VDOPLY_FEATURE_BT__)    
    gui_cancel_timer(mmi_vdoply_draw_bt_connecting_anim);
    mmi_vdoply_stop_animation();

    if (mmi_vdoply_is_output_to_bt())
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_CLOSE, __LINE__);             
        av_bt_close(KAL_FALSE);
    }

    /* TODO: stop anim */
#endif /* __VDOPLY_FEATURE_BT__ */
 
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bt_close_codec
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_bt_close_codec(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_BT_CLOSE_CODEC);      
    
#if defined(__VDOPLY_FEATURE_BT__)    
    if (mmi_vdoply_is_output_to_bt())
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_CLOSE_CODEC, __LINE__);          
        av_bt_close_codec();
    }
#endif /* __VDOPLY_FEATURE_BT__ */
 
}



/*****************************************************************************
*
* VDOPLY Play                                                        
*
*****************************************************************************/



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_null_key_event
 * DESCRIPTION
 *  empty key event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_null_key_event(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_blt_screen
 * DESCRIPTION
 *  blt full screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_blt_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_BLT_BEGIN);  
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #if defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
    #else 
        gdi_layer_blt_previous(0, 0, UI_device_height - 1, UI_device_width - 1);
    #endif 
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_BLT_END);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_is_background_call
 * DESCRIPTION
 *  check if is call at background
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_is_background_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_BACKGROUND_CALL__) && !defined(__RF_DESENSE_TEST__)
    if (srv_ucm_is_background_call())
    {
        return MMI_TRUE;
    }
#endif /* __MMI_BACKGROUND_CALL__ */

    return MMI_FALSE;
   
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_display_not_available_popup
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_display_not_available_popup(mmi_id parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_BACKGROUND_CALL__) && !defined(__RF_DESENSE_TEST__)
    mmi_ucm_entry_error_message();
#else /* __MMI_BACKGROUND_CALL__ */
    mmi_vdoply_display_popup(parent_id, 
        STR_GLOBAL_CURRENTLY_NOT_AVAILABLE,
        MMI_EVENT_FAILURE);   
#endif /* __MMI_BACKGROUND_CALL__ */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_disply_popup
 * DESCRIPTION
 *  display popup. will roate if is horizontal screen
 * PARAMETERS
 *  str_ptr             [IN]        String pointer
 *  img_id              [IN]        Image id
 *  image_on_bottom     [IN]        Is image on bottom
 *  tone_duration       [IN]        Tone duration
 *  tone_id             [IN]        Tine id
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_display_popup(mmi_id parent_id,MMI_ID_TYPE str_id, mmi_event_notify_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_popup_display_simple_ext(                   
        str_id,                                
        type,                                   
        parent_id,                                 
        NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_check_and_display_error_popup
 * DESCRIPTION
 *  display error popup.
 * PARAMETERS
 *  result      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_check_and_display_error_popup(MDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE err_strid;
    mmi_event_notify_enum popup_type;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (result < MDI_RES_VDOPLY_SUCCEED) /* error happened */
	{
	    switch (result)
	    {
	        case MDI_RES_VDOPLY_ERR_SNAPSHOT_DISK_FULL:
	        case MDI_RES_VDOPLY_ERR_SNAPSHOT_ROOT_DIR_FULL:
	        case MDI_RES_VDOPLY_ERR_SNAPSHOT_WRITE_PROTECTION:
	        case MDI_RES_VDOPLY_ERR_SNAPSHOT_NO_DISK:
	        case MDI_RES_VDOPLY_ERR_SNAPSHOT_FAILED:            
	            err_strid = mdi_util_get_mdi_error_info(result, &popup_type);
	            mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, err_strid, popup_type);
	            break;
	            
	        default:
	            err_strid = mdi_util_get_mdi_error_info(result, &popup_type);
	            cui_vdoply_evt_exit(MMI_TRUE, err_strid);
	            break;
	    }    
	    
	    return MMI_TRUE;
	}
	else
	{
	    return MMI_FALSE;
	}

}


#ifdef __VDOPLY_FEATURE_SPEED__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_speed_image
 * DESCRIPTION
 *  get speed image
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U16 mmi_vdoply_get_speed_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 speed;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    speed = mmi_vdoply_get_speed_factor();

#ifndef __VDOPLY_FEATURE_FWD_BWD_SPEED__
    switch (speed)
    {
        case 50:
            return IMG_ID_VDOPLY_OSD_SPEED_50;

        case 75:
            return IMG_ID_VDOPLY_OSD_SPEED_75;

        case 100:
            return IMG_ID_VDOPLY_OSD_SPEED_100;

        case 125:
            return IMG_ID_VDOPLY_OSD_SPEED_125;

        case 150:
            return IMG_ID_VDOPLY_OSD_SPEED_150;

        case 200:
            return IMG_ID_VDOPLY_OSD_SPEED_200;

        case 400:
            return IMG_ID_VDOPLY_OSD_SPEED_400;

        case 800:
            return IMG_ID_VDOPLY_OSD_SPEED_800;

        default:
            return IMG_ID_VDOPLY_OSD_SPEED_UNDEF;

    }
#else /* __VDOPLY_FEATURE_FWD_BWD_SPEED__ */ 
    if (speed > 0)
    {
        return IMG_ID_VDOPLY_OSD_SPEED_FWD;
    }
    else if (speed < 0)
    {
        return IMG_ID_VDOPLY_OSD_SPEED_BWD;
    }
    else
    {
        return IMG_ID_VDOPLY_OSD_SPEED_UNDEF;
    }
#endif /* __VDOPLY_FEATURE_FWD_BWD_SPEED__ */ 

}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_del_screen_hdlr
 * DESCRIPTION
 *  callback function when someone delete this screen's id
 * PARAMETERS
 *  ptr     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_del_screen_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_DEL_SCREEN_HDLR);       
	
#ifdef __MMI_VIDEO_STREAM__
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        /* need to handle stream state, since it may execute in background */
        switch (g_vdoply_cntx.state)
        {
            case VDOPLY_STATE_STREAM_CONNECTED:  
            case VDOPLY_STATE_STREAM_BT_CONNECTING:
            case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
                mdi_video_stream_disconnect();
                break;
                
            case VDOPLY_STATE_STREAM_CONNECTING:
            case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:     
                mdi_video_stream_disconnect();
                mmi_vdoply_stop_animation();
                break;

            case VDOPLY_STATE_STREAM_BUFFERING:    
                mmi_vdoply_stream_stop_buffering();
                mdi_video_stream_disconnect();
                break;

            case VDOPLY_STATE_STREAM_PLAY:
                mmi_vdoply_stop_video(); 
                mdi_video_stream_disconnect();
                break;

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__     
            case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:  
            case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
                mdi_video_stream_disconnect();
                break;

            case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
            case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
                mmi_vdoply_stop_animation();
                mdi_video_stream_disconnect();  
                break;
      
            case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING: 
                mmi_vdoply_stream_stop_buffering();
                mdi_video_stream_disconnect();          
                break;

            case VDOPLY_STATE_STREAM_FULLSCR_PLAY:            
                mmi_vdoply_stop_video();             
                mdi_video_stream_disconnect();
                break;
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        }

        if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_STREAM_INIT) == MMI_TRUE)
        {
            mdi_video_stream_deinit();
            VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_STREAM_INIT);
        }

        #ifdef __TCPIP__
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_RELEASE_BEARER, __LINE__);
        cbm_release_bearer(g_vdoply_cntx.cbm_app_id);
        #endif

        /* reset from history flag */
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY);

        g_vdoply_cntx.state = VDOPLY_STATE_EXIT;
    }
#endif /* __MMI_VIDEO_STREAM__ */



#if defined(__MMI_VIDEO_PDL__) 
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
        if(g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
        {
            MMI_ASSERT(g_vdoply_cntx.pdl_dl_session_id != -1);
            
            /* progressive DL is not finished */
        #ifdef __MMI_DOWNLOAD_AGENT__
            srv_da_stop_pdl(g_vdoply_cntx.pdl_dl_session_id);
        #endif
        }

        g_vdoply_cntx.pdl_dl_session_id = -1;     
        g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_EXIT;           
    }
    #ifdef __MMI_SUPPORT_ASMV2__
		g_vdoply_cntx.is_entry_player_from_browser = MMI_FALSE;
		g_vdoply_cntx.is_srv_da_state_complete = MMI_FALSE;
    #endif
#endif /* defined(__MMI_VIDEO_PDL__)  */

#if defined(__MMI_VIDEO_STREAM__)
    mmi_vdoply_deregister_bear_event_callback_hdlr();
        
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP && 
        VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_DA_SDP_FILE) == MMI_TRUE)
    {
        /* delete DA's tmp SDP file */
        FS_Delete((kal_wchar*)g_vdoply_cntx.source_path);
    }
#endif /* defined(__MMI_VIDEO_STREAM__) */

}

static void mmi_vdoply_create_title_name()
{
	S32 str_len;
    S32 i;
	
	if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY) == MMI_FALSE && 
        (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_DISCONNECT || 
         g_vdoply_cntx.state == VDOPLY_STATE_EXIT ||
         g_vdoply_cntx.state == VDOPLY_STATE_STREAM_CONNECTING ||
         g_vdoply_cntx.state == VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING))
    {
        /* those state did not have title name, we will use source path as title */
        
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
        {
            /* rtsp streaming, using url as default title */
            /* copy 1 char less to reserve null terminate */
            mmi_ucs2ncpy(
                g_vdoply_cntx.video_info.title_desc, 
                g_vdoply_cntx.source_path, 
                MDI_VIDEO_INFO_TITLE_CHAR_COUNT-1);
        }
        else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP ||
                 g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE ||
                 g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
			memset(g_vdoply_cntx.video_info.title_desc, 0, sizeof(g_vdoply_cntx.video_info.title_desc));
            if ((g_vdoply_cntx.video_info.title_desc[0] == 0) &&
                (g_vdoply_cntx.video_info.title_desc[1] == 0))
            {
                str_len = mmi_ucs2strlen(g_vdoply_cntx.source_path);

                /* find file name - by finding "\\" */
                for (i = str_len * 2 - 2; i >= 2; i -= 2)
                {
                    if (mmi_ucs2ncmp((CHAR*) & g_vdoply_cntx.source_path[i], (CHAR*) L"\\", 1) == 0)
                {
                    i += 2;
                    break;
                }
            }

                /* copy 1 char less to reserve null terminate */
                mmi_ucs2ncpy(
                    (CHAR*)g_vdoply_cntx.video_info.title_desc, 
                    (CHAR*)&(g_vdoply_cntx.source_path[i]),
                    MDI_VIDEO_INFO_TITLE_CHAR_COUNT-1);    
            }         
            
            srv_fmgr_path_hide_extension((WCHAR *)g_vdoply_cntx.video_info.title_desc);

        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_internal
 * DESCRIPTION
 *  internal play screen function, allows to play from id and filename
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_player_screen_internal(void* guiBuffer, MMI_BOOL is_redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

#ifdef __MMI_VIDEO_STREAM__    
    mdi_result ret = MDI_RES_VDOPLY_SUCCEED;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_ENTRY_PLAYER_SCREEN_INTERNAL);
	
    isFirstSeek = MMI_TRUE;
	
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);
	
    gdi_layer_reset_clip();

    g_vdoply_cntx.play_wnd_layer_handle = GDI_LAYER_EMPTY_HANDLE;

    /* load image viewer setting for snap shot directory */
    #ifdef __MMI_IMAGE_VIEWER__
    mmi_imgview_load_setting();
    #endif

    /* load video player setting */
    mmi_vdoply_load_setting();

#ifndef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
    entry_full_screen();
#endif

    /* entry sublcd */
#ifdef __MMI_SUBLCD__
    if (!is_redraw)
    {
        if (g_vdoply_cntx.is_sub_display == MMI_FALSE)
        {
            ForceSubLCDScreen(mmi_vdoply_entry_sublcd_screen);
        }
    }
#endif /* __MMI_SUBLCD__ */ 

    if (guiBuffer == NULL)
    {
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_DA_SDP_FILE);

        /* newly entry, will always consume drm count */
        g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
           
    }

    /* first time enter, or interrupted at opening state */
    if ((guiBuffer == NULL) || ((guiBuffer != NULL) && (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_SOURCE_OPENED) == FALSE)))
    {
        g_vdoply_cntx.cur_status.play_time = 0;
        g_vdoply_cntx.cur_status.start_play_time = 0;
        g_vdoply_cntx.cur_status.max_play_time = 0;
        g_vdoply_cntx.cur_status.speed = VDOPLY_DEFAULT_SPEED;
        g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;
		
   #ifdef __MMI_VIDEO_STREAM__            
        if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY) == MMI_TRUE)
        {
            mmi_ucs2cpy(g_vdoply_cntx.video_info.title_desc, g_vdoply_cntx.history_title_name);
        }
   #endif /* __MMI_VIDEO_STREAM__ */
        
        ReadValueSlim(NVRAM_VDOPLY_VOLUMN, (void*)&g_vdoply_cntx.cur_status.volume, DS_BYTE);

        if (g_vdoply_cntx.cur_status.volume == 0xff)
        {
            /* NVRAM not init, give a default value */
            g_vdoply_cntx.cur_status.volume = VDOPLY_VOL_8;
        }

        if (g_vdoply_cntx.cur_status.volume == VDOPLY_VOL_1)
        {
            //g_vdoply_cntx.is_mute = MMI_TRUE;
        }
		if (g_vdoply_cntx.cur_status.volume > VDOPLY_VOL_16)
        {
			g_vdoply_cntx.is_mute = MMI_TRUE;//((g_vdoply_cntx.cur_status.volume & 0x10) != 0) ? MMI_TRUE : MMI_FALSE;
			g_vdoply_cntx.bVolFlag = ((g_vdoply_cntx.cur_status.volume & 0x20) != 0) ? MMI_TRUE : MMI_FALSE;
			g_vdoply_cntx.cur_status.volume = g_vdoply_cntx.cur_status.volume & 0x0f;
        }
    }
    else
    {
        g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;        
    }

    g_vdoply_cntx.fullscr_osd_opacity = 255;
    g_vdoply_cntx.popup_anim = GDI_NULL_HANDLE;       
    g_vdoply_cntx.aud_only_anim = GDI_NULL_HANDLE;        
    
    g_vdoply_cntx.is_seeking = MMI_FALSE;
	
	VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_STREAM_OPENED);
	
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);          
    
    switch(g_vdoply_cntx.play_source)
    {
        case VDOPLY_PLAY_FROM_FILE:
        case VDOPLY_PLAY_FROM_ID:
        case VDOPLY_PLAY_FROM_PROGRESSIVE_DL:     
            g_vdoply_cntx.is_progress_seekable = MMI_TRUE;
            break;            
        case VDOPLY_PLAY_FROM_STREAMING_RTSP:
        case VDOPLY_PLAY_FROM_STREAMING_RAM:
        case VDOPLY_PLAY_FROM_STREAMING_SDP:
            if(guiBuffer == NULL)
            {
                g_vdoply_cntx.is_progress_seekable = MMI_FALSE;            
            }
            break;
    }


    /* create title name */
	mmi_vdoply_create_title_name();    

    /****************************************************************************
     * Init proper state for video applcation                                                                     
     *****************************************************************************/
    /* force all playing keypad tone off */
    srv_profiles_stop_tone(SRV_PROF_TONE_KEYPAD);
    /* disable key pad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

    /* suspend background play */
    mdi_audio_suspend_background_play();

    /* disalbe align timer */
    UI_disable_alignment_timers();

    /* 
     * This is used to solve a very rare situation. When playing a IMELODY 
     * with backlight on/off, and the screen previous to this screen is a 
     * horizontal screen. Before enter this screen, the IMELODY turn off the
     * backlight. While exit previous screen, the layer rotate back to normal
         * size and the content is not correct. So when calling srv_backlight_turn_on, 
     * LCD is in sleepin state and draw wrong content to LCD.
     * So we need to clear the buffer first to avoid this situation.
     */
     
    /* stop lcd sleep */
	srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

    /* init aud volume */
    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
		//g_vdoply_cntx.cur_status.volume = VDOPLY_VOL_1;
        mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_TRUE);
    }
    else
    {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
    }

    /* register AVRCP */
#ifdef __MMI_AVRCP_SUPPORT__
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_MMI_VT_AVRCP_SET_CMD_HDLR, __LINE__);
    mmi_bt_avrcp_set_cmd_hdlr(mmi_vdoply_bt_avrcp_cmd_hdlr);
#endif 

    /* use medium font */
    gui_set_font(&MMI_medium_font);

#if defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__)
    wgui_register_pen_down_handler(mmi_vdoply_touch_scr_pen_down_hdlr);
    wgui_register_pen_up_handler(mmi_vdoply_touch_scr_pen_up_hdlr);
    wgui_register_pen_move_handler(mmi_vdoply_touch_scr_pen_move_hdlr);
    wgui_register_pen_abort_handler(mmi_vdoply_touch_scr_pen_abort_hdlr);
    wgui_register_pen_long_tap_handler(mmi_vdoply_touch_scr_pen_log_tap_hdlr);
#endif /* defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__) */ /* __VDOPLY_FEATURE_TOUCH_SCREEN__ & __MMI_TOUCH_SCREEN__ */

    g_vdoply_cntx.normal_style_rotate = GDI_LAYER_ROTATE_0;
    g_vdoply_cntx.normal_style_lcd_width = UI_device_width;
    g_vdoply_cntx.normal_style_lcd_height = UI_device_height;
 
#ifdef __TCPIP__
#ifdef __MMI_VIDEO_STREAM__
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_HOLD_BEARER, g_vdoply_cntx.flags, __LINE__);
        if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE)==MMI_FALSE)
        {
            switch(g_vdoply_cntx.play_source)
            {
                case VDOPLY_PLAY_FROM_STREAMING_RTSP:
                case VDOPLY_PLAY_FROM_STREAMING_RAM:
                case VDOPLY_PLAY_FROM_STREAMING_SDP:        
                {
                    cbm_hold_bearer(g_vdoply_cntx.cbm_app_id);
                    break;
                }
            }
        }
#endif
#endif

 
   /****************************************************************************
   * draw skin                                                                 
   *****************************************************************************/

    /* init panel */
    mmi_vdoply_init_ui();


#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
    /* newer cip has layer bg color, we can split bg into smaller region for better performance */
    gdi_layer_set_blt_layer(
        g_vdoply_cntx.bg_region_0_layer_handle, 
        g_vdoply_cntx.bg_region_1_layer_handle,             
        0,
        0);
#else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
      
    gdi_layer_set_blt_layer(
        g_vdoply_cntx.bg_layer_handle, 
        g_vdoply_cntx.status_bar_layer_handle,   
        0, 
        0);
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */


    mmi_vdoply_redraw_normal();
        
    mmi_vdoply_set_state_softkey(g_vdoply_cntx.state);

    /* for interrupted states, the softkey will be set wrong becuz it is in exit here. */
    /* blt the screen later except for small screen.                                   */

    /* this function is entry by small screen's history draw, no need to open file */
    if (is_redraw)
    {
        mmi_vdoply_blt_screen();
        return;
    }

    /* reset flag, this need reset after check small screen */
	if (guiBuffer == NULL)
	{
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SOURCE_OPENED);
    }

    g_vdoply_cntx.prev_rotate_by_layer = (MMI_BOOL)gdi_lcd_get_rotate_by_layer();
    gdi_lcd_set_rotate_by_layer(MMI_TRUE);
    
#if defined(__BT_SPK_VOL_CONTROL__)
    mdi_audio_bt_register_volume_sync_callback(APP_VDOPLY, MDI_AUD_VOL_LEVEL_EXTEND, mmi_vdoply_hfp_vol_hdlr);
#endif


    switch(g_vdoply_cntx.play_source)
    {
        case VDOPLY_PLAY_FROM_FILE:
        case VDOPLY_PLAY_FROM_ID:
            
            /*if (mmi_vdoply_is_background_call())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BACKGROUND_CALL);
                return;
            }
            */
     
            /* check if it is first entry */
            if (guiBuffer == NULL) 
            {
                /* (1) First time enter */
                /* (2) Back from interrupt, but was interrupt at idle state */
                if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_PAUSE_WHEN_LEAVE) == MMI_TRUE)
                {
					VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_PAUSE_WHEN_LEAVE);
                    mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_OPENING);    
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
                }
                return;                      
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_OPENING);
                return;                    
            }
            
        case VDOPLY_PLAY_FROM_PROGRESSIVE_DL:   
		#ifdef __MMI_VIDEO_PDL__
            if (mmi_vdoply_is_background_call())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BACKGROUND_CALL);
                return;
            }
            
            else if ((guiBuffer == NULL) || (g_vdoply_cntx.cur_status.play_time == 0))
            {
                /* (1) First time enter */
                /* (2) Back from interrupt, but was interrupt at idle state */
                mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_OPENING);

            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING);
            }
            
       //#ifdef __MMI_VIDEO_PDL__
            if (g_vdoply_cntx.pdl_err_str_id && guiBuffer != NULL)
            {
                /* delayed PDL error, let screen entry function finish before popup */
                gui_start_timer(0, mmi_vdoply_display_pdl_err_popup);
            }
        #endif /* __MMI_VIDEO_PDL__ */
        
            break; 

        case VDOPLY_PLAY_FROM_STREAMING_RTSP:
        case VDOPLY_PLAY_FROM_STREAMING_RAM:
        case VDOPLY_PLAY_FROM_STREAMING_SDP:
        #ifdef __MMI_VIDEO_STREAM__
            if (mmi_vdoply_is_background_call())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT);
                return;
            }
            
            /* streaming have to check flight mode */
            if(srv_mode_switch_is_network_service_available() == MMI_FALSE)
            {
                cui_vdoply_evt_exit(MMI_TRUE, STR_ID_VDOPLY_NOTIFY_FLIGHT_MODE);
                return;
            }
            
            if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_STREAM_INIT) == MMI_FALSE)
            {
                mmi_vdoply_register_bear_event_callback_hdlr();
                ret = mdi_video_stream_init(GRP_ID_VDOPLY_SINGLE_PLAYER);
                VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_STREAM_INIT);
            }
            
            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)      
            {
                /* ture means has error popup */                
                return;
            }
           
            if (guiBuffer == NULL)
            {
                /* first time enter */
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);    
            }
            else
            {
                /* back from interrupt, stream maybe in connected state or connecting state in background */
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
            }
        #endif /* __MMI_VIDEO_STREAM__ */            
            break;          

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_video_play_params
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_get_video_play_params(GDI_HANDLE* play_layer_handle, U32 *play_layer, U32 *blt_layer, U16 *rotate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
	{
        /* start play video - fullscreen */
	#if defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
        *rotate = VDOPLY_PLAYBACK_ROTATE_0;    
    #else
          *rotate = VDOPLY_PLAYBACK_ROTATE_270;
    #endif 

        *blt_layer = GDI_LAYER_ENABLE_LAYER_0;   
        *play_layer = GDI_LAYER_ENABLE_LAYER_0;        
         *play_layer_handle = g_vdoply_cntx.fullscr_play_layer_handle;
    
    }
    else      
    {          
    #ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
        /* bg region 0, bg region 1, play layer */
        *blt_layer = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 | GDI_LAYER_ENABLE_LAYER_2;   
        *play_layer = GDI_LAYER_ENABLE_LAYER_2;     
    #else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
        /* bg, play layer */    
        *blt_layer = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1;   
        *play_layer = GDI_LAYER_ENABLE_LAYER_1;     
    #endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
        
        *rotate = VDOPLY_PLAYBACK_ROTATE_0;
        *play_layer_handle = g_vdoply_cntx.play_wnd_layer_handle;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_video
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MDI_RESULT mmi_vdoply_update_layer_pause(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    MDI_RESULT mdi_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_ret = mdi_video_ply_update_layer_pause();
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_UPDATE_LAYER_PAUSE,mdi_ret);
    return mdi_ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_video
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MDI_RESULT mmi_vdoply_update_layer_resume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 rotate;
    U32 blt_layer;
    U32 play_layer;
    GDI_HANDLE play_layer_handle;
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_get_video_play_params(&play_layer_handle, &play_layer, &blt_layer, &rotate);

	ret = mdi_video_ply_update_layer_resume(
		play_layer_handle,
	    blt_layer,
	    play_layer,
	    MMI_TRUE,
	    rotate);

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    if (ret == MED_RES_OK)
	{
		if(g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY 
			&& g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
		{
			mmi_vdoply_draw_fullscr_aud_only_anim();
		}
    }
#endif 

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_UPDATE_LAYER_RESUME,ret,rotate);
     
    return ret;
      
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_video
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MDI_RESULT mmi_vdoply_play_video(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 rotate;
    U32 blt_layer;
    U32 play_layer;
    BOOL is_play_audio;
    gdi_handle play_layer_handle;
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_get_video_play_params(&play_layer_handle, &play_layer, &blt_layer, &rotate);

    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_TRUE);
    }
    else
    {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
    }

    if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY || 
        g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
    {
        
    #ifdef __DRM_SUPPORT__
        if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NEED_CONSUME)
        {
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NO_CONSUME;
        }
        else if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NO_CONSUME)
        {
            mdi_video_ply_drm_disable_consume_count();
        }
        else
        {
            MMI_ASSERT(0);
        }
    #endif /* __DRM_SUPPORT__ */

    is_play_audio = TRUE;
    #if !defined(__RF_DESENSE_TEST__) && defined(__MMI_BACKGROUND_CALL__)
        if (srv_ucm_is_background_call())
        {
            is_play_audio = FALSE;
        }
    #endif /* defined(__RF_DESENSE_TEST__) && defined(__MMI_BACKGROUND_CALL__) */
        ret = mdi_video_ply_play(
                play_layer_handle,                      /* play layer handle */
                blt_layer,                              /* blt layer */
                play_layer,                             /* play_layer_flag */
                1,                                      /* repeat */
                TRUE,                                   /* visual update */
                is_play_audio,                          /* play aud */
                MDI_DEVICE_SPEAKER2,                    /* audio path */
                rotate,                                 /* rotate */
                mmi_vdoply_get_speed_factor(),          /* speed factor */
                mmi_vdoply_player_play_finish_hdlr,
                0);    /* play layer */

        MMI_VDOPLY_MSG_TRACE(ret);
        if (ret == MDI_RES_VDOPLY_SUCCEED)
        {
            /* draw aud only anim */
            if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
            {
                if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
                {
                    mmi_vdoply_draw_aud_only_anim();
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
                {
                #ifdef __VDOPLY_FEATURE_FULLSCREEN__
                    mmi_vdoply_draw_fullscr_aud_only_anim();
                #endif 
                }
            }
			mmi_vdoply_blt_screen();   
            mmi_vdoply_player_timer_cyclic();
            return MDI_RES_VDOPLY_SUCCEED;
        }    
        else
        {
        #if defined(__VDOPLY_FEATURE_BT__)
            if (mmi_vdoply_is_output_to_bt())
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_AV_BT_CLOSE_CODEC, __LINE__);                   
                av_bt_close_codec();
            }
        #endif /* __VDOPLY_FEATURE_BT__ */
            return ret;
        }

    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY || 
             g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
    {
    #ifdef __MMI_VIDEO_STREAM__        

    #ifdef __DRM_SUPPORT__
        if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NEED_CONSUME)
        {
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NO_CONSUME;
        }
        else if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NO_CONSUME)
        {
            mdi_video_stream_drm_disable_consume_count();
        }
        else
        {
            MMI_ASSERT(0);
        }
    #endif /* __DRM_SUPPORT__ */

        ret = mdi_video_stream_play(
            play_layer_handle, 
            blt_layer, 
            play_layer, 
            MMI_TRUE, 
            MDI_DEVICE_SPEAKER2, 
            rotate, 
            mmi_vdoply_player_play_finish_hdlr,
            NULL);

        MMI_VDOPLY_MSG_TRACE(ret);
        if (ret == MDI_RES_VDOPLY_SUCCEED)
        {
            /* draw aud only anim */
            if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
            {
                if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
                {
                    mmi_vdoply_draw_aud_only_anim();
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
                {
                #ifdef __VDOPLY_FEATURE_FULLSCREEN__
                    mmi_vdoply_draw_fullscr_aud_only_anim();
                #endif 
                }
                mmi_vdoply_blt_screen();                
            }
            
            mmi_vdoply_player_timer_cyclic();            
            return MDI_RES_VDOPLY_SUCCEED;           
        } 
        else
        {
            mmi_vdoply_bt_close_codec();
            return ret;        
        }
    
    #else /* __MMI_VIDEO_STREAM__ */
        MMI_ASSERT(0);
    #endif /* __MMI_VIDEO_STREAM__ */

    
    }

    return MDI_RES_VDOPLY_SUCCEED;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stop_video
 * DESCRIPTION
 *  stop play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__
static MDI_RESULT mmi_vdoply_stop_video(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	MDI_RESULT result = MDI_RES_VDOPLY_SUCCEED;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	if (g_vdoply_cntx.is_seeking == MMI_TRUE)
	{
		MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RETURN_FUCNTION, __LINE__);			
		return result;
	}
	
	gui_cancel_timer(mmi_vdoply_player_timer_cyclic);

	if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY || 
		g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
	{
		result = mdi_video_ply_stop();
		mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
	}
	else
	{
		MMI_ASSERT(0);
	}

	mmi_vdoply_bt_close_codec();
	mmi_vdoply_disconnect_bt();   

#ifdef __DRM_SUPPORT__
	if (result == MDI_RES_VDOPLY_ALREADY_FINISHED)
	{
		g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
	}
#endif /* __DRM_SUPPORT__ */

	return result;
		
}

#else
static MDI_RESULT mmi_vdoply_stop_video(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result = MDI_RES_VDOPLY_SUCCEED;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.is_seeking == MMI_TRUE)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RETURN_FUCNTION, __LINE__);          
        return result;
    }
    
    gui_cancel_timer(mmi_vdoply_player_timer_cyclic);


    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY || 
        g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
    {
        result = mdi_video_ply_stop();
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY || 
             g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
    {
    #ifdef __MMI_VIDEO_STREAM__
        result = mdi_video_stream_stop();
    #endif
    }

    mmi_vdoply_bt_close_codec();
    mmi_vdoply_disconnect_bt();   

#ifdef __DRM_SUPPORT__
    if (result == MDI_RES_VDOPLY_ALREADY_FINISHED)
    {
        g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
    }
#endif /* __DRM_SUPPORT__ */

    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
    {
        mmi_vdoply_clear_aud_only_anim();
		
		mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        mmi_vdoply_clear_fullscr_aud_only_anim();
		mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
    {
    #ifdef __MMI_VIDEO_STREAM__      
        mmi_vdoply_clear_aud_only_anim();  
    #endif 
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
    {
    #ifdef __MMI_VIDEO_STREAM__  
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        mmi_vdoply_clear_fullscr_aud_only_anim(); 
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */        
    #endif /* __MMI_VIDEO_STREAM__ */
    }
    else
    {
        MMI_ASSERT(0);
    }

    return result;
        
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_redraw_normal
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_redraw_normal(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_vdoply_draw_bg();
    mmi_vdoply_draw_title();
    mmi_vdoply_draw_softkey();
    mmi_vdoply_draw_panel();
    mmi_vdoply_draw_play_region_bg();
    
}


/*pluto basic (slim)*/
#ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw play screen background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_layer_handle);
    gdi_layer_clear(MMI_VDOPLY_BG_COLOR);
    gdi_layer_pop_and_restore_active(); 
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_title
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_title(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
    CHAR buf_filename_dest[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 str_width;
    S32 str_height;
    S32 offset_x;
    S32 offset_y;
    S32 layer_offset_x;
    S32 layer_offset_y;
    video_rect_struct *bbox_rect_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* display filename */
    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_TITLE));
	
    if ((g_vdoply_osd_cntx.title.is_draw_filename) || (g_vdoply_osd_cntx.title.is_draw_app_name))
    {
        if (g_vdoply_osd_cntx.title.is_draw_filename)
        {
            mmi_ucs2ncpy(
                (CHAR*)buf_filename, 
                (CHAR*)g_vdoply_cntx.video_info.title_desc, 
                MDI_VIDEO_INFO_TITLE_CHAR_COUNT);
        }
        else    
        {
            /* g_vdoply_osd_cntx.title.is_draw_app_name */
            mmi_ucs2cpy((CHAR*) buf_filename, (CHAR*) GetString(STR_ID_VDOPLY_APP_NAME));
        }

        gui_measure_string((UI_string_type) buf_filename, &str_width, &str_height);
        bbox_rect_p = &g_vdoply_osd_cntx.title.rect;

	#ifndef MMI_VDOPLY_SUGGEST_CUT_FOR_SLIM_PROJECT
        if (g_vdoply_osd_cntx.title.v_align == VIDEO_ALIGN_TOP)
        {
            offset_y = 0;
        }
        else if (g_vdoply_osd_cntx.title.v_align == VIDEO_ALIGN_BOTTOM)
        {
            offset_y = bbox_rect_p->height - str_height;
        }
        else    /* center */
        {
            offset_y = (bbox_rect_p->height - str_height) >> 1;
        }

        offset_y += bbox_rect_p->offset_y;

        if (g_vdoply_osd_cntx.title.h_align == VIDEO_ALIGN_LEFT)
        {
            offset_x = 0;
        }
        else if (g_vdoply_osd_cntx.title.h_align == VIDEO_ALIGN_RIGHT)
        {
            offset_x = bbox_rect_p->width - str_width;
        }
        else
        {
            offset_x = (bbox_rect_p->width - str_width) >> 1;
        }
	#else	
		offset_x = (bbox_rect_p->width - str_width) >> 1;
		offset_y = (bbox_rect_p->height - str_height) >> 1;
	#endif

        if(offset_x < 0)
        {
            offset_x = 0;
        }
        
        offset_x += bbox_rect_p->offset_x;

 
        gdi_layer_push_and_set_active(g_vdoply_cntx.title_draw_layer);
        gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
		
		gdi_image_draw_resized_id(g_vdoply_osd_cntx.bg.region_0.offset_x,
		                          g_vdoply_osd_cntx.bg.region_0.offset_y,
		                          g_vdoply_osd_cntx.bg.region_0.width,
		                          g_vdoply_osd_cntx.bg.region_0.height,
		                          IMG_ID_VDOPLY_OSD_TITLE_BG);

        #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.title_draw_layer);
        #endif

        /* short file name need covert from BIG5 to unicode */
        if (g_vdoply_cntx.is_short_filename == MMI_TRUE)
        {
            mmi_chset_mixed_text_to_ucs2_str(
                (U8*) buf_filename_dest,
                sizeof(buf_filename_dest),
                (U8*) buf_filename,
                (mmi_chset_enum)(PhnsetGetDefEncodingType()));

            mmi_vdoply_draw_style_text(
                buf_filename_dest, 
                offset_x - layer_offset_x, 
                offset_y - layer_offset_y, 
                bbox_rect_p->width,
                &g_vdoply_osd_cntx.title.style_text);
        }
        else
        {
            mmi_vdoply_draw_style_text(
                buf_filename, 
                offset_x - layer_offset_x,
                offset_y - layer_offset_y,
                bbox_rect_p->width,
                &g_vdoply_osd_cntx.title.style_text);
        }
        #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
        #endif
        gdi_layer_pop_and_restore_active();
    } 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_state
 * DESCRIPTION
 *  draw panel's state icon, do nothing on slim
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_progress
 * DESCRIPTION
 *  draw panel's progress bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_progress(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_x;
    S32 offset_y;
    S32 layer_offset_x;
    S32 layer_offset_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_vdoply_calc_progress_ratio();
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.cur_status.play_ratio);
	
    gdi_layer_push_and_set_active(g_vdoply_cntx.progress_draw_layer);     
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if (g_vdoply_cntx.is_progress_seekable == MMI_FALSE)
    {
            /* can not seek, we will show disable progress bar */   
	#ifdef __MMI_VIDEO_PDL__
        gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_fill.width,
            g_vdoply_osd_cntx.panel.progress_fill.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_BG));
	#endif

        gdi_layer_pop_and_restore_active();

        return;
    }
	
    gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_empty.width,
            g_vdoply_osd_cntx.panel.progress_empty.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_BG));

#ifdef __MMI_VIDEO_PDL__
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
        if (g_vdoply_cntx.cur_status.buff_ratio != 0)
        {
            /* draw inside filling */
            offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,

            gdi_layer_set_clip(
                offset_x,
                offset_y,
                offset_x + g_vdoply_cntx.cur_status.buff_ratio,
                offset_y + g_vdoply_cntx.progress.fill_height);

            gdi_image_draw_resized_id(
		            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
		            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
		            g_vdoply_osd_cntx.panel.progress_fill.width,
		            g_vdoply_osd_cntx.panel.progress_fill.height,
                    (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_CATHE));

            gdi_layer_reset_clip();  
        }
    }
#endif /* __MMI_VIDEO_PDL__ */

    if (g_vdoply_cntx.cur_status.play_ratio != 0)
    {
        /* draw inside filling */
        offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x;
        offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y;

        gdi_layer_set_clip(
            offset_x,
            offset_y,
            offset_x + g_vdoply_cntx.cur_status.play_ratio,
            offset_y + g_vdoply_cntx.progress.fill_height);

        gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_fill.width,
            g_vdoply_osd_cntx.panel.progress_fill.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_FILL));

        gdi_layer_reset_clip();            
    }

    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_timer
 * DESCRIPTION
 *  draw panel's timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__)
static void mmi_vdoply_draw_panel_timer(void)
{
#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
    {
        g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.cur_status.play_time;
    }

    gdi_layer_push_and_set_active(g_vdoply_cntx.timer_draw_layer);
	
    time = (U32) ( ( g_vdoply_cntx.cur_status.play_time + 500 ) / 1000);
	mmi_vdorec_draw_panel_timer_ext((void*)&g_vdoply_cntx.timer, time, MMI_FALSE);

    time = (U32) ((g_vdoply_cntx.cur_status.max_play_time + 500) / 1000);
	mmi_vdorec_draw_panel_timer_ext((void*)&g_vdoply_cntx.timer2, time, MMI_FALSE);

    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */
}
#else
static void mmi_vdoply_draw_panel_timer(void)
{
#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time;
    S32 hour;
    S32 hour_remain;
    S32 min;
    S32 sec;
    S32 layer_offset_x;
    S32 layer_offset_y;
	S32 width,height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
    {
        g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.cur_status.play_time;
    }

    time = (U32) ( ( g_vdoply_cntx.cur_status.play_time + 500 ) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    gdi_layer_push_and_set_active(g_vdoply_cntx.timer_draw_layer);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &width, &height);

    /* bg */
    gdi_draw_solid_rect(
        g_vdoply_cntx.timer.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        g_vdoply_cntx.timer.sec_1_offset_x - layer_offset_x + width,
        g_vdoply_cntx.timer.offset_y - layer_offset_y + height,
        MMI_VDOPLY_BG_COLOR);
	
    /* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));

    time = (U32) ((g_vdoply_cntx.cur_status.max_play_time + 500) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    /* bg */
	gdi_draw_solid_rect(
        g_vdoply_cntx.timer2.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer2.offset_y - layer_offset_y,
        g_vdoply_cntx.timer2.sec_1_offset_x - layer_offset_x + width,
        g_vdoply_cntx.timer2.offset_y - layer_offset_y + height,
        MMI_VDOPLY_BG_COLOR);
	
	/* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));

    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_ctrl_button_by_idx
 * DESCRIPTION
 *  draw control button by index(draw detail)
 * PARAMETERS
 *  idx    [IN] button index, see mmi_vdoply_pannel_icon_enum
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_ctrl_button_by_idx(mmi_vdoply_pannel_icon_enum idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bg_width, bg_height;
	S32 layer_offset_x, layer_offset_y;
	S32 img_width, img_height;
	S32 offset_x,offset_y;
	U16 image_id;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
    offset_x = g_vdoply_osd_cntx.panel.button[idx].offset_x;
	offset_y = g_vdoply_osd_cntx.panel.button[idx].offset_y;
	image_id = g_vdoply_osd_cntx.panel.button[idx].image_id;
	
	if (idx == MMI_VDOPLY_BTN_PLAY)
	{
	    if( VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_SEEKING_UI) == MMI_FALSE && (g_vdoply_cntx.state == VDOPLY_STATE_PLAY 
		|| g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY))
	{
	    image_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
	}
		else
		{
		    image_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
		}
	}
		
	
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_BUTTON, &bg_width, &bg_height);
	gdi_image_get_dimension_id(image_id, &img_width, &img_height);
	
	gdi_image_draw_id(
        offset_x - layer_offset_x, 
        offset_y - layer_offset_y, 
        IMG_ID_VDOPLY_OSD_BUTTON);

    gdi_image_draw_id(
        offset_x - layer_offset_x + ((bg_width - img_width)>>1), 
        offset_y - layer_offset_y + ((bg_height - img_height)>>1), 
        image_id);
 
	if(g_touch_obj_tb[idx]->is_press == MMI_TRUE)
	{
	    gdi_image_draw_resized_id(g_touch_obj_tb[idx]->offset_x - layer_offset_x, 
			                      g_touch_obj_tb[idx]->offset_y - layer_offset_y, 
			                      bg_width,
			                      bg_height,
			                      IMG_ID_VDOPLY_OSD_HIGHLIGHT);
	}

	if(g_touch_obj_tb[idx]->is_usable == MMI_FALSE)
	{
	    gdi_image_draw_resized_id(g_touch_obj_tb[idx]->offset_x - layer_offset_x, 
			                      g_touch_obj_tb[idx]->offset_y - layer_offset_y, 
			                      bg_width,
			                      bg_height,
			                      IMG_ID_VDOPLY_OSD_DISABLE);
	}
}

#ifdef MMI_VDOPLY_3D_ANAGLYPH
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_3d_button
 * DESCRIPTION
 *  draw control button by index(draw detail)
 * PARAMETERS
 *  idx    [IN] button index, see mmi_vdoply_pannel_icon_enum
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 layer_offset_x, layer_offset_y;
	S32 img_width, img_height;
	S32 offset_x,offset_y;
	U16 image_id;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) == MMI_FALSE || g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable == MMI_FALSE)
    {
        return;
    }
    
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
    offset_x = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].offset_x;
	offset_y = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].offset_y;
    img_width = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].width;
	img_height = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].height;
    if ( g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_3D || VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_FALSE)
    {
        image_id = IMG_ID_VDOPLY_OSD_3D_ON;
    }
    else
    {
        image_id = IMG_ID_VDOPLY_OSD_3D_OFF;
    }
    
    gdi_image_draw_id(
        offset_x - layer_offset_x, 
        offset_y - layer_offset_y, 
        image_id);
 
	if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press == MMI_TRUE)
	{
	    gdi_image_draw_resized_id(offset_x - layer_offset_x, 
			                      offset_y - layer_offset_y, 
			                      img_width,
			                      img_height,
			                      IMG_ID_VDOPLY_OSD_HIGHLIGHT);
	}

	if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable == MMI_FALSE)
	{
	    gdi_image_draw_resized_id(offset_x - layer_offset_x, 
			                      offset_y - layer_offset_y, 
			                      img_width,
			                      img_height,
			                      IMG_ID_VDOPLY_OSD_DISABLE);
	}
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_ctrl_button
 * DESCRIPTION
 *  draw panel's control button(play/stop/forward/back/toggle full)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_ctrl_button(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.play_draw_layer); 
	gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.play_draw_layer);
	
	for(i = 0; i < MMI_VDOPLY_BTN_TOTAL; i++)
	{
	    mmi_vdoply_draw_panel_ctrl_button_by_idx((mmi_vdoply_pannel_icon_enum)i);
	}
	
	gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_speed
 * DESCRIPTION
 *  draw panel's speed icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_speed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_volume
 * DESCRIPTION
 *  draw panel's volumn icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_volume(void)
{
#ifdef __VDOPLY_FEATURE_VOLUME__
    S32 layer_offset_x, layer_offset_y;
    S32 volumn_width, volumn_height;
	S32 volumn_draw_width;
 
    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
	
	gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_BUTTON_VOL_NULL, &volumn_width, &volumn_height);

	gdi_image_draw_id(
        g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_BUTTON_VOL_NULL));
	

	volumn_draw_width = ((g_vdoply_cntx.cur_status.volume+1) * volumn_width) / (VDOPLY_VOL_16 + 1);
    if (g_vdoply_cntx.is_mute == MMI_FALSE)
    {
        gdi_layer_push_and_set_clip(
		    g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
		    g_vdoply_osd_cntx.panel.volume.offset_x + volumn_draw_width - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y + volumn_height - layer_offset_y);
		gdi_image_draw_id(
		    g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
		    (U16) (IMG_ID_VDOPLY_OSD_BUTTON_VOL_FULL));
		gdi_layer_pop_clip();	
    }
	gdi_layer_pop_and_restore_active();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_softkey_internal
 * DESCRIPTION
 *  draw panel's soft key
 * PARAMETERS
 *  sk_str_id                          [IN] soft key string id
 * style_txt                            [IN] text style struct
 * layer_offset_x                  [IN] layer offset x
 * layer_offset_y                  [IN] layer offset y
 * type                                    [IN] soft key type(see WGUI_SOFTKEY_ENUM)
 * is_pressed                         [IN] is pressed
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_softkey_internal(
            U16 sk_str_id,
            video_style_text_struct *style_txt,
            S32 layer_offset_x,
            S32 layer_offset_y,
            WGUI_SOFTKEY_ENUM type,
            MMI_BOOL is_pressed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR* sk_str_p;
	S32 sk_offset_x, sk_offset_y;
	S32 truncated_w;
	S32 str_width, str_height;
	#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    vdoply_ui_touch_struct *touch_p = NULL;
    #endif 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	sk_str_p = (CHAR*)GetString(sk_str_id);
	wgui_softkey_get_offset(
        (UI_string_type)sk_str_p, 
        &sk_offset_x, 
        &sk_offset_y, 
        &truncated_w, 
        type,
        MMI_FRM_SCREEN_ROTATE_0);
    gui_measure_string((UI_string_type)sk_str_p, &str_width, &str_height);

    /* TRICKY, shift back from R to L MMI */
    if (mmi_fe_get_r2l_state())
    {
        sk_offset_x -= str_width;
		if(type == MMI_RIGHT_SOFTKEY)
		{
		    sk_offset_x--;
		}
    }

    if (is_pressed == MMI_TRUE)
    {
        sk_offset_x++;
        sk_offset_y++;
    }

    mmi_vdoply_draw_style_text(
        sk_str_p,
        sk_offset_x - layer_offset_x,
        sk_offset_y - layer_offset_y,
        truncated_w,
        style_txt);

#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    if(type == MMI_LEFT_SOFTKEY)
    {
		touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK];
    }
	else if(type == MMI_RIGHT_SOFTKEY)
	{
		touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK];
	}
	
    touch_p->offset_x = sk_offset_x;
    touch_p->offset_y = sk_offset_y;
    touch_p->width = truncated_w > str_width? str_width : truncated_w;
    touch_p->height = str_height;
#endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_softkey
 * DESCRIPTION
 *  draw panel's soft key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_softkey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_offset_x;
    S32 layer_offset_y;    

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.lsk_draw_layer);
#ifdef __MMI_VECTOR_FONT_SUPPORT__
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.lsk_draw_layer);
#endif

	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

	gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_BUTTON));

    gui_draw_filled_area(
			0,
	        UI_device_height - MMI_softkey_height,
	        UI_device_width,
	        UI_device_height,
	        current_MMI_theme->softkey_bar_bkg_filler);
	
	/* lsk */
#ifdef __VDOPLY_FEATURE_LSK_OPTION__
    mmi_vdoply_draw_softkey_internal(
            STR_GLOBAL_OPTIONS,
            &g_vdoply_osd_cntx.softkey.lsk_text,
            layer_offset_x,
            layer_offset_y,
            MMI_LEFT_SOFTKEY,
			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press);
#endif  

   /* rsk */
   mmi_vdoply_draw_softkey_internal(
            STR_GLOBAL_BACK,
            &g_vdoply_osd_cntx.softkey.rsk_text,
            layer_offset_x,
            layer_offset_y,
            MMI_RIGHT_SOFTKEY,
			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press);

#ifdef __MMI_VECTOR_FONT_SUPPORT__
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel
 * DESCRIPTION
 *  draw panel
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_draw_panel_volume();
    mmi_vdoply_draw_panel_timer();
    mmi_vdoply_draw_panel_progress();
    mmi_vdoply_draw_panel_ctrl_button();
    #ifdef MMI_VDOPLY_3D_ANAGLYPH
    mmi_vdoply_draw_panel_mode();
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg_internal
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_play_region_bg_internal(GDI_HANDLE play_layer, video_rect_struct *bbox_rect_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
	S32 layer_offset_x, layer_offset_y;
	S32 str_width, str_height;
    S32 offset_x, offset_y;
	CHAR* ptr;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
    {
        gdi_layer_push_and_set_active(play_layer);
        gdi_layer_get_dimension(&layer_width, &layer_height);
		gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

        gdi_layer_clear(MMI_VDOPLY_BG_COLOR); 

		gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_DEFAULT));

		ptr = (CHAR*) GetString(STR_ID_VDOPLY_AUDIO_ONLY);

		gui_measure_string((UI_string_type) ptr, &str_width, &str_height);
		
		
		offset_y = bbox_rect_p->offset_y + (bbox_rect_p->height - str_height) >> 1;
		offset_x = bbox_rect_p->offset_x + (bbox_rect_p->width - str_width) >> 1;
		#ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(play_layer);
        #endif

		mmi_vdoply_draw_style_text(
                ptr, 
                offset_x - layer_offset_x,
                offset_y - layer_offset_y,
                bbox_rect_p->width,
                &g_vdoply_osd_cntx.title.style_text);

		#ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
        #endif
		gdi_layer_pop_and_restore_active();
    } 
	
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_play_region_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_vdoply_draw_play_region_bg_internal( 
	                g_vdoply_cntx.play_wnd_layer_handle, 
	                &g_vdoply_osd_cntx.play_wnd.rect);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  clear audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
}

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_play_region_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	video_rect_struct bbox_rect;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	bbox_rect.offset_x = 0;
	bbox_rect.offset_y = 0;
	bbox_rect.width = UI_device_width;
	bbox_rect.height = UI_device_height;
    mmi_vdoply_draw_play_region_bg_internal( 
	                g_vdoply_cntx.fullscr_play_layer_handle, 
	                &bbox_rect);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  clear full screen audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_start_animation
 * DESCRIPTION
 *  start show popup animation
 * PARAMETERS
 *  ani_id     [IN] animation id
 * is_full      [IN] background screen is full screen
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_start_animation(U32 ani_id, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 width;
	S32 height; 
	S32 load_width, load_height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.popup_anim != GDI_NULL_HANDLE)
    {
        mmi_vdoply_stop_animation();
    }

	if(is_full == MMI_TRUE)
	{
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
		width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
		height = g_vdoply_fullscr_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
#endif
	}
	else
    {
		width = g_vdoply_osd_cntx.loading.rect.width;
		height = g_vdoply_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
	}

    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	gdi_image_draw_resized_id(0, 0, width, height, IMG_ID_VDOPLY_OSD_LOADING_BG);
	gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_LOADING_FULL, &load_width, &load_height);
	//gdi_image_draw_resized_id(5, (height-load_height/2)/2, width-10, load_height/2, IMG_ID_VDOPLY_OSD_LOADING_FULL);
	gdi_image_draw_resized_id(13, (height-(load_height+1))/2, width-26, load_height+1, IMG_ID_VDOPLY_OSD_LOADING_FULL);
	
	gdi_layer_pop_and_restore_active(); 
        
}

#if defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_loading
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_loading(S32 percentage, MMI_BOOL draw_bg, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 draw_width;
    S32 offset_x;
    S32 offset_y; 
	S32 loading_offset_x;
	S32 loading_offset_y;
    S32 width;
    S32 height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(is_full == MMI_TRUE)
	{
	    offset_x = g_vdoply_fullscr_osd_cntx.loading.bg.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_fullscr_osd_cntx.loading.bg.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
		width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
		height = g_vdoply_fullscr_osd_cntx.loading.rect.height;
		loading_offset_x = g_vdoply_fullscr_osd_cntx.loading.progress.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_fullscr_osd_cntx.loading.progress.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
	}
	else
    {
	    offset_x = g_vdoply_osd_cntx.loading.bg.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_osd_cntx.loading.bg.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
		loading_offset_x = g_vdoply_osd_cntx.loading.progress.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_osd_cntx.loading.progress.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
		width = g_vdoply_osd_cntx.loading.rect.width;
		height = g_vdoply_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
	}
		
    if (draw_bg)
    {
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    
        gdi_image_draw_resized_id(
            offset_x,
            offset_y,
            width,
            height,
            IMG_ID_VDOPLY_OSD_LOADING_BG);
    }

   
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_LOADING_FULL, &image_width, &image_height);
	image_height = height-2*loading_offset_x;
	image_width = width-2*loading_offset_y;

    /* draw empty loading bar */
    gdi_image_draw_resized_id(
        loading_offset_x,
        loading_offset_y,
        image_width,
        image_height,
        IMG_ID_VDOPLY_OSD_LOADING_EMPTY);

    draw_width = image_width * percentage / 100;

    gdi_layer_set_clip(
        loading_offset_x,
        loading_offset_y,
        loading_offset_x + draw_width,
        loading_offset_y + image_height);

    gdi_image_draw_resized_id(
        loading_offset_x,
        loading_offset_y,
        image_width,
        image_height,
        IMG_ID_VDOPLY_OSD_LOADING_FILL);
    


    gdi_layer_reset_clip();
    gdi_layer_pop_and_restore_active();
        
}
#endif /* defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__) */

/*FTE 2.0 */
#elif defined( __VDOPLY_FEATURE_FTE20__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw play screen background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_layer_handle);

	gui_draw_filled_area(0, 0, GDI_LCD_WIDTH, GDI_LCD_HEIGHT, current_MMI_theme->main_menu_bkg_filler);

    gdi_layer_pop_and_restore_active();

    mmi_vdoply_draw_region_bg(g_vdoply_cntx.bg_region_0_layer_handle);
    mmi_vdoply_draw_region_bg(g_vdoply_cntx.bg_region_1_layer_handle);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw play screen background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_region_bg(gdi_handle region_layer_hdl)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_layer_struct* act_l;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(region_layer_hdl);
    act_l = (gdi_layer_struct*)region_layer_hdl;
    gdi_bitblt(
            g_vdoply_cntx.bg_layer_handle, 
            0 + act_l->offset_x, 
            0 + act_l->offset_y, 
            act_l->width - 1 + act_l->offset_x, 
            act_l->height - 1 + act_l->offset_y, 
            0,
            0);
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_title
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_title(void)
{
    #ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR,
        g_vdoply_cntx.bg_layer_handle);
    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_0_layer_handle);
    wgui_status_icon_bar_show_horizontal_bar();  
    gdi_layer_pop_and_restore_active();
    #endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_state
 * DESCRIPTION
 *  draw panel's state icon, do nothing on slim
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_SNAPSHOT__  //remove warning
static void mmi_vdoply_draw_panel_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_progress
 * DESCRIPTION
 *  draw panel's progress bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_progress(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_x;
    S32 offset_y;
    S32 layer_offset_x;
    S32 layer_offset_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_vdoply_calc_progress_ratio();
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.cur_status.play_ratio);
	
    gdi_layer_push_and_set_active(g_vdoply_cntx.progress_draw_layer); 
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if (g_vdoply_cntx.is_progress_seekable == MMI_FALSE)
    {
            /* can not seek, we will show disable progress bar */   
	#ifdef __MMI_VIDEO_PDL__
        gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_fill.width,
            g_vdoply_osd_cntx.panel.progress_fill.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_BG));
	#endif
        gdi_pop_and_restore_alpha_blending_source_layer();
        gdi_layer_pop_and_restore_active();

        return;
    }
	
    gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_empty.width,
            g_vdoply_osd_cntx.panel.progress_empty.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_BG));

#ifdef __MMI_VIDEO_PDL__
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
        if (g_vdoply_cntx.cur_status.buff_ratio != 0)
        {
            /* draw inside filling */
            offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,

            gdi_layer_set_clip(
                offset_x,
                offset_y,
                offset_x + g_vdoply_cntx.cur_status.buff_ratio,
                offset_y + g_vdoply_cntx.progress.fill_height);

            gdi_image_draw_resized_id(
		            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
		            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
		            g_vdoply_osd_cntx.panel.progress_fill.width,
		            g_vdoply_osd_cntx.panel.progress_fill.height,
                    (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_CATHE));

            gdi_layer_reset_clip();  
        }
    }
#endif /* __MMI_VIDEO_PDL__ */

    if (g_vdoply_cntx.cur_status.play_ratio != 0)
    {
        /* draw inside filling */
        offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x;
        offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y;

        gdi_layer_set_clip(
            offset_x,
            offset_y,
            offset_x + g_vdoply_cntx.cur_status.play_ratio,
            offset_y + g_vdoply_cntx.progress.fill_height);

        gdi_image_draw_resized_id(
            g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_fill.width,
            g_vdoply_osd_cntx.panel.progress_fill.height,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_FILL));

        gdi_layer_reset_clip();            
    }
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_timer
 * DESCRIPTION
 *  draw panel's timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_timer(void)
{
#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time;
    S32 hour;
    S32 hour_remain;
    S32 min;
    S32 sec;
    S32 layer_offset_x;
    S32 layer_offset_y;
	S32 width,height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
    {
        g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.cur_status.play_time;
    }

    time = (U32) ( ( g_vdoply_cntx.cur_status.play_time + 500 ) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    gdi_layer_push_and_set_active(g_vdoply_cntx.timer_draw_layer);
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);
    
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &width, &height);
	
    /* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));

    time = (U32) ((g_vdoply_cntx.cur_status.max_play_time + 500) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    
	/* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));

    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_ctrl_button_by_idx
 * DESCRIPTION
 *  draw control button by index(draw detail)
 * PARAMETERS
 *  idx    [IN] button index, see mmi_vdoply_pannel_icon_enum
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_ctrl_button_by_idx(mmi_vdoply_pannel_icon_enum idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 layer_offset_x, layer_offset_y;
	S32 offset_x,offset_y;
	U16 image_id;
	PU8 image_ptr;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
    offset_x = g_vdoply_osd_cntx.panel.button[idx].offset_x;
	offset_y = g_vdoply_osd_cntx.panel.button[idx].offset_y;


	if (idx == MMI_VDOPLY_BTN_PLAY)
	{
		if( VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_SEEKING_UI) == MMI_FALSE && (g_vdoply_cntx.state == VDOPLY_STATE_PLAY 
			|| g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY))
		{
			image_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
		}
		else
		{
			image_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
		}
	}
	else
	{
		image_id = g_vdoply_osd_cntx.panel.button[idx].image_id;
	}


    if(g_touch_obj_tb[idx]->is_usable == MMI_TRUE)
    {        
        gdi_image_draw_id(offset_x - layer_offset_x , offset_y - layer_offset_y , image_id);
    }
    else
    {
	    image_ptr = (PU8) GetImage(image_id);
	    if(image_ptr == NULL)
	    {
	        return;
	    }
		gui_draw_image_with_alpha_transparent(image_ptr, offset_x - layer_offset_x, offset_y, 125);
    }	
 
	if(g_touch_obj_tb[idx]->is_press == MMI_TRUE)
	{
	    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_region_1_layer_handle);
	    gdi_image_draw_id(
                offset_x - layer_offset_x , 
                offset_y - layer_offset_y ,
			    IMG_ID_VDOPLY_OSD_HIGHLIGHT);
        gdi_pop_and_restore_alpha_blending_source_layer();
	}
    
}

#ifdef MMI_VDOPLY_3D_ANAGLYPH
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_3d_button
 * DESCRIPTION
 *  draw control button by index(draw detail)
 * PARAMETERS
 *  idx    [IN] button index, see mmi_vdoply_pannel_icon_enum
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 layer_offset_x, layer_offset_y;
	S32 img_width, img_height;
	S32 offset_x,offset_y;
	U16 image_id;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) == MMI_FALSE || g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable == MMI_FALSE)
    {
        return;
    }
    
    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
    offset_x = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].offset_x;
	offset_y = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].offset_y;
    img_width = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].width;
	img_height = g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].height;
    
    if ( g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_3D || VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_FALSE)
    {
        image_id = IMG_ID_VDOPLY_OSD_3D_ON_BUTTON_UP;
    }
    else
    {
        image_id = IMG_ID_VDOPLY_OSD_3D_OFF_BUTTON_UP;
    }

    if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press == MMI_TRUE)
    {
        image_id ++;
    }
    
    gdi_image_draw_id(
        offset_x - layer_offset_x, 
        offset_y - layer_offset_y, 
        image_id);
 
	gdi_layer_pop_and_restore_active();
 
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_ctrl_button
 * DESCRIPTION
 *  draw panel's control button(play/stop/forward/back/toggle full)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_ctrl_button(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.play_draw_layer); 
	gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);
	
	for(i = 0; i < MMI_VDOPLY_BTN_TOTAL; i++)
	{
	    mmi_vdoply_draw_panel_ctrl_button_by_idx((mmi_vdoply_pannel_icon_enum)i);
	}
	
	gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_speed
 * DESCRIPTION
 *  draw panel's speed icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_speed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_mute
 * DESCRIPTION
 *  draw panel's volumn icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_mute(void)
{
#ifdef __VDOPLY_FEATURE_VOLUME__
    S32 layer_offset_x, layer_offset_y;
    U16 mute_id;
 
    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if(g_vdoply_cntx.is_mute == MMI_FALSE)
    {
        mute_id = IMG_ID_VDOPLY_OSD_BUTTON_MUTE;
    }
    else
    {
        mute_id = IMG_ID_VDOPLY_OSD_BUTTON_UNMUTE;
    }

	if(g_vdoply_cntx.cur_status.volume <= VDOPLY_VOL_1 && g_vdoply_cntx.bVolFlag)
	{
		mute_id = IMG_ID_VDOPLY_OSD_BUTTON_UNMUTE;
	}
    gdi_image_draw_id(
		    g_vdoply_osd_cntx.panel.speaker.offset_x - layer_offset_x,
		    g_vdoply_osd_cntx.panel.speaker.offset_y - layer_offset_y,
		    mute_id);
    
    gdi_pop_and_restore_alpha_blending_source_layer();

    if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press == MMI_TRUE)
    {
        mute_id ++;
		gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_region_1_layer_handle);
		gdi_image_draw_id(
				g_vdoply_osd_cntx.panel.speaker.offset_x - layer_offset_x,
				g_vdoply_osd_cntx.panel.speaker.offset_y - layer_offset_y,
				mute_id);
		gdi_pop_and_restore_alpha_blending_source_layer();
    }

	gdi_layer_pop_and_restore_active();
#endif
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_volume
 * DESCRIPTION
 *  draw panel's volumn icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_volume(void)
{
#ifdef __VDOPLY_FEATURE_VOLUME__
    S32 layer_offset_x, layer_offset_y;
    S32 volumn_width, volumn_height;
	S32 volumn_draw_width;

    mmi_vdoply_draw_panel_mute();
 
    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

	gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_BUTTON_VOL_NULL, &volumn_width, &volumn_height);

	gdi_image_draw_id(
        g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_BUTTON_VOL_NULL));
	
    if(g_vdoply_cntx.cur_status.volume > VDOPLY_VOL_1 || g_vdoply_cntx.is_mute == MMI_FALSE || ((g_vdoply_cntx.cur_status.volume == VDOPLY_VOL_1) && !g_vdoply_cntx.bVolFlag))
    {
	    volumn_draw_width = ((g_vdoply_cntx.cur_status.volume + 1) * volumn_width) / (VDOPLY_VOL_16 + 1);

        gdi_layer_push_and_set_clip(
		    g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
		    g_vdoply_osd_cntx.panel.volume.offset_x + volumn_draw_width - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y + volumn_height - layer_offset_y);
	    gdi_image_draw_id(
		    g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
		    g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
		    (U16) (IMG_ID_VDOPLY_OSD_BUTTON_VOL_FULL));
	    gdi_layer_pop_clip();
    }
   
    gdi_pop_and_restore_alpha_blending_source_layer();
	gdi_layer_pop_and_restore_active();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_softkey_internal
 * DESCRIPTION
 *  draw panel's soft key
 * PARAMETERS
 *  sk_str_id                          [IN] soft key string id
 * style_txt                            [IN] text style struct
 * layer_offset_x                  [IN] layer offset x
 * layer_offset_y                  [IN] layer offset y
 * type                                    [IN] soft key type(see WGUI_SOFTKEY_ENUM)
 * is_pressed                         [IN] is pressed
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_softkey_internal(
            S32 layer_offset_x,
            S32 layer_offset_y,
            S32 sk_offset_x,
            S32 sk_offset_y,
            U16 image_id,
            vdoply_ui_touch_struct* touch_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_width, img_height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (touch_p->is_press)
    {
        image_id++;
    }

    gdi_image_get_dimension_id(image_id, &img_width, &img_height);

    gdi_image_draw_id(
        sk_offset_x - layer_offset_x, 
        sk_offset_y - layer_offset_y, 
        image_id);

#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    /* remain these code if design change */
    touch_p->offset_x = sk_offset_x;
    touch_p->offset_y = sk_offset_y;
    touch_p->width = img_width;
    touch_p->height = img_height;
#endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_softkey
 * DESCRIPTION
 *  draw panel's soft key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_softkey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_offset_x;
    S32 layer_offset_y;    

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.lsk_draw_layer);
    
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.bg_layer_handle);

	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

#ifdef __VDOPLY_FEATURE_LSK_OPTION__
    mmi_vdoply_draw_softkey_internal(
            layer_offset_x,
            layer_offset_y,
            g_vdoply_osd_cntx.softkey.icon_lsk_pos.offset_x,
            g_vdoply_osd_cntx.softkey.icon_lsk_pos.offset_y,
            IMG_ID_VDOPLY_LSK_OPTION_UP,
            &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK]);
#endif  

   /* rsk */
   mmi_vdoply_draw_softkey_internal(
            layer_offset_x,
            layer_offset_y,
            g_vdoply_osd_cntx.softkey.icon_rsk_pos.offset_x,
            g_vdoply_osd_cntx.softkey.icon_rsk_pos.offset_y,
            IMG_ID_VDOPLY_RSK_BACK_UP,
            &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK]);

    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel
 * DESCRIPTION
 *  draw panel
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_draw_panel_volume();
    mmi_vdoply_draw_panel_timer();
    mmi_vdoply_draw_panel_progress();
    mmi_vdoply_draw_panel_ctrl_button();
    #ifdef MMI_VDOPLY_3D_ANAGLYPH
    mmi_vdoply_draw_panel_mode();
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
    gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
    gdi_layer_get_dimension(&layer_width, &layer_height);
    gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);

    gdi_layer_clear(GDI_COLOR_BLACK);

    gdi_image_get_dimension_id(
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &image_width,
        &image_height);

    offset_x = (layer_width - image_width) >> 1;
    offset_y = (layer_height - image_height) >> 1;                    

    gdi_image_draw_animation_id(
        offset_x, 
        offset_y, 
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &g_vdoply_cntx.aud_only_anim);

    gdi_layer_pop_and_restore_active();     
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_play_region_bg(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
    {
        gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
        gdi_layer_get_dimension(&layer_width, &layer_height);

        gdi_layer_clear(GDI_COLOR_BLACK);

        gdi_image_get_dimension_id(
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
            &image_width,
            &image_height);

        offset_x = (layer_width - image_width) >> 1;
        offset_y = (layer_height - image_height) >> 1;                    

        gdi_image_draw_id(
            offset_x, 
            offset_y, 
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM);

        gdi_layer_pop_and_restore_active();
    }
    else
    {
        gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_pop_and_restore_active();        
    }  
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  clear audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_vdoply_cntx.aud_only_anim != GDI_NULL_HANDLE)
    {
        gdi_image_stop_animation(g_vdoply_cntx.aud_only_anim);
        g_vdoply_cntx.aud_only_anim = GDI_NULL_HANDLE;
    }
    
}

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
	mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
	gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.fullscr_play_layer_handle);
    gdi_layer_get_dimension(&layer_width, &layer_height);
    gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);

    gdi_layer_clear(GDI_COLOR_BLACK);

    gdi_image_get_dimension_id(
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &image_width,
        &image_height);

    offset_x = (layer_width - image_width) >> 1;
    offset_y = (layer_height - image_height) >> 1;                    

    gdi_image_draw_animation_id(
        offset_x, 
        offset_y, 
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &g_vdoply_cntx.aud_only_anim);

	gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_play_region_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
    {    
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
        gdi_layer_get_dimension(&layer_width, &layer_height);

        gdi_layer_clear(GDI_COLOR_BLACK);

        gdi_image_get_dimension_id(
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
            &image_width,
            &image_height);

        offset_x = (layer_width - image_width) >> 1;
        offset_y = (layer_height - image_height) >> 1;                    

        gdi_image_draw_id(
            offset_x, 
            offset_y, 
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM);

        gdi_layer_pop_and_restore_active();
    }
    else
    {
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_pop_and_restore_active();        
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  clear full screen audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.aud_only_anim != GDI_NULL_HANDLE)
    {
        gdi_image_stop_animation(g_vdoply_cntx.aud_only_anim);
        g_vdoply_cntx.aud_only_anim = GDI_NULL_HANDLE;
    }
    
}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_start_animation
 * DESCRIPTION
 *  start show popup animation
 * PARAMETERS
 *  ani_id     [IN] animation id
 * is_full      [IN] background screen is full screen
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_start_animation(U32 ani_id, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 width, height; 
	S32 load_width, load_height;

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.popup_anim != GDI_NULL_HANDLE)
    {
        mmi_vdoply_stop_animation();
    }

	if(is_full == MMI_TRUE)
	{
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
		width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
		height = g_vdoply_fullscr_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
#endif
	}
	else
    {
		width = g_vdoply_osd_cntx.loading.rect.width;
		height = g_vdoply_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
	}
	
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	gdi_image_draw_resized_id(0, 0, width, height, IMG_ID_VDOPLY_OSD_LOADING_BG);
	gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_LOADING_FULL, &load_width, &load_height);
	gdi_image_draw_resized_id(5, (height-load_height/2)/2, width-10, load_height/2, IMG_ID_VDOPLY_OSD_LOADING_FULL);

	gdi_layer_pop_and_restore_active(); 
        
}

#if defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_loading
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_loading(S32 percentage, MMI_BOOL draw_bg, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 draw_width;
    S32 offset_x;
    S32 offset_y; 
	S32 loading_offset_x;
	S32 loading_offset_y;
    S32 width;
    S32 height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(is_full == MMI_TRUE)
	{
	    offset_x = g_vdoply_fullscr_osd_cntx.loading.bg.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_fullscr_osd_cntx.loading.bg.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
		width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
		height = g_vdoply_fullscr_osd_cntx.loading.rect.height;
		loading_offset_x = g_vdoply_fullscr_osd_cntx.loading.progress.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_fullscr_osd_cntx.loading.progress.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
	}
	else
    {
	    offset_x = g_vdoply_osd_cntx.loading.bg.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_osd_cntx.loading.bg.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
		loading_offset_x = g_vdoply_osd_cntx.loading.progress.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_osd_cntx.loading.progress.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
		width = g_vdoply_osd_cntx.loading.rect.width;
		height = g_vdoply_osd_cntx.loading.rect.height;
        gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
	}
	
    gdi_push_and_set_alpha_blending_source_layer(GDI_NULL_HANDLE);
    if (draw_bg)
    {
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    
        gdi_image_draw_resized_id(
                0,
                0,
                width,
                height,
                IMG_ID_VDOPLY_OSD_LOADING_BG);
    }

   
    image_width = g_vdoply_osd_cntx.loading.progress.width;
    image_height = g_vdoply_osd_cntx.loading.progress.height;
    /* draw empty loading bar */
    gdi_image_draw_resized_id(
        loading_offset_x,
        loading_offset_y,
        image_width,
        image_height,
        IMG_ID_VDOPLY_OSD_LOADING_EMPTY);

    draw_width = image_width * percentage / 100;

    gdi_layer_set_clip(
        loading_offset_x,
        loading_offset_y,
        loading_offset_x + draw_width,
        loading_offset_y + image_height);

    gdi_image_draw_resized_id(
        loading_offset_x,
        loading_offset_y,
        image_width,
        image_height,
        IMG_ID_VDOPLY_OSD_LOADING_FILL);
    


    gdi_layer_reset_clip();
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
        
}
#endif /* defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__) */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw play screen background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_press_mute_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press = MMI_TRUE;
    mmi_vdoply_draw_panel_mute();
    mmi_vdoply_blt_screen();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw play screen background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_press_mute_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press == MMI_TRUE)
    {
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press = MMI_FALSE;
		
		if(g_vdoply_cntx.cur_status.volume <= VDOPLY_VOL_1 && g_vdoply_cntx.bVolFlag)
		{
			;
		}
		else
		{
	        if(g_vdoply_cntx.is_mute == MMI_TRUE)
	        {
	            g_vdoply_cntx.is_mute = MMI_FALSE;
	        }
	        else
	        {
	            g_vdoply_cntx.is_mute = MMI_TRUE;
	        }
		}

        mmi_vdoply_draw_panel_mute();
        mmi_vdoply_blt_screen();

        if (!mmi_vdoply_is_background_call())
        {
            mdi_audio_set_mute(MDI_VOLUME_MEDIA, g_vdoply_cntx.is_mute);
        }
        
    }
}


/* Old version: pluto + FTE*/
#else /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_bg
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__    
    S32 offset_x;
    S32 offset_y;
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__   
    /* newer cip has layer bg color, we can split bg into smaller region for better performance */
    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_0_layer_handle);
    gdi_layer_get_position(&offset_x, &offset_y);
    gdi_image_draw_id(-offset_x, -offset_y, IMG_ID_VDOPLY_OSD_BG);
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_1_layer_handle);
    gdi_layer_get_position(&offset_x, &offset_y);
    gdi_image_draw_id(-offset_x, -offset_y, IMG_ID_VDOPLY_OSD_BG);
    gdi_layer_pop_and_restore_active();

#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    /* draw timer bg */
#ifndef __MMI_FTE_SUPPORT__
    gdi_layer_push_and_set_active(g_vdoply_cntx.timer_draw_layer);    
    gdi_image_draw_id(
        (-offset_x) + g_vdoply_osd_cntx.panel.timer_bg.offset_x,
        (-offset_y) + g_vdoply_osd_cntx.panel.timer_bg.offset_y,
        IMG_ID_VDOPLY_OSD_TIMER_BG);
    gdi_layer_pop_and_restore_active();
#endif
    
#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */


#else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */  
    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_layer_handle);
    gdi_image_draw_id(0, 0, IMG_ID_VDOPLY_OSD_BG);

#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    gdi_image_draw_id(
        g_vdoply_osd_cntx.panel.timer_bg.offset_x,
        g_vdoply_osd_cntx.panel.timer_bg.offset_y,
        IMG_ID_VDOPLY_OSD_TIMER_BG);
#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */

    gdi_layer_pop_and_restore_active();
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */

   
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_title
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_title(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
    CHAR buf_filename_dest[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 str_width;
    S32 str_height;
    S32 offset_x;
    S32 offset_y;
    S32 layer_offset_x;
    S32 layer_offset_y;
    video_rect_struct *bbox_rect_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* display filename */
    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_TITLE));
    if ((g_vdoply_osd_cntx.title.is_draw_filename) || (g_vdoply_osd_cntx.title.is_draw_app_name))
    {
        if (g_vdoply_osd_cntx.title.is_draw_filename)
        {
            mmi_ucs2ncpy(
                (CHAR*)buf_filename, 
                (CHAR*)g_vdoply_cntx.video_info.title_desc, 
                MDI_VIDEO_INFO_TITLE_CHAR_COUNT);
        }
        else    
        {
            /* g_vdoply_osd_cntx.title.is_draw_app_name */
            mmi_ucs2cpy((CHAR*) buf_filename, (CHAR*) GetString(STR_ID_VDOPLY_APP_NAME));
        }

        gui_measure_string((UI_string_type) buf_filename, &str_width, &str_height);
        bbox_rect_p = &g_vdoply_osd_cntx.title.rect;

        if (g_vdoply_osd_cntx.title.v_align == VIDEO_ALIGN_TOP)
        {
            offset_y = 0;
        }
        else if (g_vdoply_osd_cntx.title.v_align == VIDEO_ALIGN_BOTTOM)
        {
            offset_y = bbox_rect_p->height - str_height;
        }
        else    /* center */
        {
            offset_y = (bbox_rect_p->height - str_height) >> 1;
        }

        offset_y += bbox_rect_p->offset_y;

        if (g_vdoply_osd_cntx.title.h_align == VIDEO_ALIGN_LEFT)
        {
            offset_x = 0;
        }
        else if (g_vdoply_osd_cntx.title.h_align == VIDEO_ALIGN_RIGHT)
        {
            offset_x = bbox_rect_p->width - str_width;
        }
        else
        {
            offset_x = (bbox_rect_p->width - str_width) >> 1;
        }

        offset_x += bbox_rect_p->offset_x;

 
        gdi_layer_push_and_set_active(g_vdoply_cntx.title_draw_layer);
        gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

        #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.title_draw_layer);
        #endif

        /* short file name need covert from BIG5 to unicode */
        if (g_vdoply_cntx.is_short_filename == MMI_TRUE)
        {
            mmi_chset_mixed_text_to_ucs2_str(
                (U8*) buf_filename_dest,
                sizeof(buf_filename_dest),
                (U8*) buf_filename,
                (mmi_chset_enum)(PhnsetGetDefEncodingType()));

            mmi_vdoply_draw_style_text(
                buf_filename_dest, 
                offset_x - layer_offset_x, 
                offset_y - layer_offset_y, 
                bbox_rect_p->width,
                &g_vdoply_osd_cntx.title.style_text);
        }
        else
        {
            mmi_vdoply_draw_style_text(
                buf_filename, 
                offset_x - layer_offset_x,
                offset_y - layer_offset_y,
                bbox_rect_p->width,
                &g_vdoply_osd_cntx.title.style_text);
        }
        #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
        #endif
        gdi_layer_pop_and_restore_active();
    } 

#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR,
        g_vdoply_cntx.title_draw_layer);
    gdi_layer_push_and_set_active(g_vdoply_cntx.status_bar_layer_handle);
    wgui_status_icon_bar_show_horizontal_bar();  
    gdi_layer_pop_and_restore_active();
#endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_state
 * DESCRIPTION
 *  draw panel's state icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_state(void)
{
#ifndef __MMI_FTE_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_offset_x;
    S32 layer_offset_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_FULLSCREEN__

    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscreen_draw_layer);    
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.fullscreen.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.fullscreen.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN_DIS));        
    }
    else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.fullscreen.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.fullscreen.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN_SEL));
    }
    else
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.fullscreen.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.fullscreen.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN));
    }
    
    gdi_layer_pop_and_restore_active();    
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

#ifdef __VDOPLY_FEATURE_SNAPSHOT__

    gdi_layer_push_and_set_active(g_vdoply_cntx.snapshot_draw_layer);  
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.snapshot.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.snapshot.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_SNAPSHOT_DIS));        
    }
    else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.snapshot.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.snapshot.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_SNAPSHOT_SEL));
    }
    else
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.snapshot.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.snapshot.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_TOUCH_OSD_SNAPSHOT));
    }

    gdi_layer_pop_and_restore_active();                
#endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_progress
 * DESCRIPTION
 *  draw panel's progress bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_progress(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_x;
    S32 offset_y;
    S32 layer_offset_x;
    S32 layer_offset_y;
    #ifdef __MMI_FTE_SUPPORT__
    S32 width, height;
    #endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_vdoply_calc_progress_ratio();
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.cur_status.play_ratio);

    gdi_layer_push_and_set_active(g_vdoply_cntx.progress_draw_layer);     
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

#ifndef __MMI_FTE_SUPPORT__
    if (g_vdoply_cntx.is_progress_seekable == MMI_FALSE)
    {
            /* can not seek, we will show disable progress bar */   
	#ifdef __MMI_VIDEO_PDL__
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_DIS));
	#endif

        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_INC_DIS);

        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_DEC_DIS);

        gdi_layer_pop_and_restore_active();

        return;
    }
#endif

    /* draw empty first */
    #ifdef __MMI_FTE_SUPPORT__
        gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_PROGRESS_FILL, &width, &height);
        
        gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.progress_draw_layer);

        gdi_layer_push_and_set_clip(
            g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x + width,
            g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y + height);
        gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
        gdi_layer_pop_clip();
    #endif

    gdi_image_draw_id(
        g_vdoply_osd_cntx.panel.progress_empty.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.panel.progress_empty.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_EMPTY));

    #ifdef __MMI_FTE_SUPPORT__
        gdi_pop_and_restore_alpha_blending_source_layer();
    #endif

#ifdef __MMI_VIDEO_PDL__
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
        if (g_vdoply_cntx.cur_status.buff_ratio != 0)
        {
            /* draw inside filling */
            offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x,
            offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y,

            gdi_layer_set_clip(
                offset_x,
                offset_y,
                offset_x + g_vdoply_cntx.cur_status.buff_ratio,
                offset_y + g_vdoply_cntx.progress.fill_height);

        #ifdef __MMI_FTE_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.progress_draw_layer);
            gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
        #endif

            gdi_image_draw_id(
                offset_x,
                offset_y,
                (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_BUFFER));

        #ifdef __MMI_FTE_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
        #endif

            gdi_layer_reset_clip();  
        }
    }
#endif /* __MMI_VIDEO_PDL__ */

    if (g_vdoply_cntx.cur_status.play_ratio != 0)
    {
        /* draw inside filling */
        offset_x = g_vdoply_osd_cntx.panel.progress_fill.offset_x - layer_offset_x;
        offset_y = g_vdoply_osd_cntx.panel.progress_fill.offset_y - layer_offset_y;

        gdi_layer_set_clip(
            offset_x,
            offset_y,
            offset_x + g_vdoply_cntx.cur_status.play_ratio,
            offset_y + g_vdoply_cntx.progress.fill_height);

    #ifdef __MMI_FTE_SUPPORT__
        gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.progress_draw_layer);
        gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
    #endif

        gdi_image_draw_id(
            offset_x,
            offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_PROGRESS_FILL));
            
        #ifdef __MMI_FTE_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
        #endif

        gdi_layer_reset_clip();            
    }


    #ifdef __MMI_FTE_SUPPORT__
        gdi_image_get_dimension_id(IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_INC_DIS, &width, &height);
        
        gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.progress_draw_layer);

        gdi_layer_push_and_set_clip(
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x + width,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y + height);
        gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
        gdi_layer_pop_clip();
    #endif

    /* progress inc */
    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_INC_DIS);
    }
    else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_INC_SEL);
    }
    else
    {

        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_INC);
    }

    #ifdef __MMI_FTE_SUPPORT__
        gdi_pop_and_restore_alpha_blending_source_layer();
    #endif

    /* progress dec */
#ifdef __MMI_FTE_SUPPORT__
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_DEC_DIS, &width, &height);

    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.progress_draw_layer);

    gdi_layer_push_and_set_clip(
        g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y,
        g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x + width,
        g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y + height);
    gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
    gdi_layer_pop_clip();
#endif

    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_DEC_DIS);
    }    
    else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_DEC_SEL);
    }
    else
    {

        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.progress_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.progress_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_PROGRESS_DEC);
    }

#ifdef __MMI_FTE_SUPPORT__
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_timer
 * DESCRIPTION
 *  draw panel's timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_timer(void)
{
#ifndef __VDOPLY_FEATURE_HIDE_TIMER__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time;
    S32 hour;
    S32 hour_remain;
    S32 min;
    S32 sec;
    S32 layer_offset_x;
    S32 layer_offset_y;
    #ifdef __MMI_FTE_SUPPORT__
    S32 width, height;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
    {
        g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.cur_status.play_time;
    }

    time = (U32) ((g_vdoply_cntx.cur_status.play_time + 500) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    gdi_layer_push_and_set_active(g_vdoply_cntx.timer_draw_layer);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

#ifdef __MMI_FTE_SUPPORT__
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &width, &height);

    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.timer_draw_layer);

    gdi_layer_push_and_set_clip(
        g_vdoply_cntx.timer.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        g_vdoply_cntx.timer2.sec_1_offset_x - layer_offset_x + width,
        g_vdoply_cntx.timer.offset_y - layer_offset_y + height);
    gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
    gdi_layer_pop_clip();
#endif

    /* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));


#ifdef __MMI_FTE_SUPPORT__

    gdi_image_draw_id(
        g_vdoply_cntx.bias_pos - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_BIAS));


    time = (U32) ( ( g_vdoply_cntx.cur_status.max_play_time +500 ) / 1000);

    hour = time / 3600;
    hour_remain = time % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60;

    if (hour > 99)
    {
        hour = 99;
    }

    /* hr */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.hr_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) hour % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* min */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.min_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) min % 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.col_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_COL));

    /* sec */
    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_0_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec / 10));

    gdi_image_draw_id(
        g_vdoply_cntx.timer2.sec_1_offset_x - layer_offset_x,
        g_vdoply_cntx.timer.offset_y - layer_offset_y,
        (U16) (IMG_ID_VDOPLY_OSD_TIMER_0 + (U16) sec % 10));
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif

    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_HIDE_TIMER__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_ctrl_button
 * DESCRIPTION
 *  draw panel's timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_ctrl_button(void)
{
#ifdef __MMI_FTE_SUPPORT__
    S32 lsk_offset_x;
    S32 lsk_offset_y;
    S32 rsk_offset_x;
    S32 rsk_offset_y;
    S32 ck_offset_x;
    S32 ck_offset_y;
    S32 img_width;
    S32 img_height;
    S32 layer_offset_x;
    S32 layer_offset_y;    
    U16 image_id;
#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    vdoply_ui_touch_struct *touch_p;
#endif 

    if (g_vdoply_cntx.play_img_id != 0)
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_PAUSE)
        {
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable)
            {
                image_id = g_vdoply_cntx.play_img_id + 2;       
            }                 
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press)
            {
                image_id = g_vdoply_cntx.play_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.play_img_id;
            }
        }
        else
        {
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable)
            {
                image_id = g_vdoply_cntx.play_img_id + 2;       
            }                 
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press)
            {
                image_id = g_vdoply_cntx.play_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.play_img_id;
            }
        }

        gdi_image_get_dimension_id(image_id, &img_width, &img_height);

        lsk_offset_x = g_vdoply_osd_cntx.panel.play.offset_x;
        lsk_offset_y = g_vdoply_osd_cntx.panel.play.offset_y;

        gdi_layer_push_and_set_active(g_vdoply_cntx.play_draw_layer);
        gdi_layer_get_position(&layer_offset_x, &layer_offset_y); 

        gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.play_draw_layer);

        gdi_layer_push_and_set_clip(
            lsk_offset_x - layer_offset_x,
            lsk_offset_y - layer_offset_y,
            lsk_offset_x - layer_offset_x + img_width,
            lsk_offset_y - layer_offset_y + img_height);
        gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
        gdi_layer_pop_clip();

        gdi_image_draw_id(
            lsk_offset_x - layer_offset_x, 
            lsk_offset_y - layer_offset_y, 
            image_id);

        gdi_pop_and_restore_alpha_blending_source_layer();

        gdi_layer_pop_and_restore_active();
#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
        /* remain these code if design change */
        touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY];
        touch_p->offset_x = lsk_offset_x;
        touch_p->offset_y = lsk_offset_y;
        touch_p->width = img_width;
        touch_p->height = img_height;
#endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
    }

    if (g_vdoply_cntx.stop_img_id != 0)
    {
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable)
        {
            image_id = g_vdoply_cntx.stop_img_id + 2;       
        }                 
        else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press)
        {
            image_id = g_vdoply_cntx.stop_img_id + 1;
        }
        else
        {
            image_id = g_vdoply_cntx.stop_img_id;
        }

        gdi_image_get_dimension_id(image_id, &img_width, &img_height);

        lsk_offset_x = g_vdoply_osd_cntx.panel.stop.offset_x;
        lsk_offset_y = g_vdoply_osd_cntx.panel.stop.offset_y;

        gdi_layer_push_and_set_active(g_vdoply_cntx.stop_draw_layer);
        gdi_layer_get_position(&layer_offset_x, &layer_offset_y); 

        gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.stop_draw_layer);

        gdi_layer_push_and_set_clip(
            lsk_offset_x - layer_offset_x,
            lsk_offset_y - layer_offset_y,
            lsk_offset_x - layer_offset_x + img_width,
            lsk_offset_y - layer_offset_y + img_height);
        gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
        gdi_layer_pop_clip();

        gdi_image_draw_id(
            lsk_offset_x - layer_offset_x, 
            lsk_offset_y - layer_offset_y, 
            image_id);

        gdi_pop_and_restore_alpha_blending_source_layer();

        gdi_layer_pop_and_restore_active();
#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
        /* remain these code if design change */
        touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP];
        touch_p->offset_x = lsk_offset_x;
        touch_p->offset_y = lsk_offset_y;
        touch_p->width = img_width;
        touch_p->height = img_height;
#endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_speed
 * DESCRIPTION
 *  draw panel's speed icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_speed(void)
{
#ifndef __MMI_FTE_SUPPORT__
#ifdef __VDOPLY_FEATURE_SPEED__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_offset_x;
    S32 layer_offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gdi_layer_push_and_set_active(g_vdoply_cntx.speed_draw_layer);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    gdi_image_draw_id(
        g_vdoply_osd_cntx.panel.speed.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.panel.speed.offset_y - layer_offset_y,
        mmi_vdoply_get_speed_image());

    if(!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.speed_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.speed_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_SPEED_INC_DIS);
            
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.speed_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.speed_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_SPEED_DEC_DIS);        

        gdi_layer_pop_and_restore_active();
        return;
    }

    /* speed inc */
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.speed_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.speed_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_SPEED_INC_SEL);
    }
    else
    {

        if (g_vdoply_cntx.cur_status.speed < VDOPLY_FEATURE_SPEED_COUNT - 1)
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.speed_inc.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.speed_inc.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_SPEED_INC);

        }
        else
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.speed_inc.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.speed_inc.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_SPEED_INC_DIS);

        }
    }

    /* speed dec */
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.speed_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.speed_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_SPEED_DEC_SEL);
    }
    else
    {
        if (g_vdoply_cntx.cur_status.speed > 0)
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.speed_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.speed_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_SPEED_DEC);
        }
        else
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.speed_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.speed_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_SPEED_DEC_DIS);
        }
    }

    gdi_layer_pop_and_restore_active();
#endif /* __VDOPLY_FEATURE_SPEED__ */ 
#endif
}


#ifdef MMI_VDOPLY_3D_ANAGLYPH
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_3d_button
 * DESCRIPTION
 *  draw control button by index(draw detail)
 * PARAMETERS
 *  idx    [IN] button index, see mmi_vdoply_pannel_icon_enum
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_mode(void)
{
#ifdef __MMI_FTE_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 layer_offset_x, layer_offset_y;
	S32 offset_x,offset_y;
	U16 image_id;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) == MMI_FALSE)
    {
        return;
    }
    
	gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
	gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.volume_draw_layer);
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
        offset_x = g_vdoply_osd_cntx.panel.mode.offset_x;
	offset_y = g_vdoply_osd_cntx.panel.mode.offset_y;

     if ( g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_3D || VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_FALSE)
    {
        if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press)
        {
            image_id = IMG_ID_VDOPLY_TOUCH_OSD_3D_ON_SEL;
        }
        else
        {
            image_id = IMG_ID_VDOPLY_TOUCH_OSD_3D_ON;
        }
    }
    else
    {
        if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press)
        {
            image_id = IMG_ID_VDOPLY_TOUCH_OSD_3D_OFF_SEL;
        }
        else
        {
            image_id = IMG_ID_VDOPLY_TOUCH_OSD_3D_OFF;
        }
    }
	
    gdi_image_draw_id(
        offset_x - layer_offset_x, 
        offset_y - layer_offset_y, 
        image_id);

    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
#endif
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel_volume
 * DESCRIPTION
 *  draw panel's volumn icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel_volume(void)
{
#ifdef __VDOPLY_FEATURE_VOLUME__
#ifdef __MMI_FTE_SUPPORT__
    S32 layer_offset_x;
    S32 layer_offset_y;
    S32 clip_x1, clip_y1, clip_x2, clip_y2;
    S32 volumn_width, volumn_height;
    U16 volumn_draw_width;
    S32 speaker_width, speaker_height;

    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    /*clear background*/
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_VOLUME_BG, &volumn_width, &volumn_height);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_VOLUME_SPEAKER_ON, &speaker_width, &speaker_height);
    if (volumn_height < speaker_height)
    {
        volumn_height = speaker_height;
    }
    gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.volume_draw_layer);
    clip_x1 = g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x;
    clip_y1 = g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y;
    clip_x2 = g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x + 
        (g_vdoply_osd_cntx.panel.volume.offset_x + volumn_width - g_vdoply_osd_cntx.panel.volume_dec.offset_x);
    clip_y2 = g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y + volumn_height;
    gdi_layer_push_and_set_clip(
        clip_x1,
        clip_y1,
        clip_x2,
        clip_y2);
    gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
    gdi_layer_pop_clip();

    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_OSD_VOLUME_SPEAKER_OFF);

		gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_VOLUME_BG));
    }
    else
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_VOLUME_SPEAKER_ON));

    
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_VOLUME_BG));
    
    
        volumn_draw_width = (( g_vdoply_cntx.cur_status.volume + 1 ) * volumn_width) / (VDOPLY_VOL_16 + 1);
        gdi_layer_push_and_set_clip(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            g_vdoply_osd_cntx.panel.volume.offset_x + volumn_draw_width - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y + volumn_height - layer_offset_y);
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_VOLUME_FG));
        gdi_layer_pop_clip();
	}
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_offset_x;
    S32 layer_offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_vdoply_cntx.volume_draw_layer);
    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_OSD_VOLUME_MUTE);
    }
    else
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume.offset_y - layer_offset_y,
            (U16) (IMG_ID_VDOPLY_OSD_VOLUME_1 + g_vdoply_cntx.cur_status.volume));

    }

    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_INC_DIS);

        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC_DIS);

        gdi_layer_pop_and_restore_active();
        return;
    } 
    
    /* vol inc */
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_inc.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_inc.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_INC_SEL);
    }
    else
    {
        if (g_vdoply_cntx.cur_status.volume < VDOPLY_VOL_16)
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_inc.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_inc.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_INC);
        }
        else
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_inc.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_inc.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_INC_DIS);
        }
    }

    /* vol dec */
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_press)
    {
        gdi_image_draw_id(
            g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
            g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
            IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC_SEL);
    }
    else
    {

    #ifdef __VDOPLY_FEATURE_VOLUME_MUTE__
        if (g_vdoply_cntx.is_mute == MMI_FALSE)
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC);
        }
        else
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC_DIS);
        }
    #else /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 
        if (g_vdoply_cntx.cur_status.volume > VDOPLY_VOL_1)
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC);
        }
        else
        {
            gdi_image_draw_id(
                g_vdoply_osd_cntx.panel.volume_dec.offset_x - layer_offset_x,
                g_vdoply_osd_cntx.panel.volume_dec.offset_y - layer_offset_y,
                IMG_ID_VDOPLY_TOUCH_OSD_VOLUME_DEC_DIS);
        }
    #endif /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 

    }

    gdi_layer_pop_and_restore_active();
#endif
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_softkey
 * DESCRIPTION
 *  draw panel's buttom bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_softkey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 lsk_offset_x;
    S32 lsk_offset_y;
    S32 rsk_offset_x;
    S32 rsk_offset_y;
    S32 ck_offset_x;
    S32 ck_offset_y;
    S32 str_width;
    S32 str_height;
    S32 img_width;
    S32 img_height;
    S32 layer_offset_x;
    S32 layer_offset_y;    
    U16 image_id;
    S32 truncated_w;
    mmi_frm_screen_rotate_enum rotate;


#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    vdoply_ui_touch_struct *touch_p;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_BUTTON));

    gdi_layer_push_and_set_active(g_vdoply_cntx.lsk_draw_layer);

    gdi_layer_get_position(&layer_offset_x, &layer_offset_y);

    /* horizontal do not need draw buttom bar background */
#ifndef __MMI_FTE_SUPPORT__
    gdi_image_draw_id(
        g_vdoply_osd_cntx.softkey.rect.offset_x - layer_offset_x,
        g_vdoply_osd_cntx.softkey.rect.offset_y - layer_offset_y,
        IMG_ID_VDOPLY_OSD_BUTTOM_BAR_BG);
#endif

    gdi_layer_pop_and_restore_active();

rotate = MMI_FRM_SCREEN_ROTATE_0;
#ifdef __MMI_SCREEN_ROTATE__
    #ifdef __MMI_VIDEO_PLY_USE_IDP_ROTATE__
    if ( g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        rotate = MMI_FRM_SCREEN_ROTATE_270;
    }
    #else
    rotate = mmi_frm_get_screen_rotate();
    #endif
#endif /* __MMI_SCREEN_ROTATE__ */
    
    

    if (g_vdoply_osd_cntx.softkey.is_lsk_icon == FALSE)
    {
        /* lsk string */
        if (g_vdoply_cntx.lsk_str_ptr != NULL)
        {

            wgui_softkey_get_offset(
                (UI_string_type)g_vdoply_cntx.lsk_str_ptr, 
                &lsk_offset_x, 
                &lsk_offset_y, 
                &truncated_w, 
                MMI_LEFT_SOFTKEY,
                rotate);
            gui_measure_string((UI_string_type)g_vdoply_cntx.lsk_str_ptr, &str_width, &str_height);

            /* TRICKY, shift back from R to L MMI */
            if (mmi_fe_get_r2l_state())
            {
                lsk_offset_x -= str_width;
            }

            if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press)
            {
                lsk_offset_x++;
                lsk_offset_y++;
            }

            gdi_layer_push_and_set_active(g_vdoply_cntx.lsk_draw_layer);
            gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
            #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.lsk_draw_layer);
            #endif

            mmi_vdoply_draw_style_text(
                g_vdoply_cntx.lsk_str_ptr,
                lsk_offset_x - layer_offset_x,
                lsk_offset_y - layer_offset_y,
                truncated_w,
                &g_vdoply_osd_cntx.softkey.lsk_text);
            #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
            #endif
            gdi_layer_pop_and_restore_active();

        #ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
            touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK];
            touch_p->offset_x = lsk_offset_x;
            touch_p->offset_y = lsk_offset_y;
            touch_p->width = truncated_w > str_width? str_width : truncated_w;
            touch_p->height = str_height;
        #endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 

        }
    }
    else
    {
        /* lsk */
        if (g_vdoply_cntx.lsk_img_id != 0)
        {
#ifdef __MMI_FTE_SUPPORT__
            if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press)
            {
                image_id = g_vdoply_cntx.lsk_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.lsk_img_id;
            }
#else
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable)
            {
                image_id = g_vdoply_cntx.lsk_img_id + 2;       
            }                 
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press)
            {
                image_id = g_vdoply_cntx.lsk_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.lsk_img_id;
            }
#endif

            gdi_image_get_dimension_id(image_id, &img_width, &img_height);

            lsk_offset_x = g_vdoply_osd_cntx.softkey.icon_lsk_pos.offset_x;
            lsk_offset_y = g_vdoply_osd_cntx.softkey.icon_lsk_pos.offset_y;

            gdi_layer_push_and_set_active(g_vdoply_cntx.lsk_draw_layer);
            gdi_layer_get_position(&layer_offset_x, &layer_offset_y); 
 
#ifdef __MMI_FTE_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.lsk_draw_layer);
            
            gdi_layer_push_and_set_clip(
                lsk_offset_x - layer_offset_x,
                lsk_offset_y - layer_offset_y,
                lsk_offset_x - layer_offset_x + img_width,
                lsk_offset_y - layer_offset_y + img_height);
            gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
            gdi_layer_pop_clip();
#endif
            gdi_image_draw_id(
                lsk_offset_x - layer_offset_x, 
                lsk_offset_y - layer_offset_y, 
                image_id);
#ifdef __MMI_FTE_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
#endif
            gdi_layer_pop_and_restore_active();
        #ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
            /* remain these code if design change */
            touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK];
            touch_p->offset_x = lsk_offset_x;
            touch_p->offset_y = lsk_offset_y;
            touch_p->width = img_width;
            touch_p->height = img_height;
        #endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
        }

    }

    if (g_vdoply_osd_cntx.softkey.is_rsk_icon == FALSE)
    {
        /* rsk string */
        if (g_vdoply_cntx.rsk_str_ptr != NULL)
        {
            wgui_softkey_get_offset(
                (UI_string_type)g_vdoply_cntx.rsk_str_ptr, 
                &rsk_offset_x, 
                &rsk_offset_y, 
                &truncated_w, 
                MMI_RIGHT_SOFTKEY,
                rotate);
            gui_measure_string((UI_string_type) g_vdoply_cntx.rsk_str_ptr, &str_width, &str_height);

            /* TRICKY, shift back from R to L MMI */
            if (mmi_fe_get_r2l_state())
            {
                rsk_offset_x -= (str_width + 1);
            }

            if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press)
            {
                rsk_offset_x++;
                rsk_offset_y++;
            }

            gdi_layer_push_and_set_active(g_vdoply_cntx.rsk_draw_layer);
            gdi_layer_get_position(&layer_offset_x, &layer_offset_y); 
            #ifdef __MMI_VECTOR_FONT_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.rsk_draw_layer);
            #endif
            mmi_vdoply_draw_style_text(
                g_vdoply_cntx.rsk_str_ptr,
                rsk_offset_x - layer_offset_x,
                rsk_offset_y - layer_offset_y,
                truncated_w,
                &g_vdoply_osd_cntx.softkey.lsk_text);
            #ifdef __MMI_VECTOR_FONT_SUPPORT__
    		gdi_pop_and_restore_alpha_blending_source_layer();
			#endif
            gdi_layer_pop_and_restore_active();
          
        #ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
            touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK];
            touch_p->offset_x = rsk_offset_x;
            touch_p->offset_y = rsk_offset_y;
            touch_p->width = truncated_w > str_width? str_width : truncated_w;
            touch_p->height = str_height;
        #endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 

        }
    }
    else
    {
        /* rsk */
        if (g_vdoply_cntx.rsk_img_id != 0)
        {
#ifdef __MMI_FTE_SUPPORT__
            if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press)
            {
                image_id = g_vdoply_cntx.rsk_img_id + 1;
            }
            else
            {
               image_id = g_vdoply_cntx.rsk_img_id;
            }
#else
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable)
            {
                image_id = g_vdoply_cntx.rsk_img_id + 2;       
            }            
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press)
            {
                image_id = g_vdoply_cntx.rsk_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.rsk_img_id;
            }
#endif

            gdi_image_get_dimension_id(image_id, &img_width, &img_height);

            rsk_offset_x = g_vdoply_osd_cntx.softkey.icon_rsk_pos.offset_x;
            rsk_offset_y = g_vdoply_osd_cntx.softkey.icon_rsk_pos.offset_y;

            gdi_layer_push_and_set_active(g_vdoply_cntx.rsk_draw_layer);
            gdi_layer_get_position(&layer_offset_x, &layer_offset_y);             
#ifdef __MMI_FTE_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.lsk_draw_layer);
            
            gdi_layer_push_and_set_clip(
                rsk_offset_x - layer_offset_x,
                rsk_offset_y - layer_offset_y,
                rsk_offset_x - layer_offset_x + img_width,
                rsk_offset_y - layer_offset_y + img_height);
            gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
            gdi_layer_pop_clip();
#endif          
            gdi_image_draw_id(
                rsk_offset_x - layer_offset_x, 
                rsk_offset_y - layer_offset_y,
                image_id);
#ifdef __MMI_FTE_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
#endif
            gdi_layer_pop_and_restore_active();

        #ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
            touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK];
            touch_p->offset_x = rsk_offset_x;
            touch_p->offset_y = rsk_offset_y;
            touch_p->width = img_width;
            touch_p->height = img_height;
        #endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
        }
    }
	
    if (g_vdoply_osd_cntx.softkey.is_ck_icon)
    {

        /* draw c key */
        if (g_vdoply_cntx.ck_img_id != 0)
        {
#ifdef __MMI_FTE_SUPPORT__
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable)
            {
                image_id = g_vdoply_cntx.ck_img_id + 2;
            }
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press)
            {
                image_id = g_vdoply_cntx.ck_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.ck_img_id;
            }
#else
            if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable)
            {
                image_id = g_vdoply_cntx.ck_img_id + 2;       
            }
            else if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press)
            {
                image_id = g_vdoply_cntx.ck_img_id + 1;
            }
            else
            {
                image_id = g_vdoply_cntx.ck_img_id;
            }
#endif

            gdi_image_get_dimension_id(image_id, &img_width, &img_height);

            ck_offset_x = g_vdoply_osd_cntx.softkey.icon_ck_pos.offset_x;
            ck_offset_y = g_vdoply_osd_cntx.softkey.icon_ck_pos.offset_y;

            gdi_layer_push_and_set_active(g_vdoply_cntx.ck_draw_layer);
            gdi_layer_get_position(&layer_offset_x, &layer_offset_y);  
            
#ifdef __MMI_FTE_SUPPORT__
            gdi_push_and_set_alpha_blending_source_layer(g_vdoply_cntx.lsk_draw_layer);
            
            gdi_layer_push_and_set_clip(
                ck_offset_x - layer_offset_x,
                ck_offset_y - layer_offset_y,
                ck_offset_x - layer_offset_x + img_width,
                ck_offset_y - layer_offset_y + img_height);
            gdi_image_draw_id(-layer_offset_x, -layer_offset_y, IMG_ID_VDOPLY_OSD_BG);
            gdi_layer_pop_clip();
#endif    
            gdi_image_draw_id(
                ck_offset_x - layer_offset_x, 
                ck_offset_y - layer_offset_y,
                image_id);
#ifdef __MMI_FTE_SUPPORT__
            gdi_pop_and_restore_alpha_blending_source_layer();
#endif
            gdi_layer_pop_and_restore_active();

        #ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
            touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK];
            touch_p->offset_x = ck_offset_x;
            touch_p->offset_y = ck_offset_y;
            touch_p->width = img_width;
            touch_p->height = img_height;
        #endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_panel
 * DESCRIPTION
 *  draw panel
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_panel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_draw_panel_volume();
    mmi_vdoply_draw_panel_timer();
    mmi_vdoply_draw_panel_progress();

#ifndef __MMI_FTE_SUPPORT__
	mmi_vdoply_draw_panel_speed();
    mmi_vdoply_draw_panel_state();
#endif /* __MMI_FTE_SUPPORT__ */
    mmi_vdoply_draw_panel_ctrl_button();

#ifdef MMI_VDOPLY_3D_ANAGLYPH
    mmi_vdoply_draw_panel_mode();
#endif

}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
    gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
    gdi_layer_get_dimension(&layer_width, &layer_height);
    gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);

    gdi_layer_clear(GDI_COLOR_BLACK);

    gdi_image_get_dimension_id(
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &image_width,
        &image_height);

    offset_x = (layer_width - image_width) >> 1;
    offset_y = (layer_height - image_height) >> 1;                    

    gdi_image_draw_animation_id(
        offset_x, 
        offset_y, 
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &g_vdoply_cntx.aud_only_anim);

    gdi_layer_pop_and_restore_active();   
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_play_region_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
    {
        gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
        gdi_layer_get_dimension(&layer_width, &layer_height);

        gdi_layer_clear(GDI_COLOR_BLACK);

        gdi_image_get_dimension_id(
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
            &image_width,
            &image_height);

        offset_x = (layer_width - image_width) >> 1;
        offset_y = (layer_height - image_height) >> 1;                    

        gdi_image_draw_id(
            offset_x, 
            offset_y, 
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM);

        gdi_layer_pop_and_restore_active();
    }
    else
    {
        gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_pop_and_restore_active();        
    }      
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (g_vdoply_cntx.aud_only_anim != GDI_NULL_HANDLE)
    {
        gdi_image_stop_animation(g_vdoply_cntx.aud_only_anim);
        g_vdoply_cntx.aud_only_anim = GDI_NULL_HANDLE;
    }
}


#ifdef __VDOPLY_FEATURE_FULLSCREEN__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_aud_only_anim
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
    gdi_layer_get_dimension(&layer_width, &layer_height);
    gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);

    gdi_layer_clear(GDI_COLOR_BLACK);

    gdi_image_get_dimension_id(
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &image_width,
        &image_height);

    offset_x = (layer_width - image_width) >> 1;
    offset_y = (layer_height - image_height) >> 1;                    

    gdi_image_draw_animation_id(
        offset_x, 
        offset_y, 
        IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
        &g_vdoply_cntx.aud_only_anim);

    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_play_region_bg
 * DESCRIPTION
 *  draw audio only animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_fullscr_play_region_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width, layer_height;
    S32 image_width, image_height;
    S32 offset_x, offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
    {    
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
        gdi_layer_get_dimension(&layer_width, &layer_height);

        gdi_layer_clear(GDI_COLOR_BLACK);

        gdi_image_get_dimension_id(
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM,
            &image_width,
            &image_height);

        offset_x = (layer_width - image_width) >> 1;
        offset_y = (layer_height - image_height) >> 1;                    

        gdi_image_draw_id(
            offset_x, 
            offset_y, 
            IMG_ID_VDOPLY_OSD_AUD_ONLY_ANIM);

        gdi_layer_pop_and_restore_active();
    }
    else
    {
        //gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
        //gdi_layer_clear(GDI_COLOR_BLACK);
        //gdi_layer_pop_and_restore_active();        
        mmi_vdoply_layer_clear(&g_vdoply_cntx.fullscr_play_layer_handle);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_aud_only_anim
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_fullscr_aud_only_anim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.aud_only_anim != GDI_NULL_HANDLE)
    {
        gdi_image_stop_animation(g_vdoply_cntx.aud_only_anim);
        g_vdoply_cntx.aud_only_anim = GDI_NULL_HANDLE;
    }
}

#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_animation
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_start_animation(U32 ani_id, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 offset_x;
	S32 offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.popup_anim != GDI_NULL_HANDLE)
    {
        mmi_vdoply_stop_animation();
    }
  
	if(is_full == MMI_TRUE)
	{
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	    offset_x = g_vdoply_fullscr_osd_cntx.loading.bg.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_fullscr_osd_cntx.loading.bg.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y; 
        gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);	
#endif
	}
	else
    {
	    offset_x = g_vdoply_osd_cntx.loading.bg.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_osd_cntx.loading.bg.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y; 
        gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);	
	}
       

    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    gdi_image_draw_animation_id(
        offset_x,
        offset_y,
        ani_id,
        &g_vdoply_cntx.popup_anim);

    gdi_layer_pop_and_restore_active();
        
}


#if defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_loading
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_loading(S32 percentage, MMI_BOOL draw_bg, MMI_BOOL is_full)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 draw_width;
    S32 offset_x;
    S32 offset_y; 
	S32 loading_offset_x;
	S32 loading_offset_y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(is_full == MMI_TRUE)
	{
	    offset_x = g_vdoply_fullscr_osd_cntx.loading.bg.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_fullscr_osd_cntx.loading.bg.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
		loading_offset_x = g_vdoply_fullscr_osd_cntx.loading.progress.offset_x - g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_fullscr_osd_cntx.loading.progress.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;
	}
	else
    {
	    offset_x = g_vdoply_osd_cntx.loading.bg.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
        offset_y = g_vdoply_osd_cntx.loading.bg.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
		loading_offset_x = g_vdoply_osd_cntx.loading.progress.offset_x - g_vdoply_osd_cntx.loading.rect.offset_x;
		loading_offset_y = g_vdoply_osd_cntx.loading.progress.offset_y - g_vdoply_osd_cntx.loading.rect.offset_y;
	} 
		
    gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
    if (draw_bg)
    {
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    
        gdi_image_draw_id(
            offset_x,
            offset_y,
            IMG_ID_VDOPLY_OSD_LOADING_BG);
    }

   
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_LOADING_EMPTY, &image_width, &image_height);

    /* draw empty loading bar */
    gdi_image_draw_id(
        loading_offset_x,
        loading_offset_y,
        IMG_ID_VDOPLY_OSD_LOADING_EMPTY);

    draw_width = image_width * percentage / 100;

    gdi_layer_set_clip(
        loading_offset_x,
        loading_offset_y,
        loading_offset_x + draw_width,
        loading_offset_y + image_height);

    gdi_image_draw_id(
        loading_offset_x,
        loading_offset_y,
        IMG_ID_VDOPLY_OSD_LOADING_FILL);
    


    gdi_layer_reset_clip();
    gdi_layer_pop_and_restore_active();

        
}
#endif /* defined(__MMI_VIDEO_STREAM__) || defined(__MMI_VIDEO_PDL__) */


#endif /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stop_anim
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stop_animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.popup_anim != GDI_NULL_HANDLE)
    {    
        gdi_image_stop_animation(g_vdoply_cntx.popup_anim);
        g_vdoply_cntx.popup_anim = GDI_NULL_HANDLE;  
    } 
}


#ifndef __VDOPLY_FEATURE_FTE20__  //remove warning
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_style_text
 * DESCRIPTION
 *  init panel's UI item
 * PARAMETERS
 *  offset_x        [IN]        Offset x
 *  offset_y        [IN]        Offset y
 *  truncate_width  [IN]        Tauncate width
 *  style_txt       [IN]        Text style
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_draw_style_text(CHAR* str, S32 offset_x, S32 offset_y, S32 truncate_width, video_style_text_struct *style_txt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_fe_get_r2l_state())
    {
        offset_x += (truncate_width < gui_get_string_width((UI_string_type) str)) ? truncate_width : gui_get_string_width((UI_string_type) str);
    }

    if (style_txt->style == VIDEO_TEXT_STYLE_BORDER)
    {
        if (truncate_width != 0)
        {        
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_set_text_border_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
            gui_print_truncated_borderd_text(offset_x, offset_y, truncate_width, (UI_string_type)str);
        }
        else
        {
            gui_move_text_cursor(offset_x, offset_y);
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_set_text_border_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
            gui_print_bordered_text((UI_string_type) str);
        }
    }
#ifndef MMI_VDOPLY_SUGGEST_CUT_FOR_SLIM_PROJECT
	else if (style_txt->style == VIDEO_TEXT_STYLE_NORMAL)
    {
        if (truncate_width != 0)
        {
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_print_truncated_text(offset_x, offset_y, truncate_width, (UI_string_type)str);
        }
        else
        {
            gui_move_text_cursor(offset_x, offset_y);
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_print_text((UI_string_type) str);
        }
    }
    else if (style_txt->style == VIDEO_TEXT_STYLE_SHADOW)
    {
        if (truncate_width != 0)
        {            
            gui_set_text_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
            gui_print_truncated_text(offset_x + 1, offset_y + 1, truncate_width, (UI_string_type)str);
            
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_print_truncated_text(offset_x, offset_y, truncate_width, (UI_string_type)str);
        }
        else
        {
            gui_move_text_cursor(offset_x + 1, offset_y + 1);
            gui_set_text_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
            gui_print_text((UI_string_type) str);

            gui_move_text_cursor(offset_x, offset_y);
            gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
            gui_print_text((UI_string_type) str);
        }
    }
#endif
    else
    {
        MMI_ASSERT(0);
    }

}
#endif

#ifdef __VDOPLY_FEATURE_FTE20__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_init_ui
 * DESCRIPTION
 *  init panel's UI item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_init_ui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 digit_width;
    S32 col_width;
    S32 height;
    PU8 buf_ptr;
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__    
    S32 layer_offset_x;
    S32 layer_offset_y;    
    S32 layer_width;
    S32 layer_height;
#endif 
    
    S32 load_buf_size;  
    video_rect_struct *rect_ptr;
    video_pos_struct *pos_ptr;
    
    vdoply_ui_touch_struct *touch_p; 

    mdi_util_create_hw_layer_intmemory_in_struct play_layer_in;
	mdi_util_create_hw_layer_extmemory_in_struct full_play_layer_in;

    mdi_util_create_hw_layer_out_struct play_layer_out;
	mdi_util_create_hw_layer_out_struct full_play_layer_out;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* bg */
    /* newer cip has layer bg color, we can split bg into smaller region for better performance */
    /* we will use base layer's buffer to create two smaller layer region */
    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);

    /* region 0 */
    rect_ptr = &g_vdoply_osd_cntx.bg.region_0;
    
    gdi_layer_create(
        rect_ptr->offset_x,
        rect_ptr->offset_y,
        rect_ptr->width,        
        rect_ptr->height,        
        &g_vdoply_cntx.bg_region_0_layer_handle);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_0_layer_handle);       
    gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

    /* region 1 */
    rect_ptr = &g_vdoply_osd_cntx.bg.region_1;    

    

    gdi_layer_create(
        rect_ptr->offset_x,
        rect_ptr->offset_y,
        rect_ptr->width,        
        rect_ptr->height,        
        &g_vdoply_cntx.bg_region_1_layer_handle);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_1_layer_handle);       
    gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);

    /* create loading layer */
    load_buf_size = g_vdoply_osd_cntx.loading.rect.width*g_vdoply_osd_cntx.loading.rect.height*VDOPLY_BUFFER_DEPTH;
#ifndef __MMI_SUPPORT_ASMV2__
	g_vdoply_cntx.load_buf_ptr = mmi_frm_scrmem_alloc_framebuffer(load_buf_size);   
#else
    g_vdoply_cntx.load_buf_ptr = mmi_frm_asm_alloc_nc_r(GRP_ID_VDOPLY_SINGLE_PLAYER, load_buf_size);
#endif  
    MMI_ASSERT(g_vdoply_cntx.load_buf_ptr != NULL);
    gdi_layer_create_using_outside_memory(
        g_vdoply_osd_cntx.loading.rect.offset_x,
        g_vdoply_osd_cntx.loading.rect.offset_y,                
        g_vdoply_osd_cntx.loading.rect.width,                 
        g_vdoply_osd_cntx.loading.rect.height,                                 
        &g_vdoply_cntx.process_layer_handle,   
        (PU8)g_vdoply_cntx.load_buf_ptr,
        (S32)load_buf_size);

    gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

#ifdef __VDOPLY_FEATURE_FULLSCREEN__

#if !defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
    /* if MT6238 series, we need use IDP rotate, to rotate the process layer vertically */

    layer_offset_y = 
        UI_device_width - 
        g_vdoply_fullscr_osd_cntx.loading.rect.offset_y - 
        g_vdoply_fullscr_osd_cntx.loading.rect.height;

    layer_offset_x = g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;

    layer_width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
    layer_height = g_vdoply_fullscr_osd_cntx.loading.rect.height;    
   
#else /* defined(MDI_VIDEO_MT6238_SERIES) && defined(GDI_USING_2D_ENGINE_V3) */
    /* chipset other than MT6238 series */
    layer_offset_x = g_vdoply_fullscr_osd_cntx.loading.rect.offset_x;
    layer_offset_y = g_vdoply_fullscr_osd_cntx.loading.rect.offset_y;    

    layer_width = g_vdoply_fullscr_osd_cntx.loading.rect.width;
    layer_height = g_vdoply_fullscr_osd_cntx.loading.rect.height;  
#endif /* defined(MDI_VIDEO_MT6238_SERIES) && defined(GDI_USING_2D_ENGINE_V3) */

    /* create fullscr loading layer */
    gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
    gdi_layer_get_buffer_ptr(&buf_ptr);
    gdi_layer_create_using_outside_memory(
        layer_offset_x,
        layer_offset_y,                
        layer_width,                 
        layer_height,         
        &g_vdoply_cntx.fullscr_process_layer_handle,   
        (PU8)buf_ptr,
        (S32)g_vdoply_osd_cntx.loading.rect.width * g_vdoply_osd_cntx.loading.rect.height * (gdi_layer_get_bit_per_pixel() >> 3));
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();


#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */

    /* create play wnd buffer */
    MMI_ASSERT(g_vdoply_cntx.vdo_frame_buf_ptr == NULL);
	
    play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	play_layer_in.width = g_vdoply_osd_cntx.play_wnd.rect.width;
	play_layer_in.height = g_vdoply_osd_cntx.play_wnd.rect.height;
	play_layer_in.offset_x = 0;
	play_layer_in.offset_y = 0;
    g_vdoply_cntx.play_wnd_layer_handle = mdi_util_hw_layer_create_with_intmemory(&play_layer_in, &play_layer_out);

	gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);

    gdi_layer_set_position(
        g_vdoply_osd_cntx.play_wnd.rect.offset_x, 
        g_vdoply_osd_cntx.play_wnd.rect.offset_y);
    gdi_layer_set_background(MMI_VDOPLY_BG_COLOR);
    gdi_layer_clear(MMI_VDOPLY_BG_COLOR);
    gdi_layer_pop_and_restore_active();

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    /* create full screen layer using base layer's buffer */
    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_layer_handle);
    gdi_layer_get_buffer_ptr(&buf_ptr);
    gdi_layer_pop_and_restore_active();

#if defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
    full_play_layer_in.buffer = (PU8)buf_ptr;
	full_play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    full_play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	full_play_layer_in.width = UI_device_width;
	full_play_layer_in.height = UI_device_height;
	full_play_layer_in.offset_x = 0;
	full_play_layer_in.offset_y = 0;
    g_vdoply_cntx.fullscr_play_layer_handle = mdi_util_hw_layer_create_with_extmemory(&full_play_layer_in, &full_play_layer_out);
#else
    full_play_layer_in.buffer = (PU8)buf_ptr;
	full_play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    full_play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	full_play_layer_in.width = UI_device_height;
	full_play_layer_in.height = UI_device_width;
	full_play_layer_in.offset_x = 0;
	full_play_layer_in.offset_y = 0;
    g_vdoply_cntx.fullscr_play_layer_handle = mdi_util_hw_layer_create_with_extmemory(&full_play_layer_in, &full_play_layer_out);
#endif
    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
	gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    

#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__

    g_vdoply_cntx.status_bar_layer_handle = g_vdoply_cntx.bg_region_0_layer_handle;

    g_vdoply_cntx.prev_status_bar_layer_handle = 
        wgui_status_icon_bar_get_target_layer(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_status_icon_bar_set_target_layer(
        WGUI_STATUS_ICON_BAR_H_BAR,
        g_vdoply_cntx.status_bar_layer_handle);
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        mmi_vdoply_redraw_status_bar_background_hdlr);
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_set_wallpaper_on_bottom(MMI_TRUE);

#else /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */
    g_vdoply_cntx.status_bar_layer_handle = GDI_LAYER_EMPTY_HANDLE;
#endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */


    g_vdoply_cntx.volume_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.progress_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.fullscreen_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.rsk_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.lsk_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.ck_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle; 
    g_vdoply_cntx.title_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.timer_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.play_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;
    g_vdoply_cntx.stop_draw_layer = g_vdoply_cntx.bg_region_1_layer_handle;

/* timer */
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_COL, &col_width, &height);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &digit_width, &height);


    pos_ptr = &g_vdoply_osd_cntx.panel.play_time;
    
    g_vdoply_cntx.timer.offset_y = pos_ptr->offset_y;

    g_vdoply_cntx.timer.hr_0_offset_x = pos_ptr->offset_x;
    g_vdoply_cntx.timer.hr_1_offset_x = g_vdoply_cntx.timer.hr_0_offset_x + digit_width ;
    g_vdoply_cntx.timer.col_0_offset_x = g_vdoply_cntx.timer.hr_1_offset_x + digit_width ;
    g_vdoply_cntx.timer.min_0_offset_x = g_vdoply_cntx.timer.col_0_offset_x + col_width ;
    g_vdoply_cntx.timer.min_1_offset_x = g_vdoply_cntx.timer.min_0_offset_x + digit_width ;
    g_vdoply_cntx.timer.col_1_offset_x = g_vdoply_cntx.timer.min_1_offset_x + digit_width ;
    g_vdoply_cntx.timer.sec_0_offset_x = g_vdoply_cntx.timer.col_1_offset_x + col_width ;
    g_vdoply_cntx.timer.sec_1_offset_x = g_vdoply_cntx.timer.sec_0_offset_x + digit_width ;

    pos_ptr = &g_vdoply_osd_cntx.panel.duration;
    
    g_vdoply_cntx.timer2.offset_y = pos_ptr->offset_y;

	g_vdoply_cntx.timer2.sec_1_offset_x = pos_ptr->offset_x - digit_width;
	g_vdoply_cntx.timer2.sec_0_offset_x = g_vdoply_cntx.timer2.sec_1_offset_x - digit_width ;
	g_vdoply_cntx.timer2.col_1_offset_x = g_vdoply_cntx.timer2.sec_0_offset_x - col_width ;
	g_vdoply_cntx.timer2.min_1_offset_x = g_vdoply_cntx.timer2.col_1_offset_x - digit_width ;
	g_vdoply_cntx.timer2.min_0_offset_x = g_vdoply_cntx.timer2.min_1_offset_x - digit_width;
	g_vdoply_cntx.timer2.col_0_offset_x = g_vdoply_cntx.timer2.min_0_offset_x - col_width ;
	g_vdoply_cntx.timer2.hr_1_offset_x = g_vdoply_cntx.timer2.col_0_offset_x - digit_width ;
	g_vdoply_cntx.timer2.hr_0_offset_x = g_vdoply_cntx.timer2.hr_1_offset_x - digit_width ;

	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY], MMI_VDOPLY_BTN_PLAY, IMG_ID_VDOPLY_OSD_BUTTON_PLAY);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP], MMI_VDOPLY_BTN_STOP, IMG_ID_VDOPLY_OSD_BUTTON_STOP);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC], MMI_VDOPLY_BTN_PREV, IMG_ID_VDOPLY_OSD_BUTTON_BACK);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC], MMI_VDOPLY_BTN_NEXT, IMG_ID_VDOPLY_OSD_BUTTON_FORWARD);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN], MMI_VDOPLY_BTN_FULL, IMG_ID_VDOPLY_OSD_BUTTON_FULLSCREEN);

	/* progress bar */
    touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.progress_empty.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.progress_empty.offset_y;
    touch_p->is_press = MMI_FALSE;
    touch_p->width = g_vdoply_osd_cntx.panel.progress_fill.width;
	touch_p->height = g_vdoply_osd_cntx.panel.progress_fill.height;
    g_vdoply_cntx.progress.fill_width = touch_p->width;
    g_vdoply_cntx.progress.fill_height = touch_p->height;

    touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.speaker.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.speaker.offset_y;
    touch_p->is_press = MMI_FALSE;
    touch_p->is_usable = MMI_TRUE;
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_BUTTON_MUTE, &touch_p->width, &touch_p->height);

    /*3d */
    #ifdef MMI_VDOPLY_3D_ANAGLYPH
    touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.mode.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.mode.offset_y;
    touch_p->is_press = MMI_FALSE;
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_3D_OFF_BUTTON_UP, &touch_p->width, &touch_p->height);
    #endif
}

#else
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_init_ui
 * DESCRIPTION
 *  init panel's UI item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_init_ui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 digit_width;
    S32 col_width;
    S32 height;
    PU8 buf_ptr;
#ifndef __GDI_MEMORY_PROFILE_2__ 
	S32 buf_size; 
#endif
	
#ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__	
    const U32 TIME_GAP = 1;
#else
    S32 bias_width;
#endif
	
    
#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
    S32 region_0_buf_size;
    S32 region_1_buf_size;    
    S32 offset_x;
    S32 offset_y;
    S32 str_width;
    S32 str_height;
    video_rect_struct *rect_ptr;
    video_osd_vodply_panel_struct *panel_ptr;
    video_osd_softkey_struct *sk_ptr;    
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
    video_pos_struct *pos_ptr;
    
    vdoply_ui_touch_struct *touch_p; 

#if defined(__VDOPLY_FEATURE_INT_RAM_FRAME_BUF__ )||!defined(__GDI_MEMORY_PROFILE_2__)
    mdi_util_create_hw_layer_extmemory_in_struct play_layer_in;
#else
    mdi_util_create_hw_layer_intmemory_in_struct play_layer_in;
#endif
	mdi_util_create_hw_layer_extmemory_in_struct full_play_layer_in;

    mdi_util_create_hw_layer_out_struct play_layer_out;
	mdi_util_create_hw_layer_out_struct full_play_layer_out;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__    
    /* bg */
    /* newer cip has layer bg color, we can split bg into smaller region for better performance */
    /* we will use base layer's buffer to create two smaller layer region */

    /* region 0 */
    rect_ptr = &g_vdoply_osd_cntx.bg.region_0;

    region_0_buf_size = rect_ptr->width*rect_ptr->height*VDOPLY_BUFFER_DEPTH;
    g_vdoply_cntx.bg_region_0_buf_ptr = mmi_frm_asm_alloc_nc_r(GRP_ID_VDOPLY_SINGLE_PLAYER, region_0_buf_size);

    MMI_ASSERT(g_vdoply_cntx.bg_region_0_buf_ptr != NULL);
    
    gdi_layer_create_using_outside_memory(
        rect_ptr->offset_x,
        rect_ptr->offset_y,
        rect_ptr->width,        
        rect_ptr->height,        
        &g_vdoply_cntx.bg_region_0_layer_handle,   
        (PU8)g_vdoply_cntx.bg_region_0_buf_ptr,
        (S32)region_0_buf_size);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_0_layer_handle);       
    gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

    /* region 1 */
    rect_ptr = &g_vdoply_osd_cntx.bg.region_1;    

    region_1_buf_size = rect_ptr->width*rect_ptr->height*VDOPLY_BUFFER_DEPTH;
    g_vdoply_cntx.bg_region_1_buf_ptr = mmi_frm_asm_alloc_nc_r(GRP_ID_VDOPLY_SINGLE_PLAYER, region_1_buf_size);
    
    MMI_ASSERT(g_vdoply_cntx.bg_region_1_buf_ptr != NULL);

    gdi_layer_create_using_outside_memory(
        rect_ptr->offset_x,
        rect_ptr->offset_y,
        rect_ptr->width,        
        rect_ptr->height,        
        &g_vdoply_cntx.bg_region_1_layer_handle,   
        (PU8)g_vdoply_cntx.bg_region_1_buf_ptr,
        (S32)region_1_buf_size);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_region_1_layer_handle);       
    gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);

#else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */

	#ifndef __GDI_MEMORY_PROFILE_2__ 
    /* create loading layer */
	buf_size = g_vdoply_osd_cntx.loading.rect.width*g_vdoply_osd_cntx.loading.rect.height*VDOPLY_BUFFER_DEPTH;
	g_vdoply_cntx.load_buf_ptr = mmi_frm_scrmem_alloc_framebuffer(buf_size);
    gdi_layer_create_using_outside_memory(
        g_vdoply_osd_cntx.loading.rect.offset_x,
        g_vdoply_osd_cntx.loading.rect.offset_y,                
        g_vdoply_osd_cntx.loading.rect.width,                 
        g_vdoply_osd_cntx.loading.rect.height,                                 
        &g_vdoply_cntx.process_layer_handle,   
        (PU8)g_vdoply_cntx.load_buf_ptr,
        (S32)buf_size);
	#else
    gdi_layer_create(
        g_vdoply_osd_cntx.loading.rect.offset_x,
        g_vdoply_osd_cntx.loading.rect.offset_y,                
        g_vdoply_osd_cntx.loading.rect.width,                 
        g_vdoply_osd_cntx.loading.rect.height,                                 
        &g_vdoply_cntx.process_layer_handle);

    #endif
    gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

#ifdef __VDOPLY_FEATURE_FULLSCREEN__

    /* create fullscr loading layer */
    gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
    gdi_layer_get_buffer_ptr(&buf_ptr);

#if !defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
	/* if MT6238 series, we need use IDP rotate, to rotate the process layer vertically */
	gdi_layer_create_using_outside_memory(
	g_vdoply_fullscr_osd_cntx.loading.rect.offset_x,
	UI_device_width - g_vdoply_fullscr_osd_cntx.loading.rect.offset_y - g_vdoply_fullscr_osd_cntx.loading.rect.height,				  
	g_vdoply_fullscr_osd_cntx.loading.rect.width,				  
	g_vdoply_fullscr_osd_cntx.loading.rect.height,		   
	&g_vdoply_cntx.fullscr_process_layer_handle,   
	(PU8)buf_ptr,
	(S32)g_vdoply_osd_cntx.loading.rect.width * g_vdoply_osd_cntx.loading.rect.height * (gdi_layer_get_bit_per_pixel() >> 3));
#else/* defined(MDI_VIDEO_MT6238_SERIES) && defined(GDI_USING_2D_ENGINE_V3) */
	/* chipset other than MT6238 series */
	gdi_layer_create_using_outside_memory(
	g_vdoply_fullscr_osd_cntx.loading.rect.offset_x,
	g_vdoply_fullscr_osd_cntx.loading.rect.offset_y,				
	g_vdoply_fullscr_osd_cntx.loading.rect.width,				  
	g_vdoply_fullscr_osd_cntx.loading.rect.height,		   
	&g_vdoply_cntx.fullscr_process_layer_handle,   
	(PU8)buf_ptr,
	(S32)g_vdoply_osd_cntx.loading.rect.width * g_vdoply_osd_cntx.loading.rect.height * (gdi_layer_get_bit_per_pixel() >> 3));
#endif/* defined(MDI_VIDEO_MT6238_SERIES) && defined(GDI_USING_2D_ENGINE_V3) */
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();


#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */

#ifdef __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__
    /* create play wnd buffer */
    MMI_ASSERT(g_vdoply_cntx.vdo_frame_buf_ptr == NULL);
    media_get_int_buffer(MOD_MMI, (void**)&g_vdoply_cntx.vdo_frame_buf_ptr, VDOPLY_LAYER_BUFFER_SIZE);
    MMI_ASSERT(g_vdoply_cntx.vdo_frame_buf_ptr != NULL);

	play_layer_in.buffer = (PU8)g_vdoply_cntx.vdo_frame_buf_ptr;
	play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	play_layer_in.width = UI_device_width;
	play_layer_in.height = UI_device_height;
	play_layer_in.offset_x = 0;
	play_layer_in.offset_y = 0;
    g_vdoply_cntx.play_wnd_layer_handle = mdi_util_hw_layer_create_with_extmemory(&play_layer_in, &play_layer_out);
	
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
	full_play_layer_in.buffer = (PU8)g_vdoply_cntx.vdo_frame_buf_ptr;
	full_play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    full_play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	full_play_layer_in.width = UI_device_height;
	full_play_layer_in.height = UI_device_width;
	full_play_layer_in.offset_x = 0;
	full_play_layer_in.offset_y = 0;
    g_vdoply_cntx.fullscr_play_layer_handle = mdi_util_hw_layer_create_with_extmemory(&full_play_layer_in, &full_play_layer_out);
	
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        
#else /* __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__ */
    /* create play wnd buffer */
    //MMI_ASSERT(g_vdoply_cntx.vdo_frame_buf_ptr == NULL);
	
	#ifndef __GDI_MEMORY_PROFILE_2__
	buf_size = g_vdoply_osd_cntx.play_wnd.rect.width*g_vdoply_osd_cntx.play_wnd.rect.height*VDOPLY_BUFFER_DEPTH;
	g_vdoply_cntx.vdo_frame_buf_ptr= mmi_frm_scrmem_alloc_framebuffer(buf_size);
	play_layer_in.buffer = (PU8)g_vdoply_cntx.vdo_frame_buf_ptr;
	play_layer_in.buffer_size = buf_size;
	#endif
    play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	play_layer_in.width = g_vdoply_osd_cntx.play_wnd.rect.width;
	play_layer_in.height = g_vdoply_osd_cntx.play_wnd.rect.height;
	play_layer_in.offset_x = 0;
	play_layer_in.offset_y = 0;
	#ifndef __GDI_MEMORY_PROFILE_2__ 
    g_vdoply_cntx.play_wnd_layer_handle = mdi_util_hw_layer_create_with_extmemory(&play_layer_in, &play_layer_out);
	#else
    g_vdoply_cntx.play_wnd_layer_handle = mdi_util_hw_layer_create_with_intmemory(&play_layer_in, &play_layer_out);
    #endif

	gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);

    gdi_layer_set_position(
        g_vdoply_osd_cntx.play_wnd.rect.offset_x, 
        g_vdoply_osd_cntx.play_wnd.rect.offset_y);
    gdi_layer_set_background(MMI_VDOPLY_BG_COLOR);
    gdi_layer_clear(MMI_VDOPLY_BG_COLOR);
    gdi_layer_pop_and_restore_active();

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    /* create full screen layer using base layer's buffer */
    gdi_layer_get_base_handle(&g_vdoply_cntx.bg_layer_handle);

    gdi_layer_push_and_set_active(g_vdoply_cntx.bg_layer_handle);
    gdi_layer_get_buffer_ptr(&buf_ptr);
    gdi_layer_pop_and_restore_active();

#if defined(__VDOPLY_FEATURE_LANDSCAPE_LCD__)
    full_play_layer_in.buffer = (PU8)buf_ptr;
	full_play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    full_play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	full_play_layer_in.width = UI_device_width;
	full_play_layer_in.height = UI_device_height;
	full_play_layer_in.offset_x = 0;
	full_play_layer_in.offset_y = 0;
    g_vdoply_cntx.fullscr_play_layer_handle = mdi_util_hw_layer_create_with_extmemory(&full_play_layer_in, &full_play_layer_out);
#else
    full_play_layer_in.buffer = (PU8)buf_ptr;
	full_play_layer_in.buffer_size = VDOPLY_LAYER_BUFFER_SIZE;
    full_play_layer_in.scenario_id = MDI_MULTIMEDIA_VIDEO;
	full_play_layer_in.width = UI_device_height;
	full_play_layer_in.height = UI_device_width;
	full_play_layer_in.offset_x = 0;
	full_play_layer_in.offset_y = 0;
    g_vdoply_cntx.fullscr_play_layer_handle = mdi_util_hw_layer_create_with_extmemory(&full_play_layer_in, &full_play_layer_out);
#endif
    gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
	gdi_layer_set_background(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    
#endif /* __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__ */

#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__

#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
    g_vdoply_cntx.status_bar_layer_handle = g_vdoply_cntx.bg_region_0_layer_handle;
#else
	#ifndef __GDI_MEMORY_PROFILE_2__
	buf_size = UI_DEVICE_WIDTH*MMI_STATUS_BAR_HEIGHT*VDOPLY_BUFFER_DEPTH;
	g_vdoply_cntx.status_layer_ptr = mmi_frm_scrmem_alloc_framebuffer(buf_size);
    gdi_layer_create_using_outside_memory(
        0,
        0,                
        UI_DEVICE_WIDTH,                 
        MMI_STATUS_BAR_HEIGHT,                                 
        &g_vdoply_cntx.status_bar_layer_handle,   
        (PU8)g_vdoply_cntx.status_layer_ptr,
        (S32)buf_size);
	#else
    gdi_layer_create(
        0, 
        0, 
        UI_DEVICE_WIDTH, 
        MMI_STATUS_BAR_HEIGHT, 
        &g_vdoply_cntx.status_bar_layer_handle);
    #endif
    gdi_layer_push_and_set_active(g_vdoply_cntx.status_bar_layer_handle);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
#endif

    g_vdoply_cntx.prev_status_bar_layer_handle = 
        wgui_status_icon_bar_get_target_layer(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_status_icon_bar_set_target_layer(
        WGUI_STATUS_ICON_BAR_H_BAR,
        g_vdoply_cntx.status_bar_layer_handle);
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        mmi_vdoply_redraw_status_bar_background_hdlr);
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_set_wallpaper_on_bottom(MMI_TRUE);

#else /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */
    g_vdoply_cntx.status_bar_layer_handle = GDI_LAYER_EMPTY_HANDLE;
#endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */


#define ASSIGN_DRAW_LAYER(__offset_x__, __offset_y__, __draw_layer__)       \
do {                                                                        \
    video_rect_struct *rect_0_ptr;                                          \
    video_rect_struct *rect_1_ptr;                                          \
    __draw_layer__ = GDI_LAYER_EMPTY_HANDLE;                                \
    rect_0_ptr = &g_vdoply_osd_cntx.bg.region_0;                            \
    rect_1_ptr = &g_vdoply_osd_cntx.bg.region_1;                            \
    if ((__offset_x__ >= rect_0_ptr->offset_x) &&                           \
        (__offset_x__ <= rect_0_ptr->offset_x+rect_0_ptr->width) &&         \
        (__offset_y__ >= rect_0_ptr->offset_y) &&                           \
        (__offset_y__ <= rect_0_ptr->offset_y+rect_0_ptr->height))          \
    {                                                                       \
        __draw_layer__ = g_vdoply_cntx.bg_region_0_layer_handle;            \
    }                                                                       \
    else if ((__offset_x__ >= rect_1_ptr->offset_x) &&                      \
             (__offset_x__ <= rect_1_ptr->offset_x+rect_1_ptr->width) &&    \
             (__offset_y__ >= rect_1_ptr->offset_y) &&                      \
             (__offset_y__ <= rect_1_ptr->offset_y+rect_1_ptr->height))     \
    {                                                                       \
        __draw_layer__ = g_vdoply_cntx.bg_region_1_layer_handle;            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        /* object not within any region */                                  \
        MMI_ASSERT(0);                                                      \
    }                                                                       \
} while(0);


#ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__

    g_vdoply_cntx.volume_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.progress_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.fullscreen_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.rsk_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.lsk_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.ck_draw_layer = g_vdoply_cntx.bg_layer_handle; 
    g_vdoply_cntx.title_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.timer_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.play_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.stop_draw_layer = g_vdoply_cntx.bg_layer_handle;

/* timer */
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_COL, &col_width, &height);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &digit_width, &height);


    pos_ptr = &g_vdoply_osd_cntx.panel.play_time;
    
    g_vdoply_cntx.timer.offset_y = pos_ptr->offset_y;

    g_vdoply_cntx.timer.hr_0_offset_x = pos_ptr->offset_x;
    g_vdoply_cntx.timer.hr_1_offset_x = g_vdoply_cntx.timer.hr_0_offset_x + digit_width + TIME_GAP;
    g_vdoply_cntx.timer.col_0_offset_x = g_vdoply_cntx.timer.hr_1_offset_x + digit_width + TIME_GAP;
    g_vdoply_cntx.timer.min_0_offset_x = g_vdoply_cntx.timer.col_0_offset_x + col_width + TIME_GAP;
    g_vdoply_cntx.timer.min_1_offset_x = g_vdoply_cntx.timer.min_0_offset_x + digit_width + TIME_GAP;
    g_vdoply_cntx.timer.col_1_offset_x = g_vdoply_cntx.timer.min_1_offset_x + digit_width + TIME_GAP;
    g_vdoply_cntx.timer.sec_0_offset_x = g_vdoply_cntx.timer.col_1_offset_x + col_width + TIME_GAP;
    g_vdoply_cntx.timer.sec_1_offset_x = g_vdoply_cntx.timer.sec_0_offset_x + digit_width + TIME_GAP;

    pos_ptr = &g_vdoply_osd_cntx.panel.duration;
    
    g_vdoply_cntx.timer2.offset_y = pos_ptr->offset_y;

	g_vdoply_cntx.timer2.sec_1_offset_x = pos_ptr->offset_x - digit_width;
	g_vdoply_cntx.timer2.sec_0_offset_x = g_vdoply_cntx.timer2.sec_1_offset_x - digit_width - TIME_GAP;
	g_vdoply_cntx.timer2.col_1_offset_x = g_vdoply_cntx.timer2.sec_0_offset_x - col_width - TIME_GAP;
	g_vdoply_cntx.timer2.min_1_offset_x = g_vdoply_cntx.timer2.col_1_offset_x - digit_width - TIME_GAP;
	g_vdoply_cntx.timer2.min_0_offset_x = g_vdoply_cntx.timer2.min_1_offset_x - digit_width - TIME_GAP;
	g_vdoply_cntx.timer2.col_0_offset_x = g_vdoply_cntx.timer2.min_0_offset_x - col_width - TIME_GAP;
	g_vdoply_cntx.timer2.hr_1_offset_x = g_vdoply_cntx.timer2.col_0_offset_x - digit_width - TIME_GAP;
	g_vdoply_cntx.timer2.hr_0_offset_x = g_vdoply_cntx.timer2.hr_1_offset_x - digit_width - TIME_GAP;

	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY], MMI_VDOPLY_BTN_PLAY, IMG_ID_VDOPLY_OSD_BUTTON);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP], MMI_VDOPLY_BTN_STOP, IMG_ID_VDOPLY_OSD_BUTTON);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC], MMI_VDOPLY_BTN_PREV, IMG_ID_VDOPLY_OSD_BUTTON);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC], MMI_VDOPLY_BTN_NEXT, IMG_ID_VDOPLY_OSD_BUTTON);
	mmi_vdoply_init_touch_obj(&g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN], MMI_VDOPLY_BTN_FULL, IMG_ID_VDOPLY_OSD_BUTTON);

	/* progress bar */
	touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.progress_empty.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.progress_empty.offset_y;
    touch_p->is_press = MMI_FALSE;
    touch_p->width = g_vdoply_osd_cntx.panel.progress_fill.width;
	touch_p->height = g_vdoply_osd_cntx.panel.progress_fill.height;
    g_vdoply_cntx.progress.fill_width = touch_p->width;
    g_vdoply_cntx.progress.fill_height = touch_p->height;  

    /*3d */
    #ifdef MMI_VDOPLY_3D_ANAGLYPH
    touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.mode.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.mode.offset_y;
    touch_p->is_press = MMI_FALSE;
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_3D_OFF, &touch_p->width, &touch_p->height);
    #endif
#else /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */


#define INIT_TOUCH_OBJ(__x__, __X__)                                                                 \
do {                                                                                                 \
    touch_p = &g_vdoply_cntx.touch_##__x__##;                                                        \
    touch_p->offset_x = g_vdoply_osd_cntx.panel.##__x__##.offset_x;                                  \
    touch_p->offset_y = g_vdoply_osd_cntx.panel.##__x__##.offset_y;                                  \
    touch_p->is_press = MMI_FALSE;                                                                       \
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_TOUCH_OSD_##__X__##, &touch_p->width, &touch_p->height);\
} while(0);

#define INIT_TOUCH_FULL_OBJ(__x__, __X__)                                                                 \
do {                                                                                                      \
    touch_p = &g_vdoply_cntx.full_touch_##__x__##;                                                        \
    touch_p->offset_x = g_vdoply_fullscr_osd_cntx.panel.##__x__##.offset_x;                               \
    touch_p->offset_y = g_vdoply_fullscr_osd_cntx.panel.##__x__##.offset_y;                               \
    touch_p->is_press = MMI_FALSE;                                                                            \
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_TOUCH_FULL_OSD_##__X__##, &touch_p->width, &touch_p->height);\
} while(0);


    /* timer */
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_COL, &col_width, &height);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_0, &digit_width, &height);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_TIMER_BIAS, &bias_width, &height);


    pos_ptr = &g_vdoply_osd_cntx.panel.timer;
    
    g_vdoply_cntx.timer.offset_y = pos_ptr->offset_y;

    g_vdoply_cntx.timer.hr_0_offset_x = pos_ptr->offset_x;
    g_vdoply_cntx.timer.hr_1_offset_x = g_vdoply_cntx.timer.hr_0_offset_x + digit_width;
    g_vdoply_cntx.timer.col_0_offset_x = g_vdoply_cntx.timer.hr_1_offset_x + digit_width;
    g_vdoply_cntx.timer.min_0_offset_x = g_vdoply_cntx.timer.col_0_offset_x + col_width;
    g_vdoply_cntx.timer.min_1_offset_x = g_vdoply_cntx.timer.min_0_offset_x + digit_width;
    g_vdoply_cntx.timer.col_1_offset_x = g_vdoply_cntx.timer.min_1_offset_x + digit_width;
    g_vdoply_cntx.timer.sec_0_offset_x = g_vdoply_cntx.timer.col_1_offset_x + col_width;
    g_vdoply_cntx.timer.sec_1_offset_x = g_vdoply_cntx.timer.sec_0_offset_x + digit_width;

    g_vdoply_cntx.bias_pos = g_vdoply_cntx.timer.sec_1_offset_x + digit_width;


    g_vdoply_cntx.timer2.hr_0_offset_x = g_vdoply_cntx.bias_pos + bias_width;
    g_vdoply_cntx.timer2.hr_1_offset_x = g_vdoply_cntx.timer2.hr_0_offset_x + digit_width;
    g_vdoply_cntx.timer2.col_0_offset_x = g_vdoply_cntx.timer2.hr_1_offset_x + digit_width;
    g_vdoply_cntx.timer2.min_0_offset_x = g_vdoply_cntx.timer2.col_0_offset_x + col_width;
    g_vdoply_cntx.timer2.min_1_offset_x = g_vdoply_cntx.timer2.min_0_offset_x + digit_width;
    g_vdoply_cntx.timer2.col_1_offset_x = g_vdoply_cntx.timer2.min_1_offset_x + digit_width;
    g_vdoply_cntx.timer2.sec_0_offset_x = g_vdoply_cntx.timer2.col_1_offset_x + col_width;
    g_vdoply_cntx.timer2.sec_1_offset_x = g_vdoply_cntx.timer2.sec_0_offset_x + digit_width;

#ifdef __VDOPLY_FEATURE_TOUCH_SCREEN__
    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;

    /* init touch obj region */
    INIT_TOUCH_OBJ(speed_inc, SPEED_INC);
    INIT_TOUCH_OBJ(speed_dec, SPEED_DEC);
    INIT_TOUCH_OBJ(volume_inc, VOLUME_INC);
    INIT_TOUCH_OBJ(volume_dec, VOLUME_DEC);
    INIT_TOUCH_OBJ(progress_inc, PROGRESS_INC);
    INIT_TOUCH_OBJ(progress_dec, PROGRESS_DEC);
    INIT_TOUCH_OBJ(snapshot, SNAPSHOT);
    INIT_TOUCH_OBJ(fullscreen, FULLSCREEN);
    #ifdef __MMI_FTE_SUPPORT__
    #ifdef MMI_VDOPLY_3D_ANAGLYPH 
    INIT_TOUCH_OBJ(mode, 3D_OFF);
    #endif
    #endif
	
    /* progress bar */
    touch_p = &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR];
    touch_p->offset_x = g_vdoply_osd_cntx.panel.progress_empty.offset_x;
    touch_p->offset_y = g_vdoply_osd_cntx.panel.progress_empty.offset_y;
    touch_p->is_press = MMI_FALSE;
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_OSD_PROGRESS_EMPTY, &touch_p->width, &touch_p->height);
    g_vdoply_cntx.progress.fill_width = touch_p->width;
    g_vdoply_cntx.progress.fill_height = touch_p->height;   

#else /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 

    gdi_image_get_dimension_id(
        IMG_ID_VDOPLY_OSD_PROGRESS_EMPTY, 
        &g_vdoply_cntx.progress.fill_width, 
        &g_vdoply_cntx.progress.fill_height);

    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = FALSE;
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_press = FALSE;

#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_INC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_DEC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_INC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press = FALSE;
    g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_BAR].is_press = FALSE;
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

#endif /* __VDOPLY_FEATURE_TOUCH_SCREEN__ */ 

#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ 
    panel_ptr = &g_vdoply_osd_cntx.panel;
    ASSIGN_DRAW_LAYER(panel_ptr->speed.offset_x, panel_ptr->speed.offset_y, g_vdoply_cntx.speed_draw_layer);
    ASSIGN_DRAW_LAYER(panel_ptr->volume.offset_x, panel_ptr->volume.offset_y, g_vdoply_cntx.volume_draw_layer);    
    ASSIGN_DRAW_LAYER(panel_ptr->progress_empty.offset_x, panel_ptr->progress_empty.offset_y, g_vdoply_cntx.progress_draw_layer);       
    ASSIGN_DRAW_LAYER(panel_ptr->snapshot.offset_x, panel_ptr->snapshot.offset_y, g_vdoply_cntx.snapshot_draw_layer);           
    ASSIGN_DRAW_LAYER(panel_ptr->fullscreen.offset_x, panel_ptr->fullscreen.offset_y, g_vdoply_cntx.fullscreen_draw_layer);
    ASSIGN_DRAW_LAYER(panel_ptr->timer.offset_x, panel_ptr->timer.offset_y, g_vdoply_cntx.timer_draw_layer);
#ifdef __MMI_FTE_SUPPORT__
    ASSIGN_DRAW_LAYER(panel_ptr->play.offset_x, panel_ptr->play.offset_y, g_vdoply_cntx.play_draw_layer);
    ASSIGN_DRAW_LAYER(panel_ptr->stop.offset_x, panel_ptr->stop.offset_y, g_vdoply_cntx.stop_draw_layer);
#endif
    sk_ptr = &g_vdoply_osd_cntx.softkey;
    ASSIGN_DRAW_LAYER(sk_ptr->icon_ck_pos.offset_x, sk_ptr->icon_ck_pos.offset_y, g_vdoply_cntx.ck_draw_layer); 

    if (sk_ptr->is_lsk_icon)
    {
        ASSIGN_DRAW_LAYER(sk_ptr->icon_lsk_pos.offset_x, sk_ptr->icon_lsk_pos.offset_y, g_vdoply_cntx.lsk_draw_layer);        
    }
    else
    {
        gui_measure_string((UI_string_type)L"Test", &str_width, &str_height);    
        offset_x = 2;
        offset_y = (UI_device_height - MMI_button_bar_height) + ((MMI_button_bar_height - str_height) >> 1) + 1;
        ASSIGN_DRAW_LAYER(offset_x, offset_y, g_vdoply_cntx.lsk_draw_layer);        
    }

    if (sk_ptr->is_rsk_icon)
    {
        ASSIGN_DRAW_LAYER(sk_ptr->icon_rsk_pos.offset_x, sk_ptr->icon_rsk_pos.offset_y, g_vdoply_cntx.rsk_draw_layer);        
    }
    else
    {
        gui_measure_string((UI_string_type)L"Test", &str_width, &str_height);    
        offset_x = UI_device_width - str_width - 2;
        offset_y = (UI_device_height - MMI_button_bar_height) + ((MMI_button_bar_height - str_height) >> 1) + 1;
        ASSIGN_DRAW_LAYER(offset_x, offset_y, g_vdoply_cntx.rsk_draw_layer);        
    }

    if ((g_vdoply_osd_cntx.title.is_draw_filename) || (g_vdoply_osd_cntx.title.is_draw_app_name))
    {
        ASSIGN_DRAW_LAYER(
            g_vdoply_osd_cntx.title.rect.offset_x,\
            g_vdoply_osd_cntx.title.rect.offset_y,\
            g_vdoply_cntx.title_draw_layer);
    }

#else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
    g_vdoply_cntx.speed_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.volume_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.progress_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.snapshot_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.fullscreen_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.rsk_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.lsk_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.ck_draw_layer = g_vdoply_cntx.bg_layer_handle; 
    g_vdoply_cntx.title_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.timer_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.play_draw_layer = g_vdoply_cntx.bg_layer_handle;
    g_vdoply_cntx.stop_draw_layer = g_vdoply_cntx.bg_layer_handle;
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */

#ifdef __MMI_FTE_SUPPORT__ 
    g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
    g_vdoply_cntx.stop_img_id = IMG_ID_VDOPLY_OSD_BUTTON_STOP;
#endif

#endif /* __VDOPLY_FEATURE_SLIM_IMG_RES__ */

}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_timer_cyclic
 * DESCRIPTION
 *  timer. will ask actual play time from driver and display on screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_timer_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U64 prev_play_time;
    #ifdef __VDOPLY_FEATURE_SPEED__
    S32 speed_factor;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_play_time = (U32) (g_vdoply_cntx.cur_status.play_time);        /* change to sec */
    #ifdef __VDOPLY_FEATURE_SPEED__
    speed_factor = mmi_vdoply_get_speed_factor();
    #endif

    if ((g_vdoply_cntx.state == VDOPLY_STATE_PLAY) ||
        (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY))
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
        {
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
        {
        #ifdef __MMI_VIDEO_STREAM__
            mdi_video_stream_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
        #endif
        }

        #ifdef __VDOPLY_FEATURE_SPEED__
        if (((speed_factor > 0) && (g_vdoply_cntx.cur_status.play_time >= g_vdoply_cntx.cur_status.start_play_time)) ||      /* play foward */
            ((speed_factor < 0) && (g_vdoply_cntx.cur_status.play_time <= g_vdoply_cntx.cur_status.start_play_time)))        /* play backward */
        #endif /* __VDOPLY_FEATURE_SPEED__ */
		{              
            if (g_vdoply_cntx.cur_status.play_time != prev_play_time)
            {
                mmi_vdoply_draw_panel_timer();
				mmi_vdoply_draw_panel_progress();
                mmi_vdoply_blt_screen();
             }
  
        }
		
		goto start_cyclic_timer;

    }
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    else if ((g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY) || 
             (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY))
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
        {
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
        {
        #ifdef __MMI_VIDEO_STREAM__
            mdi_video_stream_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
        #endif
        }

		goto start_cyclic_timer;
	}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

start_cyclic_timer:
	/* start cyclic timer */
	if (g_vdoply_cntx.video_info.total_time_duration < 5000)
	{
		gui_start_timer(50, mmi_vdoply_player_timer_cyclic);
	}
	else
	{
		gui_start_timer(200, mmi_vdoply_player_timer_cyclic);
	}
}



#ifndef __VDOPLY_FEATURE_CROSS_LAYEROUT__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_softkey
 * DESCRIPTION
 *  set softkey display string
 * PARAMETERS
 *  lsk_str_ptr     [IN]        Lsk string
 *  rsk_str_ptr     [IN]        Rsk string
 *  lsk_img_id      [IN]        Lsk image
 *  rsk_img_id      [IN]        Lsk image
 *  ck_img_id       [IN]        Ck image
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_set_softkey(CHAR* lsk_str_ptr, CHAR* rsk_str_ptr, U16 lsk_img_id, U16 rsk_img_id, U16 ck_img_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    g_vdoply_cntx.lsk_str_ptr = 0;
    g_vdoply_cntx.rsk_str_ptr = 0;

    g_vdoply_cntx.lsk_img_id = IMG_ID_VDOPLY_LSK_OPTION;
    g_vdoply_cntx.rsk_img_id = IMG_ID_VDOPLY_RSK_BACK;
    g_vdoply_cntx.ck_img_id = IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN;
#else
    g_vdoply_cntx.lsk_str_ptr = lsk_str_ptr;
    g_vdoply_cntx.rsk_str_ptr = rsk_str_ptr;

    g_vdoply_cntx.lsk_img_id = lsk_img_id;
    g_vdoply_cntx.rsk_img_id = rsk_img_id;
    g_vdoply_cntx.ck_img_id = ck_img_id;
#endif
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_lsk_release
 * DESCRIPTION
 *  lsk release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_lsk_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_LSK, MMI_VDOPLY_FULL_TOUCH_LSK);
#else
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {    
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press = MMI_FALSE;
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_LSK].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_LSK].is_press = MMI_FALSE;
    }

    /* stop seek key timer */
    gui_cancel_timer(mmi_vdoply_seek_key_release);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
	gui_cancel_timer(mmi_vdoply_play_next_file_worked);
	gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
	#endif
#endif

    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_OPENING:
        case VDOPLY_STATE_INTERRUPTED_OPENING:

        #ifdef __VDOPLY_FEATURE_LSK_OPTION__
        
           /* link to option screen */
        mmi_vdoply_enter_grp_settings(); 
       
        #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
            break;            
   

	   #ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING:
			mmi_vdoply_draw_softkey_and_blt();
            
        #ifdef __VDOPLY_FEATURE_LSK_OPTION__            
        
            /* link to option screen */
        mmi_vdoply_enter_grp_settings();

       
        #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
            break;
       #endif
    
        case VDOPLY_STATE_IDLE:
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();

        #ifdef __VDOPLY_FEATURE_LSK_OPTION__
    
            /* link to option screen */
        mmi_vdoply_enter_grp_settings();


        #else /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
        #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 

            break;

        case VDOPLY_STATE_PLAY:
            /* get latest time */
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();
			mmi_vdoply_draw_softkey_and_blt();

        #ifdef __VDOPLY_FEATURE_LSK_OPTION__

            /* link to option screen */
        mmi_vdoply_enter_grp_settings(); 

        #else /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
            mmi_vdoply_stop_video();
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);

        #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
            break;

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:

            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();

        #ifdef __VDOPLY_FEATURE_LSK_OPTION__
       
            /* link to option screen */
        mmi_vdoply_enter_grp_settings();

        #else /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
        
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
        #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 

            break;

		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
			mmi_vdoply_stop_non_block_seeking();
			mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();

		    #ifdef __VDOPLY_FEATURE_LSK_OPTION__
		   
		        /* link to option screen */
		    mmi_vdoply_enter_grp_settings();

		    #else /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
		    
		        if (mmi_vdoply_is_output_to_bt())
		        {
		            mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
		        }
		        else
		        {
		            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
		        }
		    #endif /* __VDOPLY_FEATURE_LSK_OPTION__ */ 
			break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            /* full screen */
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_IDLE:

            mmi_vdoply_blt_screen();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
            break;

        case VDOPLY_STATE_FULLSCR_PAUSE:
            /* get latest time */
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_blt_screen();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }

            break;

        case VDOPLY_STATE_FULLSCR_PLAY:
            mmi_vdoply_stop_video();
            
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);        
            
            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PAUSE);
            break;

		#endif
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 


    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_CONNECTED:    
        case VDOPLY_STATE_STREAM_DISCONNECT: 
        case VDOPLY_STATE_STREAM_CONNECTING: 
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
        case VDOPLY_STATE_STREAM_BUFFERING:
        case VDOPLY_STATE_STREAM_BT_CONNECTING:            
			mmi_vdoply_draw_softkey_and_blt();      

            /* enter option screen */
            mmi_vdoply_enter_grp_settings();
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            /* not use in these states */
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_stop_video();

            mdi_video_stream_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTED);
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_blt_screen();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }            
            break;      
            
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:  
            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);
            break;      
    #endif /*  __VDOPLY_FEATURE_FULLSCREEN__ */
            
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING: 
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING: 

			mmi_vdoply_draw_softkey_and_blt();

            mmi_vdoply_enter_grp_settings();
            break;            
    #endif /* defined(__MMI_VIDEO_PDL__) */   

        case VDOPLY_STATE_BACKGROUND_CALL:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
			mmi_vdoply_draw_softkey_and_blt();       
            mmi_vdoply_display_not_available_popup(GRP_ID_VDOPLY_SINGLE_PLAYER);
            break;

    }

    #ifndef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);                  
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_rsk_release
 * DESCRIPTION
 *  rsk release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_rsk_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_RSK, MMI_VDOPLY_FULL_TOUCH_RSK);
#else
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {    
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press = MMI_FALSE;
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_RSK].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_RSK].is_press = MMI_FALSE;
    }

    gui_cancel_timer(mmi_vdoply_seek_key_release);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
	gui_cancel_timer(mmi_vdoply_play_next_file_worked);
	gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
	#endif
	#endif

    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_EXIT: /* exit */
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();

            cui_vdoply_exit_button_worked();
            break;
        case VDOPLY_STATE_IDLE: /* exit */
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();
            mmi_vdoply_close_file();
            cui_vdoply_exit_button_worked();
            break;

        case VDOPLY_STATE_PLAY: /* stop */
			mmi_vdoply_draw_softkey_and_blt();
        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_stop_video();
            mmi_vdoply_close_file();
        #else
            mmi_vdoply_stop_video();
        #endif

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif
            break;


		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING: 
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_disconnect_bt();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    mmi_vdoply_close_file();
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif
            break;
        #endif

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:    /* stop */
			mmi_vdoply_draw_softkey_and_blt();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_close_file();
        #endif

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:        
			mmi_vdoply_draw_softkey_and_blt();

        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_close_file();
        #endif
            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

            mmi_vdoply_stop_non_block_seeking();
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif

            break;

        case VDOPLY_STATE_INTERRUPTED_SEEKING:
			mmi_vdoply_draw_softkey_and_blt();

            mmi_vdoply_stop_non_block_seeking();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
		    mmi_vdoply_close_file();
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif
            break;

        case VDOPLY_STATE_INTERRUPTED_OPENING:
        case VDOPLY_STATE_OPENING:  /* exit */
			mmi_vdoply_draw_softkey_and_blt();

            mmi_vdoply_stop_animation();
            mmi_vdoply_close_file();
            cui_vdoply_exit_button_worked();
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        /* full screen */
        case VDOPLY_STATE_FULLSCR_IDLE:
            mmi_vdoply_blt_screen();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_close_file();
        #endif

        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        #endif
            break;

        case VDOPLY_STATE_FULLSCR_PAUSE:
            mmi_vdoply_blt_screen();

        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_stop_video();
            mmi_vdoply_close_file();
        #endif

        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);
        #endif
            break;

        case VDOPLY_STATE_FULLSCR_PLAY:
            mmi_vdoply_blt_screen();

            mmi_vdoply_stop_video();

        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_close_file();
        #endif

        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
        #endif
            break;

        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
            mmi_vdoply_blt_screen();
            mmi_vdoply_disconnect_bt();
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);
        #endif
            break;

        case VDOPLY_STATE_FULLSCR_SEEKING:
            mmi_vdoply_blt_screen();
            
            mmi_vdoply_stop_non_block_seeking();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);
        #endif
            break;           
            
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:     
            mmi_vdoply_blt_screen();
            
            mmi_vdoply_stop_non_block_seeking();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
        #endif    
            break;
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

        case VDOPLY_STATE_BACKGROUND_CALL:
			mmi_vdoply_draw_softkey_and_blt();

            cui_vdoply_exit_button_worked();
            break;        

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_PLAY:
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_stop_video();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
            mmi_vdoply_close_file();
        #endif

            g_vdoply_cntx.cur_status.play_time = 0;
            g_vdoply_cntx.cur_status.start_play_time = 0;   

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
        #ifdef MMI_VDOPLY_RSK_EXIT
            cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
        #endif
            break;
            
        case VDOPLY_STATE_STREAM_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
			mmi_vdoply_draw_softkey_and_blt();            
            
            
			cui_vdoply_exit_button_worked();
        
            break;       
            
        case VDOPLY_STATE_STREAM_DISCONNECT:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
			mmi_vdoply_draw_softkey_and_blt();
			cui_vdoply_exit_button_worked();
            break;        

        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_stop_animation();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
		cui_vdoply_exit_button_worked();
        #else    
		    mdi_video_stream_disconnect();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);            
        #endif
            break;        
            
        case VDOPLY_STATE_STREAM_BUFFERING:
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_stream_stop_buffering();

        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
		    g_vdoply_cntx.cur_status.play_time = 0;
            g_vdoply_cntx.cur_status.start_play_time = 0;   
			
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);                
        #endif
            break;     

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_disconnect_bt();

        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);                
        #endif
            break;     
            
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /* fullscr */
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
            mmi_vdoply_stop_animation();
            mmi_vdoply_blt_screen();
            
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
		    mdi_video_stream_disconnect();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);
        #endif
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            mmi_vdoply_stop_animation();
            mmi_vdoply_blt_screen();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
		    mdi_video_stream_disconnect();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING);
        #endif
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            mmi_vdoply_blt_screen();

            gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);                
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
        #endif
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            mmi_vdoply_blt_screen();
            
            mmi_vdoply_disconnect_bt();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
        #endif
           break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_blt_screen();
            
            mdi_video_stream_pause();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_PLAY);
        #endif
            break;            

            
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_blt_screen();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
        #endif
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
            mmi_vdoply_blt_screen();
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
        #endif
            break;            
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
            mmi_vdoply_stop_animation();

			mmi_vdoply_draw_softkey_and_blt();

            mdi_video_progressive_close_file();
			cui_vdoply_exit_button_worked();
            break;
            
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:                 
			mmi_vdoply_draw_softkey_and_blt();

            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);
            mdi_video_progressive_close_file();
			cui_vdoply_exit_button_worked();
            break;

        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING: 
			mmi_vdoply_draw_softkey_and_blt();

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
            
            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);
            mdi_video_progressive_close_file();
			cui_vdoply_exit_button_worked();
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
            mmi_vdoply_blt_screen();
            gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_BUFFERING);
        #endif
            break;

        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
            mmi_vdoply_blt_screen();
            gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);
        #ifdef MMI_VDOPLY_RSK_EXIT
		    cui_vdoply_exit_button_worked();
        #else
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
        #endif
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_PDL__ */

    }

	#ifndef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);                  
	#endif
}



#ifdef __VDOPLY_FEATURE_VOLUME__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_up_cyclic
 * DESCRIPTION
 *  volume up cyclic
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_up_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_vdoply_cntx.bVolFlag = MMI_FALSE;
#ifdef __VDOPLY_FEATURE_VOLUME_MUTE__

    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_TRUE);
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }        

        g_vdoply_cntx.is_mute = MMI_FALSE;
        
        /* start timer for next vol up */
        gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_up_cyclic);        
    }
    else if (g_vdoply_cntx.cur_status.volume < VDOPLY_VOL_16)
    {
        g_vdoply_cntx.cur_status.volume++;
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }

        /* start timer for next vol up */
        gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_up_cyclic);
    }
    else
    {
        return;
    }

#else /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 
    if (g_vdoply_cntx.cur_status.volume < VDOPLY_VOL_16)
    {
        g_vdoply_cntx.cur_status.volume++;
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }        

        /* start timer for next vol up */
        gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_up_cyclic);        
    }
    else
    {
        return;
    }
#endif /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_VOLUME_INC, MMI_VDOPLY_FULL_TOUCH_VOLUME_INC);
#else
	mmi_vdoply_vol_cyclic_update_ui(MMI_VDOPLY_TOUCH_VOLUME_INC, MMI_VDOPLY_FULL_TOUCH_VOLUME_INC);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_up_key_press
 * DESCRIPTION
 *  volume up key press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_up_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_vol_up_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_up_key_release
 * DESCRIPTION
 *  volume up key release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_up_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_vdoply_vol_up_cyclic);

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_VOLUME_INC, MMI_VDOPLY_FULL_TOUCH_VOLUME_INC);
#else
	mmi_vdoply_vol_key_release_to_do(MMI_VDOPLY_TOUCH_VOLUME_INC, MMI_VDOPLY_FULL_TOUCH_VOLUME_INC);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_down_cyclic
 * DESCRIPTION
 *  volume down cyclic
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_down_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_VOLUME_MUTE__
#ifndef __VDOPLY_FEATURE_FTE20__
    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        return;
    }
#endif

    if (g_vdoply_cntx.cur_status.volume > VDOPLY_VOL_1)
    {
        g_vdoply_cntx.is_mute = MMI_FALSE;
        g_vdoply_cntx.cur_status.volume--;
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }
        //gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_down_cyclic);
    }
    else if (g_vdoply_cntx.cur_status.volume == VDOPLY_VOL_1)
    {
        g_vdoply_cntx.is_mute = MMI_TRUE;
		g_vdoply_cntx.bVolFlag = MMI_TRUE;
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_TRUE);
        }        
        //gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_down_cyclic);
    }
	gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_down_cyclic);
#else /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 
    if (g_vdoply_cntx.cur_status.volume > VDOPLY_VOL_1)
    {
        g_vdoply_cntx.cur_status.volume--;
        if (!mmi_vdoply_is_background_call())
        {
        mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }        
        gui_start_timer(VDOPLY_VOL_ADJUST_TIME_DUR, mmi_vdoply_vol_down_cyclic);

    }
    else
    {
        return;
    }
#endif /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_VOLUME_DEC, MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC);
#else
	mmi_vdoply_vol_cyclic_update_ui(MMI_VDOPLY_TOUCH_VOLUME_DEC, MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_down_key_press
 * DESCRIPTION
 *  volume down key press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_down_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_vol_down_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_vol_down_key_release
 * DESCRIPTION
 *  volume down key release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_vol_down_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_vdoply_vol_down_cyclic);

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_VOLUME_INC, MMI_VDOPLY_FULL_TOUCH_VOLUME_INC);
#else
	mmi_vdoply_vol_key_release_to_do(MMI_VDOPLY_TOUCH_VOLUME_DEC, MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC);
#endif
}
#endif /* __VDOPLY_FEATURE_VOLUME__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_speed_inc_key_press
 * DESCRIPTION
 *  up arrow key press hdlr, for speed up
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_SPEED__
static void mmi_vdoply_speed_inc_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEPPD_INC_KEY_PRESS);   
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_IS_KEY_PRESSED, g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press);       

    if (g_vdoply_cntx.cur_status.speed >= VDOPLY_FEATURE_SPEED_COUNT - 1)
    {
        return;
    }

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press = MMI_TRUE;        
        mmi_vdoply_draw_panel_speed();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_INC].is_press = MMI_TRUE;      
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }
    
    mmi_vdoply_blt_screen();

 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_speed_inc_key_release
 * DESCRIPTION
 *  speed up key press
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_speed_inc_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEPPD_INC_KEY_RELEASE);   
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_IS_KEY_PRESSED, g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press);       
    
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press)
        {
            return;
        }        

        g_vdoply_cntx.cur_status.speed++;
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press = FALSE;        
        mmi_vdoply_draw_panel_speed();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__

        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_INC].is_press)
        {
            return;
        }  

        g_vdoply_cntx.cur_status.speed++;
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_INC].is_press = FALSE;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }
   
    mmi_vdoply_blt_screen();

    /* if is seeking, it is already stopped */
    if ((g_vdoply_cntx.state == VDOPLY_STATE_PLAY ||
         g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY) && (g_vdoply_cntx.is_seeking == MMI_FALSE))
    {
        /* speed change, need pause and restart */
        ret = mmi_vdoply_stop_video();

        if (ret != MDI_RES_VDOPLY_ALREADY_FINISHED)
        {

            if (mmi_vdoply_is_output_to_bt())
            {
                if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
                }
            }
            else
            {
                ret = mmi_vdoply_play_video();

                if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
                {
                    if(g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
                        return;                    
                    }
                    else if(g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING);
                        return;
                    }
                    else
                    {
                        MMI_ASSERT(0);
                    }
                }
                else if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)      /* true means has error popup */
                {
                    return;
                }
            }
            /* reset start play time */
            g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;
        }
        else
        {
            mmi_vdoply_player_play_finish_hdlr(MDI_RES_VDOPLY_SUCCEED, 0);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_speed_dec_key_press
 * DESCRIPTION
 *  down arrow key press hdlr, for speed down
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_speed_dec_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEPPD_DEC_KEY_PRESS);   
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_IS_KEY_PRESSED, g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press);       

    if (g_vdoply_cntx.cur_status.speed == 0)
    {
        return;
    }

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press = MMI_TRUE;   
        mmi_vdoply_draw_panel_speed();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_DEC].is_press = MMI_TRUE;       
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }

    mmi_vdoply_blt_screen();
   
 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_speed_dec_key_release
 * DESCRIPTION
 *  speed up key press
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_speed_dec_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEPPD_DEC_KEY_RELEASE);   
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_IS_KEY_PRESSED, g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press);       

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press)
        {
            return;
        }        

        g_vdoply_cntx.cur_status.speed--;
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press = FALSE;        
        mmi_vdoply_draw_panel_speed();
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_DEC].is_press)
        {
            return;
        }        
        
        g_vdoply_cntx.cur_status.speed--;
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_SPEED_DEC].is_press = FALSE;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }

    mmi_vdoply_blt_screen();

    /* speed change, need pause and restart */
    if ((g_vdoply_cntx.state == VDOPLY_STATE_PLAY ||
         g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY) && (g_vdoply_cntx.is_seeking == MMI_FALSE))
    {
        /* speed change, need pause and restart */
        ret = mmi_vdoply_stop_video();

        if (ret != MDI_RES_VDOPLY_ALREADY_FINISHED)
        {
            /* play may already stopped when invoking mmi_vdoply_stop video,*/
            /*   but we haven't received indication yet                     */
            /* and call back won't be invoked becuz we called stop video    */
            /* only play when it is not finished                            */
            if (mmi_vdoply_is_output_to_bt())
            {
                if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
                }
            }
            else
            {
                ret = mmi_vdoply_play_video();

                if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
                {
                    if(g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
                        return;                       
                    }
                    else if(g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING);
                        return;                       
                    }
                    else
                    {
                        MMI_ASSERT(0);
                    }
                    return;
                }
                else if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)      /* ture means has error popup */
                {
                    return;
                }
            }
            /* reset start play time */
            g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;
        }
        else
        {
        	  /* callback won't be invoked here, so we invoked it ourself */
            mmi_vdoply_player_play_finish_hdlr(MDI_RES_VDOPLY_SUCCEED, 0);
        }
    }
}
#endif /* __VDOPLY_FEATURE_SPEED__ */


static mmi_ret mmi_vdoply_switch_first_to_last_file_hdlr(mmi_event_struct *param)
{
	/* check if already exit player screen */
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return MMI_RET_OK;
    }
	
	if(cui_folder_browser_is_filelist_locked(g_vdoply_cntx.fmgr_scr_id))
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
	}
	
	mmi_vdoply_play_prev_file_worked();
	return MMI_RET_OK;
}

static mmi_ret mmi_vdoply_switch_last_to_first_file_hdlr(mmi_event_struct *param)
{
	/* check if already exit player screen */
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return MMI_RET_OK;
    }
	
	if(cui_folder_browser_is_filelist_locked(g_vdoply_cntx.fmgr_scr_id))
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
	}
	
	mmi_vdoply_play_next_file_worked();
	return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_result_hdlr
 * DESCRIPTION
 *  seek result
 * PARAMETERS
 *  result      [IN]        Seek result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_result_hdlr(MDI_RESULT result, void *user_data)
{
	U32 i;
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* clear all pressed key */
	for(i=MMI_VDOPLY_TOUCH_CK; i<=MMI_VDOPLY_TOUCH_SPEED_DEC; i++)
		g_vdoply_cntx.touch_obj[i].is_press = MMI_FALSE;

    g_vdoply_cntx.is_seeking = MMI_FALSE;

	if(result == MDI_RES_VDOPLY_ERR_GET_FRAME_FAILED)
	{
		result = MDI_RES_VDOPLY_SUCCEED;
	}

    /* error check */
    if (mmi_vdoply_check_and_display_error_popup(result) == MMI_TRUE)       /* ture means has error popup */
    {
        return;
    }

    /* seek partial done */
    if (result == MDI_RES_VDOPLY_SEEK_PARTIAL_DONE)
    {
        /* get current play time */
        mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
    }

    /* enter next state */
    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_SEEKING:
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);
            break;

        case VDOPLY_STATE_PLAY_SEEKING:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;

        case VDOPLY_STATE_INTERRUPTED_SEEKING:
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_CONTINUE_PLAY) == MMI_TRUE)
            {
                VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_CONTINUE_PLAY);
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_PAUSE);
            }
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_SEEKING:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PAUSE);
            break;

        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }

            break;
		#endif
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    }
}

#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_key_release
 * DESCRIPTION
 *  seek key release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_KEY_RELEASE);  

    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);      


    switch (g_vdoply_cntx.state)
    {
            /* normal */
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
            mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);
            break;
        case VDOPLY_STATE_BT_CONNECTING:  
        case VDOPLY_STATE_PLAY:
            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);
            break;

		case VDOPLY_STATE_PLAY_SEEKING:
			mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);
			break;
			
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
		case VDOPLY_STATE_SEEKING:
			mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);
			break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
            /* full screen */
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PAUSE:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_SEEKING);
            break;
	 
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
        case VDOPLY_STATE_FULLSCR_PLAY:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY_SEEKING);
            break;
		#endif
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            break;

        case VDOPLY_STATE_STREAM_DISCONNECT:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);
            break;
            
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_BUFFERING: 
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            break;
        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            break;
            
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:  
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;   
			
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            break;  
		
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */ 

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
            mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);            
            break;
            
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:            
            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);  
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_SEEKING);            
            break;            
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:            
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY_SEEKING);  
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_PDL__ */
    
        default:
            MMI_ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward
 * DESCRIPTION
 *  seek foward
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_seek_foward(MMI_BOOL first_in)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	U64 jump_time;
	U64 total_time;
	U64 max_play_time;
	U64 cur_time;
	
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARND);	   
	
	cur_time = g_vdoply_cntx.cur_status.play_time;
	total_time = g_vdoply_cntx.video_info.total_time_duration;
	
	if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
	{
		max_play_time = g_vdoply_cntx.cur_status.max_play_time;
	}
	else
	{
		max_play_time = g_vdoply_cntx.video_info.total_time_duration;
	}
	
	if(cur_time < max_play_time)
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_TRUE;
		}
	}
	else
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_FALSE;
		}
	}
	
	if (cur_time < max_play_time)
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_TRUE;
		}
			
		jump_time = total_time / g_vdoply_cntx.progress.fill_width;
	
		if (jump_time == 0)
		{
			jump_time = 1;
		}
	
		jump_time <<= 3;
	
		if ((jump_time + cur_time) >= max_play_time)   /* time stamp is from 0 to total-1 */
		{
			cur_time = max_play_time;
		}
		else
		{
			cur_time += jump_time;
		}
	
		g_vdoply_cntx.cur_status.play_time = cur_time;
	
		if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
		{
			if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
			}
	
			mmi_vdoply_draw_panel_timer();
			mmi_vdoply_draw_panel_progress();
		}
		#ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
		else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
		{
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
		    
			if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
			}
				
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
		}
	    #endif
		mmi_vdoply_blt_screen();
	
		return MMI_TRUE;
	}
	else if (cur_time == max_play_time)
	{
		/* redraw button only */
		if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
		{
			if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
			}
	
			mmi_vdoply_draw_panel_timer();
			mmi_vdoply_draw_panel_progress();
		}
		else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
		{
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
		
			if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
			}
				
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
		}
		mmi_vdoply_blt_screen();
	}
	
	return MMI_FALSE;	/* reach limit, cant seek anymore */
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward_key_press_cyclic
 * DESCRIPTION
 *  right arrow long press timer hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_foward_key_press_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_vdoply_seek_foward(MMI_FALSE))
    {
        gui_start_timer(100, mmi_vdoply_seek_foward_key_press_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_right_arrow_key_press
 * DESCRIPTION
 *  right arrow press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_right_arrow_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	//kal_uint32 curTick,seekInterval;
	//curTick = kal_get_systicks();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
	if(isFirstSeek)
	{
		lastPressSeekKeyTime = curTick;
		isFirstSeek = MMI_FALSE;
	}
	else
	{
		seekInterval = curTick-lastPressSeekKeyTime;
		if(seekInterval<100)
		{
            //It's invalid seek press when the seek time interval is smaller than 100 ticks
			MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_PRESS_INVALID);
			isInvalidSeek = MMI_TRUE;
			return;
		}
		else
		{
			lastPressSeekKeyTime = curTick;
		}
	}
	*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_PRESS);      
	
	g_vdoply_cntx.is_switch_to_play_next_file = g_vdoply_cntx.is_entry_player_from_other_app ? MMI_FALSE : MMI_TRUE;

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_INC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = MMI_TRUE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if(g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press = MMI_TRUE;
    }
#endif
	mmi_vdoply_seek_key_press_to_do(MMI_TRUE);                   
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_fastforward
 * DESCRIPTION
 *  right arrow longpress release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_fastforward(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;
	if (mmi_vdoply_seek_foward(MMI_TRUE))
    {
        gui_start_timer(100, mmi_vdoply_seek_foward_key_press_cyclic);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_right_arrow_key_release
 * DESCRIPTION
 *  right arrow longpress release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_right_arrow_key_release(void)
{
    /*
	if(isInvalidSeek)
	{
        //It's invalid seek press when the seek time interval is smaller than 100 ticks
		MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_RELEASE_INVALID);
		isInvalidSeek = MMI_FALSE;
		return;
	}
	*/

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_RELEASE);  
	VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);	
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_PROGRESS_INC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
	{
		if(!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
		{
		    return;
		}
		g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = MMI_FALSE;
	}
	else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
	{
		if(!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press)
		{
		    return;
		}
		g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press = MMI_FALSE;
	}
#endif
	mmi_vdoply_seek_key_release_to_do();
	gui_cancel_timer(mmi_vdoply_seek_foward_key_press_cyclic);

	#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
	if(g_vdoply_cntx.is_switch_to_play_next_file)
	{
	
        g_vdoply_cntx.is_seeking = MMI_FALSE;
		MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__); 
		gui_start_timer(200, mmi_vdoply_play_next_file_worked);
		return;
	}
    #endif

    gui_start_timer(100, mmi_vdoply_seek_key_release);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward
 * DESCRIPTION
 *  seek backward
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_seek_backward(MMI_BOOL first_in)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	U64 jump_time;
	U64 total_time;
	U64 cur_time;
	
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD);	
	
	cur_time = g_vdoply_cntx.cur_status.play_time;
	total_time = g_vdoply_cntx.video_info.total_time_duration;
	
	if (cur_time > 0)
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return MMI_TRUE;
		}
			
		jump_time = total_time / g_vdoply_cntx.progress.fill_width;
	
		if (jump_time == 0)
		{
			jump_time = 1;
		}
	
		jump_time <<= 3;
	
		if (jump_time > cur_time)
		{
			cur_time = 0;
		}
		else
		{
			cur_time -= jump_time;
		}
	
		g_vdoply_cntx.cur_status.play_time = cur_time;
	
		if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
		{
			if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
			}
	
			mmi_vdoply_draw_panel_timer();
			mmi_vdoply_draw_panel_progress();
		}	
		#ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
		else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
		{
    	#ifdef __VDOPLY_FEATURE_FULLSCREEN__
			if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
			}
				
    	#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
		}
		#endif
		mmi_vdoply_blt_screen();
	
		return MMI_TRUE;
	}
	
	return MMI_FALSE;	/* reach limit, cant seek anymore */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward_key_press_cyclic
 * DESCRIPTION
 *  left arrow long press timer hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_backward_key_press_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_vdoply_seek_backward(MMI_FALSE))
    {
        gui_start_timer(100, mmi_vdoply_seek_backward_key_press_cyclic);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_left_arrow_key_press
 * DESCRIPTION
 *  left arrow press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_left_arrow_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //kal_uint32 curTick,seekInterval;
	//curTick = kal_get_systicks();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
	if(isFirstSeek)
	{
		lastPressSeekKeyTime = curTick;
		isFirstSeek = MMI_FALSE;
	}
	else
	{
		seekInterval = curTick-lastPressSeekKeyTime;
		if(seekInterval<100)
		{
            //It's invalid seek press when the seek time interval is smaller than 100 ticks
			MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_PRESS_INVALID);
			isInvalidSeek = MMI_TRUE;
			return;
		}
		else
		{
			lastPressSeekKeyTime = curTick;
		}
	}
	*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD_KEY_PRESS);
	g_vdoply_cntx.is_switch_to_play_next_file = g_vdoply_cntx.is_entry_player_from_other_app ? MMI_FALSE : MMI_TRUE;

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_DEC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = MMI_TRUE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if(g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press = MMI_TRUE;
    }   
#endif 
    mmi_vdoply_seek_key_press_to_do(MMI_FALSE);              
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_rewind
 * DESCRIPTION
 *  left arrow longpress release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_rewind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;

	if (mmi_vdoply_seek_backward(MMI_TRUE))
	{
		 gui_start_timer(100, mmi_vdoply_seek_backward_key_press_cyclic);
	}

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_right_arrow_key_release
 * DESCRIPTION
 *  right arrow longpress release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_left_arrow_key_release(void)
{
   /*
	if(isInvalidSeek)
	{
        //It's invalid seek press when the seek time interval is smaller than 100 ticks
		MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_RELEASE_INVALID);
		isInvalidSeek = MMI_FALSE;
		return;
	}
	*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD_KEY_RELEASE);
	VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);
	
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_DEC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = MMI_FALSE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press = MMI_FALSE;
    }
#endif
	mmi_vdoply_seek_key_release_to_do();
	gui_cancel_timer(mmi_vdoply_seek_backward_key_press_cyclic);
#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
	if(g_vdoply_cntx.is_switch_to_play_next_file)
	{
		g_vdoply_cntx.is_seeking = MMI_FALSE;
		gui_start_timer(200,mmi_vdoply_play_prev_file_worked);
		return;
	}
#endif

    gui_start_timer(200, mmi_vdoply_seek_key_release);

}

#else

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_key_release
 * DESCRIPTION
 *  seek key release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_KEY_RELEASE);  

    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);      


    switch (g_vdoply_cntx.state)
    {
            /* normal */
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
            mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);
            break;
            
        case VDOPLY_STATE_BT_CONNECTING:  
        case VDOPLY_STATE_PLAY:
            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);
            break;

		case VDOPLY_STATE_PLAY_SEEKING:
			mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);
			break;
			
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
		case VDOPLY_STATE_SEEKING:
			mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);
			break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
            /* full screen */
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PAUSE:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_SEEKING);
            break;

        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
        case VDOPLY_STATE_FULLSCR_PLAY:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY_SEEKING);
            break;
		#endif
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            break;

        case VDOPLY_STATE_STREAM_DISCONNECT:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);
            break;
            
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_BUFFERING:            
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            break;

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            break;
            
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:            
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;   

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            break;              
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */ 

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
            mmi_vdoply_enter_state(VDOPLY_STATE_SEEKING);            
            break;
            
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:            
            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY_SEEKING);  
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_SEEKING);            
            break;            
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:            
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY_SEEKING);  
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_PDL__ */
    
        default:
            MMI_ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward
 * DESCRIPTION
 *  seek foward
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_seek_foward(MMI_BOOL first_in)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U64 jump_time;
    U64 total_time;
    U64 max_play_time;
    U64 cur_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARND);      

    cur_time = g_vdoply_cntx.cur_status.play_time;
    total_time = g_vdoply_cntx.video_info.total_time_duration;

    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
        max_play_time = g_vdoply_cntx.cur_status.max_play_time;
    }
    else
    {
        max_play_time = g_vdoply_cntx.video_info.total_time_duration;
    }

	if(cur_time < max_play_time)
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_TRUE;
		}
	}
	else
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_FALSE;
		}
	}

    if (cur_time < max_play_time)
    {
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return KAL_TRUE;
		}
		
        jump_time = total_time / g_vdoply_cntx.progress.fill_width;

        if (jump_time == 0)
        {
            jump_time = 1;
        }

        jump_time <<= 3;

        if ((jump_time + cur_time) >= max_play_time)   /* time stamp is from 0 to total-1 */
        {
            cur_time = max_play_time;
        }
        else
        {
            cur_time += jump_time;
        }

        g_vdoply_cntx.cur_status.play_time = cur_time;

        if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
        {
             if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
            {
                /* change to pause state */
                g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
            }

            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();
        }
		#ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
        {
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
            {
                /* change to pause state */
                g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
            }
            
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        }
        #endif
        mmi_vdoply_blt_screen();

        return MMI_TRUE;
    }
    else if (cur_time == max_play_time)
    {
        /* redraw button only */
        if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
        {
             if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
            {
                /* change to pause state */
                g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
            }

            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();
        }
        else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
        {
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
            {
                /* change to pause state */
                g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
            }
            
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        }
        mmi_vdoply_blt_screen();
    }

    return MMI_FALSE;   /* reach limit, cant seek anymore */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward_key_press_cyclic
 * DESCRIPTION
 *  right arrow long press timer hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_foward_key_press_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;
    if (mmi_vdoply_seek_foward(MMI_FALSE))
    {
        gui_start_timer(100, mmi_vdoply_seek_foward_key_press_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward_key_press
 * DESCRIPTION
 *  right arrow press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_foward_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	kal_uint32 curTick,seekInterval;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	curTick = kal_get_systicks();
	if(isFirstSeek)
	{
		lastPressSeekKeyTime = curTick;
		isFirstSeek = MMI_FALSE;
	}
	else
	{ 
		seekInterval = curTick-lastPressSeekKeyTime;
		if(seekInterval<100)
		{
			/*It's invalid seek press when the seek time interval is smaller than 100 ticks */
			isInvalidSeek = MMI_TRUE;
			return;
		}
		else
		{
			lastPressSeekKeyTime = curTick;
		}
	}
	
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_PRESS);      
	g_vdoply_cntx.is_switch_to_play_next_file = g_vdoply_cntx.is_entry_player_from_other_app ? MMI_FALSE : MMI_TRUE;

    gui_cancel_timer(mmi_vdoply_seek_key_release);

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_INC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = MMI_TRUE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if(g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press = MMI_TRUE;
    }
#endif
    
	mmi_vdoply_seek_key_press_to_do(MMI_TRUE);                

    if (mmi_vdoply_seek_foward(MMI_TRUE))
    {
        gui_start_timer(200, mmi_vdoply_seek_foward_key_press_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_foward_key_release
 * DESCRIPTION
 *  right arrow release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_foward_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(isInvalidSeek)
	{
		/*It's invalid seek press when the seek time interval is smaller than 100 ticks   */
		isInvalidSeek = MMI_FALSE;
		return;
	}

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_FOWARD_KEY_RELEASE);      
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_PROGRESS_INC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
	{
		if(!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press)
		{
		    return;
		}
		g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = MMI_FALSE;
	}
	else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
	{
		if(!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press)
		{
		    return;
		}
		g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_INC].is_press = MMI_FALSE;
	}
#endif

	mmi_vdoply_seek_key_release_to_do();
#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
	if(g_vdoply_cntx.is_switch_to_play_next_file)
	{
		g_vdoply_cntx.is_seeking = MMI_FALSE;
		gui_cancel_timer(mmi_vdoply_seek_foward_key_press_cyclic);

		if(1)
		{
			SRV_FMGR_FILELIST_HANDLE hlist;
			S32 cur_index, index_saved, ret;
			srv_fmgr_fileinfo_struct info;
			WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];
			
			ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
			if(ret == 0)
			{
				index_saved = cur_index;
				g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
				if(g_vdoply_cntx.total_files > 1)
				{
					if(++cur_index == g_vdoply_cntx.total_files)
					{
						cur_index = 0;
					}
					cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
					ret = cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
					if(ret == SRV_FMGR_FILELIST_ERROR_FILE_NOT_READY)
					{
						srv_fmgr_filelist_load_file(hlist, cur_index, mmi_vdoply_switch_last_to_first_file_hdlr, NULL);
						cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
						//cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
						return;
					}
					cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
				}
			}
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		}
		mmi_vdoply_play_next_file_worked();
		return;
	}
#endif

    gui_cancel_timer(mmi_vdoply_seek_foward_key_press_cyclic);
    gui_start_timer(100, mmi_vdoply_seek_key_release);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward
 * DESCRIPTION
 *  seek backward
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_seek_backward(MMI_BOOL first_in)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	U64 jump_time;
	U64 total_time;
	U64 cur_time;

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD);	

	cur_time = g_vdoply_cntx.cur_status.play_time;
	total_time = g_vdoply_cntx.video_info.total_time_duration;

	if (cur_time > 0)
	{
		if(first_in && g_vdoply_cntx.is_switch_to_play_next_file)
		{
			return MMI_TRUE;
		}
		
		jump_time = total_time / g_vdoply_cntx.progress.fill_width;

		if (jump_time == 0)
		{
			jump_time = 1;
		}

		jump_time <<= 3;

		if (jump_time > cur_time)
		{
			cur_time = 0;
		}
		else
		{
			cur_time -= jump_time;
		}

		g_vdoply_cntx.cur_status.play_time = cur_time;

		if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
		{
			 if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
			}

			mmi_vdoply_draw_panel_timer();
			mmi_vdoply_draw_panel_progress();
		}
		#ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
		else if  (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
		{
    	#ifdef __VDOPLY_FEATURE_FULLSCREEN__
			if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
			{
				/* change to pause state */
				g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
			}
			
    	#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
		}
        #endif
		mmi_vdoply_blt_screen();

		return MMI_TRUE;
	}

	return MMI_FALSE;	/* reach limit, cant seek anymore */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward_key_press_cyclic
 * DESCRIPTION
 *  left arrow long press timer hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_backward_key_press_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;
    if (mmi_vdoply_seek_backward(MMI_FALSE))
    {
        gui_start_timer(100, mmi_vdoply_seek_backward_key_press_cyclic);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward_key_press
 * DESCRIPTION
 *  left arrow press hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_backward_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	kal_uint32 curTick,seekInterval;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	curTick = kal_get_systicks();
	if(isFirstSeek)
	{
		lastPressSeekKeyTime = curTick;
		isFirstSeek = MMI_FALSE;
	}
	else
	{
        seekInterval = curTick-lastPressSeekKeyTime;
		if(seekInterval<100)
		{
            /*It's invalid seek press when the seek time interval is smaller than 100 ticks */
			isInvalidSeek = MMI_TRUE;
			return;
		}
		else
		{
			lastPressSeekKeyTime = curTick;
		}
	}

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD_KEY_PRESS);
	g_vdoply_cntx.is_switch_to_play_next_file = g_vdoply_cntx.is_entry_player_from_other_app ? MMI_FALSE : MMI_TRUE;
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_DEC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = MMI_TRUE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if(g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press = MMI_TRUE;
    }
#endif
    
    mmi_vdoply_seek_key_press_to_do(MMI_FALSE);              

    if (mmi_vdoply_seek_backward(MMI_TRUE))
    {
        gui_start_timer(200, mmi_vdoply_seek_backward_key_press_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_seek_backward_key_release
 * DESCRIPTION
 *  left arrow release hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_seek_backward_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(isInvalidSeek)
	{
		/*It's invalid seek press when the seek time interval is smaller than 100 ticks */
		isInvalidSeek = MMI_FALSE;
		return;
	}

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SEEK_BACKWARD_KEY_RELEASE);
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);

#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_PROGRESS_DEC, MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC);
#else
	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        if(!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = MMI_FALSE;
    }
    else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_PROGRESS_DEC].is_press = MMI_FALSE;
    }
#endif

	mmi_vdoply_seek_key_release_to_do();
#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
	if(g_vdoply_cntx.is_switch_to_play_next_file)
	{
		g_vdoply_cntx.is_seeking = MMI_FALSE;
		gui_cancel_timer(mmi_vdoply_seek_backward_key_press_cyclic);

		if(1)
		{
			SRV_FMGR_FILELIST_HANDLE hlist;
			S32 cur_index, index_saved, ret;
			srv_fmgr_fileinfo_struct info;
			WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];
			
			ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
			if(ret == 0)
			{
				index_saved = cur_index;
				g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
				if(g_vdoply_cntx.total_files > 1)
				{
					if(--cur_index < 0)
					{
						cur_index = g_vdoply_cntx.total_files - 1;
					}
					cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
					ret = cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
					if(ret == SRV_FMGR_FILELIST_ERROR_FILE_NOT_READY)
					{
						srv_fmgr_filelist_load_file(hlist, cur_index, mmi_vdoply_switch_first_to_last_file_hdlr, NULL);
						cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
						//cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
						return;
					}
					cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
				}
			}
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		}
		
		mmi_vdoply_play_prev_file_worked();
		return;
	}
#endif
   
    gui_cancel_timer(mmi_vdoply_seek_backward_key_press_cyclic);
    gui_start_timer(200, mmi_vdoply_seek_key_release);
}

#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_lsk_press
 * DESCRIPTION
 *  lsk hdlr when pressed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_lsk_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_LSK, MMI_VDOPLY_FULL_TOUCH_LSK);
#else
	mmi_vdoply_sk_press_to_do(MMI_VDOPLY_TOUCH_LSK, MMI_VDOPLY_FULL_TOUCH_LSK);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_rsk_press
 * DESCRIPTION
 *  rsk hdlr when pressed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_rsk_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
    mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_RSK, MMI_VDOPLY_FULL_TOUCH_RSK);
#else
	mmi_vdoply_sk_press_to_do(MMI_VDOPLY_TOUCH_RSK, MMI_VDOPLY_FULL_TOUCH_RSK);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_ck_press
 * DESCRIPTION
 *  ck hdlr when pressed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_ck_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_CK, MMI_VDOPLY_FULL_TOUCH_CK);
#else
	mmi_vdoply_sk_press_to_do(MMI_VDOPLY_TOUCH_CK, MMI_VDOPLY_FULL_TOUCH_CK);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_ck_release
 * DESCRIPTION
 *  ck hdlr when release
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_ck_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    U64 cur_time;
	MDI_RESULT ret;
#endif
    FS_HANDLE fd;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable)
    {
        return;
    }

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {    
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press)
        {
            return;
        }
    }
#else
	#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_CK, MMI_VDOPLY_FULL_TOUCH_CK);
	#else
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {    
        if (!g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press)
        {
            return;
        }
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press = MMI_FALSE;
    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        if (!g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_CK].is_press)
        {
            return;
        }
        g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_CK].is_press = MMI_FALSE;
    }
	#endif
#endif

    if(g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE)
    {
        fd = FS_Open((const WCHAR *)g_vdoply_cntx.source_path,FS_READ_ONLY); 
        if(fd<0)
        {
	    cui_vdoply_close(GRP_ID_VDOPLY_SINGLE_PLAYER);
        }
        else
        {
            FS_Close(fd);
        }
    }
	
#ifdef __MMI_FTE_SUPPORT__
    mmi_vdoply_toggle_fullscreen_key_release();
    return;
#else
	#ifndef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ
    /* stop seek timer */
    gui_cancel_timer(mmi_vdoply_seek_key_release);
    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);      
    #endif

    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_IDLE:
			mmi_vdoply_draw_softkey_and_blt();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;

        case VDOPLY_STATE_PLAY:
			ret = mmi_vdoply_stop_video();        
			mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.video_info.total_time_duration)	                   
			{
			    g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;    
			}
			#ifdef __MAIN_LCM_SCANLINE_ROTATION_270__
			 	mdi_video_ply_seek_and_get_frame(g_vdoply_cntx.cur_status.play_time,g_vdoply_cntx.play_wnd_layer_handle);		
				mmi_vdoply_blt_screen();
			#endif
            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();

			mmi_vdoply_draw_softkey_and_blt();

            mdi_video_ply_get_cur_play_time(&cur_time);        
            if (cur_time < g_vdoply_cntx.cur_status.start_play_time || ret == MDI_RES_VDOPLY_ALREADY_FINISHED) 
            {
                /* 
                 *  this means driver already send out play finish indication, 
                 *  but MMI still not receive yet.
                 */
                if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE); 
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_IDLE); 
                }
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);
            }
            break;

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:  
			mmi_vdoply_draw_softkey_and_blt();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;

		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
        mmi_vdoply_stop_non_block_seeking();
			mmi_vdoply_draw_softkey_and_blt();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;

        case VDOPLY_STATE_BACKGROUND_CALL:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();            
            mmi_vdoply_display_not_available_popup(GRP_ID_VDOPLY_SINGLE_PLAYER);
            break;

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_BUFFERING:
            /* CK is disable in these states */
            break;
            
        case VDOPLY_STATE_STREAM_PLAY:

            mmi_vdoply_stop_video();                             

            /* get latest time */
            mdi_video_stream_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();

			mmi_vdoply_draw_softkey_and_blt();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
			break;
				
        case VDOPLY_STATE_STREAM_CONNECTED:
			mmi_vdoply_draw_softkey_and_blt();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }           
            break;
            
        case VDOPLY_STATE_STREAM_DISCONNECT: 
			mmi_vdoply_draw_softkey_and_blt();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);            
            break;            

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            /* ck is disable in these stats */
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:

            mmi_vdoply_stop_video();            

            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTED);
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_blt_screen();
            
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:  
            mmi_vdoply_blt_screen();
            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);    
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */
    #endif /* __MMI_VIDEO_STREAM__ */


    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            /* full screen */
	    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_IDLE:
            mmi_vdoply_blt_screen();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }

            break;

        case VDOPLY_STATE_FULLSCR_PAUSE:

            /* get latest time */
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_blt_screen();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }

            break;

        case VDOPLY_STATE_FULLSCR_PLAY:

            mmi_vdoply_stop_video();

            mdi_video_ply_get_cur_play_time(&cur_time);        
            mmi_vdoply_blt_screen();


            if(cur_time < g_vdoply_cntx.cur_status.start_play_time)
            {
                /* 
                 *  this means driver already send out play finish indication, 
                 *  but MMI still not receive yet.
                 */
                if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PAUSE); 
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_IDLE); 
                }
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PAUSE);
            }
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    }

    g_vdoply_cntx.is_seeking = MMI_FALSE;
#endif
}


#ifdef __DRM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_file_request_right_callback
 * DESCRIPTION
 *  request right callback
 * PARAMETERS
 *  result       [IN]       result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_file_request_right_callback(MMI_BOOL result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  

    if (result == MMI_FALSE)
    {
        /* if do not want right, exit player */
        cui_vdoply_evt_exit(MMI_FALSE, 0);
    }
    else
    {
        /* clear play time, so the bar will reset to start when come back */
        g_vdoply_cntx.cur_status.play_time = 0;
        g_vdoply_cntx.cur_status.start_play_time = 0;
    }
}
#endif /* __DRM_SUPPORT__ */


#ifdef __VDOPLY_FEATURE_FULLSCREEN__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_toggle_fullscreen_key_press
 * DESCRIPTION
 *  toggle to fullscreen display key press
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_fullscreen_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ 
	mmi_vdoply_key_press_to_do(MMI_VDOPLY_TOUCH_FULLSCREEN,MMI_VDOPLY_FULL_TOUCH_TOTAL);
#else
	g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_TRUE;

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        mmi_vdoply_draw_panel();
        /* MAUI_02595971 */
		mmi_vdoply_draw_softkey_and_blt();
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_toggle_fullscreen_key_release
 * DESCRIPTION
 *  toggle to fullscreen display key release
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_fullscreen_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_VDOPLY_SLIM_FOR_TOUCH_OBJ 
	mmi_vdoply_key_release_to_do(MMI_VDOPLY_TOUCH_FULLSCREEN,MMI_VDOPLY_FULL_TOUCH_TOTAL);
	if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
	{
		mmi_vdoply_draw_panel();
		mmi_vdoply_draw_softkey_and_blt();
	}	  
	mmi_vdoply_stop_non_block_seeking();
	mmi_vdoply_toggle_fullscreen_display();
#else
	if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press)
	{	 
		g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;
		
        /* cancel seek timer */    
        gui_cancel_timer(mmi_vdoply_seek_key_release);        
		#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
		gui_cancel_timer(mmi_vdoply_play_next_file_worked);
		gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
		#endif
        g_vdoply_cntx.is_seeking = MMI_FALSE;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);
        
        if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
        {
            mmi_vdoply_draw_panel();
            /* MAUI_02595971 */
			mmi_vdoply_draw_softkey_and_blt();
        }     
        mmi_vdoply_stop_non_block_seeking();
        mmi_vdoply_toggle_fullscreen_display();
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_toggle_fullscreen_display
 * DESCRIPTION
 *  toggle to fullscreen display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_fullscreen_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* flush key event */
    mmi_vdoply_clear_key_event();

    /* if is seeking, do not allowed toggle */
    if (g_vdoply_cntx.is_seeking == MMI_TRUE)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RETURN_FUCNTION, __LINE__);                  
        return;
    }
          
    switch (g_vdoply_cntx.state)
    {
            /* normal */
        case VDOPLY_STATE_PLAY:
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE);
            mmi_vdoply_update_layer_pause();
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            break;

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();

            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
            break;
        #endif

        case VDOPLY_STATE_IDLE:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
            break;

        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
            break;

        case VDOPLY_STATE_SEEKING:
            /* stop non-blocking seeking */
            mmi_vdoply_stop_non_block_seeking();
            
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
            break;

        case VDOPLY_STATE_PLAY_SEEKING:
            /* stop non-blocking seeking */
            mmi_vdoply_stop_non_block_seeking();
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }

            break;

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;
        #endif

        case VDOPLY_STATE_FULLSCR_PLAY:
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE);
            mmi_vdoply_update_layer_pause();
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            break;

        #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
            mmi_vdoply_stop_non_block_seeking();
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
            break;
		#endif

    #ifdef __MMI_VIDEO_STREAM__
    
        case VDOPLY_STATE_STREAM_DISCONNECT:  
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);
            break;

        case VDOPLY_STATE_STREAM_CONNECTING:
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);
            break;

        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
            mmi_vdoply_stop_animation();    
            mdi_video_stream_disconnect();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING);
            break;
            
        case VDOPLY_STATE_STREAM_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;
            
        case VDOPLY_STATE_STREAM_BUFFERING:
            gui_cancel_timer(mmi_vdoply_stream_buffering_cyclic);            
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            break;
            
        case VDOPLY_STATE_STREAM_PLAY:
            mdi_video_stream_pause();                
            mmi_vdoply_clear_aud_only_anim();  
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_PLAY);
            break;

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING: 
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING); 
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING); 
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);                        
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_clear_fullscr_aud_only_anim();               
            
            mdi_video_stream_pause();
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
            mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_PLAY);
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */        
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);      
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING);
            break;
            
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:    
            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);      
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING);
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
            gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);      
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_BUFFERING);
            break;
            
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:    
            gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);      
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
            break;            
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_PDL__ */
    
        default:
            //MMI_ASSERT(0);
            break;

    }

}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 


#ifdef MMI_VDOPLY_3D_ANAGLYPH
/*****************************************************************************
 * FUNCTION
 * mmi_vdoply_toggle_display_mode
 * DESCRIPTION
 *  register player's key event hdlr for different state
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_display_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_CONTINUE_PLAY);
    switch (g_vdoply_cntx.state)
    {
            /* normal */
        case VDOPLY_STATE_PLAY:
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_CONTINUE_PLAY);
            mmi_vdoply_stop_video();
            break;

        case VDOPLY_STATE_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();
            break;

        case VDOPLY_STATE_IDLE:
            break;

        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE: 
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_INTERRUPTED_SEEKING:
            mmi_vdoply_stop_non_block_seeking();
            break;

        case VDOPLY_STATE_PLAY_SEEKING:
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_CONTINUE_PLAY);
            mmi_vdoply_stop_non_block_seeking();
            
            break;    
        default:
            MMI_ASSERT(0);

    }

    mmi_vdoply_close_file();
    mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_OPENING);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_state_key_event
 * DESCRIPTION
 *  register player's key event hdlr for different state
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_mode_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_FALSE)
    {
        mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_3D_ONLY, MMI_EVENT_FAILURE);
        return;
    }
    
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press = MMI_TRUE;

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        mmi_vdoply_draw_panel_mode();
        mmi_vdoply_blt_screen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_state_key_event
 * DESCRIPTION
 *  register player's key event hdlr for different state
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_toggle_mode_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press)
    { 
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press = MMI_FALSE;

        if(g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_3D)
        {
            g_vdoply_cntx.play_mode = MDI_VIDEO_TRACK_2D_NORMAL;
        }
        else
        {
            g_vdoply_cntx.play_mode = MDI_VIDEO_TRACK_3D;
        }
    
        if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
        {
            mmi_vdoply_draw_panel_mode();
            mmi_vdoply_blt_screen();
        }     

        mmi_vdoply_toggle_display_mode();
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_state_key_event
 * DESCRIPTION
 *  register player's key event hdlr for different state
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_set_state_key_event(U16 state)
{
	U32 i;
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearInputEventHandler(MMI_DEVICE_KEY);    
    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_SEEKING_UI);

    /* dont let CK mapping to LSK */
	SetKeyDownHandler(mmi_vdoply_null_key_event, KEY_ENTER);

	//should keep mute usable status
	for(i=0; i<MMI_VDOPLY_TOUCH_MUTE; i++)
	{
		g_vdoply_cntx.touch_obj[i].is_usable = MMI_FALSE;
	}
	g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable = MMI_FALSE;
	for(i=0; i<MMI_VDOPLY_FULL_TOUCH_TOTAL; i++)
	{
		g_vdoply_cntx.full_touch_obj[i].is_usable = MMI_FALSE;
	}
	

#ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__
    switch (state)
    {     
		case VDOPLY_STATE_IDLE:
	    case VDOPLY_STATE_PAUSE:
	    case VDOPLY_STATE_PLAY:
	    case VDOPLY_STATE_INTERRUPTED_PAUSE:

		#ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
	    case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
        case VDOPLY_STATE_STREAM_DISCONNECT:
	    case VDOPLY_STATE_STREAM_CONNECTED:  
	    case VDOPLY_STATE_STREAM_BUFFERING:    
	    case VDOPLY_STATE_STREAM_PLAY:    
	    #endif

		#ifdef __MMI_VIDEO_PDL__
	    case VDOPLY_STATE_PROGRESSIVE_BUFFERING:    
	    case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
        #endif    
		    if ((state != VDOPLY_STATE_PLAY && state != VDOPLY_STATE_STREAM_PLAY) || 
                g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
			    SetKeyDownHandler(mmi_vdoply_play_button_pressed, KEY_CSK);
			    SetKeyUpHandler(mmi_vdoply_play_button_released, KEY_CSK);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable = MMI_TRUE;
		    }

        case VDOPLY_STATE_SEEKING:
	    case VDOPLY_STATE_PLAY_SEEKING:
        	#ifdef __VDOPLY_FEATURE_FULLSCREEN__
            //if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
            //    g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            { 
	            #if defined(__MMI_MAINLCD_320X240__) 
				SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_DOWN_ARROW);

				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;
		        
		    	#else /* __MMI_MAINLCD_320X240__ */ 
				SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_UP_ARROW);
		        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_key_release, KEY_UP_ARROW);

				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;

	            #endif /* __MMI_MAINLCD_320X240__ */
            }
			#endif  /* __VDOPLY_FEATURE_FULLSCREEN__ */
			#ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
			SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
			#else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);

				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;

				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);

				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
			#endif

			#ifdef __VDOPLY_FEATURE_VOLUME__
			mmi_vdoply_set_volume_key_event(); 

			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;
        	#endif /* __VDOPLY_FEATURE_VOLUME__ */

			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
            if ((g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
                 g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY) && 
                 !mdi_video_ply_is_drm_file())
            {     
                /* if has visual track, and not drm file, will be able to snapshot */
				SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, KEY_CAMERA);
                SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, KEY_CAMERA);

                if (VDOPLY_SNAP_EXTRA_KEY != -1)
                {
					SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, (U16)VDOPLY_SNAP_EXTRA_KEY);
                    SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, (U16)VDOPLY_SNAP_EXTRA_KEY);
                }
                
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_usable = MMI_TRUE;
            }
        	#endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 
		    /*break; not need break here*/

        case VDOPLY_STATE_BT_CONNECTING:
        	#ifdef MMI_VDOPLY_3D_ANAGLYPH
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE)==MMI_TRUE)
            {
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable = MMI_TRUE;
            }
        	#endif
            /*break; not need break here*/
            
        case VDOPLY_STATE_OPENING:
		case VDOPLY_STATE_INTERRUPTED_OPENING:
        
	    case VDOPLY_STATE_INTERRUPTED_SEEKING:
		case VDOPLY_STATE_BACKGROUND_CALL:
			
			
		#ifdef __MMI_VIDEO_STREAM__
	    case VDOPLY_STATE_STREAM_CONNECTING:
	    case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
		case VDOPLY_STATE_STREAM_BT_CONNECTING:
		#endif

		#ifdef __MMI_VIDEO_PDL__
		case VDOPLY_STATE_PROGRESSIVE_OPENING:
	    case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
		#endif
			#if defined(__MMI_MAINLCD_320X240__)
			SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_UP_ARROW);

			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable = MMI_TRUE;
			#else
			SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);

			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable = MMI_TRUE;
			#endif
		
			#ifdef __VDOPLY_FEATURE_LSK_OPTION__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);

			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;
			#endif

			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
	        SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);

			g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;
			break;

        case VDOPLY_STATE_FULLSCR_IDLE:  
	    case VDOPLY_STATE_FULLSCR_PAUSE:
	    case VDOPLY_STATE_FULLSCR_PLAY:
	    case VDOPLY_STATE_FULLSCR_BT_CONNECTING:        
	    case VDOPLY_STATE_FULLSCR_SEEKING:
	    case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
			
	    #ifdef __MMI_VIDEO_STREAM__
	    case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
	    case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:  
	    case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:      
	    case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:   
	    case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:   
	    case VDOPLY_STATE_STREAM_FULLSCR_PLAY:   
	    case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
		#endif

		#ifdef __MMI_VIDEO_PDL__
	    case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:        
	    case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
		#endif
        	#ifdef __VDOPLY_FEATURE_FULLSCREEN__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
        	#endif
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif

			#ifdef __VDOPLY_FEATURE_VOLUME__
			mmi_vdoply_set_volume_key_event();

            g_vdoply_cntx.touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
			g_vdoply_cntx.touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;
        	#endif /* __VDOPLY_FEATURE_VOLUME__ */
			break;
    }
#else
    switch (state)
    {
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PLAY:
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;

			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

			SetKeyDownHandler(mmi_vdoply_ck_press, KEY_ENTER);
            SetKeyUpHandler(mmi_vdoply_ck_release, KEY_ENTER);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable = MMI_TRUE;

        #ifdef __VDOPLY_FEATURE_VOLUME__
			SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;  
       #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable = MMI_TRUE;
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable = MMI_TRUE; 

		#ifdef __MMI_FTE_SUPPORT__
			SetKeyDownHandler(mmi_vdoply_play_button_pressed, KEY_UP_ARROW);
            SetKeyUpHandler(mmi_vdoply_play_button_released, KEY_UP_ARROW);
            SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
            SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);
		#else /* __MMI_FTE_SUPPORT__ */
        #ifdef __VDOPLY_FEATURE_SPEED__
            if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
                g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            {        
				SetKeyDownHandler(mmi_vdoply_speed_inc_key_press, KEY_UP_ARROW);
                SetKeyUpHandler(mmi_vdoply_speed_inc_key_release, KEY_UP_ARROW);
                SetKeyDownHandler(mmi_vdoply_speed_dec_key_press, KEY_DOWN_ARROW);
                SetKeyUpHandler(mmi_vdoply_speed_dec_key_release, KEY_DOWN_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_usable = MMI_TRUE;                 
            }
        #endif /* __VDOPLY_FEATURE_SPEED__ */ 
		#endif /* __MMI_FTE_SUPPORT__ */
        #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
			SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
		#else  
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
              	SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE; 
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;                   
            }
        #endif
        #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            if ((g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
                 g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY) && 
                 !mdi_video_ply_is_drm_file())
            {     
                /* if has visual track, and not drm file, will be able to snapshot */
				SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, KEY_CAMERA);
                SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, KEY_CAMERA);

                if (VDOPLY_SNAP_EXTRA_KEY != -1)
                {
                  	SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, (U16)VDOPLY_SNAP_EXTRA_KEY);
                    SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, (U16)VDOPLY_SNAP_EXTRA_KEY);
                }
                
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_usable = MMI_TRUE;
            }
        #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            //if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
            //    g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            {           
            	#ifndef __MMI_FTE_SUPPORT__
				SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_STAR);
                SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_key_release, KEY_STAR);
            	#endif
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;            
            }
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

	#ifdef MMI_VDOPLY_3D_ANAGLYPH
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE)==MMI_TRUE)
            {
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable = MMI_TRUE;
            }
        #endif
            break;
		
		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
			#ifdef __VDOPLY_FEATURE_LSK_OPTION__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;
			#endif

			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;


        #ifdef __VDOPLY_FEATURE_VOLUME__
			SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;  
       #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable = MMI_TRUE; 
		#ifdef __MMI_FTE_SUPPORT__
			SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
            SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);
		#else /* __MMI_FTE_SUPPORT__ */
        #ifdef __VDOPLY_FEATURE_SPEED__
            if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
                g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            {        
				SetKeyDownHandler(mmi_vdoply_speed_inc_key_press, KEY_UP_ARROW);
                SetKeyUpHandler(mmi_vdoply_speed_inc_key_release, KEY_UP_ARROW);
                SetKeyDownHandler(mmi_vdoply_speed_dec_key_press, KEY_DOWN_ARROW);
                SetKeyUpHandler(mmi_vdoply_speed_dec_key_release, KEY_DOWN_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_usable = MMI_TRUE;                 
            }
        #endif /* __VDOPLY_FEATURE_SPEED__ */ 
		#endif /* __MMI_FTE_SUPPORT__ */
        #ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
			SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
		#else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
                SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE; 
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;                   
            }
		#endif

	#ifdef MMI_VDOPLY_3D_ANAGLYPH
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE)==MMI_TRUE)
            {
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable = MMI_TRUE;
            }
        #endif
            break;

        case VDOPLY_STATE_BACKGROUND_CALL:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:            
            {
                SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
	        	SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;
                 
                /* exit */
                SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
	        	SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

                SetKeyDownHandler(mmi_vdoply_ck_press, KEY_ENTER);
                SetKeyUpHandler(mmi_vdoply_ck_release, KEY_ENTER);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable = MMI_TRUE;
            #ifdef __VDOPLY_FEATURE_VOLUME__
				SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            	SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            	SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            	SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;        
            #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable = MMI_TRUE; 
            }
            break;


        case VDOPLY_STATE_BT_CONNECTING:  
        #ifdef __VDOPLY_FEATURE_LSK_OPTION__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;
        #endif 
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;
			#ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
			SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
						
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);			
						
			if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
			{
							
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
			
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
			}
			#else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
                SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE; 
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;                   
            }
            #endif
	#ifdef MMI_VDOPLY_3D_ANAGLYPH
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE)==MMI_TRUE)
            {
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_usable = MMI_TRUE;
            }
        #endif
            break;

        case VDOPLY_STATE_OPENING:
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;
            
			#ifdef __VDOPLY_FEATURE_LSK_OPTION__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;            
			#endif
            break;
            
        case VDOPLY_STATE_INTERRUPTED_OPENING:
            /* do nothing */
            break;


    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_PLAY:
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;

			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

            
			SetKeyDownHandler(mmi_vdoply_ck_press, KEY_ENTER);
            SetKeyUpHandler(mmi_vdoply_ck_release, KEY_ENTER);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable = MMI_TRUE;
            
        #ifdef __VDOPLY_FEATURE_VOLUME__
            SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;          
        #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
		#ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
			SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
					
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);	
					
			if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
			{
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
			
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
			}
		#else

            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE; 
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;     
            }
        #endif
	    #ifdef __MMI_FTE_SUPPORT__
            SetKeyDownHandler(mmi_vdoply_play_button_pressed, KEY_UP_ARROW);
            SetKeyUpHandler(mmi_vdoply_play_button_released, KEY_UP_ARROW);
            SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
            SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);
		#endif

        #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            if ((g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
                 g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY) && 
                 !mdi_video_stream_is_drm_streaming())
            {
                /* if has visual track, and not drm file, will be able to snapshot */                
				SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, KEY_CAMERA);
                SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, KEY_CAMERA);
                
                if (VDOPLY_SNAP_EXTRA_KEY != -1)
                {
					SetKeyDownHandler(mmi_vdoply_player_snapshot_key_press, (U16)VDOPLY_SNAP_EXTRA_KEY);
                    SetKeyUpHandler(mmi_vdoply_player_snapshot_key_release, (U16)VDOPLY_SNAP_EXTRA_KEY);
                }                
                
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_usable = MMI_TRUE;
            }
        #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            //if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
            //    g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            {                                        
            	#ifndef __MMI_FTE_SUPPORT__
				SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_STAR);
                SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_key_release, KEY_STAR);
            	#endif
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;                    
            }
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
        break;
        
        case VDOPLY_STATE_STREAM_CONNECTED:
        case VDOPLY_STATE_STREAM_DISCONNECT:

			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;

			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

            #ifdef __MMI_FTE_SUPPORT__
			SetKeyDownHandler(mmi_vdoply_play_button_pressed, KEY_UP_ARROW);
            SetKeyUpHandler(mmi_vdoply_play_button_released, KEY_UP_ARROW);
		    #else /* __MMI_FTE_SUPPORT__ */
            SetKeyDownHandler(mmi_vdoply_ck_press, KEY_ENTER);
            SetKeyUpHandler(mmi_vdoply_ck_release, KEY_ENTER);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable = MMI_TRUE;
			#endif /* __MMI_FTE_SUPPORT__ */
            break;

        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
            SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

            #ifdef __VDOPLY_FEATURE_LSK_OPTION__
            SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;      
			#endif

			#ifdef __MMI_FTE_SUPPORT__
			SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
            SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);
		    #endif /* __MMI_FTE_SUPPORT__ */
            break;

        case VDOPLY_STATE_STREAM_BUFFERING:
        case VDOPLY_STATE_STREAM_BT_CONNECTING:            
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;

            #ifdef __VDOPLY_FEATURE_LSK_OPTION__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;      
			#endif

			#ifdef __MMI_FTE_SUPPORT__
			SetKeyDownHandler(mmi_vdoply_stop_button_pressed, KEY_DOWN_ARROW);
            SetKeyUpHandler(mmi_vdoply_stop_button_released, KEY_DOWN_ARROW);
		    #endif /* __MMI_FTE_SUPPORT__ */
            #ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
            SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);	
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
			#else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;    
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;           
            }
			#endif
            break;
    #endif /* __MMI_VIDEO_STREAM__ */
        
            /* Full Screen */
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PLAY:
        case VDOPLY_STATE_FULLSCR_PAUSE:
		#ifdef __VDOPLY_FEATURE_FULLSCREEN__
			#ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #else            
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK,);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #endif
        #ifdef __VDOPLY_FEATURE_VOLUME__
            SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
            g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
            g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;              
        #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
        #endif
            break;

        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__  
            #ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #else
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK,);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
			    SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #endif
        
        #endif
            break;


        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT: 
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__ 
            #ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
			    SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #else
            SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK,);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #endif
        #ifdef __VDOPLY_FEATURE_VOLUME__
            SetKeyDownHandler(mmi_vdoply_vol_up_key_press, KEY_VOL_UP);
            SetKeyUpHandler(mmi_vdoply_vol_up_key_release, KEY_VOL_UP);
            SetKeyDownHandler(mmi_vdoply_vol_down_key_press, KEY_VOL_DOWN);
            SetKeyUpHandler(mmi_vdoply_vol_down_key_release, KEY_VOL_DOWN);
            g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_DEC].is_usable = MMI_TRUE;
            g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_VOLUME_INC].is_usable = MMI_TRUE;              
        #endif /* __VDOPLY_FEATURE_VOLUME__ */ 
        #endif  /* __VDOPLY_FEATURE_FULLSCREEN__ */
            break;

        case VDOPLY_STATE_FULLSCR_SEEKING:
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.full_touch_obj[MMI_VDOPLY_FULL_TOUCH_RSK].is_usable = MMI_TRUE;            

            //if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
            //    g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            { 
            #ifndef __MMI_FTE_SUPPORT__
                SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_STAR);
                SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_key_release, KEY_STAR);
			#endif

                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;                   
            }
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
            break;            


        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:            
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            #ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #else
            SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK,);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #endif
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */         
            break;         


        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
        #ifdef __MMI_VIDEO_PDL__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);  
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;    
        
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;      
        #endif /* __MMI_VIDEO_PDL__ */
            break;

        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
		#ifdef __MMI_VIDEO_PDL__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;    
        
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;      
        #ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
            SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
		#else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
                SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;  
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;     
            }
                    
		#endif
        #endif /* __MMI_VIDEO_PDL__ */
            break;
			
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:            
        #ifdef __MMI_VIDEO_PDL__
			SetKeyDownHandler(mmi_vdoply_lsk_press, KEY_LSK);
            SetKeyUpHandler(mmi_vdoply_lsk_release, KEY_LSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_usable = MMI_TRUE;    
        
			SetKeyDownHandler(mmi_vdoply_rsk_press, KEY_RSK);
            SetKeyUpHandler(mmi_vdoply_rsk_release, KEY_RSK);
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_usable = MMI_TRUE;      

		    #ifdef MMI_VDOPLY_FEATURE_LONGPRESS	
            SetKeyDownHandler(mmi_vdoply_left_arrow_key_press, KEY_LEFT_ARROW);
			SetKeyDownHandler(mmi_vdoply_right_arrow_key_press, KEY_RIGHT_ARROW);
			
            SetKeyUpHandler(mmi_vdoply_left_arrow_key_release, KEY_LEFT_ARROW);
            SetKeyUpHandler(mmi_vdoply_right_arrow_key_release, KEY_RIGHT_ARROW);
			
			  if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
				SetKeyLongpressHandler(mmi_vdoply_rewind, KEY_LEFT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
	
				SetKeyLongpressHandler(mmi_vdoply_fastforward, KEY_RIGHT_ARROW);
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;
				g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;
            }
            #else
            if (g_vdoply_cntx.is_progress_seekable == MMI_TRUE)
            {
                SetKeyDownHandler(mmi_vdoply_seek_backward_key_press, KEY_LEFT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_backward_key_release, KEY_LEFT_ARROW);
				SetKeyDownHandler(mmi_vdoply_seek_foward_key_press, KEY_RIGHT_ARROW);
				SetKeyUpHandler(mmi_vdoply_seek_foward_key_release, KEY_RIGHT_ARROW);
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_usable = MMI_TRUE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_usable = MMI_TRUE;  
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_usable = MMI_TRUE;     
            }
            #endif

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            //if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV ||
            //    g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
            {
            #ifndef __MMI_FTE_SUPPORT__
                SetKeyDownHandler(mmi_vdoply_toggle_fullscreen_key_press, KEY_STAR);
                SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_key_release, KEY_STAR);
            #endif
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_usable = MMI_TRUE;                   
            }
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */        
        
        #endif /* __MMI_VIDEO_PDL__ */
            break;
        
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:        
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
        #ifdef __MMI_VIDEO_PDL__
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            #ifdef __MMI_QWERTY_KEYPAD_SUPPORT__
			SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #else
            SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_1);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_2);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_3);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_4);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_5);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_6);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_7);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_8);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_9);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_0);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_POUND);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LSK);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RSK,);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_ENTER);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_LEFT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_RIGHT_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_UP_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_DOWN_ARROW);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CLEAR);
	        SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_STAR);
			#ifdef __VDOPLY_FEATURE_SNAPSHOT__
				SetKeyUpHandler(mmi_vdoply_toggle_fullscreen_display, KEY_CAMERA);
			#endif
            #endif
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        #endif /* __MMI_VIDEO_PDL__ */
            break;
    } 
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_state_layer_config
 * DESCRIPTION
 *  set layer configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_set_state_layer_config(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	GDI_HANDLE play_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* enter next state */
    switch (state)
    {
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PLAY:       
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:  
        case VDOPLY_STATE_INTERRUPTED_SEEKING:
        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_DISCONNECT: 
        case VDOPLY_STATE_STREAM_CONNECTED: 
        case VDOPLY_STATE_BACKGROUND_CALL:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:        
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:  
            gdi_lcd_set_rotate(g_vdoply_cntx.normal_style_rotate);

        #ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
            /* newer cip has layer bg color, we can split bg into smaller region for better performance */
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_region_0_layer_handle, 
                g_vdoply_cntx.bg_region_1_layer_handle,             
                g_vdoply_cntx.play_wnd_layer_handle, 
                0);
        #else 
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_layer_handle, 
                g_vdoply_cntx.play_wnd_layer_handle, 
                g_vdoply_cntx.status_bar_layer_handle, 
                0);
        #endif            
            break;

        case VDOPLY_STATE_OPENING:
        case VDOPLY_STATE_INTERRUPTED_OPENING:
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING: 
        #ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__
            play_layer = GDI_NULL_HANDLE;
        #else
		    play_layer = g_vdoply_cntx.play_wnd_layer_handle;
		#endif
		#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
        #ifdef GDI_6_LAYERS
            /* newer cip has layer bg color, we can split bg into smaller region for better performance */   
            gdi_layer_set_blt_layer_ext(
                g_vdoply_cntx.bg_region_0_layer_handle, 
                g_vdoply_cntx.bg_region_1_layer_handle, 
                play_layer,
                g_vdoply_cntx.process_layer_handle,
                GDI_NULL_HANDLE,
                GDI_NULL_HANDLE);
        #else /* GDI_6_LAYERS */      
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_region_0_layer_handle, 
                g_vdoply_cntx.bg_region_1_layer_handle,  
                play_layer,
                g_vdoply_cntx.process_layer_handle);
        #endif /* GDI_6_LAYERS */
        #else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */   
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_layer_handle, 
                play_layer, 
                g_vdoply_cntx.process_layer_handle,
                g_vdoply_cntx.status_bar_layer_handle);                
        #endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
            break;

        case VDOPLY_STATE_SNAPSHOT: 
        case VDOPLY_STATE_BT_CONNECTING:
        case VDOPLY_STATE_STREAM_BT_CONNECTING: 
        case VDOPLY_STATE_STREAM_BUFFERING: 
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:            
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:        
            gdi_lcd_set_rotate(g_vdoply_cntx.normal_style_rotate);
		#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
        #ifdef GDI_6_LAYERS
            /* newer cip has layer bg color, we can split bg into smaller region for better performance */   
            gdi_layer_set_blt_layer_ext(
                g_vdoply_cntx.bg_region_0_layer_handle, 
                g_vdoply_cntx.bg_region_1_layer_handle, 
                g_vdoply_cntx.play_wnd_layer_handle,
                g_vdoply_cntx.process_layer_handle,
                GDI_NULL_HANDLE,
                GDI_NULL_HANDLE);
        #else /* GDI_6_LAYERS */      
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_region_0_layer_handle, 
                g_vdoply_cntx.bg_region_1_layer_handle,  
                g_vdoply_cntx.play_wnd_layer_handle,
                g_vdoply_cntx.process_layer_handle);
        #endif /* GDI_6_LAYERS */
        #else /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */   
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.bg_layer_handle, 
                g_vdoply_cntx.play_wnd_layer_handle, 
                g_vdoply_cntx.process_layer_handle,
                g_vdoply_cntx.status_bar_layer_handle);                
        #endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
            break;
    
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /******************************************/
        /*              Full Screen               */
        /******************************************/
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PLAY: 
        case VDOPLY_STATE_FULLSCR_PAUSE:  
        case VDOPLY_STATE_FULLSCR_SEEKING:
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:   
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
        #ifdef __VDOPLY_FEATURE_LANDSCAPE_LCD__
            /* landscape */
            gdi_lcd_set_rotate(GDI_LAYER_ROTATE_0);
        #else /* __VDOPLY_FEATURE_LANDSCAPE_LCD__ */
            /* not landscape */
            gdi_lcd_set_rotate(GDI_LAYER_ROTATE_270);     
	    #endif /* __VDOPLY_FEATURE_LANDSCAPE_LCD__ */   

            gdi_layer_set_blt_layer(
                g_vdoply_cntx.fullscr_play_layer_handle, 
                0, 
                0, 
                0);
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:            
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:            
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:           
        #ifdef __VDOPLY_FEATURE_LANDSCAPE_LCD__
            /* landscape */
            gdi_lcd_set_rotate(GDI_LAYER_ROTATE_0);
        #else /* __VDOPLY_FEATURE_LANDSCAPE_LCD__ */
            gdi_lcd_set_rotate(GDI_LAYER_ROTATE_270);
        
	    #endif /* __VDOPLY_FEATURE_LANDSCAPE_LCD__ */   
            /* 
             *  connecting and loading state dont have video performance problem,
             *  we will show the connecting or loading bar 
             */
            gdi_layer_set_blt_layer(
                g_vdoply_cntx.fullscr_play_layer_handle, 
                g_vdoply_cntx.fullscr_process_layer_handle, 
                0, 
                0);
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_clear_key_event
 * DESCRIPTION
 *  clear key event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_clear_key_event(void)
{
	U32 i;
#ifdef __VDOPLY_FEATURE_VOLUME__
    gui_cancel_timer(mmi_vdoply_vol_up_cyclic);
    gui_cancel_timer(mmi_vdoply_vol_down_cyclic);
#endif

    /* flush key event */
    ClearKeyEvents();
#ifdef __MMI_TOUCH_SCREEN__
    mmi_pen_reset();
#endif

    /* reset key state */
	for(i=0; i<MMI_VDOPLY_TOUCH_TOTAL; i++)
		g_vdoply_cntx.touch_obj[i].is_press = MMI_FALSE;
	for(i=0; i<MMI_VDOPLY_FULL_TOUCH_TOTAL; i++)
		g_vdoply_cntx.full_touch_obj[i].is_press = MMI_FALSE;
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_state_softkey
 * DESCRIPTION
 *  set softkey based on state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_set_state_softkey(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __VDOPLY_FEATURE_CROSS_LAYEROUT__
    /* enter next state */
    switch (state)
    {
        /***********/
        case VDOPLY_STATE_EXIT:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
            #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                if (g_vdoply_cntx.cur_status.play_time == 0)
                {
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PLAY),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
                }
                else
                {
                    mmi_vdoply_set_softkey(
                        (CHAR*)GetString(STR_GLOBAL_CONTINUE),
                        (CHAR*)GetString(STR_GLOBAL_BACK),
                        0,
                        0,
                        IMG_ID_VDOPLY_CK_PLAY);
                }
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;

           
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_BACKGROUND_CALL:                           
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                        NULL,
                        NULL,
                        IMG_ID_VDOPLY_LSK_OPTION,
                        IMG_ID_VDOPLY_RSK_BACK,
                        IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
                /* [Touch][Option] */
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
            #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                /* [Touch] */
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PLAY),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;


        /***********/
        case VDOPLY_STATE_PLAY:
        case VDOPLY_STATE_BT_CONNECTING:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Option] */
                #ifdef __MMI_FTE_SUPPORT__
            mmi_vdoply_set_softkey(
                        NULL,
                        NULL,
                        IMG_ID_VDOPLY_LSK_OPTION,
                        IMG_ID_VDOPLY_RSK_BACK,
                        IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PAUSE);
            #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PAUSE),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PAUSE);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;


        /***********/
        case VDOPLY_STATE_PAUSE:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                        NULL,
                        NULL,
                        IMG_ID_VDOPLY_LSK_OPTION,
                        IMG_ID_VDOPLY_RSK_BACK,
                        IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_RESUME);
                #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_CONTINUE),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_RESUME);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */   
            }
            break;


        /***********/
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_RESUME);
                #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_CONTINUE),
                    (CHAR*) GetString(STR_GLOBAL_STOP),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_RESUME);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;

        /***********/
        case VDOPLY_STATE_OPENING:
            {
    #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                if (g_vdoply_cntx.cur_status.play_time == 0)
                {            
                    /* [Touch][Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                    mmi_vdoply_set_softkey(
                        (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                        (CHAR*) GetString(STR_GLOBAL_BACK),
                        0,
                        0,
                        IMG_ID_VDOPLY_CK_PLAY);
                #endif
                }               
    #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                if (g_vdoply_cntx.cur_status.play_time == 0)
                {
                   mmi_vdoply_set_softkey(
                        (CHAR*) GetString(STR_GLOBAL_PLAY),
                        (CHAR*) GetString(STR_GLOBAL_BACK),
                        0,
                        0,
                        IMG_ID_VDOPLY_CK_PLAY);
                }               
    #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;
            
        case VDOPLY_STATE_INTERRUPTED_OPENING:
            {
    #if defined(__VDOPLY_FEATURE_LSK_OPTION__)

                {
                    /* [Touch][Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                    mmi_vdoply_set_softkey(
                        (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                        (CHAR*) GetString(STR_GLOBAL_STOP),
                        0,
                        0,
                        IMG_ID_VDOPLY_CK_PLAY);
                #endif
                }
    #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                {
                    mmi_vdoply_set_softkey(
                        (CHAR*)GetString(STR_GLOBAL_CONTINUE),
                        (CHAR*)GetString(STR_GLOBAL_BACK),
                        0,
                        0,
                        IMG_ID_VDOPLY_CK_PLAY);
                }
    #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;
      


        /***********/
        case VDOPLY_STATE_INTERRUPTED_SEEKING:
        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
            break;
        
    /*******************************/
    /*******    Fullscreen  ********/
    /*******************************/  
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /***********/    
        case VDOPLY_STATE_FULLSCR_PLAY:
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:            
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 


    /*******************************/
    /*******    Streaming   ********/
    /*******************************/  
    #ifdef __MMI_VIDEO_STREAM__
        /***********/        
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
            /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
            mmi_vdoply_set_softkey(
                (CHAR*)GetString(STR_GLOBAL_OPTIONS),
                (CHAR*)GetString(STR_GLOBAL_STOP),
                0,
                0,
                IMG_ID_VDOPLY_CK_PLAY);
            #endif
            break;

        case VDOPLY_STATE_STREAM_CONNECTED:     
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
            /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
            mmi_vdoply_set_softkey(
                (CHAR*)GetString(STR_GLOBAL_OPTIONS),
                (CHAR*)GetString(STR_GLOBAL_BACK),
                0,
                0,
                IMG_ID_VDOPLY_CK_PLAY);
            #endif
            break;
 
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_BT_CONNECTING:             
            /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
            mmi_vdoply_set_softkey(
                (CHAR*)GetString(STR_GLOBAL_OPTIONS),
                (CHAR*)GetString(STR_GLOBAL_STOP),
                0,
                0,
                IMG_ID_VDOPLY_CK_PAUSE);
            #endif
            break;            

        case VDOPLY_STATE_STREAM_BUFFERING:
            /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
            mmi_vdoply_set_softkey(
                (CHAR*)GetString(STR_GLOBAL_OPTIONS),
                (CHAR*)GetString(STR_GLOBAL_STOP),
                0,
                0,
                IMG_ID_VDOPLY_CK_PLAY);
            #endif
            break;       
           
        case VDOPLY_STATE_STREAM_DISCONNECT:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:            
            /* [Touch][Option] */
            #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
            #else
            mmi_vdoply_set_softkey(
                (CHAR*)GetString(STR_GLOBAL_OPTIONS),
                (CHAR*)GetString(STR_GLOBAL_BACK),
                0,
                0,
                IMG_ID_VDOPLY_CK_PLAY);
            #endif
            break;            

   
         /***********/        
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:     
            break;      

        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:             
            break;  

        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:     
            break;            

        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:  
            break;            
   
    #endif /* __MMI_VIDEO_STREAM__ */

    /*******************************/
    /******* Progressive DL ********/
    /*******************************/    
    #ifdef __MMI_VIDEO_PDL__
        /***********/       
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Touch][Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
                #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                /* [Touch] */
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PLAY),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;

        /***********/       
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:        
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Touch][Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
                #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                /* [Touch] */
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PLAY),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PLAY);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;

     
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
            {
            #if defined(__VDOPLY_FEATURE_LSK_OPTION__)
                /* [Touch][Option] */
                #ifdef __MMI_FTE_SUPPORT__
                mmi_vdoply_set_softkey(
                    0,
                    0,
                    IMG_ID_VDOPLY_LSK_OPTION,
                    IMG_ID_VDOPLY_RSK_BACK,
                    IMG_ID_VDOPLY_TOUCH_OSD_FULLSCREEN);
                #else
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_OPTIONS),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PAUSE);
                #endif
            #else /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
                /* [Touch] */
                mmi_vdoply_set_softkey(
                    (CHAR*) GetString(STR_GLOBAL_PAUSE),
                    (CHAR*) GetString(STR_GLOBAL_BACK),
                    0,
                    0,
                    IMG_ID_VDOPLY_CK_PAUSE);
            #endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 
            }
            break;

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
              break;
              
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
              break;  
			#endif
    #endif /*   __MMI_VIDEO_PDL__ */
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_calc_progress_ratio
 * DESCRIPTION
 *  set layer configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_calc_progress_ratio(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U64 play_time;
	S32 fill_width = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    play_time = g_vdoply_cntx.cur_status.play_time;

    if (play_time > g_vdoply_cntx.video_info.total_time_duration)
    {
        g_vdoply_cntx.video_info.total_time_duration = play_time;
    }

	if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
		fill_width = g_vdoply_cntx.progress.fill_width;
	else if(g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
		fill_width = g_vdoply_cntx.fullscr_progress.fill_width;
	else
		MMI_ASSERT(0);

	if(g_vdoply_cntx.video_info.total_time_duration != 0)
	{
		g_vdoply_cntx.cur_status.play_ratio = (U32)(play_time * fill_width / g_vdoply_cntx.video_info.total_time_duration);
	#ifdef __MMI_VIDEO_PDL__
		g_vdoply_cntx.cur_status.buff_ratio = (U32)(g_vdoply_cntx.cur_status.max_play_time * fill_width / g_vdoply_cntx.video_info.total_time_duration); 
	#endif
	}
	else
	{
		g_vdoply_cntx.cur_status.play_ratio = 0;
	#ifdef __MMI_VIDEO_PDL__
		g_vdoply_cntx.cur_status.buff_ratio = 0;	
	#endif
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_general_state
 * DESCRIPTION
 *  state transition function
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_enter_general_state(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    vdoply_ui_type_neum prev_ui_type;
    mdi_video_info_struct video_info;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_ui_type = g_vdoply_cntx.ui_type;
	g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;
    g_vdoply_cntx.state = state;
	    
    switch (state)
    {
        case VDOPLY_STATE_IDLE:           
            g_vdoply_cntx.cur_status.start_play_time = 0;
            g_vdoply_cntx.cur_status.play_time = 0;

			#ifndef __MDI_DISPLAY_RGB565_SUPPORT__  //
			if(g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV || g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
			{
				gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
				gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
				gdi_layer_pop_and_restore_active();
			}
			#endif	
            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
			#endif
                mmi_vdoply_redraw_normal();
            }
            else
            {
            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
                mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #else
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #endif
            }

            gui_cancel_timer(mmi_vdoply_player_timer_cyclic);

            ret = mdi_video_ply_seek_and_get_frame(
                    g_vdoply_cntx.cur_status.play_time,
                    g_vdoply_cntx.play_wnd_layer_handle);
			if(ret == MDI_RES_VDOPLY_ERR_GET_FRAME_FAILED)
			{
				ret = MDI_RES_VDOPLY_SUCCEED;
			}
			if(ret == MDI_RES_VDOPLY_SUCCEED)
			{
				/* draw aud only anim */
	            if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
	            {
	                if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
	                {
	                    mmi_vdoply_draw_aud_only_anim();
	                }
				   #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
	                else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
	                {
	                #ifdef __VDOPLY_FEATURE_FULLSCREEN__
	                    mmi_vdoply_draw_fullscr_aud_only_anim();
	                #endif 
	                }               
					#endif
	            }
			}
            mmi_vdoply_blt_screen();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();

            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
            {
                return;
            }
            break;

        case VDOPLY_STATE_PLAY:  
            if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE) == MMI_TRUE) 
            {

                #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
			    #endif
                mmi_vdoply_redraw_normal();
            
                VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE);
                ret = mmi_vdoply_update_layer_resume();
                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }
                mmi_vdoply_blt_screen();
                return;
            }

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
			    #endif
                mmi_vdoply_redraw_normal();
                
                mdi_video_ply_get_frame(g_vdoply_cntx.play_wnd_layer_handle);
            }
            else
            {
            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = MMI_FALSE;
                mmi_vdoply_draw_bg();
				mmi_vdoply_draw_title();
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #else
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #endif
            }

            mmi_vdoply_blt_screen();

            g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;

            /* start play video */
            ret = mmi_vdoply_play_video();

            if (ret < 0)
            {
                /* error, so not start yet, reset to idle state */
                g_vdoply_cntx.state = VDOPLY_STATE_IDLE;
            }

            if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
                return;
            }
            else if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
            {
            #ifdef __DRM_SUPPORT__
                mmi_rmgr_status_enum rmgr_ret;

                rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_path((U16*)g_vdoply_cntx.source_path, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_file_request_right_callback));

                if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
                {
                    g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
                    mmi_rmgr_request_rights_confirm();
                    return;
                }
                else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
                {                                     
                    cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
                    return;
                }
                else if (rmgr_ret == MMI_RMGR_STATUS_OK)
                {
                    /* 
                     * NOTICE!! this is a very special case, mdi_video use drm handle to check right
                     *  and there is no right, but mmi_rmgr_check_right use file name and found right.
                     * This may happend when there are more than two rights object for one file.
                     * In this case, we shall close the video, re-open it and use new right 
                     */
                    mdi_video_ply_close_file();
                    ret = mdi_video_ply_open_clip_file(0, g_vdoply_cntx.source_path, &video_info);

                    /* in this case, rmgr says it has right, so mdi shall never return DRM PROHIBITED */
                    MMI_ASSERT(ret != MDI_RES_VDOPLY_ERR_DRM_PROHIBITED);

                    /* only need to update drm handle */
                    g_vdoply_cntx.drm_handle = video_info.drm_handle;
                    g_vdoply_cntx.state = VDOPLY_STATE_PLAY;     

                    /* start play again */
                    if (g_vdoply_cntx.state == VDOPLY_STATE_IDLE)
                    {
                        g_vdoply_cntx.state = VDOPLY_STATE_PLAY;
                    }
                    ret = mmi_vdoply_play_video();

                    if (ret < 0)
                    {
                        /* error, so not start yet, reset to idle state */
                        g_vdoply_cntx.state = VDOPLY_STATE_IDLE;
                    }

                    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                    {
                        return;
                    }
                    
                    
                }
                else
                {
                    cui_vdoply_evt_exit(MMI_TRUE, STR_ID_VDOPLY_NOTIFY_INVALID_VIDEO_FILE);
                    return;                        
                }      
            #else /* __DRM_SUPPORT__ */
                MMI_ASSERT(0);
            #endif /* __DRM_SUPPORT__ */
            }
            else if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
            {
                return;
            }
            break;

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING:
            /* 
             * TRICKY!! This is used to keep screen display previous's key UI.
             * It avoid bt conecting state too short and some icon will flush.
             */                
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_PLAY);    

            /* clear process layer */
            gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                mmi_vdoply_redraw_normal();
                
                mdi_video_ply_get_frame(g_vdoply_cntx.play_wnd_layer_handle);
            }
            else
            {
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            }

            mmi_vdoply_blt_screen();   
         
            mmi_vdoply_connect_bt();
            break;
        #endif

        case VDOPLY_STATE_PAUSE:
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.video_info.total_time_duration)	                   
			{
			    g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;    
			}           
            
            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
				#ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
				#endif
                /* back from fulls screen, need draw full skin */
                mmi_vdoply_redraw_normal();
                
                mdi_video_ply_get_frame(g_vdoply_cntx.play_wnd_layer_handle);
            }
            else
            {
            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
                mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #else
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
            #endif
            }

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();

            mmi_vdoply_blt_screen();
            break;

        case VDOPLY_STATE_INTERRUPTED_PAUSE:  
			/* draw aud only anim */
		    if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
		    {
		        if (g_vdoply_cntx.state == VDOPLY_STATE_INTERRUPTED_PAUSE)
		        {
		            mmi_vdoply_draw_aud_only_anim();
		        }             
		    }
            mmi_vdoply_draw_softkey();
            mmi_vdoply_draw_panel();
            mmi_vdoply_blt_screen();
            break;

        case VDOPLY_STATE_OPENING:
        case VDOPLY_STATE_INTERRUPTED_OPENING:
			#ifdef __MDI_DISPLAY_RGB565_SUPPORT__
			gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
			gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
			gdi_layer_pop_and_restore_active();
			#endif
			mmi_vdoply_redraw_normal();
            mmi_vdoply_start_animation(MMI_VDOPLY_OPEN_ANI_ID, MMI_FALSE);
            mmi_vdoply_blt_screen();

            /* open file */
            if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE)
            {
            #ifdef __DRM_SUPPORT__
                if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NO_CONSUME)
                {
                    mdi_video_ply_drm_disable_consume_count();            
                }
            #endif /* __DRM_SUPPORT__ */
                
                ret = mdi_video_ply_open_file(GRP_ID_VDOPLY_SINGLE_PLAYER, g_vdoply_cntx.source_path, mmi_vdoply_player_open_done_hdlr, 0);

                if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
                {
                #ifdef __DRM_SUPPORT__
                    mmi_rmgr_status_enum rmgr_ret;

                    rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_path((U16*)g_vdoply_cntx.source_path, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_file_request_right_callback));

                    if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
                    {
                        g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;                        
                        mmi_rmgr_request_rights_confirm();
                        /* should press play a gain after get right */
                        cui_vdoply_evt_exit(MMI_FALSE, 0);
                        return;
                    }
                    else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
                    {
                        cui_vdoply_evt_exit(MMI_TRUE,STR_GLOBAL_DRM_PROHIBITED);
                        return;
                    }
                    else
                    {
                        MMI_ASSERT(0);
                        return;                        
                    }      
                #else /* __DRM_SUPPORT__ */
                    MMI_ASSERT(0);
                #endif /* __DRM_SUPPORT__ */
                }

            
            }
			#ifndef MMI_VDOPLY_SLIM_FOR_ID
            else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_ID)
            {
                /* play from ID is a blocking function, we will call opened done hdlr by ourself */
                ret = mdi_video_ply_open_clip_id(GRP_ID_VDOPLY_SINGLE_PLAYER, g_vdoply_cntx.video_id, &video_info);

                if (ret == MDI_RES_VDOPLY_SUCCEED)
                {
                    /* open success, call open done hdlr */
                    mmi_vdoply_player_open_done_hdlr(MDI_RES_VDOPLY_SUCCEED, &video_info, 0);
                }
            }
			#endif
            else
            {
                ret = MDI_RES_VDOPLY_ERR_FAILED;
                ASSERT(0);
            }

            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* true means has error popup */
            {
                return;
            }
            break;

        case VDOPLY_STATE_INTERRUPTED_SEEKING:       

            /* seek state dont refresh UI */
            mmi_vdoply_start_non_block_seeking();
            break;

        case VDOPLY_STATE_SEEKING:

			mmi_vdoply_draw_softkey();
            mmi_vdoply_draw_panel();
            mmi_vdoply_blt_screen();

            /* disconnect BT if needed */
	    	mmi_vdoply_start_non_block_seeking();
            mmi_vdoply_disconnect_bt();
            break;

        case VDOPLY_STATE_PLAY_SEEKING:
	        mmi_vdoply_draw_bg();
		    mmi_vdoply_draw_title();
			mmi_vdoply_draw_panel();
			mmi_vdoply_draw_softkey_and_blt();

            /* disconnect BT if needed */
	    	mmi_vdoply_start_non_block_seeking();

            mmi_vdoply_disconnect_bt();

            break;


        case VDOPLY_STATE_BACKGROUND_CALL:
			mmi_vdoply_draw_panel();
			mmi_vdoply_draw_softkey_and_blt();
            break;

        case VDOPLY_STATE_EXIT:            
        #ifdef __MMI_VIDEO_PDL__
            if( g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
            {
                if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
                {
                    /* file still downloading */
                    mmi_vdoply_entry_pdl_teminate_confirm_scr();
                    return;
                }
                else
                {
                   /* file already downloaded */
                    cui_vdoply_evt_exit(MMI_FALSE,0);
                    return;
                }
            }
        #endif /* __MMI_VIDEO_PDL__ */

            /* other case */
            cui_vdoply_evt_exit(MMI_FALSE,0);
            break;
        default:
            MMI_ASSERT(0);
            break;
        
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_fullscr_state
 * DESCRIPTION
 *  state transition function
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
static void mmi_vdoply_enter_fullscr_state(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = 0;
    vdoply_ui_type_neum prev_ui_type;
#ifdef __DRM_SUPPORT__
    mdi_video_info_struct video_info;
#endif
	U16 prev_state = g_vdoply_cntx.state;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_ui_type = g_vdoply_cntx.ui_type;
	g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;
    g_vdoply_cntx.state = state;
    
    switch (state)
    {
        case VDOPLY_STATE_FULLSCR_PLAY:
			#ifndef __MDI_DISPLAY_RGB565_SUPPORT__	//
			if(g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_AV || g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_V_ONLY)
			{
				mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.fullscr_play_layer_handle);
				gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
				gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
				gdi_layer_pop_and_restore_active();
			}
			#endif	
            mmi_vdoply_layer_clear(&g_vdoply_cntx.fullscr_play_layer_handle);
            if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE) == MMI_TRUE)
            {
                mmi_vdoply_blt_screen();
                VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_UPDATE_LAYER_PAUSE);
                ret = mmi_vdoply_update_layer_resume();
                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }
                mmi_vdoply_blt_screen();
                return;
            }

            if(prev_state == VDOPLY_STATE_SEEKING || prev_state == VDOPLY_STATE_PLAY_SEEKING || prev_state == VDOPLY_STATE_FULLSCR_BT_CONNECTING)
			{
	            ret = mdi_video_ply_seek_and_get_frame(
	                    g_vdoply_cntx.cur_status.play_time,
	                    g_vdoply_cntx.fullscr_play_layer_handle);
				if(ret == MDI_RES_VDOPLY_ERR_GET_FRAME_FAILED)
				{
					ret = MDI_RES_VDOPLY_SUCCEED;
				}
	            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
	            {
	                return;
	            }
			}
			else
			{
				mdi_video_ply_get_frame(g_vdoply_cntx.fullscr_play_layer_handle);
			}

            mmi_vdoply_blt_screen();
        

            /* start play video */
            ret = mmi_vdoply_play_video();

            if (ret < 0)
            {
                /* error, so not start yet, reset to idle state */
                g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_IDLE;
            }

            if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING);
                return;
            }
            else if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
            {
            #ifdef __DRM_SUPPORT__
                mmi_rmgr_status_enum rmgr_ret;

                rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_path((U16*)g_vdoply_cntx.source_path, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_file_request_right_callback));

                if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
                {
                    g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;                    
                    mmi_rmgr_request_rights_confirm();
                    return;
                }
                else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
                {                            
                    cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
                    return;
                }
                else if (rmgr_ret == MMI_RMGR_STATUS_OK)
                {
                    /* 
                     * NOTICE!! this is a very special case, mdi_video use drm handle to check right
                     *  and there is no right, but mmi_rmgr_check_right use file name and found right.
                     * This may happend when there are more than two rights object for one file.
                     * In this case, we shall close the video, re-open it and use new right 
                     */
                    mdi_video_ply_close_file();
                    ret = mdi_video_ply_open_clip_file(0, g_vdoply_cntx.source_path, &video_info);

                    /* in this case, rmgr says it has right, so mdi shall never return DRM PROHIBITED */
                    MMI_ASSERT(ret != MDI_RES_VDOPLY_ERR_DRM_PROHIBITED);

                    /* only need to update drm handle */
                    g_vdoply_cntx.drm_handle = video_info.drm_handle;
                    #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
                    /* start play again */
                    if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_IDLE)
                    {
                        /* becuz state is resetted to IDLE abve when error encountered, set to fullscr play again */
                        g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PLAY;
                    }
					#endif
                    ret = mmi_vdoply_play_video();

                    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                    {
                        return;
                    }
                    
                    g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PLAY;                        
                    
                }                
                else
                {
                    /* in this case, popup error and return to selection screen */
                    
                    cui_vdoply_evt_exit(MMI_TRUE, srv_fmgr_fs_error_get_string(rmgr_ret));
                    return;
                }
  
            #else /* __DRM_SUPPORT__ */
                MMI_ASSERT(0);
            #endif /* __DRM_SUPPORT__ */
            }            
            else if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
            {
                return;
            }

            /* start draw timer */
            g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;
            break;


		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_FULLSCR_PLAY);    

            /* clear process layer */
            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL) 
            {
                mmi_vdoply_draw_fullscr_play_region_bg(); 
            }

            mdi_video_ply_get_frame(g_vdoply_cntx.fullscr_play_layer_handle);

            mmi_vdoply_blt_screen();            
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_FULLSCR_BT_CONNECTING);                    
            
            mmi_vdoply_connect_bt();
            break;
		#endif

        #ifndef MMI_VDOPLY_SLIM_FOR_FULLSCR_STATE
        case VDOPLY_STATE_FULLSCR_PAUSE:
            
            /* reset osd's opacity */

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                 
            }

            mdi_video_ply_get_frame(g_vdoply_cntx.fullscr_play_layer_handle);

            mmi_vdoply_blt_screen();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();

            break;

        case VDOPLY_STATE_FULLSCR_SEEKING:

            mmi_vdoply_start_non_block_seeking();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();
            break;

        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:

            mmi_vdoply_start_non_block_seeking();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();
            break;
       #endif     
        default:
            MMI_ASSERT(0);
            break;
        
    }


}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_state
 * DESCRIPTION
 *  state transition function
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_enter_state(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#define STATE_SWITCH_CASE(__STATE__)\
    case VDOPLY_STATE_##__STATE__:\
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_STATE_##__STATE__);\
        break;
    
    switch(state)
    {
        STATE_SWITCH_CASE(EXIT);
        STATE_SWITCH_CASE(OPENING);
        STATE_SWITCH_CASE(IDLE);
        STATE_SWITCH_CASE(PAUSE);
        STATE_SWITCH_CASE(PLAY);
        STATE_SWITCH_CASE(BT_CONNECTING);        
        STATE_SWITCH_CASE(SEEKING);
        STATE_SWITCH_CASE(PLAY_SEEKING);
        STATE_SWITCH_CASE(INTERRUPTED_OPENING);
        STATE_SWITCH_CASE(INTERRUPTED_PAUSE);
        STATE_SWITCH_CASE(INTERRUPTED_SEEKING);
        STATE_SWITCH_CASE(SNAPSHOT);
        STATE_SWITCH_CASE(BACKGROUND_CALL);           
        STATE_SWITCH_CASE(FULLSCR_IDLE);
        STATE_SWITCH_CASE(FULLSCR_PAUSE);
        STATE_SWITCH_CASE(FULLSCR_PLAY);
        STATE_SWITCH_CASE(FULLSCR_BT_CONNECTING);        
        STATE_SWITCH_CASE(FULLSCR_SEEKING);
        STATE_SWITCH_CASE(FULLSCR_PLAY_SEEKING);        
        STATE_SWITCH_CASE(STREAM_DISCONNECT);        
        STATE_SWITCH_CASE(STREAM_CONNECTING);  
        STATE_SWITCH_CASE(STREAM_INTERRUPTED_CONNECTING);          
        STATE_SWITCH_CASE(STREAM_CONNECTED);  
        STATE_SWITCH_CASE(STREAM_BUFFERING);        
        STATE_SWITCH_CASE(STREAM_PLAY);  
        STATE_SWITCH_CASE(STREAM_BT_CONNECTING);   
        STATE_SWITCH_CASE(STREAM_BG_CALL_CONNECTED);
        STATE_SWITCH_CASE(STREAM_BG_CALL_DISCONNECT);
        STATE_SWITCH_CASE(STREAM_FULLSCR_DISCONNECT);        
        STATE_SWITCH_CASE(STREAM_FULLSCR_CONNECTING);  
        STATE_SWITCH_CASE(STREAM_FULLSCR_INTERRUPTED_CONNECTING); 
        STATE_SWITCH_CASE(STREAM_FULLSCR_CONNECTED);  
        STATE_SWITCH_CASE(STREAM_FULLSCR_BUFFERING);        
        STATE_SWITCH_CASE(STREAM_FULLSCR_PLAY);
        STATE_SWITCH_CASE(STREAM_FULLSCR_BT_CONNECTING);        
        STATE_SWITCH_CASE(PROGRESSIVE_OPENING);        
        STATE_SWITCH_CASE(PROGRESSIVE_INTERRUPTED_OPENING);  
        STATE_SWITCH_CASE(PROGRESSIVE_BUFFERING);  
        STATE_SWITCH_CASE(PROGRESSIVE_PLAY_BUFFERING);          
        STATE_SWITCH_CASE(PROGRESSIVE_FULLSCR_BUFFERING); 
        STATE_SWITCH_CASE(PROGRESSIVE_FULLSCR_PLAY_BUFFERING);          
        default:
            MMI_ASSERT(0);
            break;
    }

    mmi_vdoply_clear_key_event();
    mmi_vdoply_set_state_layer_config(state);
    mmi_vdoply_set_state_softkey(state);
    mmi_vdoply_set_state_key_event(state);

    /* enter next state */
    switch (state)
    {
        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PLAY:
        case VDOPLY_STATE_BT_CONNECTING:            
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:            
        case VDOPLY_STATE_OPENING: 
        case VDOPLY_STATE_INTERRUPTED_OPENING:            
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_INTERRUPTED_SEEKING:
        case VDOPLY_STATE_EXIT:
        case VDOPLY_STATE_BACKGROUND_CALL:            
            mmi_vdoply_enter_general_state(state);
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PLAY:
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:            
        case VDOPLY_STATE_FULLSCR_PAUSE:
        case VDOPLY_STATE_FULLSCR_SEEKING:
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
            mmi_vdoply_enter_fullscr_state(state);
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_BUFFERING:
        case VDOPLY_STATE_STREAM_PLAY:
        case VDOPLY_STATE_STREAM_BT_CONNECTING:
        case VDOPLY_STATE_STREAM_DISCONNECT:
        case VDOPLY_STATE_STREAM_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:            
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_enter_stream_state(state);        
            break;   
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
            mmi_vdoply_enter_progressive_state(state);        
            break;
    #endif /*   __MMI_VIDEO_PDL__ */
        default:
            MMI_ASSERT(0);
            break;
    
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_play_finish_hdlr
 * DESCRIPTION
 *  function to be called when play finished.
 * PARAMETERS
 *  result      [IN]        >=0, means successfully finished, if result < 0 measn some error happened)
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_play_finish_hdlr(MDI_RESULT result, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
	U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* new mdi error code , following error code should be ignore */
    if(result == MDI_RES_VDOPLY_ONLY_VIDEO_TRACK_ERROR || result == MDI_RES_VDOPLY_ONLY_AUDIO_TRACK_ERROR)
    {
        return;
    }
    /* if not in player screen */
    /* 
     * this may happend when video has error and driver send out this message, 
     * but before MMI receive this message, MMI stop and play the video again, 
     * that will cause driver to send another play finish message. When MMI 
     * receive first message, it will exit and display popup, when the second 
     * message comes, MMI already exit video play app. so we shall igore this 
     * message.
     */

	for(i=(U32)MMI_VDOPLY_TOUCH_LSK; i<=MMI_VDOPLY_TOUCH_SPEED_DEC; i++)
	{
		g_vdoply_cntx.touch_obj[i].is_press = MMI_FALSE;
	}
	
#ifdef __VDOPLY_FEATURE_VOLUME__
    gui_cancel_timer(mmi_vdoply_vol_down_cyclic);
    gui_cancel_timer(mmi_vdoply_vol_up_cyclic);
#endif /* __VDOPLY_FEATURE_VOLUME__ */
    
	g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = MMI_FALSE;
	g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;

    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;

    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return;
    }
    
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {   
        /* becuz key is resetted, redraw all  buttons */
#ifdef __MMI_FTE_SUPPORT__
#else
        mmi_vdoply_draw_panel_volume();
        mmi_vdoply_draw_panel_speed();
        mmi_vdoply_draw_panel_state();
#endif
    }
    
#ifdef __DRM_SUPPORT__
     g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
#endif /* __DRM_SUPPORT__ */

    /* stop UI seeking */
    gui_cancel_timer(mmi_vdoply_seek_foward_key_press_cyclic);
    gui_cancel_timer(mmi_vdoply_seek_backward_key_press_cyclic);
    g_vdoply_cntx.is_seeking = MMI_FALSE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);                  


    /* stop timer */
    gui_cancel_timer(mmi_vdoply_player_timer_cyclic);

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        mmi_vdoply_clear_fullscr_aud_only_anim();  
    #endif
    }
    else
    {
        mmi_vdoply_clear_aud_only_anim();  
    }

    mmi_vdoply_bt_close_codec();

    /* check if has error or not */
    if (mmi_vdoply_check_and_display_error_popup(result) == MMI_TRUE)       /* true means have error */
    {
		
        return;
    }

#ifdef __MMI_VIDEO_PDL__
    /* check if it progressive dl buffer underflow */
    if (result == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
        {        
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
            return;
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY)
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING);
            return;
        }
    }
#endif /* __MMI_VIDEO_PDL__ */

#ifdef __MMI_VIDEO_STREAM__

    if (result == MDI_RES_VDOPLY_STREAM_BUFFER_OVERFLOW ||
        result == MDI_RES_VDOPLY_STREAM_BUFFER_UNDERFLOW)
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
        {        
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }
            return;
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
        {
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            return;
        }
    }
    else if (result == MDI_RES_VDOPLY_ERR_STREAM_CONNECT_FAILED)
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }
        
        cui_vdoply_evt_exit(MMI_TRUE, STR_ID_VDOPLY_NOTIFY_CONNECT_FAILED);
        return;
    }   
    else if (result == MDI_RES_VDOPLY_ERR_DRM_DURATION_USED)
    {
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }
        
        cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
        return;

    }
#endif /* __MMI_VIDEO_STREAM__ */


    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY || 
        g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
    {
		#ifdef __MMI_VIDEO_PDL__	
        /* draw timer bar to end */            
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
            if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_FINISHED)
            {
                /* pdl dl finished, draw bar to end */
                g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;                                    
            }
            else
            {
                /* pdl not dl finished, draw bar to cur position */
                mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            }
        }
        else
		#endif
        {
            /* draw bar to end */
            g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;                
        }


        mmi_vdoply_draw_panel_progress();
        mmi_vdoply_draw_panel_timer();
        mmi_vdoply_blt_screen();

        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_ID || 
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
			#ifdef __VDOPLY_FEATURE_LSK_OPTION__
            if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
            {
                /* reset to start */
                g_vdoply_cntx.cur_status.start_play_time = 0;
                g_vdoply_cntx.cur_status.play_time = 0;


                mmi_vdoply_draw_panel_progress();
                mmi_vdoply_draw_panel_timer();

                ret = mdi_video_ply_seek_and_get_frame(
                        g_vdoply_cntx.cur_status.play_time,
                        g_vdoply_cntx.play_wnd_layer_handle);
				if(ret == MDI_RES_VDOPLY_ERR_GET_FRAME_FAILED)
				{
					ret = MDI_RES_VDOPLY_SUCCEED;
				}

                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)       /* true means have error */
                {
                    return;
                }
                
                mmi_vdoply_blt_screen();

                if(g_vdoply_cntx.video_info.total_time_duration < VDOPLY_REPEAT_DUR_TH )
                {
                    mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_NOT_SUPPORT_AUTO_REPEAT, MMI_EVENT_FAILURE);
                    return;
                }

                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
                    return;
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
                    return;
                }

            }
            else
			#endif
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
                return;
            }
        }
        else if(g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
                g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
                g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
        {
        #ifdef __MMI_VIDEO_STREAM__                    

            /* reset to start */
            g_vdoply_cntx.cur_status.start_play_time = 0;
            g_vdoply_cntx.cur_status.play_time = 0;


            mmi_vdoply_draw_panel_progress();
            mmi_vdoply_draw_panel_timer();
            
            /* clear playback layer to black */
            gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
            gdi_layer_clear(MMI_VDOPLY_BG_COLOR);
            gdi_layer_pop_and_restore_active();

            mmi_vdoply_blt_screen();                
        
            if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
            {
                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
                    return;
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
                    return;
                }
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
                return;
            }
        #endif /* __MMI_VIDEO_STREAM__ */
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }

    }
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    else if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY ||
             g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
    {
		#ifdef __MMI_VIDEO_PDL__
        /* draw timer bar to end */            
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
            if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_FINISHED)
            {
                g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;                                    
            }
            else
            {
                /* pdl not dl finished, draw bar to cur position */
                mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            }
        }
        else
		#endif
        {
            g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;                
        }
        
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_ID || 
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
			#ifdef __VDOPLY_FEATURE_LSK_OPTION__
            if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
            {
                /* start draw timer */
                g_vdoply_cntx.cur_status.start_play_time = 0;
                g_vdoply_cntx.cur_status.play_time = 0;


                ret = mdi_video_ply_seek_and_get_frame(
                        g_vdoply_cntx.cur_status.play_time,
                        g_vdoply_cntx.fullscr_play_layer_handle);
  
                mmi_vdoply_blt_screen();

                if(g_vdoply_cntx.video_info.total_time_duration < VDOPLY_REPEAT_DUR_TH )
                {
                    mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_NOT_SUPPORT_AUTO_REPEAT, MMI_EVENT_FAILURE);
                    return;
                }

                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
                    return;
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
                    return;
                }

            }
            else
			#endif
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
                return;
            }
        }
        else if(g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
                g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
                g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
        {
			#ifdef __MMI_VIDEO_STREAM__
            g_vdoply_cntx.cur_status.start_play_time = 0;
            g_vdoply_cntx.cur_status.play_time = 0;

            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_play_layer_handle);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_pop_and_restore_active();

            mmi_vdoply_blt_screen();
            
      		//#ifdef __MMI_VIDEO_STREAM__            
            if (g_vdoply_cntx.repeat == VDOPLY_REPEAT_ON)
            {
                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
                    return;
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
                    return;
                }
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
                return;
            }
        #endif /* __MMI_VIDEO_STREAM__ */      
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }            
    }
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
}

#ifdef __MMI_VIDEO_3D_ANAGLYPH__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_check_and_set_play_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 * 
 * RETURNS
 *  S16
 *****************************************************************************/
static void mmi_vdoply_check_and_set_play_mode(mdi_video_info_struct *vdo_clip)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 play_mode = 0;
	U32 i;
    U32 index_2d = 0, index_3d = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.flags);
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.play_mode);
    
    for( i = 0; i < vdo_clip->track_num; i++)
    {
        if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) == MMI_FALSE && MDI_VIDEO_TRACK_3D == vdo_clip->track_info[i].track_type)
        {
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_3D_MODE);
            index_3d = vdo_clip->track_info[i].track_index;
        }
        else if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_FALSE && MDI_VIDEO_TRACK_2D_NORMAL == vdo_clip->track_info[i].track_type)
        {
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_2D_MODE);
            index_2d = vdo_clip->track_info[i].track_index;
        }     
    }  

    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.flags);
    MMI_VDOPLY_MSG_TRACE(g_vdoply_cntx.play_mode);
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) && VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE))
    {
        if(g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_3D)
        {
            mdi_video_ply_set_track_index(index_3d);
        }
        else if(g_vdoply_cntx.play_mode == MDI_VIDEO_TRACK_2D_NORMAL)
        {
           mdi_video_ply_set_track_index(index_2d);
        }
    }
    else if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_3D_MODE) == MMI_TRUE)
    {
        mdi_video_ply_set_track_index(index_3d);
    }
    else if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_2D_MODE) == MMI_TRUE)
    {
        mdi_video_ply_set_track_index(index_2d);
    }
    
    
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_open_done_hdlr
 * DESCRIPTION
 *  function to be called when file is opened.
 * PARAMETERS
 *  result          [IN]        >=0, means successfully opened, if result < 0 measn some error happened)
 *  vdo_clip        [IN]        Video info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_open_done_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
#ifdef __MMI_VIDEO_PDL__    
    S32 buf_percent;
    S32 ret;
#endif /* __MMI_VIDEO_PDL__ */

#ifndef __MDI_DISPLAY_FIT_INSIDE_SUPPORT__
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
    video_osd_play_wnd_struct *play_wnd_ptr = &g_vdoply_osd_cntx.play_wnd;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if already exit player screen */
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return;
    }
    /* stop loading animation */
    mmi_vdoply_stop_animation();

    if (mmi_vdoply_check_and_display_error_popup(result) == MMI_TRUE)
    { 
           return;
    }
    /* if open sucessfully */
    if (result >= 0)
    {
	#ifdef __MMI_VIDEO_STREAM__  
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)  
        {      
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_STREAM_OPENED);
            
            /* set brightness/contrast for streaming */   
            mdi_video_stream_set_brightness(g_vdoply_cntx.brightness);
            mdi_video_stream_set_contrast(g_vdoply_cntx.contrast);
        }
        else
	#endif
        {
            /* file */
        #ifdef __DRM_SUPPORT__
            g_vdoply_cntx.drm_handle = vdo_clip->drm_handle;
        #endif
            
            /* set brightness/contrast */
            mdi_video_ply_set_brightness(g_vdoply_cntx.brightness);
            mdi_video_ply_set_contrast(g_vdoply_cntx.contrast);
            #ifdef MMI_VDOPLY_3D_ANAGLYPH
            mmi_vdoply_check_and_set_play_mode(vdo_clip);
            #endif
        }

        /* fit it into player window */
        g_vdoply_cntx.video_info.width = vdo_clip->width;
        g_vdoply_cntx.video_info.height = vdo_clip->height;
        g_vdoply_cntx.video_info.total_time_duration = vdo_clip->total_time_duration;
        g_vdoply_cntx.video_info.is_seekable = vdo_clip->is_seekable;
        g_vdoply_cntx.video_info.track = vdo_clip->track;
        g_vdoply_cntx.video_info.aud_channel_no = vdo_clip->aud_channel_no;        
        g_vdoply_cntx.video_info.aud_sample_rate= vdo_clip->aud_sample_rate;

	#ifdef __MMI_VIDEO_STREAM__  
        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)  
        {
             g_vdoply_cntx.is_progress_seekable = g_vdoply_cntx.video_info.is_seekable;
        }
	#endif

        /* this is used solve when interrupt happened while video is finish,
           driver already send out finish idication but MMI didnt reveice this message
           and call get time. Will get play time which exceed total time */
        if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.video_info.total_time_duration)
        {
            g_vdoply_cntx.cur_status.play_time = 0;
        }

        if (g_vdoply_cntx.video_info.track == MDI_VIDEO_TRACK_A_ONLY)
        {
		#ifndef __MDI_DISPLAY_RGB565_SUPPORT__
			gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
			gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
			gdi_layer_pop_and_restore_active();
		#else
			gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
			gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);
			gdi_layer_pop_and_restore_active();
		#endif
			mmi_vdoply_draw_play_region_bg();
		
        }
        else
        {
		#ifndef __MDI_DISPLAY_RGB565_SUPPORT__
			mdi_util_hw_layer_switch_to_sw_layer(g_vdoply_cntx.play_wnd_layer_handle);
			gdi_layer_push_and_set_active(g_vdoply_cntx.play_wnd_layer_handle);
			gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
			gdi_layer_pop_and_restore_active();
		#endif
        #ifndef __MDI_DISPLAY_FIT_INSIDE_SUPPORT__
            mmi_vdoply_fit_bbox(vdo_clip, MMI_FALSE);
        #else /* __MDI_DISPLAY_FIT_INSIDE_SUPPORT__ */
            mmi_vdoply_layer_clear(&g_vdoply_cntx.play_wnd_layer_handle);
        #endif /* __MDI_DISPLAY_FIT_INSIDE_SUPPORT__ */
        }
        


    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
    #ifndef __MDI_DISPLAY_FIT_INSIDE_SUPPORT__
			mmi_vdoply_fit_bbox(vdo_clip, MMI_TRUE);
    #endif /*__MDI_DISPLAY_FIT_INSIDE_SUPPORT__*/
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
        
        /* mute audio */
        if (g_vdoply_cntx.is_mute == MMI_TRUE)
        {
            mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_TRUE);
        }

		g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;
        switch (g_vdoply_cntx.state)
        {
            case VDOPLY_STATE_OPENING:
                         
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration; 
				mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);                                        
                break;
                
            case VDOPLY_STATE_PROGRESSIVE_OPENING:
            #ifdef __MMI_VIDEO_PDL__                            
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;       

                ret = mdi_video_progressive_get_buf_percentage(&buf_percent);
                
                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }     
                
                ret = mdi_video_progressive_get_max_play_time(&g_vdoply_cntx.cur_status.max_play_time);            

                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }                         

                /* start timer to get playabel time */
                if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
                {
                	gui_start_timer(100, mmi_vdoply_pdl_draw_progressbar_cyclic);
                }

                if (buf_percent == 100)
                {
                    /* have enough buffe, can enter idle state */
                    mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);                                        
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_BUFFERING);                                        
                }
            #endif /* __MMI_VIDEO_PDL__ */
                break;

            case VDOPLY_STATE_INTERRUPTED_OPENING:
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;            
                mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_SEEKING);    
                break;

            case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
            #ifdef __MMI_VIDEO_PDL__
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;            
            
                ret = mdi_video_progressive_get_buf_percentage(&buf_percent);

                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }     

                ret = mdi_video_progressive_get_max_play_time(&g_vdoply_cntx.cur_status.max_play_time);            

                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }                

                /* start timer to get playabel time */
                if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
                {
                	gui_start_timer(100, mmi_vdoply_pdl_draw_progressbar_cyclic);
                }
                
                if (buf_percent == 100)
                {
                    /* have enough buffe, seek  */
                    mmi_vdoply_enter_state(VDOPLY_STATE_INTERRUPTED_SEEKING);                                        
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_BUFFERING);                                        
                }                    
            #endif /* __MMI_VIDEO_PDL__ */
                break;

            case VDOPLY_STATE_STREAM_BUFFERING:
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;                     
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_PLAY);
                break;

            case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
                //g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;                     
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_PLAY);
                break;
               
                
        }

        /* set source is opened flag */
        VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_SOURCE_OPENED);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_exit_player_screen_internal
 * DESCRIPTION
 *  exit view detail screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_exit_player_screen_internal(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    U8 aud_vol;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* exit handler in different state */
    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_EXIT:
            break;

        case VDOPLY_STATE_IDLE:
        case VDOPLY_STATE_PAUSE:
        case VDOPLY_STATE_OPENING:
        case VDOPLY_STATE_INTERRUPTED_OPENING:
        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_BT_CONNECTING:
            mmi_vdoply_close_file();
            if (g_vdoply_cntx.state == VDOPLY_STATE_PAUSE
                || g_vdoply_cntx.state == VDOPLY_STATE_INTERRUPTED_PAUSE)
            {
                if(mmi_frm_scrn_is_present(GRP_ID_VDOPLY_SINGLE_PLAYER, SCR_ID_VDOPLY_PLAYER, MMI_FRM_NODE_ALL_FLAG))
                {
                    VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_PAUSE_WHEN_LEAVE);   
                }                
            }
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;          
            break;

        case VDOPLY_STATE_PLAY:
            /* interrupt while playing, store play time var */
            /* if interrupt while seek key is pressed, don't reload video play time */
            if (g_vdoply_cntx.is_seeking == MMI_TRUE)
            {
                mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            }

            mmi_vdoply_stop_video();

            mmi_vdoply_close_file();
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;                       
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
        case VDOPLY_STATE_INTERRUPTED_SEEKING:
            /* stop non-blocking seeking */
            mmi_vdoply_stop_non_block_seeking();
            mmi_vdoply_close_file();        
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;                     
            break;
	
        case VDOPLY_STATE_FULLSCR_IDLE:
        case VDOPLY_STATE_FULLSCR_PAUSE:
        case VDOPLY_STATE_FULLSCR_BT_CONNECTING:
            mmi_vdoply_close_file();    
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;                                 
            break;
        
        case VDOPLY_STATE_FULLSCR_PLAY:
            /* interrupt while playing, store play time var */
            /* if interrupt while seek key is pressed, don't reload video play time */
            if (g_vdoply_cntx.is_seeking == MMI_TRUE)
            {
                mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            }

            /* if is seeking, it is already stopped */

            mmi_vdoply_stop_video();

            mmi_vdoply_close_file();   

            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;
            break;
       
        case VDOPLY_STATE_FULLSCR_SEEKING:
        case VDOPLY_STATE_FULLSCR_PLAY_SEEKING:
            /* stop non-blocking seeking */
            mmi_vdoply_stop_non_block_seeking();
            mmi_vdoply_close_file();
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;       
            break;
		
        case VDOPLY_STATE_BACKGROUND_CALL:
                mmi_vdoply_close_file();
                g_vdoply_cntx.state = VDOPLY_STATE_EXIT;
            break;

    #ifdef __MMI_VIDEO_PDL__
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:    
            mmi_vdoply_stop_animation();
            mmi_vdoply_close_file();    
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;            
            break;
    
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
            mmi_vdoply_close_file();    
            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;   
            break;
    #endif /* __MMI_VIDEO_PDL__ */

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTED:  
        case VDOPLY_STATE_STREAM_BT_CONNECTING:            
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
            mdi_video_stream_disconnect();
            break;

        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();
            break;

        case VDOPLY_STATE_STREAM_BUFFERING:    
            mmi_vdoply_stream_stop_buffering();
            mdi_video_stream_disconnect();
            break;

        case VDOPLY_STATE_STREAM_PLAY:
            mmi_vdoply_stop_video(); 
            mdi_video_stream_disconnect();            
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__     
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:  
        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            mdi_video_stream_disconnect();   
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();   
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();   
            break;
  
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING: 
            mmi_vdoply_stream_stop_buffering();
            mdi_video_stream_disconnect();          
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_stop_video();             
            mdi_video_stream_disconnect();              
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */
    }

    /* disconnect bluetooth */
    mmi_vdoply_disconnect_bt();
    
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
       /* clear base as black */
       /* we cant use flatten since layer size is different */
       gdi_layer_clear(GDI_COLOR_BLACK);
    }
    else
    {
       /* flatten to base before release layers */
       gdi_layer_flatten_previous_to_base();
    }

#ifdef __MMI_VIDEO_STREAM__
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        if (!g_vdoply_cntx.video_info.is_seekable)
        {
            /* live, clear play time */
            g_vdoply_cntx.cur_status.play_time = 0;
            g_vdoply_cntx.cur_status.start_play_time = 0;
        }
    }
#endif /* __MMI_VIDEO_STREAM__ */

    /* stop all timer */
    gui_cancel_timer(mmi_vdoply_seek_backward_key_press_cyclic);
    gui_cancel_timer(mmi_vdoply_seek_foward_key_press_cyclic);
    gui_cancel_timer(mmi_vdoply_player_timer_cyclic);
    gui_cancel_timer(mmi_vdoply_seek_key_release);
    #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	gui_cancel_timer(mmi_vdoply_play_next_file_worked);
	gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
	#endif

#ifdef __VDOPLY_FEATURE_VOLUME__    
    gui_cancel_timer(mmi_vdoply_vol_down_cyclic);    
    gui_cancel_timer(mmi_vdoply_vol_up_cyclic);
#endif /* __VDOPLY_FEATURE_VOLUME__ */

#ifdef __MMI_VIDEO_PDL__
    gui_cancel_timer(mmi_vdoply_pdl_draw_progressbar_cyclic);    
    gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic); 
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    gui_cancel_timer(mmi_vdoply_pdl_fullscr_buffering_cyclic);        
#endif 
#endif /* __MMI_VIDEO_PDL__ */

#ifdef __MMI_VIDEO_STREAM__
    gui_cancel_timer(mmi_vdoply_stream_buffering_cyclic);
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
    gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
#endif /* __MMI_VIDEO_STREAM__ */


    /* restore rotate layer flag */
    gdi_lcd_set_rotate_by_layer(g_vdoply_cntx.prev_rotate_by_layer);

    /* stop all playing animation */
    gdi_image_stop_animation_all();

    /* disable multi layer */
    gdi_layer_multi_layer_disable();

    /* resume alignment timer */
    UI_disable_alignment_timers();

    /* let MMI can sleep */
    srv_backlight_turn_off();

    /* unmute */
    mdi_audio_set_mute(MDI_VOLUME_MEDIA, MMI_FALSE);

    /* resume background audio */
    mdi_audio_resume_background_play();

    if (g_vdoply_cntx.is_mute == MMI_TRUE)
    {
        //aud_vol = VDOPLY_VOL_MUTE;
        U8 save_mute;
		if(g_vdoply_cntx.bVolFlag)
		{
			save_mute = 1 << 5;
			aud_vol = g_vdoply_cntx.cur_status.volume | save_mute;
		}
		else
		{
			save_mute = 1 << 4;
        	aud_vol = g_vdoply_cntx.cur_status.volume | save_mute;
		}
        WriteValueSlim( NVRAM_VDOPLY_VOLUMN, (void*)&aud_vol, DS_BYTE);
    }
    else
    {
        WriteValueSlim( NVRAM_VDOPLY_VOLUMN, (void*)&g_vdoply_cntx.cur_status.volume, DS_BYTE);
    }

    /* re-enable keypad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);

#ifdef __MMI_AVRCP_SUPPORT__
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_CALLING_MMI_VT_AVRCP_CLEAR_CMD_HDLR, __LINE__);
    mmi_bt_avrcp_clear_cmd_hdlr(mmi_vdoply_bt_avrcp_cmd_hdlr);
#endif 

#ifdef __BT_SPK_VOL_CONTROL__
    mdi_audio_bt_clear_volume_sync_callback(APP_VDOPLY);
#endif

#ifdef __VDOPLY_FEATURE_FULLSCREEN__


    /* free fullscr video layer */
    if (g_vdoply_cntx.fullscr_play_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        mdi_util_hw_layer_free(g_vdoply_cntx.fullscr_play_layer_handle);
        g_vdoply_cntx.fullscr_play_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

    /* free play wnd layer */
    if (g_vdoply_cntx.play_wnd_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        mdi_util_hw_layer_free(g_vdoply_cntx.play_wnd_layer_handle);
        g_vdoply_cntx.play_wnd_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

    /* free video layer buffer */
    #ifdef __VDOPLY_FEATURE_SLIM_IMG_RES__
        if (g_vdoply_cntx.vdo_frame_buf_ptr != NULL)
        {
		#ifdef __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__
            media_free_int_buffer(MOD_MMI, (void**)&g_vdoply_cntx.vdo_frame_buf_ptr);
            g_vdoply_cntx.vdo_frame_buf_ptr = NULL;        
	 	#else
			#if (!defined __GDI_MEMORY_PROFILE_2__)&&(!defined(__VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__))
			mmi_frm_scrmem_free((void*)g_vdoply_cntx.vdo_frame_buf_ptr);
        	g_vdoply_cntx.vdo_frame_buf_ptr = NULL;
			#endif
		#endif /* __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__ */         
        }
    #endif /* __VDOPLY_FEATURE_INT_RAM_FRAME_BUF__ */

#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
		wgui_status_icon_bar_set_target_layer(WGUI_STATUS_ICON_BAR_H_BAR, g_vdoply_cntx.prev_status_bar_layer_handle);

	#ifndef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__
		if (g_vdoply_cntx.status_bar_layer_handle != GDI_LAYER_EMPTY_HANDLE)
		{
			gdi_layer_free(g_vdoply_cntx.status_bar_layer_handle);
			g_vdoply_cntx.status_bar_layer_handle = GDI_LAYER_EMPTY_HANDLE;
		}
		if(g_vdoply_cntx.status_layer_ptr != NULL)
		{ 
			#ifndef __GDI_MEMORY_PROFILE_2__
			mmi_frm_scrmem_free((void*)g_vdoply_cntx.status_layer_ptr);
			g_vdoply_cntx.status_layer_ptr = NULL;
			#endif
		}
	#endif
#endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */


    /* free bg layer */
#ifdef __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__    
    /* bg - we use base layer's buffer, we dont need to free the buffer */
    if (g_vdoply_cntx.bg_region_0_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_vdoply_cntx.bg_region_0_layer_handle);
        g_vdoply_cntx.bg_region_0_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

    if (g_vdoply_cntx.bg_region_1_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_vdoply_cntx.bg_region_1_layer_handle);
        g_vdoply_cntx.bg_region_1_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }   

    if (g_vdoply_cntx.bg_region_0_buf_ptr != NULL)
    {
        mmi_frm_asm_free_r(GRP_ID_VDOPLY_SINGLE_PLAYER, g_vdoply_cntx.bg_region_0_buf_ptr);
        g_vdoply_cntx.bg_region_0_buf_ptr = NULL;
    }

    if (g_vdoply_cntx.bg_region_1_buf_ptr != NULL)
    {
        mmi_frm_asm_free_r(GRP_ID_VDOPLY_SINGLE_PLAYER, g_vdoply_cntx.bg_region_1_buf_ptr);
        g_vdoply_cntx.bg_region_1_buf_ptr = NULL;
    }
    
#endif /* __VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__ */
    g_vdoply_cntx.bg_layer_handle = GDI_LAYER_EMPTY_HANDLE;


    if (g_vdoply_cntx.process_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_vdoply_cntx.process_layer_handle);
        g_vdoply_cntx.process_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }
    
    if (g_vdoply_cntx.fullscr_process_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_vdoply_cntx.fullscr_process_layer_handle);
        g_vdoply_cntx.fullscr_process_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

    if (g_vdoply_cntx.load_buf_ptr != NULL)
    {
		#if (!defined(__MMI_SUPPORT_ASMV2__)||!defined(__GDI_MEMORY_PROFILE_2__))
		mmi_frm_scrmem_free((void*)g_vdoply_cntx.load_buf_ptr);
		#else
        mmi_frm_asm_free_r(GRP_ID_VDOPLY_SINGLE_PLAYER, g_vdoply_cntx.load_buf_ptr);
		#endif
        g_vdoply_cntx.load_buf_ptr = NULL;
    }

    /* if lcd already sleep, clear the layer */
    if (srv_backlight_is_lcd_sleep())
    {
        gdi_layer_clear(GDI_COLOR_BLACK);
    }

    /* set lcm rotate to default */
    gdi_lcd_set_rotate(GDI_LAYER_ROTATE_0);

    /* rotate base layer back to normal */
    gdi_layer_resize(UI_device_width, UI_device_height);

    /* restore to base layer only */
    gdi_layer_set_blt_layer(g_vdoply_cntx.bg_layer_handle, 0, 0, 0);

    /* reset flag */
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY);

	if(cui_folder_browser_is_filelist_locked(g_vdoply_cntx.fmgr_scr_id))
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
	}
    /* exit sublcd */
#ifdef __MMI_SUBLCD__
    if (g_vdoply_cntx.is_sub_display == MMI_TRUE)
    {
        GoBackSubLCDHistory();
        g_vdoply_cntx.is_sub_display = MMI_FALSE;
    }
#endif /* __MMI_SUBLCD__ */ 

#ifdef __MMI_VIDEO_STREAM__
    if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_STREAM_INIT) == MMI_TRUE)
    {
        mdi_video_stream_deinit();
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_STREAM_INIT);
    }

    g_vdoply_cntx.state = VDOPLY_STATE_EXIT;
#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_close_file
 * DESCRIPTION
 *  close opened files
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_close_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_FILE)
    {
        mdi_video_ply_close_file();
    }
	#ifndef MMI_VDOPLY_SLIM_FOR_ID
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_ID)
    {
        mdi_video_ply_close_clip_id();
    }
	#endif
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
    {
    #ifdef __MMI_VIDEO_PDL__        
        mdi_video_progressive_close_file();
    #endif
    }
    else
    {
        /* should not go here */       
    }     
  
    #ifdef MMI_VDOPLY_3D_ANAGLYPH
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_2D_MODE);
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_3D_MODE);
    #endif
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_speed_factor
 * DESCRIPTION
 *  get speed factor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static S16 mmi_vdoply_get_speed_factor(void)
{
#ifdef __VDOPLY_FEATURE_SPEED__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_vdoply_cntx.cur_status.speed)
    {
        case 0:
            return VDOPLY_FEATURE_SPEED_0;
        case 1:
            return VDOPLY_FEATURE_SPEED_1;
        case 2:
            return VDOPLY_FEATURE_SPEED_2;
        case 3:
            return VDOPLY_FEATURE_SPEED_3;
        case 4:
            return VDOPLY_FEATURE_SPEED_4;
        case 5:
            return VDOPLY_FEATURE_SPEED_5;
        case 6:
            return VDOPLY_FEATURE_SPEED_6;
        case 7:
            return VDOPLY_FEATURE_SPEED_7;
        case 8:
            return VDOPLY_FEATURE_SPEED_8;

        default:
            ASSERT(0);
            return 0;
    }
#else /* __VDOPLY_FEATURE_SPEED__ */ 
    return 100; /* 1x play speed */
#endif /* __VDOPLY_FEATURE_SPEED__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_settings_inline_focus_change
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_settings_inline_focus_change(cui_event_inline_notify_struct *inline_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item = inline_evt->item_id - CUI_INLINE_ITEM_ID_BASE;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if (mmi_frm_group_is_present(GRP_ID_VDOPLY_ADJUST_OPTION))
    {
#if defined(__VDOPLY_FEATURE_LSK_OPTION__) 
        switch (item)
        {
#if defined(__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__)             
            case VIDEO_BRIGHTNESS_TYPE_SELECT:
            {
               g_vdoply_cntx.adjust_data.brightness = inline_evt->param;
                break;
            }
            case VIDEO_CONTRAST_TYPE_SELECT:
            {
                g_vdoply_cntx.adjust_data.contrast = inline_evt->param;
                break;
            }
#endif        
            case VIDEO_REPEAT_TYPE_SELECT:
            {
                g_vdoply_cntx.adjust_data.repeat = inline_evt->param;
                break;
            }
#ifdef MMI_VDOPLY_3D_ANAGLYPH
            case VIDEO_PLAY_MODE_TYPE_SELECT:
            {
                g_vdoply_cntx.adjust_data.play_mode = inline_evt->param;
                break;
            }
#endif
        }
#endif
    }
    else if (mmi_frm_group_is_present(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT))
    {
#ifdef __MMI_VIDEO_STREAM__         
        switch (item)
        {
            case USE_PROXY_TYPE_SELECT:
            {
                g_vdoply_cntx.inline_proxy_on_off = inline_evt->param;
                break;
            }
            default:
                break;
        }
#endif        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_adjust_option_scr
 * DESCRIPTION
 *  entry video player adjustment option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__VDOPLY_FEATURE_LSK_OPTION__)
static void mmi_vdoply_settings_video_init_item_value(MMI_ID inline_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
    U16 item_icons[VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_NUM];
    U16 item_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.adjust_data.brightness = g_vdoply_cntx.brightness;
    g_vdoply_cntx.adjust_data.contrast = g_vdoply_cntx.contrast;
    g_vdoply_cntx.adjust_data.repeat = g_vdoply_cntx.repeat;
    g_vdoply_cntx.adjust_data.play_mode = g_vdoply_cntx.play_mode;
#if defined(__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__)  
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + VIDEO_BRIGHTNESS_TYPE_SELECT, 
        (void *)g_vdoply_cntx.adjust_data.brightness);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + VIDEO_CONTRAST_TYPE_SELECT, 
        (void *)g_vdoply_cntx.adjust_data.contrast);
#endif /*__VDOPLY_FEATURE_VIDEO_ADJUSTMENT__*/
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + VIDEO_REPEAT_TYPE_SELECT, 
        (void *)g_vdoply_cntx.adjust_data.repeat);

#ifdef MMI_VDOPLY_3D_ANAGLYPH
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + VIDEO_PLAY_MODE_TYPE_SELECT, 
        (void *)g_vdoply_cntx.adjust_data.play_mode);
#endif

    while (item_count < VDOPLY_SETTINGS_VIDEO_INLINE_ITEM_NUM)
    {
        item_icons[item_count] = IMG_GLOBAL_L1 + (item_count)/2;
        item_count++;
        item_icons[item_count++] = 0;
    }
    cui_inline_set_icon_list(inline_id, &item_icons[0]);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_adjust_option_scr
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_adjust_option_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    MMI_ID inline_id;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    gid = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_SETTINGS, 
                    GRP_ID_VDOPLY_ADJUST_OPTION, 
                    mmi_vdoply_settings_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    if (GRP_ID_INVALID == gid)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);                
        return;
    }
    inline_id = cui_inline_create(GRP_ID_VDOPLY_ADJUST_OPTION, &mmi_vdoply_settings_video_inline_screen);
    if (inline_id != GRP_ID_INVALID)
    {
        cui_inline_set_title_icon(inline_id, GetRootTitleIcon(MENU_ID_VDOPLY_APP));
        mmi_vdoply_settings_video_init_item_value(inline_id);
        cui_inline_run(inline_id);
    }
    else
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_adjust_option_lsk_hdlr
 * DESCRIPTION
 *  adjust option screen lsk handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_adjust_option_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.brightness = g_vdoply_cntx.adjust_data.brightness;
    g_vdoply_cntx.contrast = g_vdoply_cntx.adjust_data.contrast;
    g_vdoply_cntx.repeat = g_vdoply_cntx.adjust_data.repeat;
    g_vdoply_cntx.play_mode = g_vdoply_cntx.adjust_data.play_mode;

    mmi_vdoply_store_setting();
    mmi_frm_group_close(GRP_ID_VDOPLY_SETTINGS);
}
#endif /* defined(__VDOPLY_FEATURE_LSK_OPTION__) */ 


/**********************************
 * Option Screen
 **********************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_option_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_ENHNACE_OPTION__
static void mmi_vdoply_entry_option_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 num_item;
    S32 menu_id;
    MMI_ID cui_gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP)
    {
        menu_id = MENU_ID_VDOPLY_OPTION_STREAMING;
    }
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
    {
        /* ram is from local file, do not let it save */
        menu_id = MENU_ID_VDOPLY_OPTION;
    }
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_DA_SDP_FILE) == MMI_TRUE)
        {
            menu_id = MENU_ID_VDOPLY_OPTION_STREAMING;
        }
        else
        {
            /* sdp from local file, do not let it save */
            menu_id = MENU_ID_VDOPLY_OPTION;
        }
    }
    else
    {
        menu_id = MENU_ID_VDOPLY_OPTION;
    }
    
    if (menu_id == MENU_ID_VDOPLY_OPTION)
    {
        num_item = GetNumOfChild(menu_id);
        if (num_item == 1)
        {
            mmi_vdoply_entry_adjust_option_scr();
            return;
        }
    }
   
    cui_gid = cui_menu_create(
                        GRP_ID_VDOPLY_SETTINGS,
                    	CUI_MENU_SRC_TYPE_RESOURCE,
                    	CUI_MENU_TYPE_OPTION,
                    	menu_id,
                    	MMI_FALSE, NULL);
    if (cui_gid > GRP_ID_INVALID)
    {
        cui_menu_set_default_title_image(cui_gid, (UI_image_type)get_image(GetRootTitleIcon(MENU_ID_VDOPLY_APP)));
        
		#if defined(__VDOPLY_FEATURE_BT__) && !defined(__MMI_A2DP_HIDE_BT_SETTINGS__)
		if(!mmi_bt_is_to_display_bt_menu())
        {
            cui_menu_set_item_hidden(cui_gid,MENU_ID_VDOPLY_BLUETOOTH_SETTING,MMI_TRUE);
        }
        #endif	
		cui_menu_run(cui_gid);
		if(mmi_frm_group_get_active_id() != cui_gid)
		{
		    mmi_vdoply_display_not_available_popup(GRP_ID_VDOPLY_SINGLE_PLAYER);
		}
    }
    else
    {   
        return;
    } 
    
}

#endif /* __VDOPLY_FEATURE_ENHNACE_OPTION__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_drive_callback
 * DESCRIPTION
 *  get drive callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
            
        

            /* after popup, will re-enter storage screen */
            /* create folder successful */
            /* after popup, will enter video player file list screen */
                /* delete 
                 * (1) FMGR DRV screen 
                 * (2) STORAGE screen
                 * (3) Option screen
                 * (4) FMGR FILE screen 
                 */                
                
                /* back to app */
                
                /* delete 
                 * (2) STORAGE screen
                 */
                /* start a 0 sec timer to let fmgr finish */

        /* user press RSK back */
            /* option -> storage */
            /* back to option */
            
            /* delete 
             * (1) STORAGE screen
             */
            /* app -> storage */
            /* exit ap */
            
            /* delete 
             * (1) STORAGE screen
             * (2) VDOPLY APP screen
             */



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_storage_select_cb
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_set_app_storage_screen
 * DESCRIPTION
 *  enter set storage screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    /* storage screen for app -> storage */



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_set_storage_screen
 * DESCRIPTION
 *  enter set storage screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* storage screen for option -> storage */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_set_storage_screen_internal
 * DESCRIPTION
 *  enter set storage screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

                    





/*****************************************************************************
 *
 *  Touch Screen Support
 *
 *****************************************************************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_pen_down_hdlr
 * DESCRIPTION
 *  touch screen hdlr when pen down
 * PARAMETERS
 *  pos     [IN]        Pen down position
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__)
static void mmi_vdoply_touch_scr_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 shift;
    S32 ratio;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {   
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        g_vdoply_cntx.touch_object = VDOPLY_TOUCH_FULLSCREEN;
        return;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN, pos.x, pos.y, __LINE__); 
    
        /* rsk */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_rsk_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_RSK;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }
    
        /* lsk */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_lsk_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_LSK;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }

        /* ck */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_ck_press();
        #ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_FULLSCREEN;
        #else
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_CK;
        #endif
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }

#ifndef __MMI_FTE_SUPPORT__
        #ifdef __VDOPLY_FEATURE_VOLUME__
        /* volume inc */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_vol_up_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_VOLUME_INC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }

        /* volume dec */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_vol_down_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_VOLUME_DEC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }
		#endif

    #ifdef __VDOPLY_FEATURE_SPEED__  
        /* speed inc */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC]))
        {
            mmi_vdoply_speed_inc_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_SPEED_INC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }
    #endif /* __VDOPLY_FEATURE_SPEED__ */
    
    #ifdef __VDOPLY_FEATURE_SPEED__  
        /* speed dec */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC]))
        {
            mmi_vdoply_speed_dec_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_SPEED_DEC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__);             
            return;
        }
    #endif /* __VDOPLY_FEATURE_SPEED__ */
#endif    
        /* progress inc */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
			mmi_vdoply_right_arrow_key_press();
			#else
            mmi_vdoply_seek_foward_key_press();
			#endif
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_PROGRESS_INC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }

        /* progress dec */
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
			mmi_vdoply_left_arrow_key_press();
			#else
            mmi_vdoply_seek_backward_key_press();
            #endif
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_PROGRESS_DEC;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }

#ifdef MMI_VDOPLY_RSK_EXIT
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_PLAY;
            mmi_vdoply_ctrl_button_pressed(g_vdoply_cntx.touch_object);
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }

        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_STOP;
            mmi_vdoply_ctrl_button_pressed(g_vdoply_cntx.touch_object);
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }
#endif

        /* progress bar */
        if (mmi_vdoply_touch_scr_hit_test_with_border(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR], 2,0))
        {
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PROGRESSBAR, g_vdoply_cntx.is_seeking, g_vdoply_cntx.state, __LINE__); 
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            if (g_vdoply_cntx.is_seeking == MMI_FALSE)
            {
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_press = MMI_TRUE;

                if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY || 
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
                {
                    mmi_vdoply_stop_video();
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING ||
                         g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
                {
                    /* hide process layer */
                    mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);                 
                    mmi_vdoply_disconnect_bt();
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING)
                {
                #ifdef __MMI_VIDEO_STREAM__
                    /* stop and enter connected state */
                    mmi_vdoply_stream_stop_buffering();
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;

                    /* but draw seeking's ui, for consitance */
                    mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SEEKING);  
                    
                #endif /* __MMI_VIDEO_STREAM__ */
                }
                else if (g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_BUFFERING ||
                         g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING)
                {
                #ifdef __MMI_VIDEO_PDL__
                    gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic); 
                #endif /* __MMI_VIDEO_PDL__ */
                }

                g_vdoply_cntx.is_seeking = MMI_TRUE;
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SET_IS_SEEKING, g_vdoply_cntx.is_seeking, __LINE__);                  
                shift = pos.x - g_vdoply_osd_cntx.panel.progress_empty.offset_x;
                if (shift < 0)
                {
                    shift = 0;
                }
                else if (shift > g_vdoply_cntx.progress.fill_width)
                {
                    shift = g_vdoply_cntx.progress.fill_width;
                }

                ratio = (shift << 10) / g_vdoply_cntx.progress.fill_width;

                g_vdoply_cntx.cur_status.play_time = (g_vdoply_cntx.video_info.total_time_duration * ratio) >> 10;

                if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
                {
                    g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.cur_status.max_play_time;
                }

                mmi_vdoply_draw_panel_progress();
                mmi_vdoply_draw_panel_timer();
                mmi_vdoply_blt_screen();

                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_PROGRESS_BAR;
                MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            }
            return;
        }

#if  !defined(__MMI_FTE_SUPPORT__) || defined(__VDOPLY_FEATURE_FTE20__)
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /* toggle fullscreen or tv-out */    
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
        
            mmi_vdoply_toggle_fullscreen_key_press();

            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_FULLSCREEN;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
#endif

#ifndef __MMI_FTE_SUPPORT__
    #ifdef __VDOPLY_FEATURE_SNAPSHOT__
        /* snapshot */    
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_player_snapshot_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_SNAPSHOT;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }
    #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 
#endif

    #ifdef __VDOPLY_FEATURE_FTE20__
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_press_mute_down();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_MUTE;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }
    #endif

    #ifdef MMI_VDOPLY_3D_ANAGLYPH
        if (mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE]))
        {
            mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_DOWN);
            mmi_vdoply_toggle_mode_key_press();
            g_vdoply_cntx.touch_object = VDOPLY_TOUCH_MODE;
            MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_DOWN_STATE, g_vdoply_cntx.touch_object, __LINE__); 
            return;
        }
    #endif
    }
	{
		S32 icon_id;
    wgui_status_icon_bar_pen_enum evt_type;

    wgui_status_icon_bar_translate_pen_event(
        MMI_PEN_EVENT_DOWN,
        pos.x,
        pos.y,
        &icon_id,
        &evt_type);
	}

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_pen_up_hdlr
 * DESCRIPTION
 *  touch screen hdlr when pen up
 * PARAMETERS
 *  pos     [IN]        Pen up position
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_touch_scr_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        if (g_vdoply_cntx.touch_object == VDOPLY_TOUCH_FULLSCREEN)
        { 
            mmi_vdoply_toggle_fullscreen_display();
        }
        g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
        return;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
    }
    else
    {
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_UP, pos.x, pos.y, g_vdoply_cntx.touch_object, __LINE__); 
        
        /* not fullscreen */
        switch (g_vdoply_cntx.touch_object)
        {
        #ifdef __VDOPLY_FEATURE_VOLUME__
            case VDOPLY_TOUCH_VOLUME_INC:
                mmi_vdoply_vol_up_key_release();
                break;

            case VDOPLY_TOUCH_VOLUME_DEC:
                mmi_vdoply_vol_down_key_release();
                break;
		#endif

        #ifdef __VDOPLY_FEATURE_SPEED__   
            case VDOPLY_TOUCH_SPEED_INC:
                mmi_vdoply_speed_inc_key_release();
                break;
        #endif /* __VDOPLY_FEATURE_SPEED__ */
        
        #ifdef __VDOPLY_FEATURE_SPEED__   
            case VDOPLY_TOUCH_SPEED_DEC:
                mmi_vdoply_speed_dec_key_release();
                break;
        #endif /* __VDOPLY_FEATURE_SPEED__ */
            
            case VDOPLY_TOUCH_PROGRESS_INC:
                #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
				mmi_vdoply_right_arrow_key_release();
				#else
                mmi_vdoply_seek_foward_key_release();
				#endif
                break;

            case VDOPLY_TOUCH_PROGRESS_DEC:
                #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
				mmi_vdoply_left_arrow_key_release();
				#else
                mmi_vdoply_seek_backward_key_release();
				#endif
                break;

            case VDOPLY_TOUCH_PROGRESS_BAR:
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_BAR].is_press = MMI_FALSE;
                mmi_vdoply_seek_key_release();
                break;

                /* snapshot */
        #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            case VDOPLY_TOUCH_SNAPSHOT:
                mmi_vdoply_player_snapshot_key_release();
                break;
        #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 

                /* fullscreen */
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__

            case VDOPLY_TOUCH_FULLSCREEN:
                mmi_vdoply_toggle_fullscreen_key_release();
                break;

        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

            case VDOPLY_TOUCH_RSK:
                mmi_vdoply_rsk_release();

                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_LSK:
                mmi_vdoply_lsk_release();

                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_CK:
                mmi_vdoply_ck_release();

                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_PLAY:
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = MMI_FALSE;
                mmi_vdoply_draw_panel_ctrl_button();
                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                mmi_vdoply_play_button_worked();
                break;

            case VDOPLY_TOUCH_STOP:
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press = MMI_FALSE;
                mmi_vdoply_draw_panel_ctrl_button();
                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                mmi_vdoply_stop_button_worked();
                break;    
                
        #ifdef __VDOPLY_FEATURE_FTE20__
            case VDOPLY_TOUCH_MUTE:
                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                mmi_vdoply_press_mute_up();
                break;
        #endif
                
        #ifdef MMI_VDOPLY_3D_ANAGLYPH
            case VDOPLY_TOUCH_MODE:
                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                mmi_vdoply_toggle_mode_key_release();
                break;
        #endif
        default:
        {
	    S32 icon_id;
    	    wgui_status_icon_bar_pen_enum evt_type;
	    wgui_status_icon_bar_translate_pen_event(
		        MMI_PEN_EVENT_UP,
		        pos.x,
		        pos.y,
		        &icon_id,
		        &evt_type);
	}
        break;
        }

    }
    
    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_pen_log_tap_hdlr
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_touch_scr_pen_log_tap_hdlr(mmi_pen_point_struct pos)	
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
        
        switch (g_vdoply_cntx.touch_object)
        {
            case VDOPLY_TOUCH_VOLUME_INC:
            case VDOPLY_TOUCH_VOLUME_DEC:
				
        #ifdef __VDOPLY_FEATURE_SPEED__   
            case VDOPLY_TOUCH_SPEED_DEC:
        #endif /* __VDOPLY_FEATURE_SPEED__ */
            
            case VDOPLY_TOUCH_PROGRESS_INC:
				#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
				mmi_vdoply_fastforward();
				break;
				#endif
            case VDOPLY_TOUCH_PROGRESS_DEC:
				#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
				mmi_vdoply_rewind();
				break;
				#endif
            case VDOPLY_TOUCH_PROGRESS_BAR:         

                /* snapshot */
        #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            case VDOPLY_TOUCH_SNAPSHOT:         
        #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 
		
                /* fullscreen */
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            case VDOPLY_TOUCH_FULLSCREEN:
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 
		
            case VDOPLY_TOUCH_RSK:
            case VDOPLY_TOUCH_LSK:
            case VDOPLY_TOUCH_CK:
            case VDOPLY_TOUCH_PLAY:
            case VDOPLY_TOUCH_STOP:
            case VDOPLY_TOUCH_MUTE:
            case VDOPLY_TOUCH_MODE:
                mmi_vdoply_touch_feedback_play(TOUCH_FEEDBACK_HOLD);
                break; 
	default:
	{
            S32 icon_id;
	    wgui_status_icon_bar_pen_enum evt_type;					
		//kal_prompt_trace(MOD_MMI,"[SAMEER] vdoply long tap");
	    wgui_status_icon_bar_translate_pen_event(
	        MMI_PEN_EVENT_LONG_TAP,
	        pos.x,
	        pos.y,
	        &icon_id,
	        &evt_type);
       }
		break;
        }

    }
    
    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_pen_move_hdlr
 * DESCRIPTION
 *  touch screen hdlr when pen move
 * PARAMETERS
 *  pos     [IN]        Pen move position
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_touch_scr_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 shift;
    S32 ratio;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        /* do nothing when pen down */
        return;
    }
    else
    {
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_MOVE, pos.x, pos.y, g_vdoply_cntx.touch_object, __LINE__); 

        /* not fullscreen */
        switch (g_vdoply_cntx.touch_object)
        {
        #ifdef __VDOPLY_FEATURE_VOLUME__
            case VDOPLY_TOUCH_VOLUME_INC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC]))
                {
                    mmi_vdoply_vol_up_key_release();
 
                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_VOLUME_DEC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC]))
                {
                    mmi_vdoply_vol_down_key_release();

                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;
			#endif

            case VDOPLY_TOUCH_SPEED_INC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_speed();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_SPEED_DEC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_speed();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_PROGRESS_INC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC]))
                {
                    #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
					g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;
                    mmi_vdoply_right_arrow_key_release();
					#else 
                    mmi_vdoply_seek_foward_key_release();
                    #endif

                    mmi_vdoply_draw_panel_progress();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_PROGRESS_DEC:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC]))
                {
                    #ifdef MMI_VDOPLY_FEATURE_LONGPRESS
					g_vdoply_cntx.is_switch_to_play_next_file = MMI_FALSE;
					mmi_vdoply_left_arrow_key_release();
					#else
                    mmi_vdoply_seek_backward_key_release();
                    #endif

                    mmi_vdoply_draw_panel_progress();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_PROGRESS_BAR:
                if (pos.x > (g_vdoply_osd_cntx.panel.progress_empty.offset_x + g_vdoply_cntx.progress.fill_width - 1))
                {
                    g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.video_info.total_time_duration;
                }
                else if (pos.x < g_vdoply_osd_cntx.panel.progress_empty.offset_x)
                {
                    g_vdoply_cntx.cur_status.play_time = 0;
                }
                else
                {
                    shift = pos.x - g_vdoply_osd_cntx.panel.progress_empty.offset_x;
                    ratio = (shift << 10) / g_vdoply_cntx.progress.fill_width;

                    g_vdoply_cntx.cur_status.play_time = (g_vdoply_cntx.video_info.total_time_duration * ratio) >> 10;
                }

                if (g_vdoply_cntx.cur_status.play_time > g_vdoply_cntx.cur_status.max_play_time)
                {
                    g_vdoply_cntx.cur_status.play_time = g_vdoply_cntx.cur_status.max_play_time;
                }
                mmi_vdoply_draw_panel_progress();
                mmi_vdoply_draw_panel_timer();
                mmi_vdoply_blt_screen();
                break;

            #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            case VDOPLY_TOUCH_SNAPSHOT:
                /* snapshot */            
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT]))
                {
                    /* if move out */
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_state();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;
            #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 


            #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            case VDOPLY_TOUCH_FULLSCREEN:
                /* fullscreen */
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;

                #ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__
                    mmi_vdoply_draw_panel_ctrl_button();
                #elif __MMI_FTE_SUPPORT__
                    mmi_vdoply_draw_softkey();
                #else
                    mmi_vdoply_draw_panel_state();
                #endif
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

            case VDOPLY_TOUCH_RSK:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press = MMI_FALSE;

					mmi_vdoply_draw_softkey_and_blt();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_LSK:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK]))
                {
                     g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press = MMI_FALSE;

					mmi_vdoply_draw_softkey_and_blt();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_CK:
                if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press = MMI_FALSE;

					mmi_vdoply_draw_softkey_and_blt();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_PLAY:
                 if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = MMI_FALSE;

                	mmi_vdoply_draw_bg();
				    mmi_vdoply_draw_title();
				    mmi_vdoply_draw_softkey();
				    mmi_vdoply_draw_panel();
                    mmi_vdoply_blt_screen();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

            case VDOPLY_TOUCH_STOP:
                 if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_ctrl_button();
                    mmi_vdoply_blt_screen();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;

        #ifdef __VDOPLY_FEATURE_FTE20__
            case VDOPLY_TOUCH_MUTE:
                 if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;
       #endif
       
        #ifdef MMI_VDOPLY_3D_ANAGLYPH
                case VDOPLY_TOUCH_MODE:
                 if (!mmi_vdoply_touch_scr_hit_test(pos.x, pos.y, &g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE]))
                {
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press = MMI_FALSE;

                    mmi_vdoply_draw_panel_mode();
                    mmi_vdoply_blt_screen();

                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                }
                break;
       #endif
       default:
       {
            S32 icon_id;
    	    wgui_status_icon_bar_pen_enum evt_type;
	    wgui_status_icon_bar_translate_pen_event(
	        MMI_PEN_EVENT_MOVE,
	        pos.x,
	        pos.y,
	        &icon_id,
	        &evt_type);
	}
       	break;
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_pen_abort_hdlr
 * DESCRIPTION
 *  touch screen hdlr when pen move
 * PARAMETERS
 *  pos     [IN]        Pen move position
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_touch_scr_pen_abort_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.touch_object == VDOPLY_TOUCH_NONE)
    {
        return;
    }

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
        /* do nothing when pen down */
        return;
    }
    else
    {
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_TOUCH_PEN_MOVE, pos.x, pos.y, g_vdoply_cntx.touch_object, __LINE__); 

        /* not fullscreen */
        switch (g_vdoply_cntx.touch_object)
        {
        #ifdef __VDOPLY_FEATURE_VOLUME__
            case VDOPLY_TOUCH_VOLUME_INC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_INC].is_press = MMI_FALSE; 
                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_VOLUME_DEC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_VOLUME_DEC].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;

                break;
			#endif

            case VDOPLY_TOUCH_SPEED_INC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_INC].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_speed();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_SPEED_DEC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SPEED_DEC].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_speed();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_PROGRESS_INC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_INC].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_progress();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            case VDOPLY_TOUCH_PROGRESS_DEC:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PROGRESS_DEC].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_progress();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
               break;

            case VDOPLY_TOUCH_PROGRESS_BAR:
                mmi_vdoply_draw_panel_progress();
                mmi_vdoply_draw_panel_timer();
                mmi_vdoply_blt_screen();
                g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

            #ifdef __VDOPLY_FEATURE_SNAPSHOT__
            case VDOPLY_TOUCH_SNAPSHOT:                
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_state();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                
                break;
            #endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 


            #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            case VDOPLY_TOUCH_FULLSCREEN:                
                g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;

                #ifdef __VDOPLY_FEATURE_CROSS_LAYEROUT__
                    mmi_vdoply_draw_panel_ctrl_button();
                #elif __MMI_FTE_SUPPORT__
                    mmi_vdoply_draw_softkey();
                #else
                    mmi_vdoply_draw_panel_state();
                #endif
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                
                break;

            #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */ 

            case VDOPLY_TOUCH_RSK:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press = MMI_FALSE;
					mmi_vdoply_draw_softkey_and_blt();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;                
                break;

            case VDOPLY_TOUCH_LSK:                
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_LSK].is_press = MMI_FALSE;
					mmi_vdoply_draw_softkey_and_blt();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;               
                break;

            case VDOPLY_TOUCH_CK:
                 g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press = MMI_FALSE;
				 mmi_vdoply_draw_softkey_and_blt();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;               
                break;

            case VDOPLY_TOUCH_PLAY:                
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_ctrl_button();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;                
                break;

            case VDOPLY_TOUCH_STOP:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_ctrl_button();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;

        #ifdef __VDOPLY_FEATURE_FTE20__
                case VDOPLY_TOUCH_MUTE:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MUTE].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_volume();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;
       #endif
       
        #ifdef MMI_VDOPLY_3D_ANAGLYPH
                case VDOPLY_TOUCH_MODE:
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_MODE].is_press = MMI_FALSE;
                    mmi_vdoply_draw_panel_mode();
                    mmi_vdoply_blt_screen();
                    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
                break;
       #endif
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_hit_test
 * DESCRIPTION
 *  test if is within touch region
 * PARAMETERS
 *  pos_x           [IN]        Position x
 *  pos_y           [IN]        Position y
 *  touch_obj       [?]         
 *  touch(?)        [IN]        Touch object structure
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_vdoply_touch_scr_hit_test(S32 pos_x, S32 pos_y, vdoply_ui_touch_struct *touch_obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!touch_obj->is_usable)
    {
        return FALSE;
    }
    
    if ((pos_x >= touch_obj->offset_x) &&
        (pos_x < touch_obj->offset_x + touch_obj->width) &&
        (pos_y >= touch_obj->offset_y) && (pos_y < touch_obj->offset_y + touch_obj->height))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_touch_scr_hit_test_with_border
 * DESCRIPTION
 *  test if is within touch region
 * PARAMETERS
 *  pos_x           [IN]        Position x
 *  pos_y           [IN]        Position y
 *  touch_obj       [IN]        Touch object structure
 *  border_x        [IN]        x extra region
 *  border_y        [IN]        y extra region
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_vdoply_touch_scr_hit_test_with_border(S32 pos_x, S32 pos_y, vdoply_ui_touch_struct *touch_obj, S32 border_x, S32 border_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!touch_obj->is_usable)
    {
        return FALSE;
    }
    
    if ((pos_x >= touch_obj->offset_x - border_x) &&
        (pos_x < touch_obj->offset_x + touch_obj->width + border_x ) &&
        (pos_y >= touch_obj->offset_y - border_y) &&
        (pos_y < touch_obj->offset_y + touch_obj->height + border_y))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 * mmi_vdoply_touch_feedback_play
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_touch_feedback_play(mmi_vdoply_touch_feedback_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if defined(__MMI_TOUCH_FEEDBACK_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*defined(__MMI_TOUCH_FEEDBACK_SUPPORT__)*/
}


#endif /* defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__) */ /* __VDOPLY_FEATURE_TOUCH_SCREEN__ & __MMI_TOUCH_SCREEN__ */


#ifdef __MMI_AVRCP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bt_avrcp_cmd_hdlr
 * DESCRIPTION
 *  ACRCP command handler
 * PARAMETERS
 *  command     [IN]     command type
 *  event       [IN]     key event
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static U8 mmi_vdoply_bt_avrcp_cmd_hdlr(U8 command, mmi_avrcp_key_events event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 result = MMI_AVRCP_CR_ACCEPT;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (command)
    {
        case MMI_AVRCP_POP_PLAY:
        case MMI_AVRCP_POP_PAUSE:    
            MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_PLAY_POP, __LINE__);                    
            if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
            #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            
                /* full screen */
                if (event == MMI_AVRCP_KEY_UP)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_UP, __LINE__);
                    mmi_vdoply_toggle_fullscreen_key_release();
                }
                else if (event == MMI_AVRCP_KEY_DOWN)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_DOWN, __LINE__);
                    mmi_vdoply_toggle_fullscreen_key_press();
                }
                else if (event == MMI_AVRCP_KEY_CANCELED)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_CANCEL, __LINE__);
                    
                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;
                    
                    mmi_vdoply_blt_screen();
                }
                else
                {
                    /* ingore others */
                }        
            #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */        
            }
            else
            {
                /* normal screen */
                if (event == MMI_AVRCP_KEY_UP)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_UP, __LINE__);
                    #ifndef __MMI_FTE_SUPPORT__
                        mmi_vdoply_ck_release();
                    #else
                        mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
					    mmi_vdoply_play_button_worked();
                    #endif
                }
                else if (event == MMI_AVRCP_KEY_DOWN)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_DOWN, __LINE__);
                    #ifndef __MMI_FTE_SUPPORT__
                        mmi_vdoply_ck_press();
                    #else
                        mmi_vdoply_ctrl_button_pressed(VDOPLY_TOUCH_PLAY);
                    #endif
                }
                else if (event == MMI_AVRCP_KEY_CANCELED)
                {
                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_CANCEL, __LINE__);

                    #ifndef __MMI_FTE_SUPPORT__
                        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_press = MMI_FALSE;
                    #else
                        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_press = MMI_FALSE;
                    #endif
                    
					mmi_vdoply_draw_softkey_and_blt();
                }
                else
                {
                    /* ingore others */
                }
            }
            break;

        case MMI_AVRCP_POP_STOP:
            MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_STOP, __LINE__);
            
            if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
            #ifdef __VDOPLY_FEATURE_FULLSCREEN__
                if (g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY || 
                    g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PAUSE ||
                    g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_BT_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_SEEKING || 
                    g_vdoply_cntx.state == VDOPLY_STATE_FULLSCR_PLAY_SEEKING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_PLAY ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING)
                {
                    /* full screen */
                    if (event == MMI_AVRCP_KEY_UP)
	                {
	                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_UP, __LINE__);
	                    mmi_vdoply_toggle_fullscreen_key_release();
	                }
	                else if (event == MMI_AVRCP_KEY_DOWN)
	                {
	                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_DOWN, __LINE__);
	                    mmi_vdoply_toggle_fullscreen_key_press();
	                }
	                else if (event == MMI_AVRCP_KEY_CANCELED)
	                {
	                    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_CANCEL, __LINE__);
	                    
	                    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_FULLSCREEN].is_press = MMI_FALSE;
	                    
	                    mmi_vdoply_blt_screen();
	                }
	                else
	                {
	                    /* ingore others */
	                } 
                }
            #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
            }
            else
            {
                /* normal screen */
                if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY || 
                    g_vdoply_cntx.state == VDOPLY_STATE_PAUSE ||
                    g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_SEEKING || 
                    g_vdoply_cntx.state == VDOPLY_STATE_PLAY_SEEKING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING ||
                    g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
                {
                    /* full screen */
                    if (event == MMI_AVRCP_KEY_UP)
                    {
                        MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_UP, __LINE__);
                        #ifndef __MMI_FTE_SUPPORT__
                            mmi_vdoply_rsk_release();
                        #else
                            mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_STOP);
                            mmi_vdoply_stop_button_worked();
                        #endif
                    }
                    else if (event == MMI_AVRCP_KEY_DOWN)
                    {
                        MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_DOWN, __LINE__);
                        #ifndef __MMI_FTE_SUPPORT__
                            mmi_vdoply_rsk_press();
                        #else
                            mmi_vdoply_ctrl_button_pressed(VDOPLY_TOUCH_STOP);
                        #endif
                    }
                    else if (event == MMI_AVRCP_KEY_CANCELED)
                    {
                        MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_AVRCP_KEY_CANCEL, __LINE__);
                        #ifndef __MMI_FTE_SUPPORT__
                            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_RSK].is_press = MMI_FALSE;
                        #else
                            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_press = MMI_FALSE;
                        #endif
						mmi_vdoply_draw_softkey_and_blt();
                    }
                    else
                    {
                        /* ingore others */
                    }   
                }
 
            }
            break;

        default:
            result = MMI_AVRCP_CR_NOT_IMPLEMENT;
            break;
    }

    return result;

}
#endif /* __MMI_AVRCP_SUPPORT__ */

#if defined(__BT_SPK_VOL_CONTROL__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_hfp_vol_hdlr
 * DESCRIPTION
 *  HFP volume adjust callback
 * PARAMETERS
 *  volume     [IN]     volume type
 *  is_mute    [IN]     mute flag
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_hfp_vol_hdlr(U8 volume, MMI_BOOL is_mute)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __VDOPLY_FEATURE_VOLUME__    
    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_HFP_VOL_PARA, volume, is_mute, __LINE__);

    if(mmi_vdoply_is_in_app() &&
       GetKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN) == mmi_vdoply_vol_up_key_press)
    {     
        MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_VOL_CURR, g_vdoply_cntx.cur_status.volume, g_vdoply_cntx.is_mute);
    #ifdef __VDOPLY_FEATURE_VOLUME_MUTE__
        if (g_vdoply_cntx.is_mute != is_mute)
        {
            g_vdoply_cntx.is_mute = is_mute;
            mdi_audio_set_mute(MDI_VOLUME_MEDIA, is_mute);
        }
        
        if(is_mute != MMI_TRUE && volume <= VDOPLY_VOL_16)
        {
            g_vdoply_cntx.cur_status.volume = volume;
            mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }
        
    #else /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 
        /* ignore mute command */
        if (volume <= VDOPLY_VOL_16)
        {
            g_vdoply_cntx.cur_status.volume = volume;
            mdi_audio_set_volume(MDI_VOLUME_MEDIA, MDI_AUD_VOL_EX(g_vdoply_cntx.cur_status.volume));
        }
    #endif /* __VDOPLY_FEATURE_VOLUME_MUTE__ */ 
    
        /****************/
        /* redraw panel */
        /****************/

        if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
        {
           mmi_vdoply_draw_panel_volume();
           mmi_vdoply_blt_screen();
        }
        
        return MMI_TRUE;    /* return TRUE if the request is being handled */
    }
#endif /* __VDOPLY_FEATURE_VOLUME__ */
    
    return MMI_FALSE;       /* have to return FALSE if not running */
}
#endif /* __BT_SPK_VOL_CONTROL__ */


#ifdef __VDOPLY_FEATURE_SHOW_STATUS_BAR__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_redraw_status_bar_background_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_redraw_status_bar_background_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    gdi_handle act_hdlr;
    gdi_layer_struct* act_l;
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_push_clip();

    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gdi_layer_set_clip(x1, y1, x2, y2);
    #if defined __VDOPLY_FEATURE_FTE20__
        gdi_layer_get_active(&act_hdlr);
        act_l = (gdi_layer_struct*)act_hdlr;
        gdi_bitblt(
            g_vdoply_cntx.bg_layer_handle, 
            0 + act_l->offset_x, 
            0 + act_l->offset_y, 
            act_l->width - 1 + act_l->offset_x, 
            act_l->height - 1 + act_l->offset_y, 
            0,
            0);
    #elif defined(__VDOPLY_FEATURE_MULTI_REGION_LAYER_BG__)
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);
    #else
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    #endif

    gdi_layer_pop_clip();

}

#endif /* __VDOPLY_FEATURE_SHOW_STATUS_BAR__ */


#ifdef MMI_VDOPLY_RSK_EXIT
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_ctrl_button_pressed
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_ctrl_button_pressed(U32 mark)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_ctrl_button_do_action(mark, MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_ctrl_button_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_ctrl_button_released(U32 mark)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_ctrl_button_do_action(mark, MMI_FALSE);
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_start_non_block_seeking
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_start_non_block_seeking(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_NON_BLOCK_SEEKING) == MMI_TRUE)
	{
	    ret = mdi_video_ply_stop_non_block_seek();
		if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
        {
            return;
        }
		VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_NON_BLOCK_SEEKING);
	}
	//mmi_vdoply_stop_non_block_seeking();

    ret = mdi_video_ply_non_block_seek_and_get_frame(
                    g_vdoply_cntx.cur_status.play_time,
                    g_vdoply_cntx.play_wnd_layer_handle,
                    mmi_vdoply_seek_result_hdlr, 
                    0);

    if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
    {
        mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_BUFFERING);
        return;
    }

    /* disconnect BT if needed */
    mmi_vdoply_disconnect_bt();

    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
    {
        return;
    }
	VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_NON_BLOCK_SEEKING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stop_non_block_seeking
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stop_non_block_seeking(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_NON_BLOCK_SEEKING) == MMI_TRUE)
	{
	    ret = mdi_video_ply_stop_non_block_seek();
		if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
        {
            return;
        }
		VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_NON_BLOCK_SEEKING);
	}
}

/*build warning fix*/
#if (defined(__VDOPLY_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__)) || defined(MMI_VDOPLY_RSK_EXIT)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_button_worked
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_play_button_worked(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_OPENING:
        case VDOPLY_STATE_INTERRUPTED_OPENING:

            mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            break;            
    
        case VDOPLY_STATE_IDLE:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }

            break;

        case VDOPLY_STATE_PLAY:
            /* get latest time */
            mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();
            mmi_vdoply_blt_screen();

            mmi_vdoply_stop_video();
			#ifdef __MAIN_LCM_SCANLINE_ROTATION_270__
			mdi_video_ply_seek_and_get_frame(g_vdoply_cntx.cur_status.play_time,g_vdoply_cntx.play_wnd_layer_handle);		
			mmi_vdoply_blt_screen();
			#endif
            mmi_vdoply_enter_state(VDOPLY_STATE_PAUSE);

            break;

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:
        
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }

            break;

		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:
            mmi_vdoply_stop_non_block_seeking();
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }

            break;

        #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
            break;
            
        case VDOPLY_STATE_STREAM_BUFFERING:
            mmi_vdoply_stream_stop_buffering();
            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
                mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
                mmi_vdoply_draw_softkey();
            #else
                mmi_vdoply_draw_softkey();
            #endif

            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
            break;
            
        case VDOPLY_STATE_STREAM_PLAY:

            mmi_vdoply_stop_video();                             

            /* get latest time */
            mdi_video_stream_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);
            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();

            #ifdef __MMI_FTE_SUPPORT__
                g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
                mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
                mmi_vdoply_draw_softkey();
            #else
                mmi_vdoply_draw_softkey();
            #endif

            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
			break;
				
        case VDOPLY_STATE_STREAM_CONNECTED:
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_draw_softkey();
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
            }   

            mmi_vdoply_blt_screen();
            break;
            
        case VDOPLY_STATE_STREAM_DISCONNECT: 
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTING);            
            break;            

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            /* ck is disable in these stats */
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:

            mmi_vdoply_stop_video();            

            mmi_vdoply_blt_screen();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTED);
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            mmi_vdoply_blt_screen();
            
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
            }   
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:  
            mmi_vdoply_blt_screen();
            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_CONNECTING);    
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    #endif /* __MMI_VIDEO_STREAM__ */

        case VDOPLY_STATE_BACKGROUND_CALL:
        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
            mmi_vdoply_draw_softkey();
            mmi_vdoply_blt_screen();            
            mmi_vdoply_display_not_available_popup(GRP_ID_VDOPLY_SINGLE_PLAYER);
            break;

    }
}

#ifdef MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
static void mmi_vdoply_play_prev_file_worked(void)
{
    mmi_vdoply_play_prev_next_file_worked(MMI_FALSE);	
}

static void mmi_vdoply_play_next_file_worked(void)
{
	mmi_vdoply_play_prev_next_file_worked(MMI_TRUE);
}

static void mmi_vdoply_play_prev_next_file_worked_ext(MMI_BOOL play_next)
{
	SRV_FMGR_FILELIST_HANDLE hlist;
	S32 cur_index,ret;
	srv_fmgr_fileinfo_struct info;
	WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];

    mmi_vdoply_close_file();
	g_vdoply_cntx.state = VDOPLY_STATE_EXIT; 
	ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
	if(ret == 0)
	{
		g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
		if(g_vdoply_cntx.total_files > 1)
		{
			memset(file_name, 0, sizeof(file_name));
			if(play_next)
			{			
				if(++cur_index >= g_vdoply_cntx.total_files)
				{
					cur_index = 0;
					//cur_index = g_vdoply_cntx.total_files - 1;
				}
			}
			else
			{			
				if(--cur_index < 0)
				{
					cur_index = g_vdoply_cntx.total_files - 1;
					//cur_index = 0;
				}			
			}
			cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
			cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);

			mmi_ucs2cpy(g_vdoply_cntx.source_path, (CHAR*)file_name);
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_FILE;
			mmi_vdoply_create_title_name();
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
		}
		else
		{
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		}
	}
	else
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		mmi_vdoply_stop_button_worked();
	}
}

static void mmi_vdoply_play_prev_next_file_worked(MMI_BOOL is_next)
{    
	SRV_FMGR_FILELIST_HANDLE hlist;
	S32 cur_index, index_saved, ret;
	srv_fmgr_fileinfo_struct info;
	WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];
	if(1)
	{
		ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
		if(ret == 0)
		{
			index_saved = cur_index;
			g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
			if(g_vdoply_cntx.total_files > 0)
			{
            	if(is_next)
            	{
					if(++cur_index == g_vdoply_cntx.total_files)
					{
						cur_index = 0;
					}
				}
				else
				{
					if(--cur_index < 0)
					{
						cur_index = g_vdoply_cntx.total_files - 1;
					}
				}
				cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
				ret = cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
				if(ret == SRV_FMGR_FILELIST_ERROR_FILE_NOT_READY)
				{
                
					if(is_next)
					{
						srv_fmgr_filelist_load_file(hlist, cur_index, mmi_vdoply_switch_last_to_first_file_hdlr, NULL);
					}
					else
					{
						srv_fmgr_filelist_load_file(hlist, cur_index, mmi_vdoply_switch_first_to_last_file_hdlr, NULL);
					}
					cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
					//cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
					return;
				}
				cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, index_saved);
			}
		}
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
	}
	
	switch(g_vdoply_cntx.state)
	{
		case VDOPLY_STATE_IDLE: /* stop */ 
			mmi_vdoply_play_prev_next_file_worked_ext(is_next);
			break;
			
		case VDOPLY_STATE_PLAY: /* stop */
			mmi_vdoply_stop_video();

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
			mmi_vdoply_play_prev_next_file_worked_ext(is_next);
			break;

		case VDOPLY_STATE_BT_CONNECTING: 
			mmi_vdoply_disconnect_bt();
			mmi_vdoply_play_prev_next_file_worked_ext(is_next);
			break;

		case VDOPLY_STATE_INTERRUPTED_PAUSE:
		case VDOPLY_STATE_PAUSE:	/* stop */

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
			
			mmi_vdoply_play_prev_next_file_worked_ext(is_next);
			break;

		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:			

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

			mmi_vdoply_stop_non_block_seeking();
			mmi_vdoply_play_prev_next_file_worked_ext(is_next);
			break;		 
		default:
			break;
	}
	
}

#else
static void mmi_vdoply_play_prev_file_worked_ext(void)
{
	SRV_FMGR_FILELIST_HANDLE hlist;
	S32 cur_index, ret;
	srv_fmgr_fileinfo_struct info;
	WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];

	ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
	if(ret == 0)
	{
		g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
		if(g_vdoply_cntx.total_files > 1)
		{
			memset(file_name, 0, sizeof(file_name));
			
			if(--cur_index < 0)
			{
				cur_index = g_vdoply_cntx.total_files - 1;
				//cur_index = 0;
			}
			cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
			cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);

			mmi_ucs2cpy(g_vdoply_cntx.source_path, (CHAR*)file_name);
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_FILE;
			mmi_vdoply_create_title_name();
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
		}
		else
		{
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		}
	}
	else
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		mmi_vdoply_stop_button_worked();
	}
}

static void mmi_vdoply_play_prev_file_worked(void)
{
	switch(g_vdoply_cntx.state)
	{
		case VDOPLY_STATE_IDLE: /* stop */
			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_prev_file_worked_ext();
			break;
			
		case VDOPLY_STATE_PLAY: /* stop */
			mmi_vdoply_stop_video();

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_prev_file_worked_ext();
			break;


		case VDOPLY_STATE_BT_CONNECTING: 
			mmi_vdoply_disconnect_bt();
			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_prev_file_worked_ext();
			break;

		case VDOPLY_STATE_INTERRUPTED_PAUSE:
		case VDOPLY_STATE_PAUSE:	/* stop */

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
			
			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_prev_file_worked_ext();
			break;

		case VDOPLY_STATE_SEEKING:
		case VDOPLY_STATE_PLAY_SEEKING:
		case VDOPLY_STATE_INTERRUPTED_SEEKING:			

			/* user force stop, need consume count */
			g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

			mmi_vdoply_stop_non_block_seeking();
			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_prev_file_worked_ext();

			break;		 
		default:
			break;
	}

}

static void mmi_vdoply_play_next_file_worked_ext(void)
{
	SRV_FMGR_FILELIST_HANDLE hlist;
	S32 cur_index, ret;
	srv_fmgr_fileinfo_struct info;
	WCHAR file_name[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];

	ret = cui_folder_browser_lock_filelist(g_vdoply_cntx.fmgr_scr_id, &hlist, &cur_index);
	if(ret == 0)
	{
		g_vdoply_cntx.total_files = srv_fmgr_filelist_count(hlist);
		if(g_vdoply_cntx.total_files > 1)
		{
			memset(file_name, 0, sizeof(file_name));
			if(++cur_index >= g_vdoply_cntx.total_files)
			{
				cur_index = 0;
				//cur_index = g_vdoply_cntx.total_files - 1;
			}
			cui_folder_browser_set_highlight_index(g_vdoply_cntx.fmgr_scr_id, cur_index);
			cui_folder_browser_get_filepath(g_vdoply_cntx.fmgr_scr_id, cur_index, &info, file_name, sizeof(file_name));
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);

			mmi_ucs2cpy(g_vdoply_cntx.source_path, (CHAR*)file_name);
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_FILE;
			mmi_vdoply_create_title_name();
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
		}
		else
		{
			mmi_vdoply_enter_state(VDOPLY_STATE_OPENING);
			cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		}
	}
	else
	{
		cui_folder_browser_unlock_filelist(g_vdoply_cntx.fmgr_scr_id);
		mmi_vdoply_stop_button_worked();
	}
}

static void mmi_vdoply_play_next_file_worked(void)
{
	switch(g_vdoply_cntx.state)
	{
		case VDOPLY_STATE_IDLE: /* stop */
			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_next_file_worked_ext();
            break;
			
        case VDOPLY_STATE_PLAY: /* stop */
            mmi_vdoply_stop_video();

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

			mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_next_file_worked_ext();
            break;


        case VDOPLY_STATE_BT_CONNECTING: 
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_next_file_worked_ext();
            break;

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:    /* stop */

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
            
            mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_next_file_worked_ext();
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
        case VDOPLY_STATE_INTERRUPTED_SEEKING:	        

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

            mmi_vdoply_stop_non_block_seeking();
            mmi_vdoply_close_file();
			g_vdoply_cntx.state = VDOPLY_STATE_EXIT;  
			mmi_vdoply_play_next_file_worked_ext();

            break;       
		default:
			break;
	}
}
#endif
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stop_button_worked
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stop_button_worked(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_vdoply_cntx.state)
    {
         case VDOPLY_STATE_IDLE: /* stop */
            mmi_vdoply_blt_screen();
            break;
			
        case VDOPLY_STATE_PLAY: /* stop */
            mmi_vdoply_stop_video();

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
            break;

		#ifdef __VDOPLY_FEATURE_BT__
        case VDOPLY_STATE_BT_CONNECTING: 
            mmi_vdoply_disconnect_bt();
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
            break;
		#endif

        case VDOPLY_STATE_INTERRUPTED_PAUSE:
        case VDOPLY_STATE_PAUSE:    /* stop */

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
            
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
            break;

        case VDOPLY_STATE_SEEKING:
        case VDOPLY_STATE_PLAY_SEEKING:
        case VDOPLY_STATE_INTERRUPTED_SEEKING:	        

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

            mmi_vdoply_stop_non_block_seeking();
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);

            break;

        case VDOPLY_STATE_BACKGROUND_CALL:
			cui_vdoply_exit_button_worked();
            break;        

    #ifdef __MMI_VIDEO_STREAM__
        case VDOPLY_STATE_STREAM_PLAY:
            mmi_vdoply_stop_video();
            
            g_vdoply_cntx.cur_status.play_time = 0;
            g_vdoply_cntx.cur_status.start_play_time = 0;   

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;

            

			if(g_vdoply_cntx.video_info.is_seekable)
            {
            	mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
            }
			else
			{
			    mdi_video_stream_disconnect();
				mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
				
			}
            break;
            
        case VDOPLY_STATE_STREAM_CONNECTED:
            g_vdoply_cntx.cur_status.play_time = 0;

            mmi_vdoply_draw_panel_timer();
            mmi_vdoply_draw_panel_progress();

            #ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
            mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
            #endif

			mmi_vdoply_draw_softkey_and_blt();
            break;

        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
            mmi_vdoply_stop_animation();
            
            mdi_video_stream_disconnect();
            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);            
            break;        
            
        case VDOPLY_STATE_STREAM_BUFFERING:
            mmi_vdoply_stream_stop_buffering();

            if(g_vdoply_cntx.video_info.is_seekable)
            {
            	mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);
            }
			else
			{
			    mdi_video_stream_disconnect();
				mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
				
			}               
            break;     

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            mmi_vdoply_disconnect_bt();

            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_CONNECTED);                
            break;     
            
    #endif /* __MMI_VIDEO_STREAM__ */

    #ifdef __MMI_VIDEO_PDL__
            
        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:                 

            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);
            mdi_video_progressive_close_file();
			cui_vdoply_exit_button_worked();
            break;

        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING: 

            /* user force stop, need consume count */
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;
            
            gui_cancel_timer(mmi_vdoply_pdl_buffering_cyclic);
            mdi_video_progressive_close_file();
			cui_vdoply_exit_button_worked();
            break;

    #endif /* __MMI_VIDEO_PDL__ */

    }
}
#endif

#ifdef MMI_VDOPLY_RSK_EXIT
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_button_presse
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_play_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_PLAY].is_usable)
    {
         mmi_vdoply_ctrl_button_pressed(VDOPLY_TOUCH_PLAY);
	     g_vdoply_cntx.touch_object = VDOPLY_TOUCH_PLAY;
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_play_button_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_play_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_vdoply_cntx.touch_object == VDOPLY_TOUCH_PLAY)
    {
        mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_PLAY);
	    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
		mmi_vdoply_play_button_worked();
    }
    
}

/*To disable it because it will cause warning !Now, you can press seek button to chose play next/prev file.(press long time to seek)
If there is some key used for play next/prev, then, those functions will enabled*/
#if 0//def MMI_VDOPLY_ADD_PLAY_NEXT_PREV_FEATURE
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stop_button_pressed
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stop_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_STOP].is_usable)
    {
        mmi_vdoply_ctrl_button_pressed(VDOPLY_TOUCH_STOP);
	    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_STOP;
    }
    
}


/*****************************************************************************
 * FUNCTION
 * mmi_vdoply_stop_button_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stop_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_vdoply_cntx.touch_object == VDOPLY_TOUCH_STOP)
    {
        mmi_vdoply_ctrl_button_released(VDOPLY_TOUCH_STOP);
	    g_vdoply_cntx.touch_object = VDOPLY_TOUCH_NONE;
		mmi_vdoply_stop_button_worked();
    }
}
#endif


#ifdef __MMI_AP_DCM_VDOPLY__
#pragma arm section rodata, code
#endif

#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
static void mmi_vdoply_get_drive_callback(CHAR drv_letter)
{
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 create_result;
    U16 prev_storage;
    MMI_ID_TYPE err_strid;
    mmi_event_notify_enum popup_type;
    if (drv_letter != 0)
    {
        prev_storage = g_vdoply_cntx.storage;
        g_vdoply_cntx.storage = (U16)drv_letter;
        mmi_vdoply_get_storage_file_path(buf_filepath);
        create_result = mmi_vdoply_create_file_dir(buf_filepath);
        if (create_result != FS_NO_ERROR)
        {
            err_strid = srv_fmgr_fs_error_get_string(create_result);
            popup_type = (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(create_result);
            mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, err_strid, popup_type); 
            g_vdoply_cntx.prev_storage = g_vdoply_cntx.storage;
            g_vdoply_cntx.storage = prev_storage;    
            return;            
        }
        else
        {
            mmi_vdoply_store_setting();
        #ifdef __MMI_CAMCORDER__
            mmi_camco_set_storage(g_vdoply_cntx.storage);
        #endif
        #ifdef __MMI_IMAGE_VIEWER__
            mmi_imgview_set_storage(g_vdoply_cntx.storage);
        #endif
            if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_OPTION_STORAGE) == MMI_TRUE)
            {        
                mmi_frm_group_close(GRP_ID_VDOPLY_STORAGE);
                cui_folder_browser_close(g_vdoply_cntx.fmgr_scr_id); 
            }
            else
            {
                 mmi_frm_group_close(GRP_ID_VDOPLY_STORAGE);
            }
            return;
        }
    }
    else
    {
        if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_OPTION_STORAGE) == MMI_TRUE)
        {
            mmi_frm_group_close(GRP_ID_VDOPLY_STORAGE);
        }
        else
        {
            mmi_frm_group_close(GRP_ID_VDOPLY_APP);
		#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
        }
    }
}
static void mmi_vdoply_storage_select_cb(S32 drv_letter)
{
    if (drv_letter >= 0)
    {
        mmi_vdoply_get_drive_callback((CHAR)drv_letter);
    }
}
static void mmi_vdoply_entry_set_app_storage_screen(void)
{
    VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_OPTION_STORAGE);
    mmi_vdoply_entry_set_storage_screen_internal();
}
static void mmi_vdoply_entry_set_storage_screen(void)
{
    VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_OPTION_STORAGE);
    mmi_vdoply_entry_set_storage_screen_internal();
}
static void mmi_vdoply_entry_set_storage_screen_internal(void)
{
    mmi_id fmgr_storage_selector_gid;
    U16 icon_id, string_id;
    MMI_ID ret_mmi_id;
    ret_mmi_id = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_APP, 
                    GRP_ID_VDOPLY_STORAGE, 
                    mmi_vdoply_app_proc,
                    NULL,
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    if (!ret_mmi_id)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);                
        return;
    }
    mmi_fmgr_get_app_title_info(APP_VDOPLY, &string_id, &icon_id, NULL);
    if ((fmgr_storage_selector_gid = cui_storage_selector_create(GRP_ID_VDOPLY_STORAGE, g_vdoply_cntx.storage, 0)) != GRP_ID_INVALID)
    {
        cui_storage_selector_set_title(fmgr_storage_selector_gid, NULL, icon_id);
        cui_storage_selector_set_ui_style(fmgr_storage_selector_gid, CUI_FMGR_UI_STYLE_BANNER_LIST);//NEED TEST
        cui_storage_selector_run(fmgr_storage_selector_gid);
    }
    else
    {
        mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);
        mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
    }
}
#endif


/*****************************************************************************
* FUNCTION
*  mmi_vdoply_a2dp_connect_callback_hdlr
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#if defined(__MMI_A2DP_SUPPORT__) && defined(__BT_SPEAKER_SUPPORT__)
mmi_ret mmi_vdoply_a2dp_connect_callback_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (mmi_frm_group_get_state(GRP_ID_VDOPLY_SINGLE_PLAYER) != MMI_SCENARIO_STATE_NONE)
	{
		mmi_frm_close_to_idle_group();
	}		
    
}
#endif /*defined(__MMI_A2DP_SUPPORT__) && (__BT_SPEAKER_SUPPORT__)*/


#if defined(__MMI_BT_MUSIC__) || defined(__MMI_AUDIO_PLAYER_BT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bt_music_disconnect_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_bt_music_disconnect_callback(MMI_BOOL result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (result)
    {
        mmi_vdoply_entry_player_screen_from_file(g_filename,g_is_short);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bt_music_disconnect_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_app_bt_music_disconnect_callback(MMI_BOOL result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (result)
    {
       mmi_vdoply_entry_app();
    }
}
#endif 

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_highlight_play
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_highlight_play(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_vdoply_entry_player_screen, KEY_EVENT_UP);
	SetKeyDownHandler(mmi_vdoply_entry_player_screen, KEY_RIGHT_ARROW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen
 * DESCRIPTION
 *  enter player's screen from filemanger, will use file manager's selected file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_fileinfo_struct file_info;
	cui_vdoply_param_struct param;
	cui_vdoply_type_enum cui_type;
    CHAR* buffer;
	mmi_id gid;

#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get file name from file manager's structure  */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_ENTRY_PLAYER_SCREEN);
    buffer = (CHAR*)srv_fmgr_types_query_fileinfo(&file_info);

	cui_type = CUI_VDOPLY_TYPE_FILE;
	param.video_hdr.file_name = buffer;
	param.video_title.title_str = NULL;
    param.is_short = MMI_FALSE;

#ifdef __MMI_VIDEO_STREAM__     
    if (file_info.type == FMGR_TYPE_RAM)
    {   
        cui_type = CUI_VDOPLY_TYPE_RAM_FILE;
    }
    else if (file_info.type == FMGR_TYPE_SDP)
    {
        cui_type = CUI_VDOPLY_TYPE_SDP;
    }
#endif

    gid = cui_vdoply_create(GRP_ID_VDOPLY_APP, cui_type, &param); 
    if (GRP_ID_INVALID != gid)
    {
        cui_vdoply_run(gid);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_file
 * DESCRIPTION
 *  enter player's screen and play from file
 * PARAMETERS
 *  filename        [IN]        Filename with full path
 *  is_short        [IN]        Short name, need to covert from BIG5 to Unicode before display
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_file(CHAR* filename, MMI_BOOL is_short)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_FILE);
	
	#if defined(__MMI_BT_MUSIC__) || defined(__MMI_AUDIO_PLAYER_BT__)
	if (mmi_bt_music_check_connection())
	{	    
	    g_is_short = is_short;
	    g_filename = filename;
	    
		mmi_bt_music_disconnect(mmi_vdoply_bt_music_disconnect_callback);
		//return;
	}
	#endif
	
	#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
	if(mmi_frm_app_is_launched(APP_BROWSER)&& (!mmi_frm_app_is_launched(APP_VDOPLY)))
	//if(!mmi_frm_group_is_present(BRW_SCREEN_GROUP))
	{
		//kal_prompt_trace(MOD_MMI_MEDIA_APP,"[VDOPLY]vdoply app lauched from DA play option");
		mmi_vdoply_entry_player_screen_from_browser(g_vdoply_cntx.source_path, MMI_FALSE, MMI_TRUE);
 
	}
	else
	{
		mmi_vdoply_entry_player_screen_from_file_ext(filename, is_short, NULL);
	}
	#else
	mmi_vdoply_entry_player_screen_from_file_ext(filename, is_short, NULL);
	#endif
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_file_ext
 *  filename        [IN]        Filename with full path
 *  is_short        [IN]        Short name, need to covert from BIG5 to Unicode before display
 *  title_str        [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_file_ext(CHAR* filename, MMI_BOOL is_short, CHAR* title_str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID cid;
	MMI_ID gid;
	cui_vdoply_param_struct param;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_FILE_EXT);
#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
#endif
	g_vdoply_cntx.is_entry_player_from_other_app = MMI_TRUE;
	#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
	if(g_vdoply_cntx.is_entry_player_from_browser)
	{
		if(!mmi_frm_group_is_present(APP_VDOPLY))
		{
			//kal_prompt_trace(MOD_MMI_MEDIA_APP,"[VDOPLY]don't lauch app before %d",__LINE__);
			mmi_frm_app_launch(APP_VDOPLY, 0, 0, mmi_vdoply_app_launch_proc, NULL, 0);
		}
		gid = mmi_frm_group_create_ex(
                    	APP_VDOPLY, 
                    	GRP_ID_VDOPLY_PLAYER, 
                    	mmi_vdoply_player_proc,
                    	NULL, 
                    	MMI_FRM_NODE_SMART_CLOSE_FLAG);
	}
	else
	{
		gid = mmi_frm_group_create_ex(
                    	GRP_ID_ROOT, 
                    	GRP_ID_VDOPLY_PLAYER, 
                    	mmi_vdoply_player_proc,
                    	NULL, 
                    	MMI_FRM_NODE_SMART_CLOSE_FLAG);
	}
	#else
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    #endif
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.file_name = filename;
	param.video_title.title_str = title_str;
	param.is_short = is_short;
    cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_FILE, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
	    return;
	}
	cui_vdoply_run(cid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_id
 * DESCRIPTION
 *  enter player's screen and play from ID
 * PARAMETERS
 *  video_id            [IN]        
 *  video_name_id       [IN]        Video's name string id
 *  vidoe_id(?)         [IN]        Video clip resource id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_id(U16 video_id, U16 video_name_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	MMI_ID cid;
	MMI_ID gid;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_ID, video_id);
#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
#endif
	g_vdoply_cntx.is_entry_player_from_other_app = MMI_TRUE;
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.video_id = video_id;
	param.video_title.title_id = video_name_id;
    cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_ID, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
	    return;
	}
	cui_vdoply_run(cid);
}


#ifdef __VDOPLY_FEATURE_SNAPSHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_next_snapshot_filename
 * DESCRIPTION
 *  get next file name to be snapshot
 * PARAMETERS
 *  file_buf        [OUT]       Filename buffer ptr
 *  file_path       [IN]        Filepath
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_get_next_snapshot_filename(CHAR* file_buf, CHAR* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buffer[25];
    CHAR UCS2_buffer[50];
    CHAR UCS2_testname[50];
    CHAR UCS2_alpha[10];
    S16 error = 0;
    U16 filename_seq_no;
    U16 alpha_count;
    U16 alpha_index;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get/store sequentail number */
    ReadValueSlim(NVRAM_VDOPLY_SNAPSHOT_SEQ_NO, &filename_seq_no, DS_SHORT);
    if (filename_seq_no == 0xffff)
    {
        filename_seq_no = 1;    /* init value */
    }
    else
    {
        /* TODO: if seq no turn around, add some protection */
        filename_seq_no++;
        if (filename_seq_no > 9999) /* more than 4 digits */
        {
            filename_seq_no = 1;
        }
    }
    WriteValueSlim(NVRAM_VDOPLY_SNAPSHOT_SEQ_NO, &filename_seq_no, DS_SHORT);

    alpha_count = 'Z' - 'A' + 1;
    alpha_index = 0;

    sprintf((CHAR*) buffer, "SNP%04d", filename_seq_no);
    mmi_asc_to_ucs2((CHAR*) UCS2_buffer, (CHAR*) buffer);

    while (1)
    {
        sprintf((CHAR*) buffer, "%c", 'A' + alpha_index);
        mmi_asc_to_ucs2((CHAR*) UCS2_alpha, (CHAR*) buffer);

        mmi_ucs2cpy(UCS2_testname, UCS2_buffer);
        mmi_ucs2cat(UCS2_testname, UCS2_alpha);
        mmi_ucs2cat(UCS2_testname, (CHAR*) L".jpg");

        mmi_ucs2ncpy((CHAR*) file_buf, (CHAR*) file_path, SRV_FMGR_PATH_MAX_LEN);
        mmi_ucs2cat((CHAR*) file_buf, (CHAR*) UCS2_testname);

        file_handle = FS_Open((U16*) file_buf, FS_READ_ONLY);

        if (file_handle >= 0)
        {
            /* file exist */
            FS_Close(file_handle);
            alpha_index++;
        }
        else
        {
            /* file not exit. return */
            return;
        }

        /* exit condition - will get a IMGXXXXZ.jpg as file name */
        if (alpha_index >= alpha_count - 1)
        {
            return;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_snapshot
 * DESCRIPTION
 *  snapshot current play screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_snapshot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_pathname[SRV_FMGR_PATH_BUFFER_SIZE];
    CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
    MDI_RESULT ret;
    MDI_RESULT snap_ret;
    S32 create_result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.is_seeking == MMI_TRUE)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RETURN_FUCNTION, __LINE__);          
                     
        /* if is seeking, do not take snapshot, this may avoid delay timer and NVRAM access problem */
        return;
    }

    /* already exit */
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return;
    }

    /* init value */
    ret = 0;

    create_result = mmi_imgview_get_storage_file_path((WCHAR*)buf_pathname);

    /* check if storage path is valid or not */
    if (FS_NO_ERROR == FS_GetDevStatus((U16)buf_pathname[0] ,FS_MOUNT_STATE_ENUM))
    {
        /* if drv is valid, check if the folder is crated or not */
        /* create_result = mmi_imgview_create_file_dir(buf_pathname); */

        /* create directory failed */
        if (create_result == FS_WRITE_PROTECTION)
        {
            ret = MDI_RES_VDOPLY_ERR_SNAPSHOT_WRITE_PROTECTION;
        }
        else if (create_result == FS_DISK_FULL)
        {
            ret = MDI_RES_VDOPLY_ERR_SNAPSHOT_DISK_FULL;
        }
        else if (create_result == FS_ROOT_DIR_FULL)
        {
            ret = MDI_RES_VDOPLY_ERR_SNAPSHOT_ROOT_DIR_FULL;
        }
        else
        {
            /* no error */
            ret = MDI_RES_VDOPLY_SUCCEED;
        }

        /* error check */
        if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)      /* ture means has error popup */
        {
            return;
        }
    }
    else
    {
    #ifdef __USB_IN_NORMAL_MODE__
        if (srv_usb_is_in_mass_storage_mode())
        {
            /* phone drive is exported, cant use this app */
            mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
            return;
        }
	    else
	    {
            mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_NOTIFY_STORAGE_NOT_READY, MMI_EVENT_FAILURE);
            return;
	    }
    #else /* __USB_IN_NORMAL_MODE__ */
        mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_NOTIFY_STORAGE_NOT_READY, MMI_EVENT_FAILURE);
        return;
        
    #endif /* __USB_IN_NORMAL_MODE__ */ 
    }

    /* start snapshot */
    mmi_vdoply_get_next_snapshot_filename(buf_filename, buf_pathname);

    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
    {
        ret = mmi_vdoply_stop_video();           
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_BT_CONNECTING ||
             g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
    {    
        mmi_vdoply_disconnect_bt();
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
    {
    #ifdef __MMI_VIDEO_STREAM__

        ret = mmi_vdoply_stop_video();  
    
        if (!g_vdoply_cntx.video_info.is_seekable)
        {        
            /* reset value after stop video */
            g_vdoply_cntx.cur_status.play_time = 0;            
        }
    #endif /* __MMI_VIDEO_STREAM__ */        
    }

    if (ret != MDI_RES_VDOPLY_ALREADY_FINISHED)
    {
        /* update the video time */
        /* if it's already finished, bar will be cleared, however, we will call finish handler, */
        /* then it will be draw as full again, to prevent this happen, don't update in this case */
        mmi_vdoply_draw_panel_progress();
        mmi_vdoply_draw_panel_timer();
    }

    mmi_vdoply_set_state_layer_config(VDOPLY_STATE_SNAPSHOT);
    mmi_vdoply_start_animation(MMI_VDOPLY_SNAPSHOT_ANI_ID, MMI_FALSE);
    mmi_vdoply_blt_screen();

    /* show 200 ms */
    kal_sleep_task(50);

    snap_ret = mdi_video_ply_snapshot(g_vdoply_cntx.play_wnd_layer_handle, buf_filename);
    MMI_VDOPLY_MSG_TRACE(ret);

    /* error check */
    if (snap_ret < MDI_RES_VDOPLY_SUCCEED)
    {
        /* when error happened, video will be stopp again if player stay in PLAY state */
        /* which will cause mdi return VDOPLY_ALREADY_FINISHED, and MMI will reset play time to zero */
        /* therefore, change the state of player to pause, since it is paused. */
        /* so the video won't be stop again */
        switch (g_vdoply_cntx.state)
        {
            case VDOPLY_STATE_PLAY:
                g_vdoply_cntx.state = VDOPLY_STATE_PAUSE;
                break;
            case VDOPLY_STATE_FULLSCR_PLAY:               
                g_vdoply_cntx.state = VDOPLY_STATE_FULLSCR_PAUSE;
                break;
            case VDOPLY_STATE_STREAM_PLAY:
                g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;
                break;
            case VDOPLY_STATE_STREAM_FULLSCR_PLAY:                
                g_vdoply_cntx.state = VDOPLY_STATE_STREAM_FULLSCR_CONNECTED;
                break;
        }
    }
    if (mmi_vdoply_check_and_display_error_popup(snap_ret) == MMI_TRUE)     /* ture means has error popup */
    {
        return;
    }

    mmi_vdoply_set_state_layer_config(g_vdoply_cntx.state);
    mmi_vdoply_blt_screen();
    mmi_vdoply_stop_animation();


    if (ret == MDI_RES_VDOPLY_ALREADY_FINISHED)
    {
        #ifdef __MMI_VIDEO_PDL__
        if(g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL  && 
			g_vdoply_cntx.cur_status.max_play_time < g_vdoply_cntx.video_info.total_time_duration)
        {
            mmi_vdoply_player_play_finish_hdlr(MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH, 0);
			return;
        }
		#endif
		
        mmi_vdoply_player_play_finish_hdlr(MDI_RES_VDOPLY_SUCCEED, 0);
        return;
    }

    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
    {
        /* if is seeking, means snapshot event is insert into seeking event */
        /* since after seeking, video will restart again, we do not need to start play here */

        /* seek again before play */
        mdi_video_ply_get_frame(g_vdoply_cntx.play_wnd_layer_handle);
        
        /* reset start play time */
        g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;

        if (mmi_vdoply_is_output_to_bt())
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
        }
        else
        {
            ret = mmi_vdoply_play_video();

            if (ret == MDI_RES_VDOPLY_PROGRESSIVE_FILE_NOT_ENOUGH)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING);
                return;
            }
            else if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)      /* ture means has error popup */
            {
                return;
            }
        }
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_PLAY)
    {
        /* reset start play time */
        g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;
        
    #ifdef __MMI_VIDEO_STREAM__
        if (mmi_vdoply_is_output_to_bt())
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
        }
        else
        {  
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);            
        }
    #endif /* __MMI_VIDEO_STREAM__ */
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_snapshot_key_press
 * DESCRIPTION
 *  press snapshot key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_snapshot_key_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* draw press snapshot key */
    g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = MMI_TRUE;
    
    mmi_vdoply_draw_panel_state();
    mmi_vdoply_blt_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_snapshot_key_release
 * DESCRIPTION
 *  release snapshot key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_player_snapshot_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press)
    {
        /* draw release snapshot key */
        g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_SNAPSHOT].is_press = MMI_FALSE;

        mmi_vdoply_draw_panel_state();
        mmi_vdoply_blt_screen();

		mmi_vdoply_stop_non_block_seeking();

        /* snapshot */
        mmi_vdoply_player_snapshot();

        mmi_vdoply_clear_key_event();
    }
}
#endif /* __VDOPLY_FEATURE_SNAPSHOT__ */ 


#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_event_screen_locker_callback_hdlr
 * DESCRIPTION
 *  this is callback handler for framework event braodcast
 * PARAMETERS
 *  mmi_event_struct*  [IN] event info
 * RETURNS
 * mmi_ret
 *****************************************************************************/
mmi_ret mmi_vdoply_event_screen_locker_callback_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(event->evt_id)
    {
        case EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING:
        	switch(g_vdoply_cntx.state)
          {
                  case VDOPLY_STATE_OPENING:
                  case VDOPLY_STATE_PLAY:
                  case VDOPLY_STATE_BT_CONNECTING:
                  case VDOPLY_STATE_PLAY_SEEKING:
                  case VDOPLY_STATE_FULLSCR_PLAY:
                  
                  #ifdef __MMI_MEDIA_PLAYER_STREAM__
                  case VDOPLY_STATE_STREAM_CONNECTING:
                  case VDOPLY_STATE_STREAM_BUFFERING:
                  case VDOPLY_STATE_STREAM_PLAY:
                  case VDOPLY_STATE_STREAM_BT_CONNECTING:
                  case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
                  case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
                  case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
                  #endif
                  
                  #ifdef __MMI_VIDEO_PDL__
                  case VDOPLY_STATE_PROGRESSIVE_OPENING:
                  case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
                  case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
                  case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
                  case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
                  #endif
                  {
                      mmi_scr_locker_pre_lock_evt_struct* lock_event = (mmi_scr_locker_pre_lock_evt_struct*)event;
                      if(lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_POWER_KEY)
                      {
              	          return MMI_RET_OK;
                      }
                      else
                      {
                          return MMI_RET_ERR;
                      }
                  }
                  default:
          	          return MMI_RET_OK; 
          	  }         
          	  
        default:
        {
            return MMI_RET_OK;
        }
    }
}
#endif



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_is_in_app
 * DESCRIPTION
 *  is in video player app or not
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
BOOL mmi_vdoply_is_in_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.state != VDOPLY_STATE_EXIT)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 * mmi_vdoply_gpio_after_lcd_leep_in
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_vdoply_gpio_after_lcd_leep_in(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 * mmi_vdoply_gpio_clam_open_close_query_tone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_vdoply_gpio_clam_open_close_query_tone(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_vdoply_is_in_app())
    {
        return MMI_RET_OK;
    }
    else
    {
        return 1;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_notify_storage_change_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_vdoply_notify_storage_change_evt_hdlr(mmi_event_struct *evt)
{
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FMGR_SUPPORT_DEFAULT_STORAGE__
    if (evt->evt_id == EVT_ID_SRV_FMGR_NOTIFICATION_SET_DEF_STORAGE)
    {
        srv_fmgr_notification_set_def_storage_event_struct *fmgr_event = (srv_fmgr_notification_set_def_storage_event_struct*)evt; 
        if (fmgr_event->state == SRV_FMGR_NOTIFICATION_STATE_AFTER)
        {
            mmi_vdoply_set_storage((U16)fmgr_event->drv_letter);            
            #ifdef __MMI_IMAGE_VIEWER__
                mmi_imgview_set_storage(g_vdoply_cntx.storage);
            #endif
            #ifdef __MMI_CAMCORDER__
                mmi_camco_set_storage(g_vdoply_cntx.storage);
            #endif
        }
        
    }
#endif
#endif
    return MMI_RET_OK;

}

#if defined(__MMI_VIDEO_STREAM__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_resume_stream_video
 * DESCRIPTION
 *  start play video
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_resume_stream_video(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 rotate;
    U32 blt_layer;
    U32 play_layer;
    gdi_handle play_layer_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_get_video_play_params(&play_layer_handle, &play_layer, &blt_layer, &rotate);

    mdi_video_stream_resume(
        play_layer_handle, 
        blt_layer, 
        play_layer, 
        MMI_TRUE, 
        MDI_DEVICE_SPEAKER2, 
        rotate);

}

#endif /* __MMI_VIDEO_STREAM__ */


#if defined(__MMI_VIDEO_STREAM__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_grp_network_profile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_enter_grp_network_profile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    gid = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_APP, 
                    GRP_ID_VDOPLY_NETWORK_PROFILE, 
                    mmi_vdoply_network_profile_proc,
                    NULL,
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);

    if (GRP_ID_INVALID == gid)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);
        return;
    }
	
    mmi_vdoply_entry_network_profile_scr();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_network_profile_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_MENU_ITEM_SELECT:
		{
            cui_menu_event_struct *menu_evt = (cui_menu_event_struct *)evt;           
            if (menu_evt->parent_menu_id == MENU_ID_VDOPLY_NETWORK_PROFILE_OPTION)
            {
                switch(menu_evt->highlighted_menu_id)
                {
                    case MENU_ID_VDOPLY_NETWORK_EDIT_PROFILE:
                        mmi_vdoply_entry_network_profile_edit_scr();
                        break;
                    case MENU_ID_VDOPLY_NETWORK_ACTIVE_PROFILE:
                        mmi_vdoply_network_profile_active_hdlr();
                        break;
                }
            }
			break;
        }
        		
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
		{
            cui_menu_event_struct* menu_evt = (cui_menu_event_struct*)evt;          
            cui_menu_close(menu_evt->sender_id); 
			break;
        }
		
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_event_inline_notify_struct *inline_evt = (cui_event_inline_notify_struct *)evt;
            switch(inline_evt->event_type)
            {
                case CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED:
                {
                    mmi_vdoply_settings_inline_focus_change(inline_evt);
                    break;
                }
                default:
                    break;
            }
            break;
        }
		
        case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
        {
            cui_event_inline_common_struct *inline_evt = (cui_event_inline_common_struct *)evt;
            mmi_vdoply_settings_inline_set_item_value(inline_evt);
            break;
        }

        case EVT_ID_CUI_INLINE_SET_KEY:
        {
            cui_event_inline_set_key_struct *inline_evt = (cui_event_inline_set_key_struct *)evt;
            U32 item = inline_evt->item_id - CUI_INLINE_ITEM_ID_BASE;                                   
            if (mmi_frm_group_is_present(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT))
            {
                switch(item)
                {
                    case DATA_ACCOUNT_TYPE_DISPLAY_ONLY:
                    {
                        cui_inline_set_softkey_text(inline_evt->sender_id, 
                            CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_DISPLAY_ONLY, 
                            MMI_LEFT_SOFTKEY, 
                            STR_GLOBAL_SELECT);
                        wgui_inline_set_lsk_function(mmi_vdoply_entry_network_data_account_scr);
                        if (mmi_frm_kbd_is_key_supported(KEY_CSK))
                        {
                            ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
                            SetCenterSoftkeyFunction(mmi_vdoply_entry_network_data_account_scr, KEY_EVENT_UP);
							SetKeyUpHandler(mmi_vdoply_entry_network_data_account_scr, KEY_ENTER);
                            cui_inline_set_softkey_icon(inline_evt->sender_id, 
                                CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_DISPLAY_ONLY, 
                                MMI_CENTER_SOFTKEY, 
                                IMG_GLOBAL_COMMON_CSK);
                        }
                        break;
                    }
                    default:
                        break;
                }
            }           
            break;
        }
		
        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            mmi_vdoply_display_popup_confirm(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT,
				                              STR_GLOBAL_SAVE_ASK,
				                              mmi_vdoply_network_profile_save_confirm_cb,
				                              CNFM_TYPE_YESNO,
							      MMI_EVENT_QUERY
							      ); 
            break;
        }
		
        case EVT_ID_CUI_INLINE_ABORT:
        {
            cui_event_inline_abort_struct *inline_evt = (cui_event_inline_abort_struct*)evt;
            cui_inline_close(inline_evt->sender_id);
            break;
        }
		
        case EVT_ID_ALERT_QUIT:
        {
            mmi_alert_result_evt_struct *confirm = (mmi_alert_result_evt_struct *)evt;
            switch (confirm->result)
            {
                case MMI_ALERT_CNFM_OK:  
                case MMI_ALERT_CNFM_YES:         
                {
                    if (confirm->user_tag == (void *)GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT)
                    {
                        mmi_vdoply_network_profile_save_confirm_yes();        
                    }
                    break;
                }
                case MMI_ALERT_CNFM_NO:         
                case MMI_ALERT_CNFM_CANCEL:      
                {
                    
                    if (confirm->user_tag == (void *)GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT)
                    {
                        mmi_alert_dismiss(confirm->alert_id);                        
                        mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT);        
                    }
                    
                    break;
                }
                default:
                    break;
            }
            break;
        }         
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_streaming_url_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_streaming_url_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
	    case EVT_ID_CUI_MENU_LIST_ENTRY: 
        {
            cui_menu_event_struct *menu_evt = (cui_menu_event_struct *)evt;
            if (mmi_frm_kbd_is_key_supported(KEY_CSK))
            {
                cui_menu_enable_center_softkey(menu_evt->sender_id, 0, IMG_GLOBAL_COMMON_CSK);
            }
            cui_menu_set_currlist_left_softkey(menu_evt->sender_id, (WCHAR*)GetString(STR_GLOBAL_OK));
            break;
        } 
		
        case EVT_ID_CUI_MENU_ITEM_SELECT: 
		case EVT_ID_CUI_MENU_ITEM_CSK_SELECT:
		{
            cui_menu_event_struct* menu_evt = (cui_menu_event_struct*)evt;       
            if (menu_evt->parent_menu_id == MENU_ID_VDOPLY_STREAMING_URL)
            {
                switch(menu_evt->highlighted_menu_id)
                {
                    case MENU_ID_VDOPLY_PREDEFINED_URL:
	                        mmi_frm_scrn_create(GRP_ID_VDOPLY_APP,
				                    SCR_ID_VDOPLY_PREDEFINED_URL,
				                    mmi_vdoply_entry_predefined_url_screen_proc,
				                    NULL);
                        break;
                    case MENU_ID_VDOPLY_INPUT_URL:
                        mmi_vdoply_entry_url_editor_scr();
                        break;
                    case MENU_ID_VDOPLY_HISTORY_URL:
	                        mmi_frm_scrn_create(GRP_ID_VDOPLY_APP,
						            SCR_ID_VDOPLY_HISTORY_URL,
						            mmi_vdoply_history_url_screen_proc,
						            NULL);   
                        break;
                } 
            }
            else if (menu_evt->parent_menu_id == MENU_ID_VDOPLY_HISTORY_OPTION)
            {
                switch(menu_evt->highlighted_menu_id)
                {
                    case MENU_ID_VDOPLY_HISTORY_PLAY:
                        mmi_vdoply_history_play_url();
                        break;
                    case MENU_ID_VDOPLY_HISTORY_REMOVE:
                        mmi_vdoply_display_popup_confirm(
							        GRP_ID_VDOPLY_STREAMING_URL,
							        STR_ID_VDOPLY_NOTIFY_REMOVE_URL_CONFIRM,
							        mmi_vdoply_history_remove_confirm_cb,
							        CNFM_TYPE_YESNO,
							        MMI_EVENT_QUERY
							    );
                        break;
                    case MENU_ID_VDOPLY_HISTORY_REMOVE_ALL:
                        mmi_vdoply_display_popup_confirm(
							        GRP_ID_VDOPLY_STREAMING_URL,
							        STR_ID_VDOPLY_NOTIFY_REMOVE_URL_ALL_CONFIRM,
							        mmi_vdoply_history_remove_all_confirm_cb,
							        CNFM_TYPE_YESNO,
							        MMI_EVENT_QUERY
							    ); 
                        break;
                }                 
            }
            break;
		}
				
        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
		{
            cui_menu_event_struct* menu_evt = (cui_menu_event_struct*)evt;          
            cui_menu_close(menu_evt->sender_id); 
			break;
        }
        
        case EVT_ID_CUI_FSEDITOR_SUBMMIT:
        {
            cui_fseditor_evt_struct *editor_evt = (cui_fseditor_evt_struct *)evt;
             
            cui_fseditor_get_text(editor_evt->sender_id, 
                (WCHAR *)g_vdoply_cntx.edit_buf, 
                VDOPLY_MAX_URL_CHAR_COUNT);
            mmi_vdoply_check_url_and_enter();            
            break;
        }
		
        case EVT_ID_CUI_FSEDITOR_ABORT:
        {
            cui_fseditor_evt_struct *editor_evt = (cui_fseditor_evt_struct *)evt;
            cui_fseditor_close(editor_evt->sender_id);
            break;
        }
		
/**********************confirm event*************************/             
        case EVT_ID_ALERT_QUIT:
        {
            mmi_alert_result_evt_struct *confirm = (mmi_alert_result_evt_struct *)evt;
            switch (confirm->result)
            {
                case MMI_ALERT_CNFM_OK:  
                case MMI_ALERT_CNFM_YES:         
                {
                    ((FuncPtr)confirm->user_tag)();
                    break;
                }
                case MMI_ALERT_CNFM_NO:         
                case MMI_ALERT_CNFM_CANCEL:      
                {
                    mmi_alert_dismiss(confirm->alert_id);
                    break;
                }
                default:
                    break;
            }
            break;
        }

    }

    return MMI_RET_OK;

}
#endif



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_stream_state
 * DESCRIPTION
 *  state transition function
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_VIDEO_STREAM__
static void mmi_vdoply_enter_stream_state(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_VDOPLY_SUCCEED;
    U16 prev_state;
    vdoply_ui_type_neum prev_ui_type;
    nvram_ef_video_network_profile_struct *profile_p;
    U32 data_account_id;
	srv_dtcnt_sim_type_enum sim_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_state = g_vdoply_cntx.state;
    prev_ui_type = g_vdoply_cntx.ui_type;
    g_vdoply_cntx.state = state;

    sim_type = mmi_vdoply_network_get_data_account_sim_type();
    profile_p = &g_vdoply_cntx.network_profile[g_vdoply_cntx.active_profile_idx];
	data_account_id = cbm_encode_data_account_id(
						  profile_p->data_account_id[sim_type - SRV_DTCNT_SIM_TYPE_1],
						  (cbm_sim_id_enum)(sim_type - SRV_DTCNT_SIM_TYPE_1),
						  g_vdoply_cntx.cbm_app_id,
						  KAL_FALSE);
    if(mmi_dtcnt_acct_is_valid(data_account_id) == MMI_DTCNT_ACCT_VALID_NONE )
    {
        profile_p->data_account_id[sim_type - SRV_DTCNT_SIM_TYPE_1] = CBM_DEFAULT_ACCT_ID;
		data_account_id = cbm_encode_data_account_id(
							  CBM_DEFAULT_ACCT_ID,
							  (cbm_sim_id_enum)(sim_type - SRV_DTCNT_SIM_TYPE_1),
							  g_vdoply_cntx.cbm_app_id,
							  KAL_FALSE);

    }
    
    switch (state)
    {
        case VDOPLY_STATE_STREAM_CONNECTING:
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
            g_vdoply_cntx.touch_obj[MMI_VDOPLY_TOUCH_CK].is_usable = MMI_FALSE;

            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;

            mmi_vdoply_redraw_normal();
			mmi_vdoply_start_animation(MMI_VDOPLY_CONNECT_ANI_ID, MMI_FALSE);
            mmi_vdoply_blt_screen();

                if (mmi_ucs2strlen(g_vdoply_cntx.source_path) == 0)
                {
                    cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_INVALID_URL);
                    return;
                }
                
            #ifdef __DRM_SUPPORT__
                if (g_vdoply_cntx.drm_state == VDOPLY_DRM_NO_CONSUME)
                {
                    mdi_video_stream_drm_disable_consume_count();            
                }
            #endif /* __DRM_SUPPORT__ */

                if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
                    g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
                {
                    ret = mdi_video_stream_connect(
                            data_account_id,
                            MDI_VIDEO_STREAM_RTSP_URL, 
                            g_vdoply_cntx.source_path, 
                            (MMI_BOOL)profile_p->proxy_on_off, 
                            profile_p->proxy_addr, 
                            profile_p->proxy_port,
                        #ifdef __VDOPLY_FEATURE_UDP_PORT__
						    MMI_TRUE,
                        #else
						    MMI_FALSE,
                        #endif
                            profile_p->highest_udp_port,
                            profile_p->lowest_udp_port,                          
                            mmi_vdoply_stream_connect_result_hdlr,
                            NULL);
                }
                else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
                {
                    ret = mdi_video_stream_connect(
                            data_account_id, 
                            MDI_VIDEO_STREAM_SDP_FILE, 
                            g_vdoply_cntx.source_path, 
                            (MMI_BOOL)profile_p->proxy_on_off, 
                            profile_p->proxy_addr, 
                            profile_p->proxy_port,
                        #ifdef __VDOPLY_FEATURE_UDP_PORT__
						    MMI_TRUE,
                        #else
						    MMI_FALSE,
                        #endif
                            profile_p->highest_udp_port,
                            profile_p->lowest_udp_port,                          
                            mmi_vdoply_stream_connect_result_hdlr,
                            NULL);
                }
                else
                {
                    MMI_ASSERT(0);
                }

                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }                  
            
            break;

        case VDOPLY_STATE_STREAM_BUFFERING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;
			
			#ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
			#endif

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                mmi_vdoply_redraw_normal();
				mmi_vdoply_draw_loading(0, MMI_TRUE, MMI_FALSE); 
            }
            else
            {
                mmi_vdoply_draw_panel();
		mmi_vdoply_draw_softkey();
            }

            if(prev_state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING)
            {                                 
                mmi_vdoply_stream_buffering_cyclic();                  
            }
            else
            {
                mmi_vdoply_stream_start_buffering();                
            }
            break;

        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;

            /* 
             * TRICKY!! This is used to keep screen display previous's key UI.
             * It avoid bt conecting state too short and some icon will flush.
             */       
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_STREAM_BUFFERING);    

            /* clear process layer */
            gdi_layer_push_and_set_active(g_vdoply_cntx.process_layer_handle);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
                mmi_vdoply_redraw_normal();
            }
			else
			{
			    mmi_vdoply_draw_panel();            
                mmi_vdoply_draw_softkey(); 
			}   
            mmi_vdoply_blt_screen();
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_STREAM_BT_CONNECTING);     
            
            mmi_vdoply_connect_bt();
            break;

        case VDOPLY_STATE_STREAM_PLAY:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;
            gui_cancel_timer(mmi_vdoply_stream_buffering_cyclic);

            #ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PAUSE;
			#endif
            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                mmi_vdoply_redraw_normal();
            }
            else
            {
                mmi_vdoply_draw_panel();            
                mmi_vdoply_draw_softkey(); 
            }
            mmi_vdoply_blt_screen();

            /* add start play time */
            g_vdoply_cntx.cur_status.start_play_time = g_vdoply_cntx.cur_status.play_time;

            if(prev_state == VDOPLY_STATE_STREAM_FULLSCR_PLAY)
            {   
                /* toggle from fullscr */
                mmi_vdoply_resume_stream_video();
            }
            else
            {
                ret = mmi_vdoply_play_video();      

                if (ret < 0)
                {
                    /* error, so not start yet, reset to connected state */
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;
                }

                if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
                {
                #ifdef __DRM_SUPPORT__
                    mmi_rmgr_status_enum rmgr_ret;
                   
                    mmi_vdoply_bt_close_codec();

                    rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_handle(g_vdoply_cntx.drm_handle, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_stream_request_right_callback));

                    if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
                    {
                        g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;                        
                        mmi_rmgr_request_rights_confirm();
                        return;
                    }
                    else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
                    {
                        cui_vdoply_evt_exit(MMI_TRUE,STR_GLOBAL_DRM_PROHIBITED);
                        return;
                    }
                    else
                    {
                        MMI_ASSERT(0);
                        return;                        
                    }      
                #endif /* __DRM_SUPPORT__ */


                }

                if (ret != MDI_RES_VDOPLY_SUCCEED)
                {
                    /* failed when calling play, driver will stop directly, shall change to connected state */
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED; 
                }
                
                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }                        
            }
            break;

        case VDOPLY_STATE_STREAM_DISCONNECT:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;

            #ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
			#endif

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                mmi_vdoply_redraw_normal();
            }
            else
            {
                mmi_vdoply_draw_panel();            
                mmi_vdoply_draw_softkey(); 
            } 
            mmi_vdoply_blt_screen();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();            
            break;

        case VDOPLY_STATE_STREAM_CONNECTED:
           g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;

            #ifdef __MMI_FTE_SUPPORT__
            g_vdoply_cntx.play_img_id = IMG_ID_VDOPLY_OSD_BUTTON_PLAY;
            #endif 
           if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {

                mmi_vdoply_redraw_normal();
            }
            else
            {
                mmi_vdoply_draw_panel();            
                mmi_vdoply_draw_softkey(); 
            }
       
    		mmi_vdoply_blt_screen();			
            break;

        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;

            mmi_vdoply_draw_softkey();
            mmi_vdoply_draw_panel();
            mmi_vdoply_blt_screen();
            break;

    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                       
            }
            
            mmi_vdoply_start_animation(MMI_VDOPLY_CONNECT_ANI_ID, MMI_TRUE);
            mmi_vdoply_blt_screen();

            if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
                g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
            {
                ret = mdi_video_stream_connect(
                        data_account_id, 
                        MDI_VIDEO_STREAM_RTSP_URL, 
                        g_vdoply_cntx.source_path, 
                        (MMI_BOOL)profile_p->proxy_on_off,  
                        profile_p->proxy_addr, 
                        profile_p->proxy_port,
                    #ifdef __VDOPLY_FEATURE_UDP_PORT__
					    MMI_TRUE,
                    #else
					    MMI_FALSE,
                    #endif
                        profile_p->highest_udp_port,
                        profile_p->lowest_udp_port,  
                        mmi_vdoply_stream_connect_result_hdlr,
                        NULL);
            }
            else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
            {
                ret = mdi_video_stream_connect(
                        data_account_id, 
                        MDI_VIDEO_STREAM_SDP_FILE, 
                        g_vdoply_cntx.source_path, 
                        (MMI_BOOL)profile_p->proxy_on_off, 
                        profile_p->proxy_addr, 
                        profile_p->proxy_port,
                    #ifdef __VDOPLY_FEATURE_UDP_PORT__
					    MMI_TRUE,
                    #else
					    MMI_FALSE,
                    #endif
                        profile_p->highest_udp_port,
                        profile_p->lowest_udp_port,                        
                        mmi_vdoply_stream_connect_result_hdlr,
                        NULL);
            }
            else
            {
                MMI_ASSERT(0);
            }
            
            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
            {
                return;
            }                
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                  
            }

            if(prev_state == VDOPLY_STATE_STREAM_BUFFERING)
            {

                mmi_vdoply_draw_loading(0, MMI_TRUE, MMI_TRUE);
                mmi_vdoply_stream_fullscr_buffering_cyclic();            
            }
            else
            {

                mmi_vdoply_draw_loading(0, MMI_TRUE, MMI_TRUE);
                mmi_vdoply_blt_screen();

                mmi_vdoply_stream_start_buffering();
            }
            
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;

            /* 
             * TRICKY!! This is used to keep screen display previous's key UI.
             * It avoid bt conecting state too short and some icon will flush.
             */       
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);    

            /* clear process layer */
            gdi_layer_push_and_set_active(g_vdoply_cntx.fullscr_process_layer_handle);
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                  
            }
            
            mmi_vdoply_blt_screen();     
            mmi_vdoply_set_state_key_event(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);                
            
            mmi_vdoply_connect_bt();            
            break;

 
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;            
            gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                    
            }

            
            mmi_vdoply_blt_screen();

            if(prev_state == VDOPLY_STATE_STREAM_PLAY)
            {   
                /* toggle from fullscr */
                mmi_vdoply_resume_stream_video();
            }
            else
            {
                ret = mmi_vdoply_play_video();      

                if (ret < 0)
                {
                    /* error, so not start yet, reset to connected state */
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_FULLSCR_CONNECTED;
                }

                if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
                {
                #ifdef __DRM_SUPPORT__
                    mmi_rmgr_status_enum rmgr_ret;
                   
                    mmi_vdoply_bt_close_codec();

                    rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_handle(g_vdoply_cntx.drm_handle, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_stream_request_right_callback));

                    if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
                    {
                        g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;                        
                        mmi_rmgr_request_rights_confirm();
                        return;
                    }
                    else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
                    {
                        cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
                        return;
                    }
                    else
                    {
                        MMI_ASSERT(0);
                        return;                        
                    }      
                #endif /* __DRM_SUPPORT__ */
                }


                if (ret != MDI_RES_VDOPLY_SUCCEED)
                {
                    /* failed when calling play, driver will stop directly, shall change to connected state */
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_FULLSCR_CONNECTED; 
                }
                
                if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
                {
                    return;
                }                        
            }
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;    

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                    
            }

            mmi_vdoply_blt_screen();

            /* disconnect BT if needed */
            mmi_vdoply_disconnect_bt();            
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTED:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;  

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                   
            }

            mmi_vdoply_blt_screen();
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        default:
            MMI_ASSERT(0);
            break;
    
    }

}
#endif /* __MMI_VIDEO_STREAM__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_enter_progressive_state
 * DESCRIPTION
 *  state transition function
 * PARAMETERS
 *  state       [IN]        Video player's state
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_VIDEO_PDL__
static void mmi_vdoply_enter_progressive_state(U16 state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    vdoply_ui_type_neum prev_ui_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_ui_type = g_vdoply_cntx.ui_type;
    g_vdoply_cntx.state = state;
    
    switch (state)
    {
        case VDOPLY_STATE_PROGRESSIVE_OPENING:
        case VDOPLY_STATE_PROGRESSIVE_INTERRUPTED_OPENING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;  
            mmi_vdoply_redraw_normal();
            mmi_vdoply_start_animation(MMI_VDOPLY_OPEN_ANI_ID, MMI_FALSE);
            mmi_vdoply_blt_screen();

            ret = mdi_video_progressive_open_file(
                    0,
                    g_vdoply_cntx.source_path, 
                    mmi_vdoply_player_open_done_hdlr,
                    0);

            /* error check */
            if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* true means has error popup */
            {
                /* TODO: Call DA Terminate connection */
                return;
            }
            break;

        case VDOPLY_STATE_PROGRESSIVE_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_NORMAL;   

            if (prev_ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
                mmi_vdoply_redraw_normal();
            }
            else
            {
                mmi_vdoply_draw_panel();            
                mmi_vdoply_draw_softkey();
                g_vdoply_cntx.pdl_buf_percent = 0;
            }

            mmi_vdoply_draw_loading(g_vdoply_cntx.pdl_buf_percent, MMI_TRUE, MMI_FALSE); 
            mmi_vdoply_blt_screen();
        
            gui_start_timer(100, mmi_vdoply_pdl_buffering_cyclic);
            break;
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING:
        case VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING:
            g_vdoply_cntx.ui_type = VDOPLY_UI_TYPE_FULLSCR;            
                            

            if (prev_ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_draw_fullscr_play_region_bg();                                    
            }
            else
            {
                g_vdoply_cntx.pdl_buf_percent = 0;
            }

            mmi_vdoply_draw_loading(g_vdoply_cntx.pdl_buf_percent, MMI_TRUE, MMI_TRUE);
            mmi_vdoply_blt_screen();

            gui_start_timer(100, mmi_vdoply_pdl_fullscr_buffering_cyclic);
            break;
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
        default:
            MMI_ASSERT(0);
            break;
    }
}
#endif /* __MMI_VIDEO_PDL__ */



#ifdef __MMI_VIDEO_STREAM__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bear_event_disconnect
 * DESCRIPTION
 *  check if mediaplayer is currently playing or prepare to play
 * PARAMETERS
 *  void
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
static void mmi_vdoply_bear_event_disconnect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE)==MMI_TRUE)
    {
        return;
    }
    
    switch(g_vdoply_cntx.state)
    {
        case VDOPLY_STATE_STREAM_CONNECTED:  
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
            break;

        case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT;
            break;
            
        case VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT:
            /* do nothing */
            break;
            
        case VDOPLY_STATE_STREAM_BT_CONNECTING:
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
            break;

        case VDOPLY_STATE_STREAM_CONNECTING:
            mmi_vdoply_stop_animation();
            
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;           
            break;
            
        case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:            
            mmi_vdoply_stop_animation();
            
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;             
            break;

        case VDOPLY_STATE_STREAM_BUFFERING:    
            mmi_vdoply_stream_stop_buffering();
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
            break;

        case VDOPLY_STATE_STREAM_PLAY:
            mmi_vdoply_stop_video(); 
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;            
            break;

        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /* fullscr */
        case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
        case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            mmi_vdoply_stop_animation();
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;  
            break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
            mmi_vdoply_stream_stop_buffering();
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
            break;

        case VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING:            
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;       
           break;
            
        case VDOPLY_STATE_STREAM_FULLSCR_PLAY:
            mmi_vdoply_stop_video(); 
            mdi_video_stream_disconnect();
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT; 
            break;            

        default:    
            break;            
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    } 
    
    #ifdef __TCPIP__
        MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_RELEASE_BEARER, __LINE__);
        cbm_release_bearer(g_vdoply_cntx.cbm_app_id);
    #endif    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bear_event_reconnect
 * DESCRIPTION
 *  check if mediaplayer is currently playing or prepare to play
 * PARAMETERS
 *  void
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
static void mmi_vdoply_bear_event_reconnect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifdef __TCPIP__
    U32 data_account_id;
    S32 status;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __TCPIP__
    mmi_vdoply_get_data_account_id(&data_account_id);
    status = cbm_get_bearer_status(data_account_id);
    MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_HOLD_BEARER, status, __LINE__);
    if(CBM_DEACTIVATED == status)
    {
        gui_start_timer(MMI_VDOPLY_QUERY_BEARER_TIMER, mmi_vdoply_bear_event_reconnect);
        return;
    }
    MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_HOLD_BEARER, status, __LINE__);
    cbm_hold_bearer(g_vdoply_cntx.cbm_app_id);
    #endif
    
    if(VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE)==MMI_TRUE)
    {
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_BEARER_PAUSE);

        if(GetExitScrnID() == SCR_ID_VDOPLY_PLAYER)
        {
            mmi_vdoply_enter_state(g_vdoply_cntx.state);
        }
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_bear_event_callback_hdlr
 * DESCRIPTION
 *  check if mediaplayer is currently playing or prepare to play
 * PARAMETERS
 *  void
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
static mmi_ret mmi_vdoply_bear_event_callback_hdlr(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_bearer_event_struct *cbm_event = (srv_cbm_bearer_event_struct *)evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //kal_prompt_trace(MOD_MMI_MEDIA_APP, "[VDOPLY]bear_event_callback_hdlr:type:%d, state:%d", cbm_event->type, g_vdoply_cntx.state);
    if (g_vdoply_cntx.play_source != VDOPLY_PLAY_FROM_STREAMING_RAM && 
        g_vdoply_cntx.play_source != VDOPLY_PLAY_FROM_STREAMING_RTSP&&
        g_vdoply_cntx.play_source != VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        return MMI_RET_OK;
    }
    
    switch(cbm_event->type)
    {
        case SRV_CBM_BEARER_EVENT_DISCONNECT:
            mmi_vdoply_bear_event_disconnect();
            break;

        case SRV_CBM_BEARER_EVENT_SWITCH:
            mmi_vdoply_bear_event_disconnect();
            mmi_vdoply_bear_event_reconnect();
            break;
    }
    return MMI_RET_OK;
      
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_register_bear_event_callback_hdlr
 * DESCRIPTION
 *  check if mediaplayer is currently playing or prepare to play
 * PARAMETERS
 *  void
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
static mmi_ret mmi_vdoply_register_bear_event_callback_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_result_error_enum ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_cbm_register_bearer_event(
                   SRV_CBM_BEARER_EVENT_SWITCH,
                   g_vdoply_cntx.cbm_app_id,
                   mmi_vdoply_bear_event_callback_hdlr,
                   0);
     MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_BEARER_REG, ret);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_deregister_bear_event_callback_hdlr
 * DESCRIPTION
 *  check if mediaplayer is currently playing or prepare to play
 * PARAMETERS
 *  void
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
static mmi_ret mmi_vdoply_deregister_bear_event_callback_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_result_error_enum ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_cbm_deregister_bearer_event(g_vdoply_cntx.cbm_app_id);
     MMI_TRACE(MMI_MEDIA_TRC_G4_MDI, MMI_TRC_VDOPLY_BEARER_DEREG, ret);
}


#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_draw_sublcd_icon
 * DESCRIPTION
 *  draw a sublcd icon.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_SUBLCD__
static void mmi_vdoply_draw_sublcd_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 lcd_width;
    S32 lcd_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_lcd_get_dimension(&lcd_width, &lcd_height);

    gdi_layer_reset_clip();

    gdi_layer_clear(GDI_COLOR_WHITE);
    gdi_image_get_dimension_id(IMG_ID_VDOPLY_SUBLCD_ICON, &image_width, &image_height);
    gdi_image_draw_id((lcd_width - image_width) >> 1, (lcd_height - image_height) >> 1, IMG_ID_VDOPLY_SUBLCD_ICON);
    gdi_layer_blt_base_layer(0, 0, lcd_width - 1, lcd_height - 1);

    gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_sublcd_screen
 * DESCRIPTION
 *  entry sublcd screen, if still remain on standard MMI sublcd screen, time update will
 *  redraw sublcd while mainlcd is previewing, will cause driver assert.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecSubLCDCurrExitHandler();
    ShowCategory331Screen();
    SetSubLCDExitHandler(mmi_vdoply_exit_sublcd_screen);

    /* draw a icon on sub */
    mmi_vdoply_draw_sublcd_icon();

    g_vdoply_cntx.is_sub_display = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_exit_sublcd_screen
 * DESCRIPTION
 *  exit sublcd screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_exit_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SubLCDHistoryNode SubLCDHistory;

    /* someone may exit/draw sublcd first then exit mainlcd, this may cause driver assert */
    /* also stop preview here */

    if (g_vdoply_cntx.state == VDOPLY_STATE_PLAY)
    {
        /* interrupt while playing, store play time var */
        mdi_video_ply_get_cur_play_time(&g_vdoply_cntx.cur_status.play_time);

        mmi_vdoply_stop_video();

        g_vdoply_cntx.state = VDOPLY_STATE_IDLE;
    }

    /* stop seek skip frame timer */
    gui_cancel_timer(mmi_vdoply_seek_key_release);
	#ifdef MMI_VDOPLY_FEATURE_LONGPRESS
	gui_cancel_timer(mmi_vdoply_play_next_file_worked);
	gui_cancel_timer(mmi_vdoply_play_prev_file_worked);
	#endif

    /* exit sub */
    g_vdoply_cntx.is_sub_display = MMI_FALSE;

    SubLCDHistory.entryFuncPtr = mmi_vdoply_entry_sublcd_screen;
    AddSubLCDHistory(&SubLCDHistory);
}
#endif /* __MMI_SUBLCD__ */ 

/*****************************************************************************
*
* Initialization and Entry of Video Player Application                                                                  
*
*****************************************************************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_highlight_app
 * DESCRIPTION
 *  app hilight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_highlight_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    SetLeftSoftkeyFunction(mmi_vdoply_entry_app, KEY_EVENT_UP);   
}



#if defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__)
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_uri_lauch_streaming
 * DESCRIPTION
 *  launch streaming
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_uri_lauch_streaming(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_entry_player_screen_from_rtsp_link(g_vdoply_cntx.source_path);   
}

static mmi_ret mmi_vdoply_uri_lauch_streaming_confirm_cb(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *alert_evt = (mmi_alert_result_evt_struct *)evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_uri_lauch_streaming();
            break;
        default:
            break;
        }
    }
    return MMI_RET_OK;
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_uri_scheme_handler
 * DESCRIPTION
 *  uri scheme handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_uri_scheme_handler(
    srv_uriagent_appid_enum ura_appid, 
    char *url, 
    char *param, 
    srv_uriagent_options_enum options, 
    srv_uriagent_uri_request_hdlr_cb uri_agent_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* notify uri we got the message */
    if(uri_agent_cb)
    {
        uri_agent_cb(ura_appid, SRV_URIAGENT_APPID_STREAMING, SRV_URIAGENT_ERR_OK);
    }

    /* note: the url from uri scheme manager is ascii */
    mmi_asc_n_to_ucs2((CHAR*)g_vdoply_cntx.source_path, (CHAR*)url, VDOPLY_MAX_URL_CHAR_COUNT);

    if (options == SRV_URIAGENT_OPTION_NEED_CONFIRM_POPUP)
    {
    // 10A FW: it's hard to handle the YES case of the confirm.
    // The confirm is showing by video player, but there's no video player group here
    // Currently, just lanch video player, no confirm
        mmi_vdoply_display_popup_confirm(
					    GRP_ID_ROOT,
                        STR_ID_VDOPLY_NOTIFY_CONFIRM_STREAMING,
                        mmi_vdoply_uri_lauch_streaming_confirm_cb,
                        CNFM_TYPE_YESNO,
                        MMI_EVENT_QUERY
                    );   
        
    }
    else
    {
        mmi_vdoply_entry_player_screen_from_rtsp_link(g_vdoply_cntx.source_path);        
    }
    
}
#endif /* defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__) */



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_init_app
 * DESCRIPTION
 *  init video player applcation, register highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__)
    srv_uriagent_err_enum ret;
#endif
//10ADA
#if defined(__MMI_VIDEO_STREAM__)
    cbm_app_info_struct app_info;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(WAP_SUPPORT) && defined(__MMI_VIDEO_STREAM__)
    SetProtocolEventHandler(mmi_vdoply_rtsp_url_hdlr, MSG_ID_MMI_VDOPLY_RTSP_URL_REQ);
#endif
    
    /* init variable */
	kal_mem_set(&g_vdoply_cntx, 0, sizeof(vdoply_context_struct));
	g_vdoply_cntx.pdl_dl_session_id = -1;
	g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_EXIT;
    g_vdoply_cntx.video_info.is_pausable = MMI_TRUE; /* currently not used */

//10ADA
#ifdef __MMI_VIDEO_STREAM__
    app_info.app_icon_id = GetRootTitleIcon(MENU_ID_VDOPLY_APP);
    app_info.app_str_id = STR_ID_VDOPLY_APP_NAME;
    app_info.app_type = DTCNT_APPTYPE_PLAYER | DTCNT_APPTYPE_SKIP_CSD;
    cbm_register_app_id_with_app_info(&app_info, &(g_vdoply_cntx.cbm_app_id));
    mmi_vdoply_create_file_dir((CHAR*)L"Z:\\@VideoStream\\");
#endif

#if defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__)
    /* register rtsp scheme */
    ret = srv_uriagent_register_hdlr_by_scheme("rtsp", mmi_vdoply_uri_scheme_handler, MMI_FALSE);
    MMI_ASSERT(ret == SRV_URIAGENT_ERR_OK);
#endif /* defined(__MMI_URI_AGENT__) && defined(__MMI_VIDEO_STREAM__) */

    /* MAUI_03026994 */
    mmi_vdoply_load_setting();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_exit_from_fmgr_emptry_folder
 * DESCRIPTION
 *  exit from fmgr when enter empty foloder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_exit_from_fmgr_emptry_folder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_medply_app_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_vdoply_app_launch_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_APP_ENTER:
	{
            mmi_vdoply_pre_entry_app();
	    break;
	}
        default:
	    break;
    }
    return MMI_RET_OK;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_medply_read_settings
 * DESCRIPTION
 *  read settings from nvram while init application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
	#if defined(__MMI_BT_MUSIC__) || defined(__MMI_AUDIO_PLAYER_BT__)
	if (mmi_bt_music_check_connection())
	{
		mmi_bt_music_disconnect(mmi_vdoply_app_bt_music_disconnect_callback);
		//return;
	}
	#endif

#ifdef MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE
		g_vdoply_cntx.is_need_change_storage = KAL_FALSE;
#endif

	g_vdoply_cntx.is_entry_player_from_other_app = MMI_FALSE;
    
	#ifndef __MMI_SUPPORT_ASMV2__
	mmi_vdoply_pre_entry_app();
	#else
	if (mmi_frm_app_is_launched(APP_VDOPLY)) 
	{
        mmi_frm_app_close(APP_VDOPLY);
    }
    mmi_frm_app_launch(APP_VDOPLY, 0, 0, mmi_vdoply_app_launch_proc, NULL, 0);
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_app_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_app_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
	SRV_FMGR_DRVLIST_HANDLE drv_list;
    U16 storage;
	U8  total_drv_num;
#endif

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
		case EVT_ID_CUI_FOLDER_BROWSER_ON_ENTRY:
		{			
		#ifdef MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE			
			if(!g_vdoply_cntx.is_need_change_storage)
			{
				g_vdoply_cntx.is_need_change_storage = KAL_TRUE;

				if(mmi_vdoply_get_total_files() != MMI_RET_OK)
					break;

				if(g_vdoply_cntx.total_files == 0 && g_vdoply_cntx.storage == 'D')
				{
					mmi_vdoply_change_storage_to_memory_card();
				}
			}
		#endif
			break;
		}
        case EVT_ID_CUI_FOLDER_BROWSER_ON_MENU:
        {		
			cui_folder_browser_on_menu_event_struct *option_menu_evt = (cui_folder_browser_on_menu_event_struct *)evt;
					
            switch(option_menu_evt->menuitem_id)
            {				
			#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
		    case MENU_ID_VDOPLY_STORAGE:
                mmi_vdoply_entry_set_storage_screen();
				return MMI_RET_DONT_CARE;
			#endif
				
			#ifdef __MMI_VIDEO_STREAM__	
			case MENU_ID_VDOPLY_INPUT_URL:
				mmi_vdoply_entry_url_editor_scr();
				return MMI_RET_DONT_CARE;
				
			case MENU_ID_VDOPLY_PREDEFINED_URL:
					mmi_frm_scrn_create(GRP_ID_VDOPLY_APP,
		                    SCR_ID_VDOPLY_PREDEFINED_URL,
		                    mmi_vdoply_entry_predefined_url_screen_proc,
		                    NULL);
				return MMI_RET_DONT_CARE;
				
			case MENU_ID_VDOPLY_HISTORY_URL:
					mmi_frm_scrn_create(GRP_ID_VDOPLY_APP,
			            SCR_ID_VDOPLY_HISTORY_URL,
			            mmi_vdoply_history_url_screen_proc,
			            NULL);   
				return MMI_RET_DONT_CARE;
				
			case MENU_ID_VDOPLY_NETWORK_PROFILE:
				mmi_vdoply_enter_grp_network_profile();
				return MMI_RET_DONT_CARE;
			#endif
			
            default:
                break;
            }
        }
        break;
		
        case EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT:
		#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
			storage = g_vdoply_cntx.storage ;
            if (FS_GetDevStatus(storage, FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)
            {
			    drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
			    total_drv_num = (U8)srv_fmgr_drivelist_count(drv_list);
			    srv_fmgr_drivelist_destroy(drv_list);
				 
			    if (total_drv_num == 0)
			    {
				    /* no storage is avaible right now, need to plug memory card */
					mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_INSERT_MEMORY_CARD,MMI_EVENT_FAILURE);
                    mmi_frm_group_close(GRP_ID_VDOPLY_APP);
				#ifdef __MMI_AP_DCM_VDOPLY__
					mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
				#endif
			    }
			    else if (total_drv_num == 1)
			    {

				    /* only phone storage is avaible */
					 mmi_vdoply_display_popup_confirm(
					    GRP_ID_VDOPLY_APP,
                        STR_GLOBAL_MC_REMOVED_USE_PHONE,
                        mmi_vdoply_storage_change_confirm_cb,
                        CNFM_TYPE_YESNO,
                        MMI_EVENT_QUERY
                    ); 
			    }
			    else
			    {
				    /* more than 2 storage is avaible */
			 	    mmi_vdoply_entry_set_storage_screen();
			    }
			}
			else
		#endif
            {
                mmi_frm_group_close(GRP_ID_VDOPLY_APP);            
		#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
            }  
            break;

		case EVT_VDOPLY_EXIT_WITH_POPUP:
		{
			cui_vdoply_exit_evt_struct *vdoply_evt = (cui_vdoply_exit_evt_struct *)evt;
			if(vdoply_evt->with_popup)
			{
                mmi_vdoply_display_popup(
					GRP_ID_VDOPLY_APP, 
					vdoply_evt->error_str_id, 
					MMI_EVENT_FAILURE);
			}
			cui_vdoply_close(GRP_ID_VDOPLY_SINGLE_PLAYER);
			break;
		}
	#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
        case EVT_ID_CUI_STORAGE_SELECTOR_RESULT:
            {
				cui_file_selector_result_event_struct *sel_evt = (cui_file_selector_result_event_struct*)evt;

				if (sel_evt->result >= 0)
				{
				#ifdef MMI_VDOPLY_AUTO_CHANGE_STORAGE_FEATURE
					g_vdoply_cntx.is_need_change_storage = KAL_FALSE;
				#endif
					mmi_vdoply_get_total_files();
					mmi_vdoply_storage_select_cb(((cui_storage_selector_result_event_struct*)evt)->result);
				}
				else
				{
					mmi_frm_group_close(GRP_ID_VDOPLY_APP); 
				#ifdef __MMI_AP_DCM_VDOPLY__
					mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
				#endif
				}
            }
            break;
	#endif
			
        default:
            break;
			
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_app
 * DESCRIPTION
 *  video player entry point
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_pre_entry_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID ret_mmi_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/*if (mmi_vdoply_is_background_call())
	{
	    mmi_vdoply_display_not_available_popup(GRP_ID_ROOT);
		mmi_frm_app_close(APP_VDOPLY);
		return;
	}
	*/
	#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
	if(g_vdoply_cntx.is_entry_player_from_browser) 
	{ 
		if(g_vdoply_cntx.is_srv_da_state_complete)
		{
			mmi_vdoply_entry_player_screen_from_file(g_vdoply_cntx.source_path, MMI_FALSE);
		}
        else
	    {
	    	mmi_vdoply_entry_player_screen_from_pdl_file(g_vdoply_cntx.source_path, MMI_FALSE);
	    }
	    return; 
	} 
	#endif
    if (!mmi_frm_is_in_backward_scenario())
    {
		#ifndef __MMI_SUPPORT_ASMV2__
    	ret_mmi_id = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_APP, 
                    mmi_vdoply_app_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
		if (!ret_mmi_id)  
        {
            mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);
			#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
            return;
        } 
		#else
        ret_mmi_id = mmi_frm_group_create_ex(
                    APP_VDOPLY, 
                    GRP_ID_VDOPLY_APP, 
                    mmi_vdoply_app_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
        if (!ret_mmi_id)  
        {
            mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);
			mmi_frm_app_close(APP_VDOPLY);
			#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
            return;
        } 
		#endif
    }

	mmi_frm_scrn_create(GRP_ID_VDOPLY_APP, 
		                SCR_ID_VDOPLY_APP,
		                mmi_vdoply_file_list_screen_proc,
		                NULL);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_app
 * DESCRIPTION
 *  video player entry point
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_file_list_screen(MMI_BOOL is_redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
    FS_HANDLE file_handle;
    FMGR_FILTER filter;
    S32 create_result;
    MMI_ID_TYPE err_strid;
    mmi_event_notify_enum popup_type;
    MMI_ID browse_gid;
    U32 option_flag;
    U16 icon_id, string_id;
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
	SRV_FMGR_DRVLIST_HANDLE drvlist;
	S32 total_drv_num = 0;
#endif
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__USB_IN_NORMAL_MODE__)
    if (srv_usb_is_in_mass_storage_mode())
    {
        /* in mass storage mode */
		mmi_usb_app_unavailable_popup(0);
		mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
		return;
    }
#endif /* __USB_IN_NORMAL_MODE__ */
    
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
    drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
    total_drv_num = srv_fmgr_drivelist_count(drvlist);
    srv_fmgr_drivelist_destroy(drvlist); 

    if (total_drv_num == 0)
    {
        mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_INSERT_MEMORY_CARD, MMI_EVENT_FAILURE);
        mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
        return;
    }
    
    /* VDOPLY_APP is dummy screen, use this API to draw something if small screen is covered on top.*/
    ShowCategoryDummySmallScreen();
    if (is_redraw)
    {
        return;
    }
#endif
 
    mmi_vdoply_get_storage_file_path(buf_filepath);

#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
    if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE) == MMI_TRUE)
    {
        VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE);
        mmi_vdoply_entry_set_app_storage_screen();
        return;
    }
#endif

    if (FS_NO_ERROR == FS_GetDevStatus((U16)buf_filepath[0] ,FS_MOUNT_STATE_ENUM))
    {
        create_result = mmi_vdoply_create_file_dir(buf_filepath);
        if (create_result != FS_NO_ERROR)
        {
            
            err_strid = srv_fmgr_fs_error_get_string(create_result);
            popup_type = (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(create_result);
           
            /* 
             * Storage has error, set this flag and re-enter app screen, 
             * will launch storage selection screen 
             */
	    #ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
            if (total_drv_num == 1)
            {
                mmi_vdoply_display_popup(GRP_ID_ROOT, err_strid, popup_type);
                mmi_frm_group_close(GRP_ID_VDOPLY_APP);
			#ifdef __MMI_AP_DCM_VDOPLY__
				mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
                return;
            }
            else
            {
                mmi_vdoply_display_popup(GRP_ID_ROOT, err_strid, popup_type); 
                VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE);
                return;
            }
		#else
			mmi_vdoply_display_popup(GRP_ID_ROOT, err_strid, popup_type);
			mmi_frm_group_close(GRP_ID_VDOPLY_APP);
			#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
			return;
		#endif
        }
    }
    else
    {
	#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
        if (total_drv_num == 1)
        {
            mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_INSERT_MEMORY_CARD, MMI_EVENT_FAILURE);
            mmi_frm_group_close(GRP_ID_VDOPLY_APP);
			#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
            return;
        }
        else
        {
            mmi_vdoply_display_popup(GRP_ID_ROOT, STR_ID_VDOPLY_NOTIFY_STORAGE_NOT_READY, MMI_EVENT_FAILURE);        
            VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE);
            return;
        } 
	#else
		mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_INSERT_MEMORY_CARD, MMI_EVENT_FAILURE);
		mmi_frm_group_close(GRP_ID_VDOPLY_APP);
		#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
		return;	
	#endif
    }
    /* check if it is valid path */
    file_handle = FS_Open((PU16)buf_filepath, FS_OPEN_DIR | FS_READ_ONLY);

    if (file_handle >= 0)
    {
        FS_Close(file_handle);

        FMGR_FILTER_INIT(&filter);
        FMGR_FILTER_SET_VIDEO(&filter);
        
    #ifdef __MMI_VIDEO_STREAM__
        FMGR_FILTER_SET(&filter, FMGR_TYPE_SDP);
        FMGR_FILTER_SET(&filter, FMGR_TYPE_RAM);
    #endif /* __MMI_VIDEO_STREAM__ */

    #if defined(__DRM_V02__)
        FMGR_FILTER_SET(&filter, FMGR_TYPE_ODF);
    #endif 

        {
            U16 drive = SRV_FMGR_PUBLIC_DRV;
            //mmi_fmgr_browse_setting_struct setting;            
            g_vdoply_cntx.fmgr_handle = 0;

                /* Configure option flag */
            option_flag = 0;
    #if defined(__FMGR_FAST_FORWARD_CSK_SUPPORT__)
            option_flag |= CUI_FOLDER_BROWSER_OPT_FAST_FORWARD_ON;
    #endif

            g_vdoply_cntx.fmgr_scr_id = GRP_ID_INVALID;
            if ((browse_gid = cui_folder_browser_create(GRP_ID_VDOPLY_APP, (WCHAR *)buf_filepath, &filter, option_flag, MENU_ID_VDOPLY_FILE_OPTION, MENU_ID_VDOPLY_EMPTY_FOLDER_OPTION)) != GRP_ID_INVALID)
            {
                g_vdoply_cntx.fmgr_scr_id = browse_gid;                //g_imgview_context.is_entry_browse = MMI_TRUE;
                
                mmi_fmgr_get_app_title_info(APP_VDOPLY, &string_id, &icon_id, (CHAR*)buf_filepath);
			#ifdef MMI_VDOPLY_SHOW_STORAGE_IN_FILE_LIST
				if((U8)g_vdoply_cntx.storage == 'D')
					string_id = STR_ID_VDOPLY_STORAGE_PHONE;
				else
					string_id = STR_ID_VDOPLY_STORAGE_MEMORY_CARD;
			#endif
                cui_folder_browser_set_title(browse_gid, string_id, icon_id);
                cui_folder_browser_set_ui_style(browse_gid, CUI_FMGR_UI_STYLE_ICON_LIST);
                cui_folder_browser_run(browse_gid);                
            }
            else
            {
                mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
                mmi_frm_group_close(GRP_ID_VDOPLY_APP);
			#ifdef __MMI_AP_DCM_VDOPLY__
				mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
			#endif
                return;
                /*TODO: add trace*/
            }
        }
    }
    else
    {
        mmi_vdoply_display_popup(GRP_ID_ROOT, srv_fmgr_fs_error_get_string(file_handle), MMI_EVENT_FAILURE);
        mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_file_list_screen_proc
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_file_list_screen_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	switch(evt->evt_id)
	{
	    case EVT_ID_SCRN_ACTIVE:
		{
			mmi_frm_scrn_active_evt_struct* active_evt = (mmi_frm_scrn_active_evt_struct*)evt;
			mmi_vdoply_entry_file_list_screen(active_evt->is_bg_redrawing);
			break;
		}			

		case EVT_ID_SCRN_DEINIT:
			VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_NEED_CHANGE_STORAGE);
			break;
			
		default:
			break;
	}
	return MMI_RET_OK;
}

/*****************************************************************************
*
* Select Prefered Storage                                                                
*
*****************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_hint_set_storage
 * DESCRIPTION
 *  storage's hint
 * PARAMETERS
 *  index       [IN]        Selection index
 * RETURNS
 *  void
 *****************************************************************************/
#ifndef MMI_VDOPLY_HIDE_STORAGE_SCREEN
void mmi_vdoply_hint_set_storage(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* slim revise*/
	/*memset((CHAR*) hintData[(index)], 0, sizeof(hintData[(index)]));    */
    srv_fmgr_drv_get_name(
        (U8)g_vdoply_cntx.storage, 
        (WCHAR *)&hintData[index], 
        (S32)((SRV_FMGR_DRV_MAX_NAME_LEN + 1 ) * ENCODING_LENGTH));
}
#endif


/*****************************************************************************
 * FUNCTION
 * cui_vdoply_create
 * DESCRIPTION
 *  create video player cui using file
 * PARAMETERS
 *  parent_id      [IN]        cui parent id
 *  video_type    [IN]        video player cui type
 *  param            [IN]        cui create param
 * RETURNS
 *  MMI_ID    cui id
 *****************************************************************************/
MMI_ID cui_vdoply_create(MMI_ID parent_id, cui_vdoply_type_enum video_type,cui_vdoply_param_struct* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, CUI_VDOPLY_CREATE , parent_id,video_type);
	/*if (mmi_vdoply_is_background_call())
    {
	mmi_vdoply_display_not_available_popup(parent_id);
        return GRP_ID_INVALID;
    }*/

	#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())
    {
         /* file is in exported device */
        mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
        return GRP_ID_INVALID;
    }
    #endif /* __USB_IN_NORMAL_MODE__ */ 

	#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
    gid = mmi_frm_group_create_ex(
                    parent_id, 
                    GRP_ID_VDOPLY_SINGLE_PLAYER, 
                    mmi_vdoply_single_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
                    
    if (GRP_ID_INVALID == gid)
    {
        return GRP_ID_INVALID;
    }

    g_vdoply_cntx.is_short_filename = param->is_short;
    memset((void*)&g_vdoply_cntx.video_info, 0, sizeof(vdoply_video_info_struct));
	
	switch(video_type)
    {
        case CUI_VDOPLY_TYPE_FILE:
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_FILE;
            mmi_ucs2cpy(g_vdoply_cntx.source_path, param->video_hdr.file_name);
			if(param->video_title.title_str != NULL)
			{
			    mmi_ucs2ncpy((CHAR*)g_vdoply_cntx.video_info.title_desc, 
                    param->video_title.title_str,
                    MDI_VIDEO_INFO_TITLE_CHAR_COUNT-1);
			}
			break;
			
		#ifdef __MMI_VIDEO_PDL__
		case CUI_VDOPLY_TYPE_PDL_FILE:
			
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_PROGRESSIVE_DL;
		    mmi_ucs2ncpy(g_vdoply_cntx.source_path, param->video_hdr.file_name, sizeof(g_vdoply_cntx.source_path) / ENCODING_LENGTH - 1);
			break;
		#endif
		
		#ifdef __MMI_VIDEO_STREAM__ 
		case CUI_VDOPLY_TYPE_RTSP_FILE:
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_STREAMING_RTSP;
		    mmi_ucs2ncpy(g_vdoply_cntx.source_path, param->video_hdr.file_name, sizeof(g_vdoply_cntx.source_path) / ENCODING_LENGTH - 1);
			break;
			
		case CUI_VDOPLY_TYPE_SDP:
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_STREAMING_SDP;
		    mmi_ucs2ncpy(g_vdoply_cntx.source_path, param->video_hdr.file_name, sizeof(g_vdoply_cntx.source_path) / ENCODING_LENGTH - 1);
		     
			if(param->video_title.title_str != NULL)
			{
			    mmi_ucs2ncpy((CHAR*)g_vdoply_cntx.video_info.title_desc, 
		                param->video_title.title_str,
		                MDI_VIDEO_INFO_TITLE_CHAR_COUNT-1);
			}	    
			break;
			
		case CUI_VDOPLY_TYPE_RAM_FILE:
			{
				FS_HANDLE file_handle;
                U32 readed;
                CHAR url_buf[VDOPLY_MAX_URL_CHAR_COUNT+1];

				g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_STREAMING_RAM;		    
		        file_handle = FS_Open((U16*)param->video_hdr.file_name, FS_READ_ONLY);
		    
			    if (file_handle >=0)
			    {
			        FS_Read(file_handle, (void*)url_buf, VDOPLY_MAX_URL_CHAR_COUNT, &readed);
			        FS_Close(file_handle);
			    }
			    mmi_asc_to_ucs2((CHAR*)g_vdoply_cntx.source_path, (CHAR*)url_buf);
				break;
			}
		#endif

		#ifndef MMI_VDOPLY_SLIM_FOR_ID
		case CUI_VDOPLY_TYPE_ID:
			g_vdoply_cntx.play_source = VDOPLY_PLAY_FROM_ID;
            g_vdoply_cntx.video_id = param->video_hdr.video_id;
            g_vdoply_cntx.video_name_id = param->video_title.title_id;

		    if (param->video_title.title_id != 0)
		    {
		        mmi_ucs2cpy(g_vdoply_cntx.source_path, (CHAR*)GetString(g_vdoply_cntx.video_name_id));        
		        g_vdoply_cntx.is_short_filename = MMI_FALSE;
		    }
		    else
		    {
		        g_vdoply_cntx.is_short_filename = MMI_TRUE;
		    }
			break;
		#endif
	    default:
			return GRP_ID_INVALID;
    }
	return  gid;
}


/*****************************************************************************
 * FUNCTION
 *  cui_vdoply_run
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static  mmi_ret mmi_vdoply_play_screen_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	switch(evt->evt_id)
	{
	    case EVT_ID_SCRN_ACTIVE:
		{
			mmi_frm_scrn_active_evt_struct* active_evt = (mmi_frm_scrn_active_evt_struct*)evt;
			mmi_vdoply_entry_player_screen_internal(active_evt->gui_buffer, active_evt->is_bg_redrawing);
			break;
		}
			
	    case EVT_ID_SCRN_INACTIVE:
			mmi_vdoply_exit_player_screen_internal();
			break;

		case EVT_ID_SCRN_DEINIT:
			mmi_vdoply_del_screen_hdlr();
		#ifdef __MMI_AP_DCM_VDOPLY__
			mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
		#endif
			g_vdoply_cntx.is_entry_player_from_other_app = MMI_FALSE;
			break;
			
		default:
			break;
	}
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  cui_vdoply_run
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_ID cui_vdoply_run(MMI_ID vdoply_gid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, CUI_VDOPLY_RUN, vdoply_gid);
	gid = mmi_frm_group_enter(vdoply_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
                    
    if (GRP_ID_INVALID == gid)
    {
        cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_NOT_AVAILABLE);
        return GRP_ID_INVALID;
    }
	
    mmi_frm_scrn_create(
        GRP_ID_VDOPLY_SINGLE_PLAYER,
        SCR_ID_VDOPLY_PLAYER,
        mmi_vdoply_play_screen_proc,
        NULL);
	return gid;
}


/*****************************************************************************
 * FUNCTION
 *  cui_vdoply_close
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cui_vdoply_close(mmi_id vdoply_gid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, CUI_VDOPLY_CLOSE, vdoply_gid);
    mmi_frm_group_close(vdoply_gid);
	#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
}


/*****************************************************************************
 * FUNCTION
 * cui_vdoply_evt_exit
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void cui_vdoply_evt_exit(MMI_BOOL is_with_popup, MMI_ID_TYPE error_str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_exit_evt_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_CUI_EVT_EXIT, is_with_popup, error_str);
    MMI_FRM_INIT_GROUP_EVENT(&evt, EVT_VDOPLY_EXIT_WITH_POPUP, GRP_ID_VDOPLY_SINGLE_PLAYER);
    evt.with_popup = is_with_popup;
	evt.error_str_id = error_str;
    mmi_frm_group_send_to_parent(GRP_ID_VDOPLY_SINGLE_PLAYER, (mmi_group_event_struct*) & evt);
}


/*****************************************************************************
 * FUNCTION
 *  cui_vdoply_exit_button_worked
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void cui_vdoply_exit_button_worked(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    #ifdef __MMI_VIDEO_PDL__
        if( g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_PROGRESSIVE_DL)
        {
            if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
            {
                /* file still downloading */
                mmi_vdoply_entry_pdl_teminate_confirm_scr();
                return;
            }
            else
            {
               /* file already downloaded */
                cui_vdoply_evt_exit(MMI_FALSE,0);
                return;
            }
        }
    #endif /* __MMI_VIDEO_PDL__ */

    /* other case */
    cui_vdoply_evt_exit(MMI_FALSE,0);
}



#ifdef __MMI_VIDEO_STREAM__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_settings_inline_set_item_value
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_settings_inline_set_item_value(cui_event_inline_common_struct *inline_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_group_is_present(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT))
    {
        if (mmi_vdoply_is_network_profile_changed())
        {
            cui_inline_set_screen_attributes(inline_evt->sender_id, CUI_INLINE_SET_ATTRIBUTE, CUI_INLINE_SCREEN_CHANGED);
        }
    }

}
#endif


#if defined(__MMI_VIDEO_STREAM__)			
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_save_stream_file
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_save_stream_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE dest_handle;
    FS_HANDLE src_handle;    
    CHAR filename_buf[SRV_FMGR_PATH_BUFFER_SIZE];
    CHAR url_buf[VDOPLY_MAX_URL_CHAR_COUNT+1];    
    U8 tmp_buf[100];
    U32 str_len;
    U32 written;
    U32 readed;
    U32 file_size;
    S32 fs_ret;
    U16 stream_seq_no;
    S16 error = 0 ;
    MMI_ID_TYPE error_str_id;
    CHAR* skip_space_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_get_storage_file_path(filename_buf);

    /* create dir if needed, maybe user already delete the video folder */
    /* but we do not do error check here */
    if(mmi_vdoply_create_file_dir(filename_buf) != FS_NO_ERROR)
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_ID_VDOPLY_NOTIFY_STORAGE_NOT_READY, MMI_EVENT_FAILURE);
        return;
    }

    skip_space_p = (CHAR*)srv_fmgr_path_skip_leading_space((WCHAR *)g_vdoply_cntx.edit_buf);
    /* file not exist -save SDP or RAM */
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
    {
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)skip_space_p);
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)(L".ram"));
    }
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)skip_space_p);
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)(L".sdp"));
    }

    /* delete if already exist */
    FS_Delete((U16*)filename_buf);
    
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
    {
        /* save link to file */          
        dest_handle = FS_Open((U16*)filename_buf, FS_CREATE_ALWAYS);

        if (dest_handle >= 0)
        {
            mmi_ucs2_to_asc((CHAR*)url_buf, (CHAR*)g_vdoply_cntx.source_path);
            str_len = strlen(url_buf) + 1; /* +1 for null terminate */
            
            fs_ret = FS_Write(dest_handle, url_buf, str_len, &written);

            if (fs_ret < 0)
            {
                /* error */
                error_str_id = srv_fmgr_fs_error_get_string(fs_ret);
               
                FS_Close(dest_handle);
                FS_Delete((U16*)filename_buf);
                mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
                mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER,  error_str_id, MMI_EVENT_FAILURE); 
                return;
            }
            else
            {
                /* url saved */
                FS_Close(dest_handle);
                mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
                mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_GLOBAL_SAVED, MMI_EVENT_SUCCESS); 

                /* get/store sequentail number */
                ReadValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);
                stream_seq_no++;
                if (stream_seq_no > 9999) /* more than 4 digits */
                {
                    stream_seq_no = 1;
                }
                WriteValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);
                return;

            }
        }
        else
        {
            /* open file error handling */
            error_str_id = srv_fmgr_fs_error_get_string(dest_handle);
            FS_Delete((U16*)filename_buf);
            mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
            mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, error_str_id, MMI_EVENT_FAILURE); 
            return;
        }
       
    }
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        /* save link to file */          
        dest_handle = FS_Open((U16*)filename_buf, FS_CREATE_ALWAYS);

        if (dest_handle >= 0)
        {
            src_handle = FS_Open((U16*)g_vdoply_cntx.source_path, FS_READ_ONLY);
            
            if (src_handle >= 0)
            {
                /* copy from src to dest */
                FS_GetFileSize(src_handle, &file_size);
                fs_ret = FS_NO_ERROR;
                    
                do {
                    fs_ret = FS_Read(src_handle, tmp_buf, 100, &readed);
                    
                    if(fs_ret < 0)
                    {
                        break;
                    }
                    
                    fs_ret = FS_Write(dest_handle, tmp_buf, readed, &written);

                    if(fs_ret < 0)
                    {
                        break;
                    }

                    file_size -= written;
                } while(file_size);

                FS_Close(src_handle);
                FS_Close(dest_handle);
                mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
                mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, STR_GLOBAL_SAVED, MMI_EVENT_SUCCESS);

                /* get/store sequentail number */
                ReadValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);
                stream_seq_no++;
                if (stream_seq_no > 9999) /* more than 4 digits */
                {
                    stream_seq_no = 1;
                }
                WriteValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);                
                return;                    

            }
            else
            {
                /* src opened error */
                FS_Close(dest_handle);

                error_str_id = srv_fmgr_fs_error_get_string(src_handle);
                mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
                mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER,  error_str_id, MMI_EVENT_FAILURE); 
                return;
            }
        }
        else
        {
            /* dest opened error */
            error_str_id = srv_fmgr_fs_error_get_string(dest_handle);
            mmi_frm_group_close(GRP_ID_VDOPLY_STREAM_EDITOR);
            mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER, error_str_id, MMI_EVENT_FAILURE); 
            return;           
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_save_file_confirm_cb
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_save_file_confirm_cb(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *alert_evt = (mmi_alert_result_evt_struct *)evt;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 	
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
            // handle softkey event here
            break;
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_save_stream_file();
            break;
        case MMI_ALERT_CNFM_NO:
            // handle softkey event here
            mmi_frm_scrn_close_active_id();
            break;
        }
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_check_filename_and_save
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_check_filename_and_save(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE dest_handle;
    CHAR filename_buf[SRV_FMGR_PATH_BUFFER_SIZE];
    CHAR* skip_space_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* file not exist -save SDP or RAM */
    if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
        g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
    {
        mmi_vdoply_get_storage_file_path(filename_buf);
        skip_space_p = (CHAR*)srv_fmgr_path_skip_leading_space((WCHAR *)g_vdoply_cntx.edit_buf);
        
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)skip_space_p);
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)(L".ram"));
    }
    else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
    {
        mmi_vdoply_get_storage_file_path(filename_buf);
        skip_space_p = (CHAR*)srv_fmgr_path_skip_leading_space((WCHAR *)g_vdoply_cntx.edit_buf);
                
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)skip_space_p);
        mmi_ucs2cat((CHAR*)filename_buf, (CHAR*)(L".sdp"));
    }
    /* check if file already exist or not */
    dest_handle = FS_Open((U16*)filename_buf, FS_READ_ONLY);

    if (dest_handle >= 0)
    {
    mmi_vdoply_display_popup_confirm(
        GRP_ID_VDOPLY_SINGLE_PLAYER,
        STR_GLOBAL_OVERWRITE_EXISTING_FILE,
        mmi_vdoply_save_file_confirm_cb,
        CNFM_TYPE_YESNO,
        MMI_EVENT_QUERY
    );  

        FS_Close(dest_handle);
        return;
    }
    else
    {
        /* save file */
        mmi_vdoply_save_stream_file();
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_stream_editor_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_stream_editor_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U16 stream_seq_no;
    CHAR buffer[50];
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
    MMI_ID ret_mmi_id;
    MMI_ID cui_gid;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_get_storage_file_path(buf_filepath);
    
#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())
    {
        /* in mass storage mode */

        if (srv_usb_check_path_exported((WCHAR*)buf_filepath))
        {
            /* phone drive is exported, cant use this app */
            mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
            return;
        }
    }
#endif /* __USB_IN_NORMAL_MODE__ */ 
    ret_mmi_id = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_SETTINGS, 
                    GRP_ID_VDOPLY_STREAM_EDITOR, 
                    mmi_vdoply_settings_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);

    if (!ret_mmi_id)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER,  STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);                
        return;
    }
    ReadValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);
    if (stream_seq_no == 0xffff)
    {
        stream_seq_no = 0;    /* init value */
        WriteValueSlim(NVRAM_VDOPLY_STREAM_SEQ_NO, &stream_seq_no, DS_SHORT);            
        stream_seq_no = 1;
    }
    else
    {
        stream_seq_no++;
        if (stream_seq_no > 9999) /* more than 4 digits */
        {
            stream_seq_no = 1;
        }
    }
    
    sprintf((CHAR*)buffer, "STREAM%04d", stream_seq_no);
    mmi_asc_to_ucs2((CHAR*)g_vdoply_cntx.edit_buf, (CHAR*)buffer);
    cui_gid = cui_filename_editor_create(GRP_ID_VDOPLY_STREAM_EDITOR, 
        (WCHAR *)g_vdoply_cntx.edit_buf, 
        sizeof(g_vdoply_cntx.edit_buf) / ENCODING_LENGTH, 
        VDOPLY_MAX_STREAM_LINK_CHAR_COUNT, NULL, NULL);//path, ext);
    if (cui_gid != GRP_ID_INVALID)
    {        
        cui_filename_editor_set_title(cui_gid, STR_ID_VDOPLY_EDIT_FILENAME, GetRootTitleIcon(MENU_ID_VDOPLY_APP));
        cui_filename_editor_run(cui_gid);
    }
    else
    {   
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_SINGLE_PLAYER,  STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
    }    
}
#endif /* defined(__MMI_VIDEO_STREAM__) */


/**********************************
 * URL Editor Screen 
 **********************************/
#if defined(__MMI_VIDEO_STREAM__) 			 

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_check_url_and_enter
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_check_url_and_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	CHAR buffer[VDOPLY_MAX_URL_CHAR_COUNT+1];
    CHAR* str_ptr;
    S32 str_len;
	mmi_id cid = GRP_ID_INVALID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    mmi_ucs2_to_asc(buffer, g_vdoply_cntx.edit_buf);

    if (applib_url_is_valid(buffer) == 0)
    {
        str_ptr = buffer;
        
        /* make lower */
        while(*str_ptr != 0)
        {
            if (*str_ptr >= 'A' && *str_ptr <= 'Z')
            {
                *str_ptr = (*str_ptr)+0x20;
            }
            str_ptr++;
        }

        /* RTSP link*/
        /* rtsp:\\...... */
        if (strncmp(buffer, (CHAR*)"rtsp", 4) == 0)
        {
            mmi_frm_group_close(GRP_ID_VDOPLY_URL_EDITOR);         
            
            /* delete: editor option, editor */
			param.video_hdr.file_name =  g_vdoply_cntx.edit_buf;
            cid = cui_vdoply_create(GRP_ID_VDOPLY_APP, CUI_VDOPLY_TYPE_RTSP_FILE, &param);
            if(GRP_ID_INVALID != cid)
            {
                cui_vdoply_run(cid);
            }
            return;        
        }
        else if (strncmp(buffer, (CHAR*)"http", 4) == 0)
        {
            str_len = strlen(buffer);
            str_ptr = buffer + (str_len - 3);
            
            if (strncmp(str_ptr, (CHAR*)"sdp", 3) == 0)
            {
                mmi_frm_group_close(GRP_ID_VDOPLY_URL_EDITOR);                
                mmi_vdoply_entry_player_screen_from_sdp_file(g_vdoply_cntx.edit_buf, MMI_FALSE);       
                
                /* delete: editor option, editor */
                
                return;
            }
        }
    }

    /* delete back to editor screen */
    mmi_frm_group_close(GRP_ID_VDOPLY_URL_EDITOR);
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_INVALID_URL, MMI_EVENT_FAILURE);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_url_editor_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_url_editor_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    MMI_ID cid;
    MMI_ID parent_id;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    parent_id = GRP_ID_VDOPLY_APP;
    gid = mmi_frm_group_create_ex(
                    parent_id, 
                    GRP_ID_VDOPLY_URL_EDITOR, 
                    mmi_vdoply_streaming_url_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);

    if (GRP_ID_INVALID == gid)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);                
        return;
    }    
    mmi_ucs2cpy(g_vdoply_cntx.edit_buf, (CHAR*)(L"rtsp://")); 
    cid = cui_fseditor_create(GRP_ID_VDOPLY_URL_EDITOR);
    if (cid != GRP_ID_INVALID)
    {
        cui_fseditor_set_text(cid,
            (WCHAR *)g_vdoply_cntx.edit_buf,
            sizeof(g_vdoply_cntx.edit_buf) / ENCODING_LENGTH,
            VDOPLY_MAX_URL_CHAR_COUNT);
        cui_fseditor_set_title(cid, STR_ID_VDOPLY_INPUT_URL, GetRootTitleIcon(MENU_ID_VDOPLY_APP));
        cui_fseditor_set_input_method(cid,IMM_INPUT_TYPE_URL,NULL,0);
        cui_fseditor_run(cid);
    }
    else
    {   
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
    }    
}


/**********************************
 * Network Setting
 **********************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_hilite_hdlr
 * DESCRIPTION
 *  highlight hander of network profile screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_network_profile_hilite_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.cur_sel_profile_idx = (U8)index;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_profile_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_profile_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    //10ADA 
    if(mmi_dtcnt_ready_check(mmi_vdoply_entry_network_profile_scr_internal, MMI_TRUE))
    {
        mmi_frm_scrn_create(GRP_ID_VDOPLY_NETWORK_PROFILE,
                    SCR_ID_VDOPLY_NETWORK_PROFILE,
                    mmi_vdoply_network_profile_screen_proc,
                    NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_screen_proc
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_network_profile_screen_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
	{
	    case EVT_ID_SCRN_ACTIVE:
		{
			mmi_frm_scrn_active_evt_struct* active_evt = (mmi_frm_scrn_active_evt_struct*) evt;
			
			mmi_vdoply_entry_network_profile_scr_internal(active_evt->gui_buffer);
			break;
		}
		default:
			break;
	}
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_profile_scr_internal
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_profile_scr_internal(void* gui_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    U8 *str_item_list[NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL];
    U16 icon_item_list[NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/              
    mmi_vdoply_load_setting();

    if (gui_buffer == NULL)
    {
        g_vdoply_cntx.cur_sel_profile_idx = g_vdoply_cntx.active_profile_idx;    
    }

    for (i = 0; i < NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL; i++)
    {
        str_item_list[i] = (U8*)g_vdoply_cntx.network_profile[i].profile_name;

        if (i == g_vdoply_cntx.active_profile_idx)
        {
            icon_item_list[i] = IMG_VICON;
        }
        else
        {
            icon_item_list[i] = 0;
        }
    }

    RegisterHighlightHandler(mmi_vdoply_network_profile_hilite_hdlr);

    ShowCategory73Screen(
        STR_ID_VDOPLY_NETWORK_PROFILE,
        GetRootTitleIcon(MENU_ID_VDOPLY_APP),
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL,
        str_item_list,
        (U16*)icon_item_list,
        (U16*)gIndexIconsImageList,
        (S32)g_vdoply_cntx.cur_sel_profile_idx,
        NULL,
        ICON_ICON_TEXT);

    if (mmi_frm_kbd_is_key_supported(KEY_CSK))
    {
        SetCenterSoftkeyFunction(mmi_vdoply_network_profile_active_hdlr, KEY_EVENT_UP);
		SetKeyUpHandler(mmi_vdoply_network_profile_active_hdlr, KEY_ENTER);
        ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    }
    SetLeftSoftkeyFunction(mmi_vdoply_entry_network_profile_option_scr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_profile_option_scr
 * DESCRIPTION
 *  entry network profile option scr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_profile_option_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID cid;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cid = cui_menu_create(
                        GRP_ID_VDOPLY_NETWORK_PROFILE,
                    	CUI_MENU_SRC_TYPE_RESOURCE,
                    	CUI_MENU_TYPE_OPTION,
                    	MENU_ID_VDOPLY_NETWORK_PROFILE_OPTION,
                    	MMI_FALSE, NULL);
    if (cid > GRP_ID_INVALID)
    {
        cui_menu_set_default_title_image(cid, (UI_image_type)get_image(GetRootTitleIcon(MENU_ID_VDOPLY_APP)));
        cui_menu_run(cid);
    }
    else
    {   
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_profile_edit_init_item_valu
 * DESCRIPTION
 *  entry network profile option scr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_profile_edit_init_item_value(MMI_ID inline_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 encode_dataaccount_id = 0;
    U16 item_icons[VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_NUM];
    U16 item_count = 0;
    U16 item_total = VDOPLY_SETTINGS_PROFILE_INLINE_ITEM_NUM;
    U8 index = 0;
    nvram_ef_video_network_profile_struct *profile_p;
    CHAR inline_proxy_name[VIDEO_MAX_PROXY_ADDR_BUF_SIZE];
    CHAR inline_profile_name[VIDEO_MAX_PROFILE_NAME_BUF_SIZE];
    U8 inline_proxy_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_highest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_lowest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
	U32 i;
    srv_dtcnt_sim_type_enum sim_type;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    index = g_vdoply_cntx.cur_sel_profile_idx;
    g_vdoply_cntx.inline_gid = inline_id;
    profile_p = &g_vdoply_cntx.network_profile[index];
   
	for (i = 0; i < MMI_MAX_SIM_NUM; i++ )
    {
        g_vdoply_cntx.inline_data_account_id[i] = profile_p->data_account_id[i];
        encode_dataaccount_id = cbm_set_app_id(g_vdoply_cntx.inline_data_account_id[i], g_vdoply_cntx.cbm_app_id);
    if(mmi_dtcnt_acct_is_valid(encode_dataaccount_id) == MMI_DTCNT_ACCT_VALID_NONE )
    {
	        g_vdoply_cntx.inline_data_account_id[i] = CBM_DEFAULT_ACCT_ID;
    }
    }
    
    
    g_vdoply_cntx.inline_proxy_on_off = profile_p->proxy_on_off;
    if (mmi_ucs2strlen((CHAR*) profile_p->profile_name))
    {
        mmi_ucs2ncpy(inline_profile_name, (CHAR*)profile_p->profile_name, VIDEO_MAX_PROFILE_NAME_BUF_SIZE);
    }
    else
    {
        mmi_ucs2ncpy(inline_profile_name, 
            (CHAR*)GetString((U16) STR_ID_VDOPLY_NETWORK_PROFILE_NAME + index), VIDEO_MAX_PROFILE_NAME_BUF_SIZE);
    }
    if (mmi_ucs2strlen((CHAR*)profile_p->proxy_addr))
    {
        kal_wsprintf((WCHAR*)inline_proxy_name, "%s", (CHAR*)profile_p->proxy_addr);
    }
    else
    {
        kal_wsprintf((WCHAR*)inline_proxy_name,  "0.0.0.0");
    }

    gui_itoa(profile_p->proxy_port, (UI_string_type)inline_proxy_port, 10);        
    gui_itoa(profile_p->highest_udp_port, (UI_string_type)inline_highest_udp_port, 10);
    gui_itoa(profile_p->lowest_udp_port, (UI_string_type)inline_lowest_udp_port, 10);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_FULLSCREEN_EDIT, 
        (void *)inline_profile_name);

	sim_type = mmi_vdoply_network_get_data_account_sim_type();
        
    encode_dataaccount_id = cbm_encode_data_account_id(
                          g_vdoply_cntx.inline_data_account_id[sim_type - SRV_DTCNT_SIM_TYPE_1],
                          (cbm_sim_id_enum)(sim_type - SRV_DTCNT_SIM_TYPE_1),
                          g_vdoply_cntx.cbm_app_id,
                          KAL_FALSE);

    mmi_dtcnt_get_full_account_name(encode_dataaccount_id,
                 (CHAR*)g_vdoply_cntx.data_account_name,
                 (MAX_DATA_ACCOUNT_NAME_LEN+1)*ENCODING_LENGTH, 
                 MMI_DTCNT_GET_ACCT_NAME_TYPE_SINGLE);  

    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_DISPLAY_ONLY, 
        (void *)g_vdoply_cntx.data_account_name);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + USE_PROXY_TYPE_SELECT, 
        (void *)g_vdoply_cntx.inline_proxy_on_off);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + PROXY_SERVER_TYPE_FULLSCREEN_EDIT, 
        (void *)inline_proxy_name);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + PROXY_PORT_TYPE_TEXT_EDIT, 
        (void *)inline_proxy_port);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + LOWEST_UDP_TYPE_TEXT_EDIT, 
        (void *)inline_lowest_udp_port);
    cui_inline_set_value(inline_id, 
        CUI_INLINE_ITEM_ID_BASE + HIGHST_UDP_TYPE_TEXT_EDIT, 
        (void *)inline_highest_udp_port);
    
    if(SRV_DTCNT_SIM_TYPE_NONE == sim_type)
    {
        cui_inline_delete_item(inline_id, CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_CAPTION);
        cui_inline_delete_item(inline_id, CUI_INLINE_ITEM_ID_BASE + DATA_ACCOUNT_TYPE_DISPLAY_ONLY);
        item_total -= 2;
    }

    while (item_count < item_total)
    {
        item_icons[item_count] = IMG_GLOBAL_L1 + (item_count)/2;
        item_count++;
        item_icons[item_count++] = 0;
    }
    cui_inline_set_icon_list(inline_id, &item_icons[0]);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_profile_edit_scr
 * DESCRIPTION
 *  entry network profile edit screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_profile_edit_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_ID gid;
	MMI_ID inline_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
	gid = mmi_frm_group_create_ex(
	                GRP_ID_VDOPLY_NETWORK_PROFILE, 
	                GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT, 
	                mmi_vdoply_network_profile_proc,
	                NULL, 
	                MMI_FRM_NODE_SMART_CLOSE_FLAG);

	if (!gid)  
	{
	    mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);                
	    return;
	}
	inline_id = cui_inline_create(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT, &mmi_vdoply_settings_profile_inline_screen);
	if (inline_id != GRP_ID_INVALID)
	{
	    cui_inline_set_title_icon(inline_id, GetRootTitleIcon(MENU_ID_VDOPLY_APP));
		cui_inline_set_fullscreen_edit_title_icon(inline_id, 
			CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_FULLSCREEN_EDIT, GetRootTitleIcon(MENU_ID_VDOPLY_APP));
	    mmi_vdoply_profile_edit_init_item_value(inline_id);
	    cui_inline_run(inline_id);
	}
	else
	{
	    mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
	}

}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_is_network_profile_changed
 * DESCRIPTION
 *  check profile is changed in inline editor screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_is_network_profile_changed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_network_profile_struct *profile_p;
    S32 proxy_port;
    S32 highest_udp_port;
    S32 lowest_udp_port;
    CHAR temp_inline_profile_name[VIDEO_MAX_PROFILE_NAME_BUF_SIZE];  
    CHAR inline_profile_name[VIDEO_MAX_PROFILE_NAME_BUF_SIZE];  
    U8 inline_proxy_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_highest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_lowest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    MMI_ID inline_gid = GRP_ID_INVALID;
    CHAR inline_proxy_name_asc[VIDEO_MAX_PROXY_ADDR_LEN];
    CHAR inline_proxy_name[VIDEO_MAX_PROXY_ADDR_BUF_SIZE];
	U32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_gid = g_vdoply_cntx.inline_gid;
    profile_p = &g_vdoply_cntx.network_profile[g_vdoply_cntx.cur_sel_profile_idx];
    
    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_FULLSCREEN_EDIT, (void *) inline_profile_name);
    if (mmi_ucs2strlen((CHAR*)profile_p->profile_name))
    {
        mmi_ucs2ncpy((CHAR*)temp_inline_profile_name, 
                 (CHAR*)profile_p->profile_name, 
                 VIDEO_MAX_PROFILE_NAME_BUF_SIZE); 
    }
    else
    {
        mmi_ucs2ncpy((CHAR*)temp_inline_profile_name, 
                 (CHAR*)GetString((U16) STR_ID_VDOPLY_NETWORK_PROFILE_NAME + g_vdoply_cntx.cur_sel_profile_idx), 
                 VIDEO_MAX_PROFILE_NAME_BUF_SIZE);
    }
    
    if (mmi_ucs2cmp((CHAR*)inline_profile_name, (CHAR*)temp_inline_profile_name) != 0)
    {
        return MMI_TRUE;
    }

    for(i = 0; i < MMI_MAX_SIM_NUM; i++)
    {
        if (g_vdoply_cntx.inline_data_account_id[i] != profile_p->data_account_id[i])
    {
        return MMI_TRUE;
    }
    }

    if (g_vdoply_cntx.inline_proxy_on_off != profile_p->proxy_on_off)
    {
        return MMI_TRUE;
    }

    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROXY_SERVER_TYPE_FULLSCREEN_EDIT, (void *) &inline_proxy_name);
    mmi_ucs2_to_asc(inline_proxy_name_asc, inline_proxy_name);
    if (app_stricmp((CHAR*)profile_p->proxy_addr, (CHAR*)inline_proxy_name_asc) != 0)
    {
        return MMI_TRUE;
    }

    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROXY_PORT_TYPE_TEXT_EDIT, (void *) inline_proxy_port);
    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + LOWEST_UDP_TYPE_TEXT_EDIT, (void *) inline_lowest_udp_port);
    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + HIGHST_UDP_TYPE_TEXT_EDIT, (void *) inline_highest_udp_port);
    proxy_port = gui_atoi((UI_string_type)&inline_proxy_port);     
    lowest_udp_port = gui_atoi((UI_string_type)&inline_lowest_udp_port);     
    highest_udp_port = gui_atoi((UI_string_type)&inline_highest_udp_port);  

    if (profile_p->proxy_port != proxy_port ||
        profile_p->highest_udp_port!= highest_udp_port ||
        profile_p->lowest_udp_port != lowest_udp_port)

    {
        return MMI_TRUE;
    }

    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_save_confirm_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_network_profile_save_confirm_cb(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *alert_evt = (mmi_alert_result_evt_struct*)evt;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
            break;
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_network_profile_save_confirm_yes();
            break;
        case MMI_ALERT_CNFM_NO:
            mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT);
            break;
        }
    }
    return MMI_RET_OK;
    
}

/*****************************************************************************
 * FUNCTION
 *  applib_url_check_ip
 * DESCRIPTION
 *  This function check whether address is in the form of IP address,
 *  if so, validate the IP address with the valid IP range.
 * PARAMETERS
 *  url          [IN]
 *  len          [IN]
 * RETURNS
 *  1 if p is a valid address
 *****************************************************************************/
int mmi_vdoply_url_check_ip(const char *addr, int len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i, count;
    int ip_addr[4] = {0};
    const char *p = addr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* hostnumber     = digits "." digits "." digits "." digits */

    for (i = 0, count = 0; i < len; i++)
    {
		if (!is_digit(addr[i]))
		{
			if (addr[i] != '.')
			{
				return 0;
			}
			else
			{
				if (i == 0 || i + 1 == len)
            	{
                	return 0;
            	}

				if (addr[i-1] == '.')
				{
					return 0;
				}

				ip_addr[count] = atoi(p);

            	if (ip_addr[count] < 0 || ip_addr[count] > 255)
				{
					return 0;
				} 

				p = addr + i + 1;
				count++;

				if (count == 4)
				{
					return 0;
				}
			}
		}
    }

    ip_addr[count] = atoi(p);

    if(ip_addr[count] < 0 || ip_addr[count] > 255)
    {
        return 0;
    }

  
    return 1;
}
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_save_confirm_yes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_network_profile_save_confirm_yes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 port;
    S32 highest_port;
    S32 lowest_port;
    U8 index;
    CHAR str_buf[20];
    MMI_ID inline_gid = GRP_ID_INVALID;
    nvram_ef_video_network_profile_struct *profile_p;
    CHAR inline_profile_name[VIDEO_MAX_PROFILE_NAME_BUF_SIZE]; 
    U8 inline_proxy_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_highest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    U8 inline_lowest_udp_port[(VDOPLY_MAX_PORT_LEN)*ENCODING_LENGTH];
    CHAR inline_proxy_addr[VIDEO_MAX_PROXY_ADDR_BUF_SIZE];
	U32 i;
    char *temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inline_gid = g_vdoply_cntx.inline_gid;
    
    /* check the data valid */
    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROXY_PORT_TYPE_TEXT_EDIT, (void *) inline_proxy_port);

    port = gui_atoi((UI_string_type)&inline_proxy_port);
    if ((port >65535) ||(g_vdoply_cntx.inline_proxy_on_off && !port))
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_ID_VDOPLY_NOTIFY_VALID_PROXY_PORT, MMI_EVENT_FAILURE); 
        return;
    }

    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROXY_SERVER_TYPE_FULLSCREEN_EDIT, (void *) &inline_proxy_addr);
    i = app_ucs2_strlen(inline_proxy_addr);
    temp = (char*)OslMalloc((i+1)*sizeof(char));
    mmi_ucs2_to_asc(temp,inline_proxy_addr);
    if ((mmi_vdoply_url_check_ip(temp,i) == 0)||(g_vdoply_cntx.inline_proxy_on_off && !(inline_proxy_addr[0] =='\0' && inline_proxy_addr[1]=='\0')))
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_ID_VDOPLY_NOTIFY_INVALID_SERVER, MMI_EVENT_FAILURE); 
        OslMfree(temp);
        return;
    }
    OslMfree(temp);    
    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + LOWEST_UDP_TYPE_TEXT_EDIT, (void *) inline_lowest_udp_port);
    lowest_port = gui_atoi((UI_string_type)&inline_lowest_udp_port);
    if ((lowest_port < 6000) || (lowest_port > 65532))
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_ID_VDOPLY_NOTIFY_VALID_LOWEST_UDP_PORT, MMI_EVENT_FAILURE); 
        return;
    }

    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + HIGHST_UDP_TYPE_TEXT_EDIT, (void *) inline_highest_udp_port);
    highest_port = gui_atoi((UI_string_type)&inline_highest_udp_port);
    if ((highest_port < 6003) || (highest_port > 65535))
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE,  STR_ID_VDOPLY_NOTIFY_VALID_HIGHEST_UDP_PORT, MMI_EVENT_FAILURE); 
        return;
    }

    if ((highest_port - lowest_port) < 3 || ((highest_port - lowest_port) == 3 && lowest_port % 2))
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE,  STR_ID_VDOPLY_NOTIFY_INVALID_UDP_PORT, MMI_EVENT_FAILURE); 
        return;
    }

    /* save the updated data */
    index = g_vdoply_cntx.cur_sel_profile_idx;
    profile_p = &g_vdoply_cntx.network_profile[index];

    cui_inline_get_value(inline_gid, CUI_INLINE_ITEM_ID_BASE + PROFILE_NAME_TYPE_FULLSCREEN_EDIT, (void *) inline_profile_name);

    if (mmi_ucs2strlen((CHAR*)profile_p->profile_name) != 0  &&
        mmi_ucs2cmp((CHAR*) profile_p->profile_name, (CHAR*)inline_profile_name))
    {
        /* CCA RULE:  if change profile name, we shouldn't update profile, so clear provurl here */
        memset((CHAR*)&profile_p->provurl, 0, sizeof(profile_p->provurl));
    }
    mmi_ucs2cpy((CHAR*)profile_p->profile_name,(CHAR*)inline_profile_name);
    if (mmi_ucs2strlen((CHAR*)profile_p->profile_name) == 0)        
    {
        sprintf(str_buf, "Profile%d", (g_vdoply_cntx.cur_sel_profile_idx+1));
        mmi_asc_to_ucs2((CHAR*)profile_p->profile_name, str_buf);
    }

    for (i = 0; i < MMI_MAX_SIM_NUM; i++)
    {
        profile_p->data_account_id[i] = g_vdoply_cntx.inline_data_account_id[i];
    }
    
    profile_p->proxy_on_off = g_vdoply_cntx.inline_proxy_on_off;
    profile_p->highest_udp_port = gui_atoi((UI_string_type)&inline_highest_udp_port);
    profile_p->lowest_udp_port = gui_atoi((UI_string_type)&inline_lowest_udp_port);
    profile_p->proxy_port = gui_atoi((UI_string_type)&inline_proxy_port);

    mmi_ucs2_to_asc(profile_p->proxy_addr, inline_proxy_addr);
    
    mmi_vdoply_store_setting();
    //DeleteNHistory(1);
    mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT);
    
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE, STR_GLOBAL_SAVED, MMI_EVENT_SUCCESS); 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_profile_active_hdlr
 * DESCRIPTION
 *  active network profile
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_network_profile_active_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.active_profile_idx = g_vdoply_cntx.cur_sel_profile_idx;

    mmi_vdoply_store_setting();
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_ACTIVATED, MMI_EVENT_SUCCESS);  
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_network_get_data_account_sim_type
 * DESCRIPTION
 *  entry profile edit   
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static srv_dtcnt_sim_type_enum mmi_vdoply_network_get_data_account_sim_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret;
    srv_dtcnt_sim_type_enum sim_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_dtcnt_get_sim_preference(&sim_type);
    if(ret == MMI_FALSE || sim_type == SRV_DTCNT_SIM_TYPE_NONE )
    {
        sim_type = SRV_DTCNT_SIM_TYPE_1;
    }
    return sim_type;
}


//10ADA
static MMI_ID g_mmi_dtcnt_select_id;

static mmi_ret mmi_vdoply_dtcnt_cui_proc(mmi_event_struct *evt) 
{

	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_dtcnt_select_event_any_sim_selected_struct  *event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    event = (cui_dtcnt_select_event_any_sim_selected_struct*)evt;

    switch (evt->evt_id)
    {
        case CUI_DTCNT_SELECT_EVENT_ANY_SIM_ACCOUNT_SELECTED:
        {
            g_vdoply_cntx.inline_data_account_id[event->selectSim - CUI_DTCNT_SIM1] = event->accountId;
            if(mmi_vdoply_network_get_data_account_sim_type() - SRV_DTCNT_SIM_TYPE_1 == event->selectSim)
            {
                mmi_dtcnt_get_full_account_name(event->accountId,
                    (CHAR*)g_vdoply_cntx.data_account_name,
                    (MAX_DATA_ACCOUNT_NAME_LEN+1)*ENCODING_LENGTH, MMI_DTCNT_GET_ACCT_NAME_TYPE_SINGLE);              
            }                         
            break;
        }            

        case CUI_DTCNT_SELECT_EVENT_RESULT_OK:
        case CUI_DTCNT_SELECT_EVENT_RESULT_FAILED:
        case CUI_DTCNT_SELECT_EVENT_RESULT_CANCEL:
        case CUI_DTCNT_SELECT_EVENT_CLOSE:
            cui_dtcnt_select_close(g_mmi_dtcnt_select_id);      
            break;
        default:
            break;
	}
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_data_account_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_data_account_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_dtcnt_select_run_struct para;
    MMI_ID ret_id;
	U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	for (i = 0; i < MMI_MAX_SIM_NUM; i++)
    {
        para.sim_account_id[i] = g_vdoply_cntx.inline_data_account_id[i];
    }
    para.AppMenuID = MENU_ID_VDOPLY_APP;
    para.app_id = g_vdoply_cntx.cbm_app_id;
    para.bearers = DATA_ACCOUNT_BEARER_GPRS | DATA_ACCOUNT_BEARER_WIFI;
    para.sim_selection = CUI_DTCNT_SELECT_SIM_ALL;
    para.option = CUI_DTCNT_SELECT_DEFAULT;
    para.type = CUI_DTCNT_SELECT_TYPE_NORMAL;
    para.icon_id = GetRootTitleIcon(MENU_ID_VDOPLY_APP);
    para.str_id = STR_GLOBAL_DATA_ACCOUNT;
    ret_id = mmi_frm_group_create_ex(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT, 
		            GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT_DA, 
		            mmi_vdoply_dtcnt_cui_proc, 
		            NULL, 
		            MMI_FRM_NODE_SMART_CLOSE_FLAG);
   
    if (!ret_id)
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
        return;
    }
    g_mmi_dtcnt_select_id = cui_dtcnt_select_create(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT_DA);
    if(g_mmi_dtcnt_select_id != GRP_ID_INVALID)
    {
        cui_dtcnt_select_set_param(g_mmi_dtcnt_select_id, &para);
        cui_dtcnt_select_run(g_mmi_dtcnt_select_id);
    }
    else
    {
        mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT_DA);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_network_data_account_scr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_network_data_account_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_entry_network_data_account_cui();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_sim_unavailable_hdlr
 * DESCRIPTION
 *  network settings data account change handler
 * PARAMETERS
 *  event  [in] event struct
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_vdoply_sim_unavailable_hdlr(mmi_event_struct* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SIM_UNAVAILABLE, param->evt_id);
    if (EVT_ID_SRV_SIM_CTRL_UNAVAILABLE == param->evt_id && 
    	  mmi_frm_group_is_present(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT))
    {
    	  MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_SIM_UNAVAILABLE, param->evt_id);
        mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE_EDIT);
    }
        
    return MMI_RET_OK;
  }


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_dtcnt_changed_hdlr
 * DESCRIPTION
 *  network settings data account change handler
 * PARAMETERS
 *  param  [in] event struct
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_vdoply_dtcnt_changed_hdlr(mmi_event_struct* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cbm_account_info_struct info;
    U32 data_acct;
    U32 i,j;
    nvram_ef_video_network_profile_struct *profile_p;
    U32 sim_id;
    U32 index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_DTCNT_CHANGED, param->evt_id);
    switch(param->evt_id)
    {
        case EVT_ID_SRV_DTCNT_ACCT_DELETE_IND:
        { 
            for (index = 0; index < NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL; index++)
            {
                profile_p = &g_vdoply_cntx.network_profile[index];
                for(sim_id = 0; sim_id < MMI_MAX_SIM_NUM; sim_id++)
                {
                    data_acct = cbm_set_app_id(profile_p->data_account_id[sim_id], g_vdoply_cntx.cbm_app_id);
                    if (cbm_decode_data_account_id_ext(data_acct, &info) == CBM_OK)
                    {
                        srv_dtcnt_acct_delete_ind_evt_struct *event = (srv_dtcnt_acct_delete_ind_evt_struct *)param;
                        for (i = 0; i < info.acct_num; i++)
                        {
                            for (j = 0; j < event->del_num; j++)
                            {
                                if (event->acc_id[j] == info.account[i].account_id)
                                {   
                                    data_acct = CBM_DEFAULT_ACCT_ID;
                                    mmi_vdoply_set_data_account(data_acct);
                                }
                            }
                        }
                    }
                }
            }
        }
        break;
        
        case EVT_ID_SRV_DTCNT_ACCT_UPDATE_IND:          
        {
            for (index = 0; index < NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL; index++)
            {
                profile_p = &g_vdoply_cntx.network_profile[index];
    
                for(sim_id = 0; sim_id < MMI_MAX_SIM_NUM; sim_id++)
                {
                    data_acct = cbm_set_app_id(profile_p->data_account_id[sim_id], g_vdoply_cntx.cbm_app_id);
                    if (cbm_decode_data_account_id_ext(data_acct, &info) == CBM_OK)
                    {
                        srv_dtcnt_acct_update_ind_evt_struct *event = (srv_dtcnt_acct_update_ind_evt_struct *)param;
                        for (i = 0; i < info.acct_num; i++)
                        {
                            if (event->acc_id == info.account[i].account_id && event->cause ==  1)
                            {
                                srv_dtcnt_bearer_enum bearer = srv_dtcnt_get_bearer_type(event->acc_id, SRV_DTCNT_ACCOUNT_PRIMARY);
                                if (bearer != SRV_DTCNT_BEARER_GPRS && bearer != SRV_DTCNT_BEARER_WIFI)
                                {
                                    data_acct = CBM_DEFAULT_ACCT_ID;
                                    mmi_vdoply_set_data_account(data_acct);
                                }
                            }
                        }
                    }
                }
            }
        }
        break;
        default: 
            break;
    }
    
    return MMI_RET_OK;
}


/*****************************************************************************
* FUNCTION
* mmi_vdoply_get_data_account_id
* DESCRIPTION
*  set network profile data account
* PARAMETERS
*  void
* RETURNS           
*  void
*****************************************************************************/
static void mmi_vdoply_get_data_account_id(U32 *data_account_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_network_profile_struct prof_p;
    S16 error;
    U8 index;
	srv_dtcnt_sim_type_enum sim_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = g_vdoply_cntx.active_profile_idx;

    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        index = 0;
    }
    
    ReadRecordSlim(
              NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
              index + 1,  /* id start from 1 */ 
              (void*)&prof_p, 
              NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);
        
    sim_type = mmi_vdoply_network_get_data_account_sim_type();
    *data_account_id = cbm_encode_data_account_id(
						  prof_p.data_account_id[sim_type-SRV_DTCNT_SIM_TYPE_1],
						  (cbm_sim_id_enum)(sim_type - SRV_DTCNT_SIM_TYPE_1),
						  g_vdoply_cntx.cbm_app_id,
						  KAL_FALSE);

}


/*****************************************************************************
* FUNCTION
*  mmi_vdoply_set_data_account
* DESCRIPTION
*  set network profile data account
* PARAMETERS
*  void
* RETURNS           
*  void
*****************************************************************************/
static MMI_BOOL mmi_vdoply_set_data_account(U32 data_account)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_network_profile_struct* prof_p;
    S16 error;
    U8 index;
	srv_dtcnt_sim_type_enum sim_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = g_vdoply_cntx.active_profile_idx;

    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        index = 0;
    }
    
    prof_p = &(g_vdoply_cntx.network_profile[index]);

	sim_type = mmi_vdoply_network_get_data_account_sim_type();
    prof_p->data_account_id[sim_type - SRV_DTCNT_SIM_TYPE_1] = data_account;

    WriteRecordSlim(
         NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
         index + 1,  /* id start from 1 */ 
         (void*)prof_p, 
         NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);
    
    g_vdoply_cntx.is_load_setting = MMI_FALSE;
     
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_predefined_url_scr
 * DESCRIPTION
 *  entry predefined url screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_entry_predefined_url_screen_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
	{
	    case EVT_ID_SCRN_ACTIVE:
		{
			mmi_vdoply_entry_predefined_url_scr(((mmi_frm_scrn_active_evt_struct*)evt)->gui_buffer);
			break;
		}
			
		default:
			break;
	}
	return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_predefined_url_scr
 * DESCRIPTION
 *  entry predefined url screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_predefined_url_scr(void* gui_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    S32 index;
    S16 error;
    S32 url_len;
    S32 server_name_len;
    U16 item_icons[16]; 
    nvram_ef_video_predefined_url_struct predef_url_list[NVRAM_EF_VIDEO_PREDEFINED_URL_COUNT];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/     
    ReadRecordSlim(
        NVRAM_EF_VIDEO_PREDEFINED_URL_LID, 
        1,  /* id start from 1 */ 
        (void*)predef_url_list, 
        NVRAM_EF_VIDEO_PREDEFINED_URL_SIZE);

    index = 0;
    for (i = 0 ; i < NVRAM_EF_VIDEO_PREDEFINED_URL_COUNT; i++)
    {
        url_len = mmi_ucs2strlen((CHAR*)predef_url_list[i].url);
        server_name_len = mmi_ucs2strlen((CHAR*)predef_url_list[i].name);
        
        if (url_len == 0 || server_name_len == 0)
        {
            break;
        }

        /* copy char - 1 to keep null terminate */
        mmi_ucs2ncpy((CHAR*)subMenuDataPtrs[i], (CHAR*)predef_url_list[i].name, MAX_SUBMENU_CHARACTERS-1);
        index++;
            
    }
    
    if (index == 0)
    {
        /* 
         * this may happend when customer didnt config nvram for predefined url,
         * but turn on display predefined compile option
         */
        ASSERT(0);
    }

    for (i = 0; i < index; i++)
    {
        item_icons[i] = (U16)(IMG_GLOBAL_L1 + i);
    }

    RegisterHighlightHandler(mmi_vdoply_url_highlight_hdlr);

    ShowCategory53Screen(
        STR_ID_VDOPLY_PREDEFINED_URL,
        GetRootTitleIcon(MENU_ID_VDOPLY_APP),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        index,
        subMenuDataPtrs,
        item_icons,
        NULL,
        0,
        0,
        gui_buffer);
    if (mmi_frm_kbd_is_key_supported(KEY_CSK))
    {
    	SetCenterSoftkeyFunction(mmi_vdoply_predefined_url_lsk_hdlr, KEY_EVENT_UP);
		SetKeyUpHandler(mmi_vdoply_predefined_url_lsk_hdlr, KEY_ENTER);
    	ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    }
    SetLeftSoftkeyFunction(mmi_vdoply_predefined_url_lsk_hdlr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP); 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_predefined_url_lsk_hdlr
 * DESCRIPTION
 *  predefine url screen lsk handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_predefined_url_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_predefined_url_struct predef_url_list[NVRAM_EF_VIDEO_PREDEFINED_URL_COUNT];    
    S16 error;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if is in flight mode, do not connect to WAP browser */
    if(srv_mode_switch_is_network_service_available() == MMI_FALSE)
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP,  STR_ID_VDOPLY_NOTIFY_FLIGHT_MODE, MMI_EVENT_FAILURE); 
        return;
    }
    
    ReadRecordSlim(
        NVRAM_EF_VIDEO_PREDEFINED_URL_LID, 
        1,    /* id start from 1 */ 
        (void*)&predef_url_list, 
        NVRAM_EF_VIDEO_PREDEFINED_URL_SIZE);
    
#if defined(MMS_SUPPORT) && defined(BROWSER_SUPPORT)
    wap_start_browser(WAP_BROWSER_GOTO_URL, (PU8)predef_url_list[g_vdoply_cntx.highlight_idx].url);
#else
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE); 
#endif

}

#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_tap_callback
 * DESCRIPTION
 *  entry history url screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_tap_callback(mmi_tap_type_enum type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    if (type == ENUM_TAP_ON_NONHIGHLIGHTED_ITEM) 
    {
        /* only change highlight.  do nothing in tap callback function */
        return;
    }

    /* ENUM_TAP_ON_HIGHLIGHTED_ITEM */
    if (type == ENUM_TAP_ON_HIGHLIGHTED_ITEM)
    {
        mmi_vdoply_history_play_url();
    }
#endif
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_url_screen_proc
 * DESCRIPTION
 * history url screen proc function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_history_url_screen_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
	{
	    case EVT_ID_SCRN_ACTIVE:
			mmi_vdoply_entry_history_url_scr(((mmi_frm_scrn_active_evt_struct*)evt)->gui_buffer);
			break;
			
		default:
			break;
	}
	return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_history_url_scr
 * DESCRIPTION
 *  entry history url screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_history_url_scr(void* gui_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    S32 index;
    S16 error;
    S32 url_len;
    S32 name_len;
    U16 item_icons[16]; 
    nvram_ef_video_history_url_struct history_url;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* remove unused files in Z:\VideoStream */
    mmi_vdoply_history_sync_sdp_file();

    index = 0;
    for (i = 0 ; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL; i++)
    {
        ReadRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            i+1,    /* id start from 1 */ 
            (void*)&history_url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);

        url_len = mmi_ucs2strlen((CHAR*)history_url.url);
        name_len = mmi_ucs2strlen((CHAR*)history_url.name);
        if (url_len == 0)
        {
            /* empty url */
            break;
        }
        
        if (name_len == 0)
        {
            /* dont have name, show url link */
            
            /* have name, show name */
            
            if (url_len > MAX_SUBMENU_CHARACTERS-1)
            {
                /* researve 3 char for "..." and 1 char for null terminate */
                mmi_ucs2ncpy((CHAR*)subMenuDataPtrs[i], (CHAR*)history_url.url, MAX_SUBMENU_CHARACTERS-4);        
                mmi_ucs2cat((CHAR*)subMenuDataPtrs[i], (CHAR*)L"...");
            }
            else
            {
                /* 1 char for null terminate */                
                mmi_ucs2ncpy((CHAR*)subMenuDataPtrs[i], (CHAR*)history_url.url, MAX_SUBMENU_CHARACTERS-1);  
            }
        }
        else
        {
            /* have name, show name */

            if (name_len > MAX_SUBMENU_CHARACTERS-1)
            {
                /* researve 3 char for "..." and 1 char for null terminate */
                mmi_ucs2ncpy((CHAR*)subMenuDataPtrs[i], (CHAR*)history_url.name, MAX_SUBMENU_CHARACTERS-4);        
                mmi_ucs2cat((CHAR*)subMenuDataPtrs[i], (CHAR*)L"...");
            }
            else
            {
                /* 1 char for null terminate */
                mmi_ucs2ncpy((CHAR*)subMenuDataPtrs[i], (CHAR*)history_url.name, MAX_SUBMENU_CHARACTERS-1);  
            }
        }

        index ++;
    }

    if (index == 0)
    {
        /* if no history - popup */
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_EMPTY, MMI_EVENT_FAILURE);
        
        mmi_frm_scrn_close(GRP_ID_VDOPLY_APP, SCR_ID_VDOPLY_HISTORY_URL);
        return;
    }

    for (i = 0; i < index; i++)
    {
        item_icons[i] = (U16)(IMG_GLOBAL_L1 + i);
    }

    RegisterHighlightHandler(mmi_vdoply_url_highlight_hdlr);

    ShowCategory53Screen(
        STR_ID_VDOPLY_HISTORY_URL,
        GetRootTitleIcon(MENU_ID_VDOPLY_APP),
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        index,
        subMenuDataPtrs,
        item_icons,
        NULL,
        0,
        0,
        gui_buffer);
    
    if (mmi_frm_kbd_is_key_supported(KEY_CSK))
    {
    	SetCenterSoftkeyFunction(mmi_vdoply_history_play_url, KEY_EVENT_UP);
        SetKeyUpHandler(mmi_vdoply_history_play_url, KEY_ENTER);
    	ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    }

#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_tap_callback(mmi_vdoply_history_tap_callback);
#endif 

    SetLeftSoftkeyFunction(mmi_vdoply_entry_history_option_scr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP); 

}




/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_history_option_scr
 * DESCRIPTION
 *  entry history option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_history_option_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID cid;
    MMI_ID gid;
    MMI_ID parent_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    parent_id = mmi_frm_group_create_ex(
                    GRP_ID_VDOPLY_APP, 
                    GRP_ID_VDOPLY_STREAMING_URL, 
                    mmi_vdoply_streaming_url_proc,
                    NULL,
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);

    if (GRP_ID_INVALID == parent_id)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE,MMI_EVENT_FAILURE);                    
        return;
    }
	
    gid = mmi_frm_group_create_ex(
                    parent_id, 
                    GRP_ID_VDOPLY_HISTORY_OPTION, 
                    mmi_vdoply_streaming_url_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    if (GRP_ID_INVALID == gid)  
    {
        mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);                
        return;
    }
    cid = cui_menu_create(GRP_ID_VDOPLY_HISTORY_OPTION,
                        CUI_MENU_SRC_TYPE_RESOURCE,
                        CUI_MENU_TYPE_OPTION,
                        MENU_ID_VDOPLY_HISTORY_OPTION,
                        MMI_FALSE, NULL);
    if (cid > GRP_ID_INVALID)
    {
        cui_menu_set_default_title_image(cid, (UI_image_type)get_image(GetRootTitleIcon(MENU_ID_VDOPLY_APP)));
        cui_menu_run(cid);
    }
    else
    {   
        mmi_vdoply_display_popup( GRP_ID_VDOPLY_APP, STR_GLOBAL_NOT_AVAILABLE, MMI_EVENT_FAILURE);
    }    
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_play_url
 * DESCRIPTION
 *  play history url
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_play_url(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	nvram_ef_video_history_url_struct history_url;
    S16 error;
	mmi_id cid;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecordSlim(
        NVRAM_EF_VIDEO_HISTORY_URL_LID, 
        g_vdoply_cntx.highlight_idx+1,    /* id start from 1 */ 
        (void*)&history_url, 
        NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
        
    mmi_ucs2ncpy(g_vdoply_cntx.history_title_name, (CHAR*)history_url.name, MDI_VIDEO_INFO_TITLE_CHAR_COUNT - 1);

    VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY);

    /* "Z:\\@VideoStream\\" */
    if (mmi_ucs2ncmp((CHAR*)L"Z:", (CHAR*)history_url.url, 2) == 0)
    {
        /* sdp file */
        mmi_frm_group_close(GRP_ID_VDOPLY_HISTORY_OPTION);
		param.video_hdr.file_name = (CHAR*)history_url.url;
		param.is_short = MMI_FALSE;
        cid = cui_vdoply_create(GRP_ID_VDOPLY_APP, CUI_VDOPLY_TYPE_SDP, &param);  
        if(GRP_ID_INVALID != cid)
        {
            cui_vdoply_run(cid);
        }
    }
    else
    {
        /* rtsp */
        mmi_frm_group_close(GRP_ID_VDOPLY_HISTORY_OPTION);
		param.video_hdr.file_name = (CHAR*)history_url.url;
		param.is_short = MMI_FALSE;
        cid = cui_vdoply_create(GRP_ID_VDOPLY_APP, CUI_VDOPLY_TYPE_RTSP_FILE, &param);  
        if(GRP_ID_INVALID != cid)
        {
            cui_vdoply_run(cid);
        }
    }
 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_sync_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_vdoply_is_history_file_need_sync(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define VDOPLY_SDP_FNAME_BUFFER_LEN   (50)   /* Z:\@VideoStream\xx.sdp */
        
    CHAR buf_filepath[(VDOPLY_SDP_FNAME_BUFFER_LEN+1) * ENCODING_LENGTH]; 
    S32 filecount;
    S32 i;
    S32 index;
    S16 error;
    S32 url_len;
    nvram_ef_video_history_url_struct history_url;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    mmi_ucs2cpy((CHAR*)buf_filepath, (CHAR*)L"Z:\\@VideoStream\\*.*");

    filecount = FS_Count((U16*)buf_filepath, FS_FILE_TYPE, NULL, 0);
    /* get sdp file cound in history */
    index = 0;
    for (i = 0 ; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL; i++)
    {
        ReadRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            i+1,    /* id start from 1 */ 
            (void*)&history_url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);

        url_len = mmi_ucs2strlen((CHAR*)history_url.url);
        if (url_len == 0)
        {
            /* empty url */
            break;
        }
        if (mmi_ucs2ncmp((CHAR*)L"Z:", (CHAR*)history_url.url, 2) == 0)
        {
            index ++;
        }
    }
    
    if (index != filecount)
    {
    	return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;		
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_remove_confirm_cb
 * DESCRIPTION
 *  remove history url confirm screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_history_remove_confirm_cb(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *alert_evt = (mmi_alert_result_evt_struct*)evt;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
            // handle softkey event here
            break;
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_history_remove_url();
            break;
        case MMI_ALERT_CNFM_NO:
            // handle softkey event here
            mmi_frm_scrn_close_active_id();
            break;
        }
    }
    return MMI_RET_OK;
}


static mmi_ret mmi_vdoply_history_remove_all_confirm_cb(mmi_event_struct* evt)
{
    mmi_alert_result_evt_struct *alert_evt = (mmi_alert_result_evt_struct*)evt;
    if (alert_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alert_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
            // handle softkey event here
            break;
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_history_remove_all_url();
            break;
        case MMI_ALERT_CNFM_NO:
            // handle softkey event here
            mmi_frm_scrn_close_active_id();
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_remove_url
 * DESCRIPTION
 *  remove history url
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_remove_url(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_history_url_struct url;
    S16 error;
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.highlight_idx == NVRAM_EF_VIDEO_HISTORY_URL_TOTAL-1)
    {
        /* last element, just remove it by reset all valeu to zero */
        memset((void*)&url, 0, sizeof(nvram_ef_video_history_url_struct));

        WriteRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            g_vdoply_cntx.highlight_idx+1,    /* id start from 1 */ 
            (void*)&url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
    }
    else
    {   
        /* not last element, move next upward and clean next one */
        for (i = g_vdoply_cntx.highlight_idx; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL - 1; i++)
        {
            /* read next */
            ReadRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                (i+1) + 1,    /* id start from 1 */ 
                (void*)&url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);

            /* write this */
            WriteRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                (i) + 1,    /* id start from 1 */ 
                (void*)&url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
        }

        /* clean last */
        memset((void*)&url, 0, sizeof(nvram_ef_video_history_url_struct));

        WriteRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            (NVRAM_EF_VIDEO_HISTORY_URL_TOTAL - 1) + 1,    /* id start from 1 */ 
            (void*)&url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);        
    }  
       
    mmi_frm_group_close(GRP_ID_VDOPLY_HISTORY_OPTION);
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_ID_VDOPLY_NOTIFY_HISTORY_REMOVED, MMI_EVENT_SUCCESS);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_remove_all_url
 * DESCRIPTION
 *  remove history url
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_remove_all_url(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_video_history_url_struct url;
    S16 error;
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset((void*)&url, 0, sizeof(nvram_ef_video_history_url_struct));
    for (i = 0; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL; i++)
    {
                 
        /* write this */
        WriteRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            (i) + 1,    /* id start from 1 */ 
            (void*)&url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE); 
    
    }       
    mmi_frm_group_close(GRP_ID_VDOPLY_HISTORY_OPTION);
    mmi_vdoply_display_popup(GRP_ID_VDOPLY_APP, STR_GLOBAL_REMOVED, MMI_EVENT_SUCCESS);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_insert_url
 * DESCRIPTION
 *  insert history url
 * PARAMETERS
 *  url_p       [IN]         url buffer in unicode
 *  name_p      [IN]        name buffer in unicode 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_insert_url(CHAR* url_p, CHAR* name_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define VDOPLY_SDP_READ_BUFFER   (30)
    
    S32 history_count;
    S32 i;
    S32 exist_ind;
    S16 error;
    S32 url_len;
    nvram_ef_video_history_url_struct history_url;
    nvram_ef_video_history_url_struct move_url;
    U8 history_sdp_file_buf[VDOPLY_SDP_READ_BUFFER];
    U8 sdp_file_buf[VDOPLY_SDP_READ_BUFFER];
    FS_HANDLE history_sdp_h;
    FS_HANDLE sdp_h;
    FS_HANDLE fs_h;    
    U32 history_sdp_read;    
    U32 sdp_read;
    U32 sdp_write;
    MMI_BOOL is_same_file;
    CHAR ansii_str[50];
    CHAR usc2_str[50];    
                   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(url_p != NULL);
    MMI_ASSERT(name_p != NULL);    
     
    /* 
     * search how many history already in history, 
     * and search if already have this entry 
     */

    history_count = 0;
    exist_ind = -1;
    
    for (i = 0 ; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL; i++)
    {
        ReadRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            i+1,    /* id start from 1 */ 
            (void*)&history_url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);


        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
        {
            url_len = mmi_ucs2strlen((CHAR*)history_url.url);

            if (url_len == 0)
            {
                /* empty entry */
                break;
            }
            
            /* compare two url */
            if (mmi_ucs2cmp((CHAR*)url_p, (CHAR*)history_url.url) == 0)
            {
                if (i == 0)
                {
                    /* already is first one */
                    return;
                }
                
                /* hit. already in history */
                exist_ind = i;
                break;
            }

        }
        else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
        {
            /* "Z:\\@VideoStream\\" */
            if (mmi_ucs2ncmp((CHAR*)L"Z:", (CHAR*)history_url.url, 2) == 0)
            {
                /* this entry's url is Z:, it is a cached SDP file */
                /* compare two sdp file */
                history_sdp_h = FS_Open((U16*)history_url.url, FS_READ_ONLY);
                sdp_h = FS_Open((U16*)url_p, FS_READ_ONLY);                

                is_same_file = MMI_TRUE;
                while (1)
                {
                    FS_Read(history_sdp_h, history_sdp_file_buf, VDOPLY_SDP_READ_BUFFER, &history_sdp_read);
                    FS_Read(sdp_h, sdp_file_buf, VDOPLY_SDP_READ_BUFFER, &sdp_read);

                    if (sdp_read != history_sdp_read)
                    {
                        /* read size not match, different file */      
                        is_same_file = MMI_FALSE;
                        break;
                    }

                    if (memcmp((void*)sdp_file_buf, (void*)history_sdp_file_buf, sdp_read) != 0)
                    {
                        /* content not match, different file */
                        is_same_file = MMI_FALSE;
                        break;
                    }

                    if (sdp_read < VDOPLY_SDP_READ_BUFFER)
                    {
                        break;
                    }
                }

                if (sdp_h  > 0)
                {
                    FS_Close(sdp_h);
                }

                if (history_sdp_h  > 0)
                {
                    FS_Close(history_sdp_h);
                }

                /* same sdp file */
                if (is_same_file)
                {
                    if (i == 0)
                    {
                        /* already is first one */
                        return;
                    }
                    
                    /* hit. already in history */
                    exist_ind = i;
                    break;
                }
                
            }

        }
        else
        {
            MMI_ASSERT(0);
        }


        history_count++;
    }

    if (exist_ind != -1)
    {
        /* already in history, move it to first and move others down */
        
        for (i = exist_ind - 1; i >= 0 ; i--)
        {
            /* read this */
            ReadRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                i+1,    /* id start from 1 */ 
                (void*)&move_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);

            /* write to next */
            WriteRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                i+1+1,    /* id start from 1 */ /* +1 for next */
                (void*)&move_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
        }
        
        /* insert this to 1st */
        WriteRecordSlim(
            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
            1,    /* id start from 1 */
            (void*)&history_url, 
            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);        

        return;
    }
    else
    {
        /* newly added */
        
        if (history_count == NVRAM_EF_VIDEO_HISTORY_URL_TOTAL)
        {
            /* avoid overflow */
            history_count--;
        }

        for (i = history_count - 1; i >= 0 ; i--)
        {
            /* read this */
            ReadRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                i+1,    /* id start from 1 */ 
                (void*)&move_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);

            /* write to next */
            WriteRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                i+1+1,    /* id start from 1 */ /* +1 for next */
                (void*)&move_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
        }

        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM)
        {
            /* insert this to 1st */
            mmi_ucs2ncpy((CHAR*)history_url.url , url_p, VIDEO_MAX_HISTORY_URL_LEN);
            mmi_ucs2ncpy((CHAR*)history_url.name , name_p, VIDEO_MAX_HISTORY_NAME_LEN);     
        
            WriteRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                1,    /* id start from 1 */
                (void*)&history_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);  
        }
        /* copy file to Z: */
        else if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)
        {
            i = 0;
            /* use a loop to find a empty file name */
            while(1)
            {
                sprintf((CHAR*)ansii_str, "Z:\\@VideoStream\\%d.sdp", i);
                /* we will store the sdp as Z:\1.sdp ... etc */
                mmi_asc_to_ucs2(usc2_str, ansii_str);
                fs_h = FS_Open((U16*)usc2_str, FS_READ_ONLY);  

                if (fs_h < 0)
                {
                    /* file not exist */
                    break;
                }
                else
                {
                    FS_Close(fs_h);
                }
                i++;
            }
            
            sdp_h = FS_Open((U16*)url_p, FS_READ_ONLY);               
            history_sdp_h = FS_Open((U16*)usc2_str, FS_CREATE);

            /* copy from original sdp file to history */
            while(1)
            {
                FS_Read(sdp_h, sdp_file_buf, VDOPLY_SDP_READ_BUFFER, &sdp_read);
                FS_Write(history_sdp_h, sdp_file_buf, VDOPLY_SDP_READ_BUFFER, &sdp_write);

                if (sdp_read < VDOPLY_SDP_READ_BUFFER)
                {
                    /* read end */
                    break;
                }
            }
            
            FS_Close(sdp_h);
            FS_Close(history_sdp_h);

            /* insert this to 1st */
            mmi_ucs2ncpy((CHAR*)history_url.url , usc2_str, VIDEO_MAX_HISTORY_URL_LEN);
            mmi_ucs2ncpy((CHAR*)history_url.name , name_p, VIDEO_MAX_HISTORY_NAME_LEN);     
        
            WriteRecordSlim(
                NVRAM_EF_VIDEO_HISTORY_URL_LID, 
                1,    /* id start from 1 */
                (void*)&history_url, 
                NVRAM_EF_VIDEO_HISTORY_URL_SIZE);  
        }
        else
        {
            MMI_ASSERT(0);
        }

    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_history_sync_sdp_file
 * DESCRIPTION
 *  sync sdp file in z:\@VideoStream folder, remove unused files
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_history_sync_sdp_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define VDOPLY_HISTORY_BUF_LEN   (50)   /* Z:\@VideoStream\xx.sdp */
        
    FS_DOSDirEntry file_info;
    CHAR buf_filename[(VDOPLY_HISTORY_BUF_LEN+1) * ENCODING_LENGTH];
    CHAR buf_filepath[(VDOPLY_HISTORY_BUF_LEN+1) * ENCODING_LENGTH]; 
    FS_HANDLE file_handle;
    nvram_ef_video_history_url_struct history;
    S16 error;
    CHAR* filename_p;
    MMI_BOOL is_in_history;
    S32 fs_ret;
    S32 i;
    CHAR filter[(VDOPLY_HISTORY_BUF_LEN+1) * ENCODING_LENGTH];
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   

    mmi_ucs2cpy((CHAR*)filter, (CHAR*)L"Z:\\@VideoStream\\*.*");

    file_handle = FS_FindFirst(
                    (U16*)filter, 
                    0, 
                    0, 
                    &file_info, 
                    (U16*)buf_filename, 
                    sizeof(buf_filename));
    

    if (file_handle  > 0)
    {
        /* extrac files in Z:\@VideoStream one by one, and check if it is in hitroy */
        do
        {
            is_in_history = MMI_FALSE;
            
            for (i = 0; i < NVRAM_EF_VIDEO_HISTORY_URL_TOTAL; i++)
            {
                 ReadRecordSlim(
		            NVRAM_EF_VIDEO_HISTORY_URL_LID, 
		            i+1,    /* id start from 1 */ 
		            (void*)&history, 
		            NVRAM_EF_VIDEO_HISTORY_URL_SIZE);
                /* check if it a sdp file, not rtsp url */
                if (mmi_ucs2ncmp((CHAR*)L"Z:", (CHAR*)history.url, 2) == 0)
                {
                    filename_p = (CHAR*)srv_fmgr_path_get_filename_ptr((WCHAR *)history.url);
                    if (mmi_ucs2cmp(buf_filename, filename_p) == 0)
                    {
                        /* this file is in history */
                        is_in_history = MMI_TRUE;
                        break;
                    }
                }
            } 

            if (!is_in_history)
            {
                /* delete file */
                mmi_ucs2cpy(buf_filepath, (CHAR*)L"Z:\\@VideoStream\\");
                mmi_ucs2cat(buf_filepath, buf_filename);
                FS_Delete((U16*)buf_filepath);
            }

            fs_ret = FS_FindNext(
                        file_handle, 
                        &file_info,
                        (PU16)buf_filename,
                        sizeof(buf_filename));
            
        }while (fs_ret == FS_NO_ERROR);

        FS_FindClose(file_handle);
    }
   
}
 

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_predefined_url_highlight_hdlr
 * DESCRIPTION
 *  entry predefined url screen
 * PARAMETERS
 
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_url_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.highlight_idx = index;
}
#endif /* defined(__MMI_VIDEO_STREAM__) */




/*****************************************************************************
 *
 * Streaming
 *
 *****************************************************************************/
#ifdef __MMI_VIDEO_STREAM__ 
 /*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_rtsp_link
 * DESCRIPTION
 *  lauch rtsp from a link (Unicode)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_rtsp_link(CHAR* rtsp_url)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID cid;
	MMI_ID gid;
    cui_vdoply_param_struct param;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_RTSP_LINK);
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.file_name = rtsp_url;
    cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_RTSP_FILE, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	    return;
	}
	cui_vdoply_run(cid);
}


 /*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_sdp_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_sdp_file(CHAR* sdp_filename, MMI_BOOL is_short)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_SDP_FILE);
	mmi_vdoply_entry_player_screen_from_sdp_file_ext(sdp_filename, is_short, NULL);

}

/*****************************************************************************
 * FUNCTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_sdp_file_ext(CHAR* sdp_filename, MMI_BOOL is_short, CHAR* title_str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	MMI_ID cid;
	MMI_ID gid;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_SDP_FILE_EXT);
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.file_name = sdp_filename;
	param.video_title.title_str = title_str;
	param.is_short = is_short;
    cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_SDP, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	    return;
	}
	cui_vdoply_run(cid);


}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_ram_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_entry_player_screen_from_ram_file(CHAR* ram_filename, MMI_BOOL is_short)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	MMI_ID cid;
	MMI_ID gid;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_RAM_FILE);
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.file_name = ram_filename;
	param.is_short = is_short;
        cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_RAM_FILE, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	    return;
	}
	cui_vdoply_run(cid);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_request_right_callback
 * DESCRIPTION
 *  request right callback
 * PARAMETERS
 *  result       [IN]       result
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __DRM_SUPPORT__
static void mmi_vdoply_stream_request_right_callback(MMI_BOOL result)
{
    if (result == MMI_FALSE)
    {
        /* press No in confirm screen */
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_CONNECTED)
        {
            mdi_video_stream_disconnect();
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
        }

        /* remove player from history, will back to previous screen */
        //DeleteNHistory(1);
        mmi_frm_scrn_close_active_id();
    }
    else
    {
        /* clear play time, so the bar will reset to start when come back */
        g_vdoply_cntx.cur_status.play_time = 0;
        g_vdoply_cntx.cur_status.start_play_time = 0;
    }
}
#endif /* __DRM_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_player_connect_done_hdlr
 * DESCRIPTION
 *  function to be called when file is opened.
 * PARAMETERS
 *  result          [IN]        >=0, means successfully opened, if result < 0 measn some error happened)
 *  vdo_clip        [IN]        Video info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stream_connect_result_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_len;
    S32 i;
    MMI_BOOL is_valid;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_STREAM_CONNECT_RESULT_HDLR,result);
    if (result >= 0)
    {
        /* 
         * connect result will only have     
         * (1) track type
         * (2) total time (media len)
         * (3) seekable or not
         * (4) aud_channel_no
         * (5) aud sample rate
         * (6) video name
         */
        g_vdoply_cntx.video_info.total_time_duration = vdo_clip->total_time_duration;
        g_vdoply_cntx.video_info.is_seekable = vdo_clip->is_seekable;
        g_vdoply_cntx.video_info.track = vdo_clip->track;
        g_vdoply_cntx.video_info.aud_channel_no = vdo_clip->aud_channel_no;        
        g_vdoply_cntx.video_info.aud_sample_rate= vdo_clip->aud_sample_rate;

        /* set max play time */
        g_vdoply_cntx.cur_status.max_play_time = g_vdoply_cntx.video_info.total_time_duration;                     

        str_len = strlen((CHAR*)vdo_clip->title_desc);

        /* stream has title, change title name to this */
        if (str_len != 0)
        {
            /* check if title is all space */
            is_valid = MMI_FALSE;
            for (i = 0; i < str_len; i++)
            {
                if (vdo_clip->title_desc[i] != ' ')
                {
                    is_valid = MMI_TRUE;
                    break;                    
                }
            }

            if (is_valid)
            {
                 mmi_asc_n_to_ucs2(
                    (CHAR*)g_vdoply_cntx.video_info.title_desc, 
                    (CHAR*)&vdo_clip->title_desc, 
                    MDI_VIDEO_INFO_TITLE_CHAR_COUNT - 1);
            }
        }
       
        /* store url to history */
        mmi_vdoply_history_insert_url(g_vdoply_cntx.source_path, g_vdoply_cntx.video_info.title_desc);
        if(mmi_vdoply_is_history_file_need_sync())
        {
            mmi_vdoply_history_sync_sdp_file();
        }
        VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_SOURCE_OPENED);

        if (g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RTSP || 
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_RAM ||
            g_vdoply_cntx.play_source == VDOPLY_PLAY_FROM_STREAMING_SDP)  
        {
             g_vdoply_cntx.is_progress_seekable = g_vdoply_cntx.video_info.is_seekable;
        }
    #ifdef __DRM_SUPPORT__
        g_vdoply_cntx.drm_handle = vdo_clip->drm_handle;
    #endif
	
    }

   
    /* check if already exit player screen (might be in option screen) */
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        /* background */
        if (result >= 0 || result == MDI_RES_VDOPLY_STREAM_DRM_NEED_RIGHT)
        {
            /* don't disconnect if result >= 0 or if DRM right required */
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;
        }
        else
        {
            g_vdoply_cntx.state = VDOPLY_STATE_STREAM_DISCONNECT;
        }
        return;            
    }    

    if (result == MDI_RES_VDOPLY_ERR_NETWORK_DISCONNECT)
    {
        mmi_vdoply_bt_close_codec();
        
        /* network tear down */
        mdi_video_stream_disconnect();

        if (g_vdoply_cntx.ui_type== VDOPLY_UI_TYPE_NORMAL)
        {
            if (mmi_vdoply_is_background_call())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
            }
        }
        else if (g_vdoply_cntx.ui_type== VDOPLY_UI_TYPE_FULLSCR)
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
        }
        else
        {
            MMI_ASSERT(0);
        }        
             
        cui_vdoply_evt_exit(MMI_TRUE, STR_ID_VDOPLY_NOTIFY_CONNECT_FAILED);
		return;
    }
    else if (result == MDI_RES_VDOPLY_ERR_NETWORK_FORBIDDEN)
    {
        /* 
         * network forbidden may due to server reject pause request when play 
         * live content, shall change to disconnect state 
         */
        /*
         * for the case that user press snapshot button, it will re-enter buffer state
         * stop video playback for this kind of link
         */
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BT_CONNECTING)
        {
            mmi_vdoply_disconnect_bt();
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING)
        {
            /* MED already stopped, stop buffer check timer */
            gui_cancel_timer(mmi_vdoply_stream_buffering_cyclic);
        #if defined(__VDOPLY_FEATURE_FULLSCREEN__)    
            gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);  
        #endif
            mmi_vdoply_bt_close_codec();
            mmi_vdoply_disconnect_bt();
        }
        
        mdi_video_stream_disconnect();

        if (g_vdoply_cntx.ui_type== VDOPLY_UI_TYPE_NORMAL)
        {
            if (mmi_vdoply_is_background_call())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
            }

        }
        else if (g_vdoply_cntx.ui_type== VDOPLY_UI_TYPE_FULLSCR)
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
        }
        else
        {
            MMI_ASSERT(0);
        }
        return;
    }
    else if (result == MDI_RES_VDOPLY_STREAM_DRM_NEED_RIGHT)
    {
    #ifdef __DRM_SUPPORT__
        mmi_rmgr_status_enum rmgr_ret;

        MMI_ASSERT(vdo_clip->is_drm_streaming);
        
        mmi_vdoply_bt_close_codec();

        g_vdoply_cntx.drm_handle = vdo_clip->drm_handle;
        rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_handle(g_vdoply_cntx.drm_handle, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_stream_request_right_callback));

        if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
        {
	        g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;                   	
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;            
            mmi_rmgr_request_rights_confirm();
            return;
        }
        else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
        {
            /* no permission - shall disconnect and show popup */
            mdi_video_stream_disconnect();
            
            if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
            }
            else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
            }
            else
            {
                MMI_ASSERT(0);
            }
                       
            cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
            return;
        }
        else
        {
            MMI_ASSERT(0);
        }      
        return;
    #endif /* __DRM_SUPPORT__ */
    }


    if (result >= 0)
    {
        switch(g_vdoply_cntx.state)
        {
            case VDOPLY_STATE_STREAM_CONNECTING:
                mmi_vdoply_stop_animation();   
                
                /* update skin from SDP/RTSP's description */
                mmi_vdoply_draw_bg();
                mmi_vdoply_draw_title();
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();

                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
                }
                break;

            case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
                mmi_vdoply_stop_animation();

                /* update skin from SDP/RTSP's description */
                mmi_vdoply_draw_bg();
                mmi_vdoply_draw_title();
                mmi_vdoply_draw_softkey();
                mmi_vdoply_draw_panel();
                
                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BT_CONNECTING);
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BUFFERING);
                }
                break;
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__
            case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
                mmi_vdoply_stop_animation();
                if (mmi_vdoply_is_output_to_bt())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
                }   
                break;
		
            case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:

                if (GetExitScrnID() == SCR_ID_VDOPLY_APP)
                {
                    /* vdoplayer is at foreground */
                   mmi_vdoply_stop_animation();

                    if (mmi_vdoply_is_output_to_bt())
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BT_CONNECTING);
                    }
                    else
                    {
                        mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
                    }       
                }
                else
                {
                    /* vdoplayer is at background */                    
                    g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;
                }
                break;
                
         #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
            default:
                MMI_ASSERT(0);
                break;                
        }
    }
    else
    {
        switch(g_vdoply_cntx.state)
        {        
            case VDOPLY_STATE_STREAM_CONNECTING:
            case VDOPLY_STATE_STREAM_INTERRUPTED_CONNECTING:
            case VDOPLY_STATE_STREAM_CONNECTED:
            case VDOPLY_STATE_STREAM_BG_CALL_CONNECTED:
            case VDOPLY_STATE_STREAM_BUFFERING:
                mmi_vdoply_stop_animation();               
                if (mmi_vdoply_is_background_call())
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_BG_CALL_DISCONNECT);
                }
                else
                {
                    mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
                }                
                break;
        #ifdef __VDOPLY_FEATURE_FULLSCREEN__                  
            case VDOPLY_STATE_STREAM_FULLSCR_CONNECTING:
            case VDOPLY_STATE_STREAM_FULLSCR_INTERRUPTED_CONNECTING:
            case VDOPLY_STATE_STREAM_FULLSCR_BUFFERING:
                mmi_vdoply_stop_animation();
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);    
                break;
        #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
             default:
                MMI_ASSERT(0);
                break;
        }
        if (result == MDI_RES_VDOPLY_ERR_UNSUPPORTED_FORMAT)
        {
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_UNSUPPORTED_FORMAT_POPUP);
            cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_UNSUPPORTED_FORMAT);
        }
        else
        {
            /* if connect failed - popup and go to previous window */
            cui_vdoply_evt_exit(MMI_TRUE, STR_ID_VDOPLY_NOTIFY_CONNECT_FAILED);
        }
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_buffering_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stream_buffering_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 percentage;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_BUFFER_CYCLIC);
    if(g_vdoply_cntx.state != VDOPLY_STATE_STREAM_BUFFERING)
    {
        return;
    }
    
    mdi_video_stream_get_buf_percentage(&percentage);
    
    mmi_vdoply_draw_loading(percentage, MMI_FALSE, MMI_FALSE); 
    mmi_vdoply_blt_screen();

    if (percentage < 100)
    {
        gui_start_timer(100, mmi_vdoply_stream_buffering_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_fullscr_buffering_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__VDOPLY_FEATURE_FULLSCREEN__)
static void mmi_vdoply_stream_fullscr_buffering_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 percentage;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING);
    
    mdi_video_stream_get_buf_percentage(&percentage);
    mmi_vdoply_draw_loading(percentage, MMI_FALSE, MMI_TRUE);
    mmi_vdoply_blt_screen();

    if (percentage < 100)
    {
        gui_start_timer(100, mmi_vdoply_stream_fullscr_buffering_cyclic);
    }
    
}
#endif /* defined(__VDOPLY_FEATURE_FULLSCREEN__) */



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_stop_buffering
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stream_stop_buffering(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.is_seeking == MMI_TRUE)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_RETURN_FUCNTION, __LINE__);                  
        return;
    }
    
    gui_cancel_timer(mmi_vdoply_stream_buffering_cyclic);
#if defined(__VDOPLY_FEATURE_FULLSCREEN__)    
    gui_cancel_timer(mmi_vdoply_stream_fullscr_buffering_cyclic);  
#endif 
    mmi_vdoply_bt_close_codec();
    mmi_vdoply_disconnect_bt();    

    mdi_video_stream_stop_buffering();
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_start_buffering
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stream_start_buffering(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (!g_vdoply_cntx.video_info.is_seekable)
    {
        g_vdoply_cntx.cur_status.start_play_time = 0;
        g_vdoply_cntx.cur_status.play_time = 0;        
    }
    
    if (VDOPLY_CHECK_FLAG(MMI_VDOPLY_HAS_STREAM_OPENED) == MMI_TRUE)
    {
        ret = mdi_video_stream_start_buffering(
                     g_vdoply_cntx.cur_status.play_time,            
                     mmi_vdoply_stream_buffering_done_hdlr,
                     NULL);
    }
    else
    {
        ret = mdi_video_stream_start_buffering(
                     g_vdoply_cntx.cur_status.play_time,            
                     mmi_vdoply_player_open_done_hdlr,
                     NULL);
    }    

    if (ret == MDI_RES_VDOPLY_ERR_DRM_PROHIBITED)
    {
    #ifdef __DRM_SUPPORT__
        mmi_rmgr_status_enum rmgr_ret;

        mmi_vdoply_bt_close_codec();

        rmgr_ret = (mmi_rmgr_status_enum)(mmi_rmgr_check_rights_by_handle(g_vdoply_cntx.drm_handle, DRM_PERMISSION_PLAY, GetRootTitleIcon(MENU_ID_VDOPLY_APP), mmi_vdoply_stream_request_right_callback));

        if (rmgr_ret == MMI_RMGR_STATUS_REQUEST_RIGHTS)
        {
	        g_vdoply_cntx.state = VDOPLY_STATE_STREAM_CONNECTED;                   	
            g_vdoply_cntx.drm_state = VDOPLY_DRM_NEED_CONSUME;            
            mmi_rmgr_request_rights_confirm();
            return;
        }
        else if (rmgr_ret == MMI_RMGR_STATUS_NO_PERMISSION)
        {
            /* no permission - shall disconnect and show popup */
            mdi_video_stream_disconnect();
            
            if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
            }
            else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
            }
            else
            {
                MMI_ASSERT(0);
            }
            cui_vdoply_evt_exit(MMI_TRUE, STR_GLOBAL_DRM_PROHIBITED);
			return;
        }
        else
        {
            MMI_ASSERT(0);
        }      
        return;        
    #else /* __DRM_SUPPORT__ */
        MMI_ASSERT(0);
        
    #endif /* __DRM_SUPPORT__ */
    
    }
   
    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
    {
        return;
    }    

    if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING)
    {
        mmi_vdoply_draw_loading(0, MMI_TRUE, MMI_FALSE);
        mmi_vdoply_stream_buffering_cyclic();  
    }
    else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        mmi_vdoply_draw_loading(0, MMI_TRUE, MMI_TRUE);
        mmi_vdoply_stream_fullscr_buffering_cyclic();   
    #endif
    }
    else
    {
        MMI_ASSERT(0);
    }
 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_buffering_done_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_stream_buffering_done_hdlr(MDI_RESULT result, mdi_video_info_struct *vdo_clip, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if already exit player screen */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_VDOPLY_BUFFER_DONE, result);
    if (GetExitScrnID() != SCR_ID_VDOPLY_PLAYER)
    {
        return;
    }

    /* if open sucessfully */
    if (result >= 0)
    {
        mdi_video_stream_set_brightness(g_vdoply_cntx.brightness);
        mdi_video_stream_set_contrast(g_vdoply_cntx.contrast);
        
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_PLAY);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING)
        {
             mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_PLAY);
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }
    }
    else
    {

        if (mmi_vdoply_is_output_to_bt())
        {
            /* shall close BT codec if it is opened */ 
            mmi_vdoply_bt_close_codec();
        }
            
        if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_BUFFERING)
        {
            mdi_video_stream_disconnect();            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_DISCONNECT);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_STREAM_FULLSCR_BUFFERING)
        {
            mdi_video_stream_disconnect();            
            mmi_vdoply_enter_state(VDOPLY_STATE_STREAM_FULLSCR_DISCONNECT);
        }
        else
        {
            /* shall not enter here */
            MMI_ASSERT(0);
        }
                
        if (mmi_vdoply_check_and_display_error_popup(result) == MMI_TRUE) 
        {
            VDOPLY_CLEAR_FLAG(MMI_VDOPLY_HAS_FROM_HISTORY);

            g_vdoply_cntx.state = VDOPLY_STATE_EXIT;
            return;
        }            
    }

}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_stream_receive_da_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_stream_receive_da_file(
        S32 session_id, 
        S32 mime_type, 
        S32 mime_subtype, 
        S32 action, 
        PU16 file_path, 
        CHAR* url, 
        CHAR* mime_type_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_STREAM_RECEIVE_DA_FILE);
    MMI_ASSERT(mime_type == MIME_TYPE_APPLICATION);
    MMI_ASSERT(mime_subtype == MIME_SUBTYPE_SDP);    

    mmi_vdoply_entry_player_screen_from_sdp_file((CHAR*)file_path, MMI_FALSE);
    VDOPLY_SET_FLAG(MMI_VDOPLY_HAS_DA_SDP_FILE);
    
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_rtsp_url_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_rtsp_url_hdlr(void *msg_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_vdoply_rtsp_url_data_struct *url_data_ptr;
    S32 str_len;
    CHAR str_buf[VDOPLY_BUF_MAX_CHAR_NUMBER * ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
    {
        /* receive this message after call launched, should igore */
        return;
    }
    
    url_data_ptr = (mmi_vdoply_rtsp_url_data_struct*)msg_ptr;

    str_len = strlen(url_data_ptr->rtsp_url);

    if (str_len > VDOPLY_MAX_URL_CHAR_COUNT)
    {
        /* TODO: change string to URL too long */
        mmi_vdoply_display_popup(GRP_ID_ROOT, STR_GLOBAL_INVALID_URL, MMI_EVENT_FAILURE);           
        return;
    }
    
    /* path is ASCII, we need covent it to Unicode */
    mmi_asc_to_ucs2(str_buf, url_data_ptr->rtsp_url);
    
    mmi_vdoply_entry_player_screen_from_rtsp_link(str_buf);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_send_rtsp_url_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_send_rtsp_url_req(CHAR* rtsp_url)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //MYQUEUE message;
    mmi_vdoply_rtsp_url_data_struct *url_data_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    url_data_ptr = OslAllocDataPtr(mmi_vdoply_rtsp_url_data_struct);
    /* url is ascii string */
    strncpy(url_data_ptr->rtsp_url, rtsp_url, SRV_FMGR_PATH_BUFFER_SIZE);

	mmi_frm_send_ilm(MOD_MMI, MSG_ID_MMI_VDOPLY_RTSP_URL_REQ, (oslParaType*)url_data_ptr, NULL);
    
}
#endif /* __MMI_VIDEO_STREAM__ */


/*****************************************************************************
 *
 * Progressive Download
 *
 *****************************************************************************/
#ifdef __MMI_VIDEO_PDL__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_browser
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef  __MMI_SUPPORT_ASMV2__
static void mmi_vdoply_entry_player_screen_from_browser(CHAR* filename, MMI_BOOL is_short,MMI_BOOL is_complete)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 	//kal_prompt_trace(MOD_MMI_MEDIA_APP,"[VDOPLY]mmi_vdoply_entry_player_screen_from_browser is_complete %d",is_complete);
    g_vdoply_cntx.is_entry_player_from_browser = MMI_TRUE; 
    g_vdoply_cntx.is_srv_da_state_complete = is_complete;
	mmi_vdoply_entry_app(); 
	
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_player_screen_from_pdl_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

void mmi_vdoply_entry_player_screen_from_pdl_file(CHAR* filename, MMI_BOOL is_short)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdoply_param_struct param;
	MMI_ID cid;
	MMI_ID gid;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_VDOPLY_ENTRY_PLAY_SCREEN_FROM_PDL_FILE);
   	#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
	if(g_vdoply_cntx.is_entry_player_from_browser)
	{
		if(!mmi_frm_group_is_present(APP_VDOPLY))
		{
			//kal_prompt_trace(MOD_MMI_MEDIA_APP,"[VDOPLY]don't launch app before %d",__LINE__);
			mmi_frm_app_launch(APP_VDOPLY, 0, 0, mmi_vdoply_app_launch_proc, NULL, 0);
		}
		gid = mmi_frm_group_create_ex(
                    	APP_VDOPLY, 
                    	GRP_ID_VDOPLY_PLAYER, 
                    	mmi_vdoply_player_proc,
                    	NULL, 
                    	MMI_FRM_NODE_SMART_CLOSE_FLAG);
	}
	else
	{
		gid = mmi_frm_group_create_ex(
                    	GRP_ID_ROOT, 
                    	GRP_ID_VDOPLY_PLAYER, 
                    	mmi_vdoply_player_proc,
                    	NULL, 
                    	MMI_FRM_NODE_SMART_CLOSE_FLAG);
	}
	#else
	gid = mmi_frm_group_create_ex(
                    GRP_ID_ROOT, 
                    GRP_ID_VDOPLY_PLAYER, 
                    mmi_vdoply_player_proc,
                    NULL, 
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
     #endif
	if (GRP_ID_INVALID == gid)  
        {
            return;
        }
	
	param.video_hdr.file_name = filename;
	param.is_short = is_short;
    cid = cui_vdoply_create(gid, CUI_VDOPLY_TYPE_PDL_FILE, &param);
	if(GRP_ID_INVALID == cid)
	{
	    cui_vdoply_close(GRP_ID_VDOPLY_PLAYER);
	    return;
	}
	cui_vdoply_run(cid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_terminate_confirm_cb
 * DESCRIPTION
 *  draw bt connecting animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_vdoply_pdl_terminate_confirm_cb(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *res_evt = (mmi_alert_result_evt_struct*)evt;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (res_evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (res_evt->result)
        {
        case MMI_ALERT_CNFM_OK:
            // handle softkey event here
            break;
        case MMI_ALERT_CNFM_YES:
            mmi_vdoply_pdl_teminate_confirm_yes();
            break;
        case MMI_ALERT_CNFM_NO:
            // handle softkey event here
            mmi_frm_scrn_close_active_id();
            break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_entry_pdl_teminate_confirm_scr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_entry_pdl_teminate_confirm_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearInputEventHandler(MMI_DEVICE_KEY);
    
    mmi_vdoply_display_popup_confirm(
		GRP_ID_VDOPLY_SINGLE_PLAYER,
        STR_ID_VDOPLY_NOTIFY_TEMINATE_PDL,
        mmi_vdoply_pdl_terminate_confirm_cb,
        CNFM_TYPE_YESNO,
        MMI_EVENT_QUERY
    ); 
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_teminate_confirm_yes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_pdl_teminate_confirm_yes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
    {
        MMI_ASSERT(g_vdoply_cntx.pdl_dl_session_id != -1);
        
        /* progressive DL is not finished */
    #ifdef __MMI_DOWNLOAD_AGENT__
        srv_da_stop_pdl(g_vdoply_cntx.pdl_dl_session_id);
    #endif
    }

    g_vdoply_cntx.pdl_dl_session_id = -1;     
    g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_EXIT;     
    cui_vdoply_evt_exit(MMI_TRUE,STR_ID_VDOPLY_NOTIFY_PDL_TERMINATED);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_buffering_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_pdl_buffering_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 prev_percent;
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_percent = g_vdoply_cntx.pdl_buf_percent;
    
    ret = mdi_video_progressive_get_buf_percentage(&g_vdoply_cntx.pdl_buf_percent);
    
    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
    {
        return;
    }     

    if (g_vdoply_cntx.pdl_buf_percent > prev_percent)
    {
        /* if bar progress foward, draw it */        
        mmi_vdoply_draw_loading(g_vdoply_cntx.pdl_buf_percent, MMI_FALSE, MMI_FALSE); 
        mmi_vdoply_blt_screen();
    }

    if (g_vdoply_cntx.pdl_buf_percent != 100)
    {
        gui_start_timer(300, mmi_vdoply_pdl_buffering_cyclic);
    }
    else
    {
        /* sleep 100ms to let 100% progress bar show longer */
        kal_sleep_task(30);
        
        /* percentage == 100 */
		
        if (g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_BUFFERING)
        {
            mmi_vdoply_enter_state(VDOPLY_STATE_IDLE);
        }
        else if (g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_PLAY_BUFFERING)
        {
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_PLAY);
            }
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_fullscr_buffering_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __VDOPLY_FEATURE_FULLSCREEN__
static void mmi_vdoply_pdl_fullscr_buffering_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 prev_percent;
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_percent = g_vdoply_cntx.pdl_buf_percent;
    
    ret = mdi_video_progressive_get_buf_percentage(&g_vdoply_cntx.pdl_buf_percent);
    
    if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
    {
        return;
    }     

    if (g_vdoply_cntx.pdl_buf_percent > prev_percent)
    {
        /* if bar progress foward, draw it */
        mmi_vdoply_draw_loading(g_vdoply_cntx.pdl_buf_percent, MMI_FALSE, MMI_TRUE);
        mmi_vdoply_blt_screen();
    }

    if (g_vdoply_cntx.pdl_buf_percent != 100)
    {
        gui_start_timer(300, mmi_vdoply_pdl_fullscr_buffering_cyclic);
    }
    else
    {
        /* because it was underflow, the video may seek fail before, always seek again before play.*/
        mdi_video_ply_seek(g_vdoply_cntx.cur_status.play_time);
        /* sleep 100ms to let 100% progress bar show longer */
        kal_sleep_task(30);
		
		if (g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_FULLSCR_PLAY_BUFFERING || 
			g_vdoply_cntx.state == VDOPLY_STATE_PROGRESSIVE_FULLSCR_BUFFERING)
        {
            if (mmi_vdoply_is_output_to_bt())
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_BT_CONNECTING);
            }
            else
            {
                mmi_vdoply_enter_state(VDOPLY_STATE_FULLSCR_PLAY);
            }
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
}
#endif /* __VDOPLY_FEATURE_FULLSCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_draw_progressbar_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_pdl_draw_progressbar_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 prev_buff_ratio;
    S32 ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_PDL_DRAW_PROGRESSBAR_CYCLIC);        
    
    prev_buff_ratio = g_vdoply_cntx.cur_status.buff_ratio;

    if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_NORMAL)
    {
       /* get progressisve dl available time */
        ret = mdi_video_progressive_get_max_play_time(&g_vdoply_cntx.cur_status.max_play_time);

        if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
        {
            return;
        }           
        
  
        if (g_vdoply_cntx.cur_status.buff_ratio != prev_buff_ratio)
        {
            if (g_vdoply_cntx.state == VDOPLY_STATE_SEEKING || 
                g_vdoply_cntx.state == VDOPLY_STATE_PLAY_SEEKING)
            {
                //do nothing. In this case, inc and dec are disable.if blt, after seek done, they seem flash
            }
            else
            {
                mmi_vdoply_draw_panel_progress();
                mmi_vdoply_blt_screen();                
            } 
        }

    }
    else if (g_vdoply_cntx.ui_type == VDOPLY_UI_TYPE_FULLSCR)
    {
    #ifdef __VDOPLY_FEATURE_FULLSCREEN__
        /* get progressisve dl available time */
        ret = mdi_video_progressive_get_max_play_time(&g_vdoply_cntx.cur_status.max_play_time);

        if (mmi_vdoply_check_and_display_error_popup(ret) == MMI_TRUE)  /* ture means has error popup */
        {
            return;
        }    


        if (g_vdoply_cntx.cur_status.buff_ratio != prev_buff_ratio)
        {
            mmi_vdoply_blt_screen();            
        }
    #endif /* __VDOPLY_FEATURE_FULLSCREEN__ */
    }
    
    if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_DOWNLOADING)
    {
        /* 1 sec get max time once */
    	gui_start_timer(1000, mmi_vdoply_pdl_draw_progressbar_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_display_pdl_err_popup
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_display_pdl_err_popup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.pdl_err_str_id)
    {
        /* delete up to the prvious screen of video player */
        g_vdoply_cntx.pdl_err_str_id = 0;
		cui_vdoply_evt_exit(MMI_TRUE, g_vdoply_cntx.pdl_err_str_id);
    }
}


#if defined __MMI_DOWNLOAD_AGENT__ 
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_da_notify_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_pdl_da_notify_file(
    	S32	session_id,
    	S32	mime_type,                  
    	S32	mime_subtype, 
    	S32 action,
    	U32	filesize,
    	CHAR*	url,                        
    	CHAR*	mime_type_string,           
    	U32	content_len,
    	CHAR*	content,
    	srv_da_setting_struct *settings_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_pdl;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_PDL_DA_NOTIFY_FILE);       

    /* not progressive video */
    srv_da_default_setting(
        session_id,
        mime_type,
        mime_subtype,
        action,
        filesize,
        url,
        mime_type_string,
        content_len,
        content,
        settings_p);
        
    if (action == MMI_DA_WAP_DOWNLOAD)
    {
        if (g_vdoply_cntx.state != VDOPLY_STATE_EXIT)
        {
            /* aviod re-entry */
            return;
        }
        if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_FINISHED)
        {
            /* avoid downloading too fast */
            return;    
        }
        
        mmi_vdoply_load_setting();
        mdi_video_progressive_is_pdl_format((PU8)content, content_len, &is_pdl);

        if (is_pdl)
        {
            /* is progressive dl 3gp and it is from WAP download */

            settings_p->bypass = MMI_DA_BYPASS_FALSE;                               /* bypass */
            settings_p->default_filename = MMI_FALSE;                     /* incoming's name, user can edit */
            settings_p->filepath_hdlr = mmi_vdoply_pdl_da_filepath_hdlr;  /* notify where is the file */
            settings_p->report_hdlr = mmi_vdoply_pdl_da_report_hdlr;      /* download status report */
            settings_p->percentage_bar = MMI_FALSE;                       /* do not show process bar */
            settings_p->storage = SRV_DA_STORAGE_NONE;                    /* let user choose storage */
            settings_p->drv = 0;                                          /* not usesed if storage is none*/
            settings_p->keepfile = MMI_TRUE;                                  /* keep file when cancel */
            mmi_ucs2cpy((CHAR*)settings_p->folder, (CHAR*)FMGR_DEFAULT_FOLDER_VIDEO);

            return;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_da_report_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_vdoply_pdl_da_report_hdlr(
                S32 session_id,
                S32 status,
                S32 cause,
                U32 seq_num,
                U32 acc_size, 
                U32 total_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scr_id;
    MMI_ID_TYPE str_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(                             \
        MMI_MEDIA_TRC_G3_APP_DETAIL,        \
        MMI_TRC_VDOPLY_PDL_DA_REPORT_HDLR,  \
        cause,                              \
        g_vdoply_cntx.pdl_dl_state,         \
        session_id,                         \
        g_vdoply_cntx.pdl_dl_session_id);   
    
    switch (status)
    {
        case SRV_DA_STATE_DOWNLOADING:
            MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_DA_DOWNLOADING);
            MMI_ASSERT(session_id == g_vdoply_cntx.pdl_dl_session_id);            
            if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_EXIT)
            {
                if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
                {
                    /* this may happened when WAP send message to DA, at this this, a call happened */
                    srv_da_stop_pdl(g_vdoply_cntx.pdl_dl_session_id);
                    g_vdoply_cntx.pdl_dl_session_id = -1;
                    return;
                }
                g_vdoply_cntx.pdl_err_str_id = NULL;
                g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_DOWNLOADING;
				#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)
				if(!mmi_frm_app_is_launched(APP_VDOPLY))
				{
                	mmi_vdoply_entry_player_screen_from_browser(g_vdoply_cntx.source_path, MMI_FALSE, MMI_FALSE);
                }
                else
                {
                	mmi_vdoply_entry_player_screen_from_pdl_file(g_vdoply_cntx.source_path, MMI_FALSE);
                }
                #else
                mmi_vdoply_entry_player_screen_from_pdl_file(g_vdoply_cntx.source_path, MMI_FALSE);     
                #endif
            }
            break;

        case SRV_DA_STATE_COMPLETE:
            MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_DA_COMPLETE);
            MMI_ASSERT(session_id == g_vdoply_cntx.pdl_dl_session_id);                        
            
            if (g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_EXIT)
            {
                g_vdoply_cntx.pdl_dl_session_id = -1;
				#if defined( __MMI_SUPPORT_ASMV2__)&&defined( __MMI_VIDEO_PDL__)		
				if(!mmi_frm_app_is_launched(APP_VDOPLY))
				{
                	mmi_vdoply_entry_player_screen_from_browser(g_vdoply_cntx.source_path, MMI_FALSE, MMI_TRUE);
                }
                else
                {
                	mmi_vdoply_entry_player_screen_from_file(g_vdoply_cntx.source_path, MMI_FALSE);
                }
               	#else
                mmi_vdoply_entry_player_screen_from_file(g_vdoply_cntx.source_path, MMI_FALSE); 
                #endif
            }
            else
            {
                g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_FINISHED;  
                g_vdoply_cntx.pdl_dl_session_id = -1;
            }
            break;
            
        case SRV_DA_STATE_PAUSE:
        case SRV_DA_STATE_ABORT:
            MMI_TRACE(MMI_MEDIA_TRC_G3_APP_DETAIL, MMI_TRC_VDOPLY_DA_ABORT);
            g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_EXIT;               
            g_vdoply_cntx.pdl_dl_session_id = -1;
            
            if (cause == SRV_DA_ERROR_DISK_FULL)
            {
                str_id = FMGR_FS_DISK_FULL_TEXT;
            }
            else
            {
                str_id = STR_GLOBAL_FAILED_TO_SAVE;
            }

            scr_id = GetExitScrnID();

            if (scr_id > SCR_ID_VDOPLY_START && scr_id < SCR_ID_VDOPLY_END)
            {
                cui_vdoply_evt_exit(MMI_TRUE, str_id);
            }
            else
            {
                g_vdoply_cntx.pdl_err_str_id = str_id;
            }
            
            break;

        case SRV_DA_STATE_USER_CANCEL:
            g_vdoply_cntx.pdl_dl_session_id = -1;
            break;

        default:
            MMI_ASSERT(0);
            break;

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_pdl_da_filepath_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static BOOL mmi_vdoply_pdl_da_filepath_hdlr(
                S32 session_id,
                S32 mime_type, 
                S32 mime_subtype, 
                PU16 filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VDOPLY_PDL_DA_FILEPATH_HDLR);   
    MMI_ASSERT(mime_type == MIME_TYPE_VIDEO);


    if (g_vdoply_cntx.pdl_dl_session_id == -1 || g_vdoply_cntx.pdl_dl_state == VDOPLY_PDL_DL_STATE_EXIT)
    {
        /* start a new session or resume download, the session id of current context will be -1 */
        /* or pdl_dl_state== exit becuz d/l agent won't reported during call                    */
        g_vdoply_cntx.pdl_dl_session_id = session_id;
    }
    else
    {
        srv_da_stop_pdl(g_vdoply_cntx.pdl_dl_session_id);
        g_vdoply_cntx.pdl_dl_state = VDOPLY_PDL_DL_STATE_EXIT;
        g_vdoply_cntx.pdl_dl_session_id = -1;
        cui_vdoply_evt_exit(MMI_FALSE, 0);
        g_vdoply_cntx.pdl_dl_session_id = session_id;
    }

    mmi_ucs2cpy(g_vdoply_cntx.source_path, (CHAR*)filepath);

    /* return TRUE will continue the downloading */
    return TRUE;
}
#endif /* __MMI_DOWNLOAD_AGENT__ */
#endif /* __MMI_VIDEO_PDL__ */



#ifdef __MMI_VIDEO_STREAM__
/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_active_profile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_vdoply_set_active_profile(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        return;
    }
    WriteValueSlim(NVRAM_VDOPLY_ACTIVE_PROFILE_IDX, &index, DS_BYTE);    
    g_vdoply_cntx.active_profile_idx = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_active_profile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index
 * RETURNS
 *  void
 *****************************************************************************/
extern U8 mmi_vdoply_get_active_profile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    U8 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValueSlim(NVRAM_VDOPLY_ACTIVE_PROFILE_IDX, &index, DS_BYTE);
    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        index = 0;
    }
    return index;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_is_profile_in_use
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index
 * RETURNS
 *  void
 *****************************************************************************/
extern MMI_BOOL mmi_vdoply_is_profile_in_use(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    U8  active_prof_idx;
    U16 state = g_vdoply_cntx.state; //TODO:

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        return MMI_FALSE;
    }
    
    ReadValueSlim(NVRAM_VDOPLY_ACTIVE_PROFILE_IDX, &active_prof_idx, DS_BYTE); 
    if (active_prof_idx == 0xff)
    {
        return MMI_FALSE;
    }

    if ( index == active_prof_idx && state == VDOPLY_STATE_STREAM_CONNECTED)
    {
        return MMI_TRUE; 
    }
    else
    {
        return MMI_FALSE;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_del_all_app_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_vdoply_del_all_app_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    mmi_frm_group_close(GRP_ID_VDOPLY_NETWORK_PROFILE);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_load_profile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index
 *  prof_p
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_vdoply_load_profile(U8 index, nvram_ef_video_network_profile_struct *prof_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        return;
    }

    if (prof_p == NULL)
    {
        return;
    }
    
    ReadRecordSlim(
          NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
          index + 1,  /* id start from 1 */ 
          (void*)prof_p, 
          NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_store_profile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index
 *  prof_p
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_vdoply_store_profile(U8 index,nvram_ef_video_network_profile_struct *prof_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if (index >= NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL)
    {
        return;
    }

    if (prof_p == NULL)
    {
        return;
    }

    WriteRecordSlim(
         NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
         index + 1,  /* id start from 1 */ 
         (void*)prof_p, 
         NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);
    memcpy(prof_p, &g_vdoply_cntx.network_profile[index], sizeof(nvram_ef_video_network_profile_struct));
    g_vdoply_cntx.is_load_setting = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_cbm_app_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern U16 mmi_vdoply_get_cbm_app_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_vdoply_cntx.cbm_app_id;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_cbm_app_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_get_string_id_and_icon_id(U16 *string_id, U16 *icon_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

     /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    *icon_id = GetRootTitleIcon(MENU_ID_VDOPLY_APP);
    *string_id = STR_ID_VDOPLY_APP_NAME;
}

#endif

#endif /* __MMI_VIDEO_PLAYER__ */ 

/*************************************************************************************************************************/
/* split follow part to new file if required */

#if defined(__MMI_VIDEO_PLAY_SUPPORT__) || (defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__))

#if !defined(__MMI_VIDEO_PLAYER__) && (defined(__MMI_VIDEO_PLAY_SUPPORT__) || (defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__)))
#include "MMIDataType.h"
#include "stdio.h"
#include "Unicodexdcl.h"
#include "FileMgrType.h"
#include "FileMgrSrvGProt.h"
#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "kal_non_specific_general_types.h"
#include "mmi_frm_nvram_gprot.h"
#include "custom_mmi_default_value.h"

#include "MMI_features_video.h" /* features */
#include "FileManagerGProt.h"   /* file path / file error  */
#include "VdoPlyApp.h"
#include "VdoPlyGProt.h"
#include "mmi_rp_app_vdoply_def.h"

vdoply_context_struct g_vdoply_cntx;

#endif /* !defined(__MMI_VIDEO_PLAYER__) && (defined(__MMI_VIDEO_PLAY_SUPPORT__) || (defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__))) */

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_storage_file_path
 * DESCRIPTION
 *  get current active storage disk path
 * PARAMETERS
 *  filepath        [OUT]       Storage file path
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_get_storage_file_path(CHAR* filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf[64];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_vdoply_load_setting();
    
    sprintf(buf, "%c:\\", (U8)g_vdoply_cntx.storage);
    mmi_asc_to_ucs2(filepath, buf);
    mmi_ucs2cat((CHAR*)filepath, (CHAR*)VDOPLY_STORAGE_FILEPATH_PHONE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_create_file_dir
 * DESCRIPTION
 *  create file directory-resursivly
 * PARAMETERS
 *  filepath        [IN]        Filepath to be created
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_vdoply_create_file_dir(CHAR *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_createpath[128];
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 fs_ret;
    S32 str_len;
    S32 cmp_ret;
    S32 i;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fs_ret = 0;
    if (FS_NO_ERROR != FS_GetDevStatus((U16)filepath[0] ,FS_MOUNT_STATE_ENUM))
    {
        return FS_DRIVE_NOT_FOUND;
    }

    fs_ret = FS_GetAttributes((kal_uint16*)filepath);
    if (fs_ret >= 0 && !(fs_ret & FS_ATTR_DIR))
    {
        /* magic dummy fold */
        FS_Delete((kal_uint16*)filepath);   
    }
    
    file_handle = FS_Open((kal_uint16*) filepath, FS_OPEN_DIR | FS_READ_ONLY);

    /* path already exist */
    if (file_handle >= 0)
    {
        FS_Close(file_handle);

        if (fs_ret & FS_ATTR_DIR)
        {
            /* folder already exist */
            return FS_NO_ERROR;   
        }
    }
    else if (file_handle != FS_FILE_NOT_FOUND &&
    	     file_handle != FS_PATH_NOT_FOUND)
    {
        return file_handle;
    }		
    		

    /* create directory if it is not there */
    mmi_ucs2cpy((CHAR*) buf_filepath, (CHAR*) filepath);

    str_len = mmi_ucs2strlen((CHAR*) buf_filepath);
    str_len *= ENCODING_LENGTH;

    /* skip drive. "C:\" */
    for (i = 3 * ENCODING_LENGTH; i < str_len; i += 2)
    {
        cmp_ret = mmi_ucs2ncmp((CHAR*) & buf_filepath[i], (CHAR*) L"\\", 1);
        if (cmp_ret == 0)
        {
            /* create dir */

            mmi_ucs2ncpy((CHAR*) buf_createpath, (CHAR*) buf_filepath, i / ENCODING_LENGTH);
            buf_createpath[i] = '\0';
            buf_createpath[i + 1] = '\0';

            fs_ret = FS_CreateDir((PU16) buf_createpath);

            if (fs_ret < 0)
            {
                return fs_ret;
            }
        }
    }

    return fs_ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_get_storage
 * DESCRIPTION
 *  get storage
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
U16 mmi_vdoply_get_storage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_vdoply_cntx.storage;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_set_storage
 * DESCRIPTION
 *  set storage
 * PARAMETERS
 *  storage     [IN]        Storage location enum
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_set_storage(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_vdoply_cntx.storage = storage;
    WriteValueSlim(NVRAM_VDOPLY_STORAGE, &g_vdoply_cntx.storage, DS_SHORT);
#if defined(__MMI_VIDEO_PLAYER__)
    /* delete all screens except VDOPLY_APP */
    cui_vdoply_close(GRP_ID_VDOPLY_SINGLE_PLAYER);
    cui_folder_browser_close(g_vdoply_cntx.fmgr_scr_id);
    mmi_frm_group_close(GRP_ID_VDOPLY_APP);
	#ifdef __MMI_AP_DCM_VDOPLY__
	mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_VDOREC);
	#endif
#endif /* defined(__MMI_VIDEO_PLAYER__) */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_load_setting
 * DESCRIPTION
 *  load setting from NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_load_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    MMI_BOOL is_inited_before;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_vdoply_cntx.is_load_setting == MMI_TRUE)
    {
        return;
    }

    is_inited_before = MMI_TRUE;

    g_vdoply_cntx.is_load_setting = MMI_TRUE;

    /* storage setting */
    ReadValueSlim(NVRAM_VDOPLY_STORAGE, &g_vdoply_cntx.storage, DS_SHORT);
    
#ifdef __MMI_VIDEO_PLAYER__
    /* init if needed */
    if (g_vdoply_cntx.storage == 0xffff)
    {
        is_inited_before = MMI_FALSE;
        g_vdoply_cntx.storage = (U16)SRV_FMGR_PUBLIC_DRV;
    }

    /* brightness setting */
    ReadValueSlim(NVRAM_VDOPLY_OPTION_BRIGHTNESS, &g_vdoply_cntx.brightness, DS_SHORT);
    if (g_vdoply_cntx.brightness == 0xffff)
    {
        g_vdoply_cntx.brightness = MDI_VIDEO_BRIGHTNESS_0;
    }

    /* contrast setting */
    ReadValueSlim(NVRAM_VDOPLY_OPTION_CONTRAST, &g_vdoply_cntx.contrast, DS_SHORT);
    if (g_vdoply_cntx.contrast == 0xffff)
    {
        g_vdoply_cntx.contrast = MDI_VIDEO_CONTRAST_0;
    }

    /* auto repeat setting */
    ReadValueSlim(NVRAM_VDOPLY_OPTION_REPEAT, &g_vdoply_cntx.repeat, DS_SHORT);
    if (g_vdoply_cntx.repeat == 0xffff)
    {
        g_vdoply_cntx.repeat = VDOPLY_REPEAT_OFF;
    }

    /* play mode settings */
    ReadValueSlim(NVRAM_VDOPLY_OPTION_PLAY_MODE, &g_vdoply_cntx.play_mode, DS_SHORT);
    if (g_vdoply_cntx.play_mode == 0xffff)
    {
        g_vdoply_cntx.play_mode = MDI_VIDEO_TRACK_2D_NORMAL;//MDI_VIDEO_TRACK_2D_NORMAL;
    }

    #if defined(__MMI_VIDEO_STREAM__)
    /* stream */
    ReadValueSlim(NVRAM_VDOPLY_ACTIVE_PROFILE_IDX, &g_vdoply_cntx.active_profile_idx, DS_BYTE);        
    if (g_vdoply_cntx.active_profile_idx == 0xff)
    {
        /* get a default DA id */      
        is_inited_before = MMI_FALSE;        
        g_vdoply_cntx.active_profile_idx = 0;
    }

    {
        S32 i;

        /* load profile for NVARM to memory */
        for (i = 0 ; i < NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL; i++)
        {
            ReadRecordSlim(
                NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
                i + 1,  /* id start from 1 */ 
                (void*)&g_vdoply_cntx.network_profile[i], 
                NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);
        }
    }
    
    #endif /* defined(__MMI_VIDEO_STREAM__) */
#else  /*  __MMI_VIDEO_PLAYER__ */

    /* init if needed */
    if (g_vdoply_cntx.storage == 0xffff)
    {
        is_inited_before = MMI_FALSE;
    #ifdef VDOREC_DEFAULT_STORAGE
        g_vdoply_cntx.storage = (U16)VDOREC_DEFAULT_STORAGE;
    #else
        g_vdoply_cntx.storage = (U16)SRV_FMGR_PUBLIC_DRV;
    #endif
    }
    
#endif /*  __MMI_VIDEO_PLAYER__ */

    if (!is_inited_before)
    {
        /* first time init, store the init value */
        mmi_vdoply_store_setting();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vdoply_store_setting
 * DESCRIPTION
 *  store storage to NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vdoply_store_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    WriteValueSlim(NVRAM_VDOPLY_STORAGE, &g_vdoply_cntx.storage, DS_SHORT);
    
#ifdef __MMI_VIDEO_PLAYER__    
    WriteValueSlim(NVRAM_VDOPLY_OPTION_BRIGHTNESS, &g_vdoply_cntx.brightness, DS_SHORT);
    WriteValueSlim(NVRAM_VDOPLY_OPTION_CONTRAST, &g_vdoply_cntx.contrast, DS_SHORT);
    WriteValueSlim(NVRAM_VDOPLY_OPTION_REPEAT, &g_vdoply_cntx.repeat, DS_SHORT);
    WriteValueSlim(NVRAM_VDOPLY_OPTION_PLAY_MODE, &g_vdoply_cntx.play_mode, DS_SHORT);

#if defined(__MMI_VIDEO_STREAM__)
    WriteValueSlim(NVRAM_VDOPLY_ACTIVE_PROFILE_IDX, &g_vdoply_cntx.active_profile_idx, DS_BYTE);        

    {
        S32 i;

        /* write profile for NVARM to memory */
        for (i = 0 ; i < NVRAM_EF_VIDEO_NETWORK_PROFILE_TOTAL; i++)
        {
            WriteRecordSlim(
                NVRAM_EF_VIDEO_NETWORK_PROFILE_LID, 
                i + 1,  /* id start from 1 */ 
                (void*)&g_vdoply_cntx.network_profile[i], 
                NVRAM_EF_VIDEO_NETWORK_PROFILE_SIZE);
        }
    }
#endif /* defined(__MMI_VIDEO_STREAM__)*/

#endif /* __MMI_VIDEO_PLAYER__*/
}

#endif /* defined(__MMI_VIDEO_PLAY_SUPPORT__) || (defined(__MMI_VIDEO_RECORDER__) && !defined(__MMI_CAMCORDER__)) */

/*****************************************************************************
*  Copyright Statement: 
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#define _FMGR_INTERNAL_SOURCE_C_
#define _FMGR_MAIN_C_
/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#include "MMI_features.h"

#if defined(__MMI_FILE_MANAGER__)

#include "CommonScreens.h"

#include "FileMgrSrvGProt.h"
#include "FileMgrSrvIProt.h"

#include "FileMgrGProt.h"
#include "FileMgrProt.h"
#include "FileMgrInstance.h"
#include "FileMgrMain.h"

#include "FileMgrFSData.h"
#include "FileMgrGUI.h"
#include "FileMgrResDef.h"
#include "FileMgrService.h"

#include "FileMgrCuiGProt.h"

#ifdef __USB_IN_NORMAL_MODE__
#include "USBDeviceGprot.h"
#endif

#ifdef __MMI_AUDIO_PLAYER__
#include "AudioPlayerDef.h"
#include "AudioPlayerPlayList.h"
#include "AudioPlayerProt.h"
#endif /* __MMI_AUDIO_PLAYER__ */ 

#ifdef __DRM_SUPPORT__
#include "DRM_gprot.h"
#include "wap_ps_struct.h"
#include "wapadp.h"
#include "app_mine.h"
#endif /* __DRM_SUPPORT__ */ 

#include "RightsMgrGProt.h"

#ifdef __OTG_ENABLE__
#include "otg_if.h"
#endif 

#include "UcmSrvGProt.h"

#include "FileMgrServiceHdlr.h"

#include "ProfilesSrvGprot.h"

#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
#include "SettingDefs.h"
#include "SettingGprots.h"
#include "CallSetUpEnum.h"
#endif

#if defined(__MMI_FMGR_MULTI_SELECT_SUPPORT__) && defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
#include "PictCuiGProt.h"
#endif

#ifdef __MMI_FMGR_SUPPORT_DEFAULT_STORAGE__
#include "MainMenuDef.h"
#endif

#ifdef __MMI_VUI_MEDIAWALL__
#include "MediaWall\vadp_mediawall.h"
#endif /* __MMI_VUI_MEDIAWALL__ */

#include "SecSetCuiGprot.h" /* Don't forget */
#ifdef __MMI_EBOOK_READER__
#include "mmi_rp_app_ebook_def.h"
#endif
#ifdef __MMI_BROWSER_2__
#include "mmi_rp_app_browser_def.h"
#endif
#ifdef __J2ME__
#include "Mmi_rp_app_java_def.h"
#endif
//for mre
#include "mmi_rp_app_mre_def.h"


#include "MMIDataType.h"
#include "kal_general_types.h"
#include "string.h"
#include "stack_msgs.h"
#include "mmi_frm_events_gprot.h"
#include "app_mem.h"
#include "mmi_rp_app_filemanager_def.h"
#include "wgui_categories_util.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "GlobalResDef.h"
#include "mmi_res_range_def.h"
#include "Unicodexdcl.h"
#include "wgui_categories_fmgr.h"
#include "mmi_rp_file_type_def.h"
#include "FileMgrType.h"
#include "CustMenuRes.h"
#include "fs_errcode.h"
#include "kal_public_api.h"
#include "mmi_frm_mem_gprot.h"
#include "GlobalConstants.h"
#include "fmt_def.h"
#include "mmi_frm_scenario_gprot.h"
#include "fs_func.h"
#include "fs_type.h"
#include "wgui_categories_list.h"
#include "CustDataRes.h"
#include "AlertScreen.h"
#include "CommonScreensResDef.h"
#include "mmi_frm_input_gprot.h"
#include "MMI_common_app_trc.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "mmi_common_app_trc.h"
#include "ScreenRotationGprot.h"
#include "GpioSrvGprot.h"
#include "mmi_frm_nvram_gprot.h"
#include "custom_mmi_default_value.h"
#include "wgui_categories_popup.h"
#include "custom_events_notify.h"
#include "gui_typedef.h"
#include "drm_def.h"
#include "wgui_categories_text_viewer.h"
#include "SettingGenum.h"
#include "wgui_inputs.h"
#include "wgui_categories_inputs.h"
#include "mmi_rp_app_restore_def.h"
#include "ImeGprot.h"
#if defined (__MMI_IMAGE_VIEWER__)
#include "mmi_rp_app_imageviewer_def.h"
#include "ImageviewCuiGProt.h"
#endif

/****************************************************************************
* Define
*****************************************************************************/

#ifndef __RF_DESENSE_TEST__
#define FMGR_WORKAROUND_SUSPEND_BG_AUDIO
#define FMGR_WORKAROUND_ABORT_COPY
#endif

/****************************************************************************
* Macro
*****************************************************************************/

/****************************************************************************
* Global Variable
*****************************************************************************/
// extern S8 nPrintableStr[];

static mmi_ret mmi_fmgri_main_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type);
static void mmi_fmgri_main_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data);
static MMI_BOOL mmi_fmgri_main_error_handler(mmi_fmgr_instance_struct *instance, S32 error);
static void mmi_fmgri_main_node_highlight_hdlr(mmi_fmgr_instance_struct *instance, S32 idx);
#if defined(__FMGR_HYPERLINK_SUPPORT__)
static MMI_BOOL mmi_fmgri_main_hyperlink_handler(mmi_fmgr_instance_struct *instance, fmgr_hyperlink_action_enum action, S32 para, S32* result);
#endif
static mmi_ret mmi_fmgri_main_event_proc_handler(mmi_fmgr_instance_struct *instance, mmi_event_struct *param);
static S32  mmi_fmgri_main_command_hdlr(mmi_fmgr_instance_struct *instance, S32 cmd, S32 para, void* data);

const mmi_fmgri_instance_callback_table_struct mmi_fmgri_main_table = 
{
    mmi_fmgri_main_key_event_hdlr,
    mmi_fmgri_main_notify_event_hdlr,
    mmi_fmgri_main_node_highlight_hdlr,
    mmi_fmgri_main_error_handler,
#ifdef __FMGR_HYPERLINK_SUPPORT__
    mmi_fmgri_main_hyperlink_handler,
#endif /* __FMGR_HYPERLINK_SUPPORT__ */
    mmi_fmgri_main_command_hdlr,
    mmi_fmgri_main_event_proc_handler
};

/****************************************************************************
* Static Variable
*****************************************************************************/
mmi_fmgr_main_context_struct fmgr_main_context;
mmi_fmgr_main_context_struct *fmgr_main_p = &fmgr_main_context;
mmi_fmgr_instance_struct *fmgr_instance_p;

#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
U8 gFMGRPassword[(MAX_SIM_SETTING_PASSWD_LEN + 1) * ENCODING_LENGTH];
U8 g_mmi_fmgr_check_passcode;
#endif 

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
static void fmgr_main_mark_several_close_callback(U32 ms_id, U32 user_data);

static void fmgr_main_send_mark(void);
#endif

extern S32 fmgr_main_check_free_space(S8 drv, U32 size_required);

static void fmgr_main_show_processing(mmi_fmgr_instance_struct *instance, U8 new_state);
static void fmgr_main_close_processing(void);
static void fmgr_main_abort_processing(void);
static void fmgr_main_processing_rsk_hdlr(void);
static U8   fmgr_main_processing_can_popup(mmi_fmgr_instance_struct *instance);
static mmi_fmgr_instance_struct* fmgr_main_get_processing_instance(void);

extern void fmgr_main_copy_select_folder_done(mmi_fmgr_instance_struct *instance, cui_folder_selector_result_event_struct* evt);

static void fmgr_main_start_filename_editor(mmi_fmgr_instance_struct *instance, U32 user_data);
#ifndef __MMI_SLIM_FILE_MANAGER__
static void fmgr_main_start_soft_unmount(mmi_fmgr_instance_struct *instance);
#endif
#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
static void fmgr_main_start_phone_lock_confirm(void);
#endif

static MMI_BOOL fmgr_main_create_folder_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id);
static MMI_BOOL fmgr_main_rename_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id);
#ifndef __MMI_SLIM_FILE_MANAGER__
static MMI_BOOL fmgr_main_rename_drive_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id);
#endif
#if defined (__MMI_IMAGE_VIEWER__)
static void fmgr_main_run_imgviewcui(mmi_fmgr_instance_struct * instance);
static void fmgr_main_close_imgviewcui(mmi_fmgr_instance_struct * instance,mmi_id sender);
#endif

#define END_OF_FUNCTION_DECLARATION

/****************************************************************************
* Function Body
*****************************************************************************/
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_init_context
 * DESCRIPTION
 *  init FMGR context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(fmgr_main_p, 0, sizeof(mmi_fmgr_main_context_struct));

    fmgr_instance_p = fmgr_main_p->instance;

    /****** Protocol Event Handler ******/    

    SetProtocolEventHandler(fmgr_main_op_abort_processing_hdlr, MSG_ID_MMI_FMT_OP_ABORT_PROCESSING_IND);

#ifdef __FS_SORT_SUPPORT__
    /* Init sort option form NVRAM */
    fmgr_main_reinit_sort_option();
#endif /* __FS_SORT_SUPPORT__ */

}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_init_mmi_context
 * DESCRIPTION
 *  init FMGR context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_init_mmi_context(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* initialize camera app-based memory */
    applib_mem_ap_register(APPLIB_MEM_AP_ID_FMGR,
                           STR_FMGR_TITLE,
                           GetRootTitleIcon(MAIN_MENU_FILE_MNGR_MENUID),
                           mmi_fmgr_app_mem_stop_callback);

    fmgr_main_p->app_mem_pool = NULL;
}

#ifdef __MMI_APP_MANAGER_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgr_app_mgr_launch
 * DESCRIPTION
 *  init FMGR context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_ID mmi_fmgr_app_mgr_launch(void* param, U32 para_size)
{
	mmi_fmgr_launch();
	if (!fmgr_main_p->instance)
		return GRP_ID_INVALID;
	else 
		return mmi_fmgri_instance_get_screen_id(fmgr_main_p->instance->id);
}

#endif/*__MMI_APP_MANAGER_SUPPORT*/



/*****************************************************************************
 * FUNCTION
 *  mmi_fmgr_launch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgr_launch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE)
    {
        FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(FS_DEVICE_BUSY), MMI_EVENT_FAILURE);
        return;        
    }
    
    /* Create fmgr instance */
    fmgr_main_p->instance = mmi_fmgri_instance_create(GRP_ID_ROOT, MMI_FMGR_TYPE_APP);
    if(!fmgr_main_p->instance)
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }
    
    fmgr_instance_p = fmgr_main_p->instance;
  
    /* Set application id */
    fmgr_instance_p->app_id = APP_FILEMANAGER;

    /* Set file path to root */
    mmi_ucs2cpy((PS8)fmgr_instance_p->file_path, (PS8)SRV_FMGR_PATH_ROOT);

    /* Set sel type to default */
    fmgr_instance_p->type = MMI_FMGR_TYPE_APP;

    /* Set drv type, don't display unmounted memory card */
#ifdef __FS_CARD2_SUPPORT__         
    fmgr_instance_p->drv_type = SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY|SRV_FMGR_DRIVELIST_ITYPE_FLAG_2ND_CARD;
#else
    fmgr_instance_p->drv_type = SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY;
#endif

    /* Set display type */
    fmgr_instance_p->display_type = FMGR_GUI_APP_STYLE;

    fmgr_instance_p->arrow_type = CAT213_ARROW_ALL;

    /* Set filter */
    FMGR_FILTER_SET_ALL(&fmgr_instance_p->filter_type);

    /* Enter file list explorer */
    mmi_fmgri_instance_general_entry_explorer(fmgr_instance_p, NULL);

}


void mmi_fmgr_launch_ex(U16 app_id)
{
#ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct            *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE)
    {
        FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(FS_DEVICE_BUSY), MMI_EVENT_FAILURE);
        return;        
    }

    /* Request/create a FMGR instance */
    instance = mmi_fmgri_instance_create(GRP_ID_ROOT, MMI_FMGR_TYPE_APP);
    
    if(!instance)
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }

    /* Save releated information */
    instance->app_id = app_id;
    instance->type = MMI_FMGR_TYPE_APP;
    instance->flag = FMGR_IFLAG_CUSTOM_ROOT;
    instance->cust_data = 0;

    mmi_ucs2ncpy(instance->file_path, (S8*)FMGR_PATH_ROOT, SRV_FMGR_PATH_MAX_LEN);
    FMGR_FILTER_INIT(&instance->filter_type);
    FMGR_FILTER_SET_ALL(&instance->filter_type);

    /* Set drv type, don't display unmounted memory card */
    instance->drv_type = SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY;

    /* GUI */
    instance->display_type = FMGR_GUI_OTHER_STYLE;
    instance->dirty_level = 0;
    instance->cur_index = 0;
    instance->arrow_type = CAT213_ARROW_ALL;

    fmgr_main_p->instance = instance;
    fmgr_instance_p = fmgr_main_p->instance;
    /* Enter file list explorer */
    mmi_fmgri_instance_general_entry_explorer(instance, NULL);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgr_app_mem_stop_callback
 * DESCRIPTION
 *  callback function used by applib to free APP-Based Memory
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgr_app_mem_stop_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_abort_processing();
}

#ifdef __MMI_MY_FAVORITE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

static S32 fmgr_main_prepare_option(mmi_fmgr_instance_struct *instance, FMGR_FILE_INFO_STRUCT *file_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *buffer;
    S32 fs_ret;
#ifdef __FMGR_HYPERLINK_SUPPORT__
    mmi_fmgr_hyperlink_info_struct info;
#endif /* __FMGR_HYPERLINK_SUPPORT__ */
    fmgr_drive_info_struct *drv_info;
    mmi_fmgr_filetype_enum file_type;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __FMGR_HYPERLINK_SUPPORT__
    if (FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_HYPER_LINK))
    {
        mmi_fmgri_instance_get_hyperlink_info(instance->id, instance->cur_index, &info);
        mmi_fmgr_reset_menu_set(MENU_ID_FMGR_HYPERLINK_OPTIONS);
        mmi_fmgri_option_replace_appstring(MENU_ID_FMGR_HYPERLINK_APP_FUNC, info.lsk_string_id);

        return MENU_ID_FMGR_HYPERLINK_OPTIONS;
    }
#endif /* __FMGR_HYPERLINK_SUPPORT__ */

    if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT) == 0)
    {
        /* Drive */
        drv_info = (fmgr_drive_info_struct*)file_info;
    #ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
        if (drv_info->drv_type == FMGR_LINK_FOLDER)
        {
            return 0;
        }
        else if (drv_info->drv_type == FMGR_LINK_ITEM)
        {
            return 0;
        }
    #endif /* __FMGR_CUSTOM_ROOT_SUPPORT__ */
        mmi_fmgr_reset_menu_set(MENU_ID_FMGR_DRIVE_OPTIONS);
        mmi_frm_hide_menu_item(MENU_ID_FMGR_FOLDER_CREATE);    
    #ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
        if(instance->flag & FMGR_IFLAG_CUSTOM_ROOT)
        {
        #ifdef __FS_CARD_SUPPORT__
        #ifndef __MMI_SLIM_FILE_MANAGER__
            mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_RENAME);
        #endif
        #endif /* __FS_CARD_SUPPORT__ */
        }
    #endif /* __FMGR_CUSTOM_ROOT_SUPPORT__ */
    
        switch (drv_info->drv_type)
        {
            case SRV_FMGR_DRV_PHONE_TYPE:
            case SRV_FMGR_DRV_PHONE_2_TYPE:
                /* Highlight NAND/NOR Drive, hide unmount option */
#ifndef __MMI_SLIM_FILE_MANAGER__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_UNMOUNT);
            #ifdef __FS_CARD_SUPPORT__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_RENAME);
                mmi_frm_hide_menu_item(MENU_ID_FMGR_CARD_DETAIL);
            #endif /* __FS_CARD_SUPPORT__ */
#else
            #ifdef __FS_CARD_SUPPORT__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_CARD_DETAIL);
            #endif /* __FS_CARD_SUPPORT__ */
#endif
                break;            

			case SRV_FMGR_DRV_CARD_TYPE:
				#if (defined(__MSDC_NOT_SUPPORT_HOT_PLUG__) ||  defined(__MSDC_DUAL_CARD_SWITCH__)) && !defined(__MMI_SLIM_FILE_MANAGER__)
				mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_UNMOUNT);	
				#endif
				break;
			case SRV_FMGR_DRV_CARD_2_TYPE:
				#if defined(__MSDC_NOT_SUPPORT_HOT_PLUG__) && !defined(__MMI_SLIM_FILE_MANAGER__)
				mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_UNMOUNT);
				#endif
			break;
			#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
			#endif

        #ifdef __SIM_PLUS__
            case SRV_FMGR_DRV_SIMPLUS_TYPE:
            case SRV_FMGR_DRV_SIMPLUS_2_TYPE:
            case SRV_FMGR_DRV_SIMPLUS_3_TYPE:
            case SRV_FMGR_DRV_SIMPLUS_4_TYPE:
#ifndef __MMI_SLIM_FILE_MANAGER__
                /* Highlight SIM+ Drive, hide unmount option */
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_UNMOUNT);
#endif
                /* Hide format option */
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_FORMAT);
#endif

            #ifdef __FS_CARD_SUPPORT__
                /* Hide card rename + detail */
            #ifndef __MMI_SLIM_FILE_MANAGER__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_RENAME);
            #endif
                mmi_frm_hide_menu_item(MENU_ID_FMGR_CARD_DETAIL);
            #endif /* __FS_CARD_SUPPORT__ */														
                break;
        #endif /* __SIM_PLUS__ */
        
        #ifdef __OTG_ENABLE__
            case SRV_FMGR_DRV_OTG_TYPE:
            case SRV_FMGR_DRV_OTG_2_TYPE:
            case SRV_FMGR_DRV_OTG_3_TYPE:
            case SRV_FMGR_DRV_OTG_4_TYPE:
            case SRV_FMGR_DRV_OTG_5_TYPE:
            case SRV_FMGR_DRV_OTG_6_TYPE:
            case SRV_FMGR_DRV_OTG_7_TYPE:
            case SRV_FMGR_DRV_OTG_8_TYPE:
            #ifdef __FS_CARD_SUPPORT__
                /* Hide card rename + detail */
            #ifndef __MMI_SLIM_FILE_MANAGER__
                mmi_frm_hide_menu_item(MENU_ID_FMGR_DRIVE_RENAME);
            #endif
                mmi_frm_hide_menu_item(MENU_ID_FMGR_CARD_DETAIL);
            #endif /* __FS_CARD_SUPPORT__ */
                break;
        #endif /* __OTG_ENABLE__ */
            default:
                return 0;
        }

        return MENU_ID_FMGR_DRIVE_OPTIONS;
    }
    else
    {
        /* File / Folder */
        buffer = mmi_fmgri_get_and_lock_buffer();
        if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), instance->file_path, file_info, MMI_FALSE))
        {
            mmi_fmgri_free_and_unlock_buffer(buffer);
            return FS_PATH_OVER_LEN_ERROR;
        }

        file_type = srv_fmgr_types_get_main_type(&file_info->file_type);
        fs_ret = srv_fmgr_types_get_option_menu(file_type, (WCHAR*)buffer, 0);
        if (fs_ret <= 0)
        {
            mmi_fmgri_free_and_unlock_buffer(buffer);
            return fs_ret;
        }
        mmi_fmgri_prepare_option(instance, fs_ret, file_info);

        /* Remove menu items of file type begin */
        #ifdef __FS_CARD2_SUPPORT__
        /* Video */
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_VID_OPTION_PLAY, instance->file_path);
		/*Mre*/
		#ifndef __MMI_MRE_DISABLE_FMGR__  
		mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_MRE_FILE_OPEN, instance->file_path);
		#endif
        /* Java */
        #ifdef __J2ME__
        #if !defined (__MMI_FMGR_DISABLE_JAVA_INSTALL__)
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_JAVA_OPTION_EXECUTE, instance->file_path);
        #endif
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_JAVA_OPTION_PACKAGE, instance->file_path);
        #endif
        /* ebook */
        #ifdef __MMI_EBOOK_READER__
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_EBOOK_OPTION_OPEN_NEW, instance->file_path);
        #endif
        
        /* bookmark */
        #ifdef __MMI_BROWSER_2__
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_BRW_FMGR_BOOKMARK_GOTO, instance->file_path);
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_BRW_FMGR_BOOKMARK_OPEN, instance->file_path);                
        #endif
        #endif
        /* Remove menu items of file type end */        
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return fs_ret;
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_key_event_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_fmgri_main_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT  *file_info = NULL;
    U16 icon_id, option_menu_id;
    S32 fs_ret;
#ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
    fmgr_drive_info_struct *drv_info;
#endif /* __FMGR_CUSTOM_ROOT_SUPPORT__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(instance == fmgr_instance_p);

    file_info = OslMalloc(sizeof(FMGR_FILE_INFO_STRUCT));
    memset(file_info, 0, sizeof(FMGR_FILE_INFO_STRUCT));
    
    fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, file_info);

    switch (event_type)
    {
        case FMGRI_EVENT_RSK:
        {
            if ((mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT) == 0) ||
                (instance->flag & FMGR_FLAG_BASEPATH && mmi_ucs2strlen(instance->file_path) <= (S32)instance->cust_data))
            {
                mmi_fmgri_instance_general_close(instance);
            }
            else
            {
                mmi_fmgri_instance_general_leave_folder(instance);
            }
            break;
        }
        
        case FMGRI_EVENT_LSK:
            if (instance->cur_index < 0)
            {
                mmi_fmgri_main_create_folder(instance);
                break;
            }

            if (fs_ret >= 0)
            {
                fs_ret = fmgr_main_prepare_option(instance, file_info);
            }

            if (fs_ret < 0)
            {
                FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
                break;
            }
            else if (fs_ret > 0)
            {
                mmi_fmgri_instance_get_title_info(instance->id, NULL, &icon_id);
                mmi_fmgri_show_option(mmi_fmgri_instance_get_screen_id(instance->id),
                    (U16)fs_ret, fmgr_main_options_handler , instance->id, icon_id);
                break;
            }

             /* Handle non-option case */
        #ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
            if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT)==0)
            {
                drv_info = (fmgr_drive_info_struct*)file_info;
                if (drv_info->drv_type == FMGR_LINK_FOLDER) /* Link folder */
                {
                    mmi_fmgri_instance_general_enter_folder(instance);
                }
                else if (drv_info->drv_type == FMGR_LINK_ITEM) /* Link item */
                {
                    if (drv_info->lsk_hdlr)
                    {
                        drv_info->lsk_hdlr();
                    }
                }
            }
        #endif /* __FMGR_CUSTOM_ROOT_SUPPORT__ */
            break;

        case FMGRI_EVENT_DEF_CMD:
            if (instance->cur_index < 0)
            {
                OslMfree(file_info);
                return MMI_RET_ERR;
            }

            if (fs_ret >= 0)
            {
                fs_ret = fmgr_main_prepare_option(instance, file_info);
            }
        
            if (fs_ret < 0)
            {
                FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
                break;
            }
            else if (fs_ret == 0)
            {
				#ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
				mmi_fmgri_main_key_event_hdlr(instance, FMGRI_EVENT_LSK);
				break;
				#endif
                OslMfree(file_info);
                return MMI_RET_ERR;
            }

            FMGR_ASSERT(fs_ret > 0);
            option_menu_id = (U16)fs_ret;

            if (!GetNumOfChild(option_menu_id))
            {
                FMGR2_DisplayPopup(instance, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
                break;
            }

            option_menu_id = GetSeqItemId(option_menu_id, 0);
            if (mmi_frm_test_menu_item_hide(option_menu_id))
            {
                OslMfree(file_info);
                return MMI_RET_ERR; /* Disabled */
            }

            /* Run it */
            option_menu_id = fmgr_main_options_handler(0, option_menu_id, instance->id, KEY_LSK);            
            if (option_menu_id)
            {
                /* If there is sub-option, stop */
                OslMfree(file_info);
                return MMI_RET_ERR;
            }
            break;
    }

    OslMfree(file_info);
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_notify_event_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_fmgri_main_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 path_len, src_len;    
    mmi_fmgri_instance_notify_creation_struct *notify;
    srv_fmgr_notification_adv_action_event_struct *adv_action;
    mmi_fmgri_instance_notify_app_info_struct *app_notify;
#ifdef FMGR_TAB_SUPPORT
    srv_fmgr_notification_dev_plug_event_struct *card_plug;
    S32 i;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (event_type)
    {
        case FMGRI_EVENT_SCREEN_DELETING:
            mmi_fmgri_main_cancel_operation(instance);
            fmgr_instance_p = NULL;
            fmgr_main_p->instance = NULL;
        #ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
            if (fmgr_main_p->ms_id)
            {
                mmi_fmgri_serv_multi_sel_close(fmgr_main_p->ms_id);
                fmgr_main_p->ms_id = 0;
                fmgr_main_p->action_from_ms = MMI_FALSE;
                fmgr_main_p->ms_caller_instance = NULL;
            }
        #endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */
            break;

        case FMGRI_EVENT_INSTANCE_CREATING:
            notify = (mmi_fmgri_instance_notify_creation_struct*)data;
            if (notify->owner != mmi_fmgri_instance_get_screen_id(instance->id))
            {                
                mmi_fmgri_main_cancel_operation(instance);
            }
            break;
#ifdef FMGR_TAB_SUPPORT
        case FMGRI_EVENT_DRIVE_MOUNT:
            card_plug = (srv_fmgr_notification_dev_plug_event_struct*)data;
         
            for (i = 0; i < FMT_MAX_DRIVE; i++)
            {
                if (card_plug->drv_letters[i] == (U8)instance->file_path[0])
                {
                    mmi_fmgri_fsdata_instance_release_load(instance->id);    
                }
            }
            break;
#endif
        case FMGRI_EVENT_DRIVE_UNMOUNT:
        #ifdef __MMI_FMGR_SUPPORT_SOFT_UNMOUNT__
            mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance->id), SCR_ID_FMGR_CARD_SOFT_UNMOUNT);
        #endif /* __MMI_FMGR_SUPPORT_SOFT_UNMOUNT__ */
            
            if (fmgr_main_p->async_fs_state == FMGR_ACTION_FORMAT)
            {
                return;
            }

            if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT) == 0)
            {
                /* Do nothing, we don't know if the removed card is the highlighted card */
            }
            else if (srv_fmgr_drv_is_accessible((U8)instance->file_path[0]) == MMI_TRUE)
            {
                break;
            }

            /* Cancel operation */
            mmi_fmgri_main_cancel_operation(instance);
            
            /* Close option */
            mmi_fmgri_close_options(instance->id);
            
        #ifdef FMGR_TAB_SUPPORT
            /* Stay if there is other tab can switch */
            if (instance->tab_id && mmi_fmgri_table_tab_get_count(instance->tab_id) > 1)
            {
                mmi_fmgri_table_tab_switch(instance->tab_id, (WCHAR*)instance->file_path, sizeof(instance->file_path), 0);
                break;
            }
       #endif /* FMGR_TAB_SUPPORT */

            /* Back to Root */
            mmi_fmgri_instance_general_update_path(instance, (S8*)SRV_FMGR_PATH_ROOT);
            break;

        case FMGRI_EVENT_APP_NOTIFY:
            app_notify = (mmi_fmgri_instance_notify_app_info_struct *)data;
            adv_action = (srv_fmgr_notification_adv_action_event_struct*)app_notify->notify_data;

            if ((adv_action->action == SRV_FMGR_NOTIFICATION_ACTION_CREATE_FOLDER) &&
                (adv_action->state == SRV_FMGR_NOTIFICATION_STATE_AFTER) &&
                (adv_action->result == FS_NO_ERROR))
            {
                    /* Compare if we need to reset index */
                    path_len = srv_fmgr_path_get_filename_pos((const WCHAR*)adv_action->src_filepath);

                    src_len = mmi_ucs2strlen(instance->file_path);
                    if ((instance->file_path[(src_len-1)*ENCODING_LENGTH] != '\\') ||
                        (instance->file_path[(src_len-1)*ENCODING_LENGTH+1] != 0))
                    {
                        src_len = srv_fmgr_path_get_filename_pos((const WCHAR*)instance->file_path);
                    }
                
                    if (mmi_ucs2ncmp((S8*)instance->file_path, (S8*)adv_action->src_filepath, path_len) == 0)
                    {
                        if (src_len == path_len)
                        {
                            mmi_fmgri_instance_general_reset_index(instance);
                        }
                    }
            }
            break;

        case FMGRI_EVENT_SCREEN_ENTRY:
            break;
    
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_serv_browse_path_error_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_fmgri_main_error_handler(mmi_fmgr_instance_struct *instance, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (error)
    {
        case FS_MEDIA_CHANGED:
        case MMI_FMGR_ERROR_EMPTY:
        case FS_DRIVE_NOT_FOUND:
            if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)FMGR_PATH_ROOT)==0)
            {
                /* Popup top level error and quit */
            #ifdef __FS_CARD_SUPPORT__
                FMGR_DisplayPopup(STR_GLOBAL_INSERT_MEMORY_CARD, MMI_EVENT_FAILURE);
            #else /* __FS_CARD_SUPPORT__ */
                FMGR_DisplayPopup(STR_ID_FMGR_NO_AVAILABLE_STORAGE, MMI_EVENT_FAILURE);
            #endif /* __FS_CARD_SUPPORT__ */
                mmi_fmgri_instance_general_close(instance);
                return MMI_FALSE;
            }
            return MMI_TRUE;

    #ifdef __USB_IN_NORMAL_MODE__
        case MMI_FMGR_ERROR_USB_MODE:
            /* Popup top level error and quit */            
            mmi_usb_app_unavailable_popup(0);
            mmi_fmgri_instance_general_close(instance);
            return MMI_FALSE;
    #endif /* __USB_IN_NORMAL_MODE__ */

        case MMI_FMGR_ERROR_LOADING_CANCEL:
            if (instance->flag & FMGR_FLAG_BASEPATH && mmi_ucs2strlen(instance->file_path) <= (S32)instance->cust_data)
            {
                mmi_fmgri_instance_general_close(instance);
            }
            else
            {
                mmi_fmgri_instance_general_leave_folder(instance);
            }
            return MMI_FALSE;

        case FS_DEVICE_BUSY:
            /* Popup top level error and quit */
            FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(error), MMI_EVENT_FAILURE);
            mmi_fmgri_instance_general_close(instance);
            return MMI_FALSE;

        default:
            /* Popup error */
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(error), MMI_EVENT_FAILURE);
            switch (error)
            {
                case FS_TOO_MANY_FILES:
                case FS_PATH_OVER_LEN_ERROR:
                    mmi_fmgri_instance_general_leave_folder(instance);
                    break;
                default:
                    /* Move to Root */
                    mmi_fmgri_instance_general_back_to_root(instance);
                break;
            }
            return MMI_FALSE;
    }
}

static void mmi_fmgri_main_node_highlight_hdlr(mmi_fmgr_instance_struct *instance, S32 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT *file_info = NULL;
#ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
    fmgr_drive_info_struct *drv_info;
#endif
    S32 ret;
    U16 lsk_id;
#ifndef __MMI_WGUI_DISABLE_CSK__
    U16 csk_icon;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    lsk_id = 0;
#ifndef __MMI_WGUI_DISABLE_CSK__
    csk_icon = 0;
    
#ifdef __FMGR_KEY_RULE__
    csk_icon = IMG_GLOBAL_COMMON_CSK;
#endif /* __FMGR_KEY_RULE__ */
#endif
    file_info = OslMalloc(sizeof(FMGR_FILE_INFO_STRUCT));

    do {
        if (idx < 0)
        {
            if (FS_GetDevStatus(instance->file_path[0], FS_MOUNT_STATE_ENUM) == FS_NO_ERROR)
            {
        #ifndef __MMI_WGUI_DISABLE_CSK__
            #ifdef FMGR_TAB_SUPPORT
                if (srv_fmgr_fs_path_exist((WCHAR*)instance->file_path) < 0)     
                {
                    csk_icon = 0;                    
                }
                else
            #endif                    
        #endif                    
                {
                  #ifndef __MMI_BTD_BOX_UI_STYLE__
                    lsk_id = STR_ID_FMGR_NEW_FOLDER_LSK;
		  #else /*__MMI_BTD_BOX_UI_STYLE__*/
		    lsk_id = 0;
		  #endif /*__MMI_BTD_BOX_UI_STYLE__*/
                }
            }
        #ifndef __MMI_WGUI_DISABLE_CSK__
            else
            {
                /* lsk_id is 0, so csk_icon should be 0 too */
#ifdef __FMGR_KEY_RULE__
                csk_icon = 0;
#endif /* __FMGR_KEY_RULE__ */                
            }
        #endif
            break;
        }

        memset(file_info, 0, sizeof(FMGR_FILE_INFO_STRUCT));
        ret = mmi_fmgri_fsdata_instance_get_file_info_ex(instance->id, idx, file_info);
    #ifdef __FMGR_HYPERLINK_SUPPORT__
        if (ret >= 0 && FMGR_FILTER_IS_SET(&(file_info->file_type), FMGR_TYPE_HYPER_LINK))
        {
            /* Try to refresh hyper link info. Because Java may be busy before, but it is available now. */
            mmi_fmgri_instance_prepare_hyperlink(instance->id);
            lsk_id = STR_GLOBAL_OPTIONS;
        }
        else
    #endif /* __FMGR_HYPERLINK_SUPPORT__ */

        if (mmi_ucs2cmp(instance->file_path, (S8*)SRV_FMGR_PATH_ROOT) == 0)
        {
        #ifdef __FMGR_CUSTOM_ROOT_SUPPORT__
            drv_info = (fmgr_drive_info_struct*)file_info;
            if (drv_info->drv_type == FMGR_LINK_ITEM)
            {
                lsk_id = drv_info->lsk_string_id;  /* Drive */
#ifndef __MMI_WGUI_DISABLE_CSK__
#ifdef __FMGR_KEY_RULE__                
                if (lsk_id == STR_GLOBAL_OPTIONS)
                {
                    csk_icon = IMG_GLOBAL_OPTION_CSK;
                }
#endif
#endif
            }
            else if (drv_info->drv_type == FMGR_LINK_FOLDER)
            {
                lsk_id = STR_GLOBAL_OPEN;
            }
            else
        #endif /* __FMGR_CUSTOM_ROOT_SUPPORT__ */
            {
                lsk_id = STR_GLOBAL_OPTIONS;   /* Drive */
            }
        }
        else
        {
        #ifdef __FMGR_KEY_RULE__
        #ifndef __MMI_WGUI_DISABLE_CSK__
			/* If highlighted file is a bookmark, icon should be IMG_GLOBAL_WEB_BROWSER_CSK */
            if (FMGR_FILTER_IS_SET(&(file_info->file_type), FMGR_TYPE_URL))
            {
                csk_icon = IMG_GLOBAL_WEB_BROWSER_CSK;
            }
        #endif

            ret = fmgr_main_prepare_option(instance, file_info);
        #ifndef __MMI_WGUI_DISABLE_CSK__
            if ( ret > 0 && GetNumOfChild((U16)ret))
            {
                ret = GetSeqItemId((U16)ret, 0);
                if (mmi_frm_test_menu_item_hide((U16)ret) ||
                    GetNumOfChild(mmi_fmgri_get_menu_link((U16)ret)))
                {
                    csk_icon = IMG_GLOBAL_OPTION_CSK;
                }
            }
        #endif
        #endif /* __FMGR_KEY_RULE__ */
            lsk_id = STR_GLOBAL_OPTIONS;
        }
    } while(0);

    ChangeLeftSoftkey(lsk_id, 0);    
#ifndef __MMI_WGUI_DISABLE_CSK__
    ChangeCenterSoftkey(0, csk_icon);
#endif
    OslMfree(file_info);
}

#ifdef __FMGR_HYPERLINK_SUPPORT__
static MMI_BOOL mmi_fmgri_main_hyperlink_handler(mmi_fmgr_instance_struct *instance, 
                                      fmgr_hyperlink_action_enum action, 
                                      S32 para, S32* result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_hyperlink_callback cb;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cb = mmi_fmgri_table_get_hyperlink_callback(instance->app_id, instance->file_path);
    if (cb)
    {
        return cb(instance->app_id, instance->file_path, action, para, result);
    }
    return MMI_FALSE;
}
#endif /* __FMGR_HYPERLINK_SUPPORT__ */

static mmi_ret mmi_fmgri_main_event_proc_handler(mmi_fmgr_instance_struct *instance, mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_CUI_FOLDER_SELECTOR_RESULT:
            fmgr_main_copy_select_folder_done(instance, (cui_folder_selector_result_event_struct*)param);
            break;

    #ifdef __FMGR_USE_EDITOR_CUI__
        case EVT_ID_CUI_FILENAME_EDITOR_RESULT:
            mmi_fmgri_main_handle_editor_event(instance, param);
            break;
    #endif /* __FMGR_USE_EDITOR_CUI__ */
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
    #ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
        case EVT_ID_CUI_VERIFY_RESULT:
            {
                cui_verify_result_evt_struct *result_evt;

                result_evt = (cui_verify_result_evt_struct *)param;
                if (result_evt->success)
                {
                    /* Do something */                    
                    cui_verify_close(result_evt->sender_id);
                    fmgr_main_drive_action_hdlr();
                }               
            }
            break;
        case EVT_ID_CUI_VERIFY_CANCEL:
            {
                cui_verify_cancel_evt_struct *cancel_evt;

                cancel_evt = (cui_verify_cancel_evt_struct*)param;
				fmgr_main_p->client_id = 0;
                fmgr_main_p->client_action = FMGR_ACTION_NONE;
                cui_verify_close(cancel_evt->sender_id);                
            }
            break;
    #endif
#endif  /* __MMI_FMGR_HIDE_FORMAT_DRIVE__ */
    #if defined (__MMI_IMAGE_VIEWER__)
        case EVT_ID_IMGVIEW_CLOSE_GID:
            {
                mmi_group_event_struct *cui_evt;
                cui_evt = (mmi_group_event_struct*)param;
                fmgr_main_close_imgviewcui(instance, cui_evt->sender_id);
            }
            break;
    #endif
    }

    return MMI_RET_OK;
}

static S32 mmi_fmgri_main_command_hdlr(mmi_fmgr_instance_struct *instance, S32 cmd, S32 para, void* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_create_folder
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_create_folder(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(fmgr_main_p->new_file_name, 0, sizeof(fmgr_main_p->new_file_name));

    fmgr_main_start_filename_editor(instance, FMGR_ACTION_CREATE_FOLDER);
}


#if defined (__FS_CARD_SUPPORT__)
#ifndef __MMI_SLIM_FILE_MANAGER__
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_rename_drive
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_rename_drive(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmgr_drive_info_struct drv_info;
    S32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SET_UCS2STR_EMPTY(fmgr_main_p->new_file_name);

    fs_ret = mmi_fmgri_fsdata_instance_get_drive_info(instance->id, instance->cur_index, &drv_info);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
        return;
    }

    ASSERT(drv_info.drv_type == SRV_FMGR_DRV_CARD_TYPE ||
           drv_info.drv_type == SRV_FMGR_DRV_CARD_2_TYPE);

    fs_ret = srv_fmgr_drv_get_name((U8)drv_info.drv_path[0], (WCHAR *)fmgr_main_p->new_file_name, (SRV_FMGR_DRV_MAX_NAME_LEN + 1) * ENCODING_LENGTH);

    if (fs_ret < 0 && fs_ret != FS_NO_MORE_FILES)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
        {
	        return;
        }
    }

    fmgr_main_start_filename_editor(instance, FMGR_ACTION_RENAME_DRIVE);
}


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_rename_drive_done
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL fmgr_main_rename_drive_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmgr_drive_info_struct drv_info;
    S32 fs_ret;
    S8 *ptr;
#ifndef __FMGR_USE_EDITOR_CUI__
    S32 len;
#endif
    U16 error_str;
    MMI_BOOL close_editor;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Old name in fmgr_p->old_file_path, new name in fmgr_p->file_path */
    //ptr = (S8 *)srv_fmgr_path_skip_leading_space((WCHAR*)fmgr_main_p->new_file_name);
	ptr = (S8*)fmgr_main_p->new_file_name;

    do {
        error_str = 0;
        close_editor = MMI_FALSE;
        
    #ifdef __FMGR_USE_EDITOR_CUI__
        if (result < 0)
        {
            error_str = srv_fmgr_fs_error_get_string(result);
            break;
        }
    #else /* __FMGR_USE_EDITOR_CUI__ */
        /* checking */
        len = mmi_ucs2strlen(ptr);
    	if (len > SRV_FMGR_DRV_MAX_VOLUME_SIZE)
    	{
    	    error_str = FMGR_FS_PATH_OVER_LEN_ERROR_TEXT;
           break;
        }
        if (len == 0)
        {
            error_str = STR_GLOBAL_PLEASE_INPUT_THE_FILENAME;
            break;
        }

        if (FS_CheckVolumeLabel((WCHAR*)ptr) != FS_NO_ERROR)
        {
            error_str = FMGR_FS_INVALID_FILENAME_TEXT;
            break;
        }
    #endif /* __FMGR_USE_EDITOR_CUI__ */
    
        fs_ret = mmi_fmgri_fsdata_instance_get_drive_info(instance->id, instance->cur_index, &drv_info);

        if (fs_ret < 0)
        {
            error_str = srv_fmgr_fs_error_get_string(fs_ret);
            close_editor = MMI_TRUE;
            break;
        }

        ASSERT(drv_info.drv_type == SRV_FMGR_DRV_CARD_TYPE ||
           drv_info.drv_type == SRV_FMGR_DRV_CARD_2_TYPE);
        
        fs_ret = FS_SetVolumeLabel((U16*)drv_info.drv_path, (U16*)ptr);

        close_editor = MMI_TRUE;
        
        if (fs_ret == FS_NO_ERROR)
        {
            FMGR2_DisplayPopup(instance, STR_GLOBAL_DONE, MMI_EVENT_SUCCESS);    
        }
        else
        {
            error_str = srv_fmgr_fs_error_get_string(fs_ret);

            if (fs_ret == FS_INVALID_FILENAME)
            {
                /* User may rename again if "invalid name" popup */
                close_editor = MMI_FALSE;
            }
        }
    } while(0);

    if (error_str)
    {
        FMGR2_DisplayPopup(instance, error_str, MMI_EVENT_FAILURE);
    }

    return close_editor;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_entry_card_detail
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_entry_card_detail(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id), 
        SCR_FMGR_CARD_DETAIL, 
        (FuncPtr)fmgr_main_entry_card_detail, 
        (void*)instance->id);
}

#endif /* #if defined (__FS_CARD_SUPPORT__) */

#define MAIN_MISC

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_detail
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_detail(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id), 
        SCR_FMGR_DETAIL, 
        (FuncPtr)fmgr_main_entry_detail, 
        (void*)instance->id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_rename
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_rename(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    PS8 ext_name;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);
    
    mmi_ucs2cpy((PS8) fmgr_main_p->new_file_name, (PS8) file_info.file_name);

    /* Rename file: old name in fmgr_p->old_file_path */

    mmi_ucs2cpy((PS8) fmgr_main_p->old_file_path, (PS8) instance->file_path);

    if (!mmi_fmgri_filepath_compose(fmgr_main_p->old_file_path, (SRV_FMGR_PATH_MAX_LEN + 1),
              fmgr_main_p->old_file_path, &file_info, MMI_FALSE))
    {
        FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
        return;
    }

    fmgr_main_p->ext_name = NULL;

#ifdef __MMI_SHOW_FILE_EXT__
    if (!(file_info.attribute & FS_ATTR_DIR))
    {
        ext_name = (PS8)srv_fmgr_path_get_extension_ptr((WCHAR*)fmgr_main_p->new_file_name);

        /* Rename file should keep original extension filename in fmgr_p->ext_name
           and append after user input new name */
        if (ext_name != NULL)
        {
            *(ext_name - 2) = 0;
            fmgr_main_p->ext_name = (PS8)srv_fmgr_path_get_extension_ptr((WCHAR*)fmgr_main_p->old_file_path);
        }
        else
        {
            fmgr_main_p->ext_name = NULL;
        }
    }
#endif /* __MMI_SHOW_FILE_EXT__ */ 

    if (file_info.attribute & FS_ATTR_DIR)
    {
        fmgr_main_start_filename_editor(instance, FMGR_ACTION_RENAME_FOLDER);
    }
    else
    {
        fmgr_main_start_filename_editor(instance, FMGR_ACTION_RENAME_FILE);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_delete_single
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_delete_single(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_delete_confirm(instance, FMGR_ACTION_DELETE_SINGLE);
}

#ifndef __MMI_SLIM_FILE_MANAGER__
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_delete_all
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_delete_all(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 action;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (FMGR_FILTER_IS_SET(&instance->filter_type, FMGR_TYPE_ALL))
    {
        action = FMGR_ACTION_DELETE_ALL; 
    }
    else
    {
        action = FMGR_ACTION_DELETE_BY_FILTER;
    }

    fmgr_main_delete_confirm(instance, action);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_hint_sort
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_hint_sort(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 menu_id = 0, str_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __FS_SORT_SUPPORT__
    switch (srv_fmgr_sort_get())
    {
        case FS_SORT_NAME:
            menu_id = MENU_ID_FMGR_SORT_BY_NAME;
            break;
        case FS_SORT_SIZE:
            menu_id = MENU_ID_FMGR_SORT_BY_SIZE;
            break;
        case FS_SORT_TYPE:
            menu_id = MENU_ID_FMGR_SORT_BY_TYPE;
            break;
        case FS_SORT_TIME:
            menu_id = MENU_ID_FMGR_SORT_BY_TIME;
            break;
        default:
            menu_id = MENU_ID_FMGR_SORT_BY_NAME;
            break;
    }
#endif /* __FS_SORT_SUPPORT__ */

    str_id = GetStringIdOfItem(menu_id);
    if (str_id)
    {
        mmi_ucs2ncpy((S8*)hintData[index], (S8*)GetString(str_id), MAX_SUBMENU_CHARACTERS-1);
    }
    else
    {
        memset((S8*)hintData[index], 0, sizeof(hintData[index]));
    }
}

#if (!defined __MMI_FMGR_HIDE_FORMAT_DRIVE__) || (!defined __MMI_SLIM_FILE_MANAGER__)
mmi_ret mmi_fmgri_main_drive_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_YES:            
                fmgr_main_drive_action_hdlr();
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_frm_scrn_close_active_id();
                break;
        }
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_drive_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_drive_confirm(mmi_fmgr_instance_struct *instance, U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;
    S8 str[100*ENCODING_LENGTH];
    U16 stringId;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    switch (action)
    {
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
        case FMGR_ACTION_FORMAT:
        #if defined (__MMI_VECTOR_FONT_MEMORY_CARD_SUPPORT__) || \
                    defined (__MMI_FE_VECTOR_FONT_ON_FILE_SYSTEM) || \
                    defined (__MMI_IME_EMMORY_CARD_SUPPORT__) || \
                    defined (__MMI_HANDWRITING_MEMORY_CARD_SUPPORT__)
            stringId = STR_ID_FMGR_RESTART_CONTINUE;
        #elif (!defined(APP_STORAGE_IN_SYS_DRV)) && defined(__MMI_EMAIL__)
            stringId = STR_FMGR_FORMAT_CONFIRM;
        #else /* (!defined(APP_STORAGE_IN_SYS_DRV)) && defined(__MMI_EMAIL__) */
            stringId = STR_FMGR_FORMAT;
        #endif /* (!defined(APP_STORAGE_IN_SYS_DRV)) && defined(__MMI_EMAIL__) */
            break;
#endif
    #ifndef __MMI_SLIM_FILE_MANAGER__
        case FMGR_ACTION_UNMOUNT:
            stringId = STR_GLOBAL_REMOVE;
            break;
    #endif
        default:
            return;
    }

    fmgr_main_p->client_id = instance->id;
    fmgr_main_p->client_action = action;
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__    
#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
    if (action == FMGR_ACTION_FORMAT)
    {
        fmgr_main_start_phone_lock_confirm();
    }
    else
#endif /* __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__ */
#endif
    {
        mmi_ucs2cpy(str, (S8*)get_string(stringId));
        mmi_ucs2cat(str, (S8*)get_string(STR_ID_FMGR_QUESTION_MARK));
        FMGR_ASSERT(mmi_ucs2strlen(str) < 100);

        mmi_confirm_property_init(&arg, CNFM_TYPE_USER_DEFINE);
        arg.parent_id = mmi_fmgri_instance_get_screen_id(instance->id);
        arg.ctype = CNFM_TYPE_YESNO;
        arg.softkey[0].str = (WCHAR *)GetString(STR_GLOBAL_YES);
        arg.softkey[2].str = (WCHAR *)GetString(STR_GLOBAL_NO);
        arg.callback = (mmi_proc_func)mmi_fmgri_main_drive_confirm_cb;
        mmi_confirm_display((WCHAR *)str, MMI_EVENT_QUERY, &arg);
    }    

}
#endif

#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_can_modify_folder
 * DESCRIPTION
 *  Check if the highlighted folder can be modified or not
 * PARAMETERS
 *  const S8* path: highlighted folder path
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_fmgri_main_can_modify_folder(mmi_fmgr_instance_struct *instance, const S8* path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pathlen = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (fmgr_main_p->client_copy_action == FMGR_ACTION_COPY ||
        fmgr_main_p->client_copy_action == FMGR_ACTION_MOVE)
    {                               
        pathlen = mmi_ucs2strlen(path); 
        
        if ((path[(pathlen-1)*ENCODING_LENGTH] == '\\') &&
            (path[(pathlen-1)*ENCODING_LENGTH+1] == 0))
        {
            pathlen--;
        }
        
        if ((mmi_ucs2ncmp(instance->file_path, path, pathlen) == 0) &&
            (instance->file_path[pathlen*ENCODING_LENGTH] == 0) &&
            (instance->file_path[pathlen*ENCODING_LENGTH+1] == 0))
        {
            return MMI_FALSE;
        }
    }
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__    
    else if (fmgr_main_p->ms_id &&
             !fmgr_main_p->action_from_ms)
    {
        /* Check MSA */
        if (mmi_fmgri_msa_is_src_folder_for_compare_all(fmgr_main_p->ms_id, path))
        {
            return MMI_FALSE;
        }
    }
#endif
    return MMI_TRUE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_copy
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_copy(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_entry_copy(instance, FMGR_ACTION_COPY);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_move
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_move(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_entry_copy(instance, FMGR_ACTION_MOVE);
}

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
void mmi_fmgr_general_option_mul_sel_handler(mmi_menu_id item_id, const WCHAR *filepath, const srv_fmgr_fileinfo_struct *fileinfo)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct* instance;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	instance = (mmi_fmgr_instance_struct*)mmi_fmgri_get_instance_by_id(fmgr_main_p->mul_sel_inst_id);

	mmi_fmgri_main_mark_several(instance, item_id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_mark_several
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_several(mmi_fmgr_instance_struct *instance, U16 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILTER filter;
    FMGR_FILE_INFO_STRUCT file_info;
    S8 *curr_filename;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    filter = instance->filter_type;
    curr_filename = NULL;
    if (mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info) >= 0)
    {
        curr_filename = file_info.file_name;
    }

	switch(action)
	{
		case MENU_ID_FMGR_GEN_OPTION_MARK_COPY:
		case MENU_ID_FMGR_GEN_OPTION_MARK_MOVE:
	#ifndef __MMI_FMGR_FOLDER_COPY_SUPPORT__
			FMGR_FILTER_CLEAR(&filter, FMGR_TYPE_FOLDER);
	#endif
			break;
		case MENU_ID_FMGR_GEN_OPTION_MARK_DELETE:
			break;
#if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
		case MENU_ID_FMGR_GEN_OPTION_MARK_PRINT:
			break;
#endif
#ifdef __MMI_OPP_SUPPORT__
		case MENU_ID_FMGR_MARK_OPTION_TO_BT:
			break;
#endif
	}
    fmgr_main_p->ms_caller_instance = instance;
	fmgr_main_p->ms_id = mmi_fmgri_serv_multi_sel_internal(
												mmi_fmgri_instance_get_screen_id(instance->id),
                                               instance->app_id, 
												action,
                                               &filter,
                                               instance->file_path, 
                                               fmgr_main_mark_several_close_callback, 
												MENU_ID_FMGR_GEN_OPTION_MARK_OPTION,
												curr_filename,
												instance->id
												);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_mark_delete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_delete(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_delete_confirm(instance, FMGR_ACTION_MARK_DELETE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_mark_copy
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_copy(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_entry_copy(instance, FMGR_ACTION_MARK_COPY);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_mark_move
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_move(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_entry_copy(instance, FMGR_ACTION_MARK_MOVE);
}


#if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_mark_print
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_print(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* clear end key handler */    
    ClearInputEventHandler(MMI_DEVICE_ALL);
    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);
    
    fmgr_main_print_mark(instance);
    mmi_fmgri_close_options(instance->id);
        
}
#endif /* #ifndef __MMI_PICT_BRIDGE_MULTI_FILE_PRINT__*/

#ifdef __MMI_OPP_SUPPORT__
mmi_ret mmi_fmgri_main_mark_send_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_YES:
                fmgr_main_send_mark();
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_frm_scrn_close_active_id();
                break;
        }
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_mark_send(mmi_fmgr_instance_struct *instance, U16 menu_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 str_id = 0;
    mmi_confirm_property_struct arg;
    S32 msa_id, send_count, folder_count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(fmgr_main_p->ms_id);
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
    FMGR_ASSERT(msa_id >= 0);

    /* if support other than BT, need to store the menu id here */
#ifdef __MMI_OPP_SUPPORT__    
    if(menu_id != MENU_ID_FMGR_MARK_OPTION_TO_BT)
    {
        FMGR2_DisplayPopup(instance, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }
#endif    

    // clear all processed flag
    mmi_fmgri_msa_set_flags(msa_id, MMI_FMGRI_MSA_PROCESSED, 0, MMI_FMGRI_MSA_PROCESSED);
    
    // check DRM 
    send_count = mmi_fmgri_msa_count_filter(msa_id, MMI_FMGRI_MSA_SENDABLE);
    folder_count = mmi_fmgri_msa_count_filter(msa_id, MMI_FMGRI_MSA_FOLDER);
    if(send_count == 0)
    {
        FMGR2_DisplayPopup(instance, STR_ID_FMGR_MARK_ALL_PROTECTED, MMI_EVENT_FAILURE);
    }
    else if(send_count == folder_count)
    {
        /* Only files can be sent. Folders can't be sent */
        FMGR2_DisplayPopup(instance, STR_ID_FMGR_MARK_ALL_CAN_NOT_SEND, MMI_EVENT_FAILURE);
    }
    else if (send_count != mmi_fmgri_msa_count(msa_id) &&
             send_count == folder_count)
    {
        FMGR2_DisplayPopup(instance, STR_ID_FMGR_MARK_ALL_CAN_NOT_SEND, MMI_EVENT_FAILURE);
    }
    else if (send_count != mmi_fmgri_msa_count(msa_id) &&
             folder_count > 0 &&
             folder_count < send_count)
    {
        str_id = STR_ID_FMGR_MARK_ALL_CAN_NOT_SEND_CONFIRM;   
    }
    else if(send_count != mmi_fmgri_msa_count(msa_id))
    {
        str_id = STR_ID_FMGR_MARK_PARTIAL_PROTECTED_CONFIRM;
    }
    else if(folder_count > 0)
    {
        str_id = STR_ID_FMGR_MARK_PARTIAL_FOLDERS_CONFIRM;
    }
    else
    {
        // do the send
        fmgr_main_send_mark();
    }

    if (str_id != 0)
    {
        mmi_confirm_property_init(&arg, CNFM_TYPE_USER_DEFINE);
        arg.ctype = CNFM_TYPE_YESNO;
        arg.softkey[0].str = (WCHAR *)GetString(STR_GLOBAL_YES);
        arg.softkey[2].str = (WCHAR *)GetString(STR_GLOBAL_NO);
        arg.callback = (mmi_proc_func)mmi_fmgri_main_mark_send_confirm_cb;
        mmi_confirm_display((WCHAR *)GetString(str_id), MMI_EVENT_QUERY, &arg);
    }
}
#endif

#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_cancel_operation
 * DESCRIPTION
 *  cancel current operation, such as rename/new folder/delete/copy/move
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_fmgri_main_cancel_operation(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_TRACE3(TRC_MMI_FMGR_2825C90702534307AB7CF5C3B8D2A746,
        "[MMIFMGR] > Main > mmi_fmgri_main_cancel_operation(%d) > current client_id=%d, client_copy_id=%d\n",
        instance->id, fmgr_main_p->client_id, fmgr_main_p->client_copy_id);

    grp_id = mmi_fmgri_instance_get_screen_id(instance->id);

    /* Send / Use / Sort by */
    mmi_fmgri_close_options(instance->id);

    /* Detail */
	if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT) != 0)
	{
		/* If this is not memory status screen, close it */
		mmi_frm_scrn_close(grp_id, SCR_FMGR_DETAIL);
	}

#if defined (__FS_CARD_SUPPORT__)
    /* Card detail */
    mmi_frm_scrn_close(grp_id, SCR_FMGR_CARD_DETAIL);
#endif

#ifndef __FMGR_USE_EDITOR_CUI__
    /* Rename / Create folder */
    /* ime screens may follow editor (when user press * directly) */
    mmi_ime_delete_editor_common_scr_with_sg(grp_id, SCR_FMGR_FILENAME_EDITOR);
    mmi_frm_scrn_close(grp_id, SCR_FMGR_FILENAME_EDITOR);
#else /* __FMGR_USE_EDITOR_CUI__ */
    cui_filename_editor_close(fmgr_main_p->editor_cui_id);
    fmgr_main_p->editor_cui_id = 0;
#endif /* __FMGR_USE_EDITOR_CUI__ */

#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__
    mmi_frm_scrn_close(grp_id, SCR_FMGR_PHONE_LOCK_VERIFY);
#endif

#if defined (__MMI_SLIM_FILE_MANAGER__) && defined (__MMI_IMAGE_VIEWER__)
    if (fmgr_main_p->imageviewer_cui_id != GRP_ID_INVALID)
    {
        cui_imgview_close(fmgr_main_p->imageviewer_cui_id);
        fmgr_main_p->imageviewer_cui_id = GRP_ID_INVALID;
    }
#endif

    if (instance->id == fmgr_main_p->client_id)
    {
        fmgr_main_p->client_id = 0;
        fmgr_main_p->client_action = FMGR_ACTION_NONE;
    }

    /* Copy / Move */
    if (instance->id == fmgr_main_p->client_copy_id)
    {
        switch (fmgr_main_p->client_copy_action)
        {
        case FMGR_ACTION_COPY:
        case FMGR_ACTION_MOVE:
            srv_fmgr_path_remove_filename((WCHAR*)instance->file_path);
            /* No break */
        case FMGR_ACTION_MARK_COPY:
        case FMGR_ACTION_MARK_MOVE:
            if (fmgr_main_p->client_copy_sel_id)
            {
                mmi_frm_group_close(fmgr_main_p->client_copy_sel_id);
                fmgr_main_p->client_copy_sel_id = 0;
            }
            break;

        default:
            FMGR_ASSERT(0);
            break;
        }
        
        fmgr_main_p->client_copy_id = 0;
        fmgr_main_p->client_copy_action = FMGR_ACTION_NONE;
    }
}


#define LOCAL_FUNCTION

/****************************************************************************
 *****************************************************************************
 * Local Function
 *****************************************************************************
 *****************************************************************************/
#if defined (__MMI_IMAGE_VIEWER__)
static void fmgr_main_run_imgviewcui(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id cui_id = GRP_ID_INVALID;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_id = cui_imgview_create(mmi_fmgri_instance_get_screen_id(instance->id));
    if (cui_id != GRP_ID_INVALID)
    {
        fmgr_main_p->imageviewer_cui_id = cui_id;
        cui_imgview_set_mode_filelist(cui_id, mmi_fmgri_fsdata_lock_file_list(), instance->cur_index);
        cui_imgview_set_display_cap(cui_id, CUI_IMGVIEW_CAP_ALL, MMI_TRUE);
        cui_imgview_run(cui_id);
    }
}

static void fmgr_main_close_imgviewcui(mmi_fmgr_instance_struct *instance, mmi_id sender)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 new_index = -1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (fmgr_main_p->imageviewer_cui_id == sender)
    {
        new_index = cui_imgview_get_cur_index(sender);
        mmi_fmgri_instance_general_set_search_filename(instance, (CHAR*)cui_imgview_get_cur_filename(sender));
        mmi_fmgri_fsdata_unlock_file_list();
        cui_imgview_close(fmgr_main_p->imageviewer_cui_id);
        fmgr_main_p->imageviewer_cui_id = GRP_ID_INVALID;
        if (new_index >= 0)
        {
            mmi_fmgri_instance_general_refresh(instance);
            mmi_fmgri_main_cancel_operation(instance);
        }
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_options_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 fmgr_main_options_handler(U16 opt_menu_id, U16 menu_id, U32 data, U16 keyCode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    FMGR_FILE_INFO_STRUCT *file_info = NULL;
    S32 result;
    MMI_BOOL no_match = MMI_FALSE;
#ifndef __FMGR_USE_EDITOR_CUI__    
    MMI_BOOL close_editor;
    U8 action;
    U32 user_data;
#endif /* __FMGR_USE_EDITOR_CUI__ */
#ifdef __FMGR_HYPERLINK_SUPPORT__
    mmi_fmgr_hyperlink_info_struct info;
#endif /* __FMGR_HYPERLINK_SUPPORT__ */
    S8* buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (menu_id == 0)
    {
        return 0;
    }

    /* Do general option first */
    result = mmi_fmgri_instance_general_option_handler(opt_menu_id, menu_id, data, keyCode);

    if (result >= 0)
    {
        return (U16)result;
    }

    file_info = OslMalloc(sizeof(FMGR_FILE_INFO_STRUCT));
    memset(file_info, 0, sizeof(FMGR_FILE_INFO_STRUCT));

    instance = mmi_fmgri_get_instance_by_id((U8)data);
    mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, file_info);
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
	fmgr_main_p->mul_sel_inst_id = data;
#endif

    switch (menu_id)
    {
        case MENU_ID_FMGR_DRIVE_OPEN:
        case MENU_ID_FMGR_FOLDER_OPEN:
            mmi_fmgri_instance_general_enter_folder(instance);
            mmi_fmgri_close_option(opt_menu_id, data);            
            break;
        case MENU_ID_FMGR_FOLDER_CREATE:
            mmi_fmgri_main_create_folder(instance);
            mmi_fmgri_close_option(opt_menu_id, data); 
            break;
    #ifndef __FMGR_USE_EDITOR_CUI__        
        case MENU_ID_FMGR_EDITOR_DONE:
            user_data = (U32)mmi_frm_scrn_get_user_data(mmi_fmgri_instance_get_screen_id(instance->id), SCR_FMGR_FILENAME_EDITOR);
            action = (U8)((((U32)user_data)>>16)&0xFF);
            
            switch (action)
            {
                case FMGR_ACTION_CREATE_FOLDER:
                    close_editor = fmgr_main_create_folder_done(instance, action, 0, 0);
                    break;

                case FMGR_ACTION_RENAME_FILE:
                case FMGR_ACTION_RENAME_FOLDER:
                    close_editor = fmgr_main_rename_done(instance, action, 0, 0);
                    break;

            #ifdef __FS_CARD_SUPPORT__
            #ifndef __MMI_SLIM_FILE_MANAGER__
                case FMGR_ACTION_RENAME_DRIVE:
	             close_editor = fmgr_main_rename_drive_done(instance, action, 0, 0);
                    break;
            #endif
            #endif /* __FS_CARD_SUPPORT__ */

                default:
                    close_editor = MMI_TRUE;
                    break;
            }

            if (close_editor)
            {
                mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance->id), SCR_FMGR_FILENAME_EDITOR);
            }
            mmi_fmgri_close_options(data);
            break;
    #endif /* __FMGR_USE_EDITOR_CUI__ */
    #ifdef __FS_SORT_SUPPORT__
        case MENU_ID_FMGR_SORT_BY_NAME:
        case MENU_ID_FMGR_SORT_BY_TYPE:
        case MENU_ID_FMGR_SORT_BY_TIME:
        case MENU_ID_FMGR_SORT_BY_SIZE:
            fmgr_main_set_sort(menu_id, instance);  
            /* Since last screen is list screen, it should be closed when LSK be done. */ 
            mmi_fmgri_close_options(data);
            break;
    #endif /* __FS_SORT_SUPPORT__ */
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
        case MENU_ID_FMGR_DRIVE_FORMAT:
            mmi_fmgri_main_drive_confirm(instance, FMGR_ACTION_FORMAT);            
            mmi_fmgri_close_option(opt_menu_id, data); 
            break;
#endif
    #ifndef __MMI_SLIM_FILE_MANAGER__
        case MENU_ID_FMGR_DRIVE_UNMOUNT:
            mmi_fmgri_main_drive_confirm(instance, FMGR_ACTION_UNMOUNT);            
            mmi_fmgri_close_option(opt_menu_id, data); 
            break;
    #endif
        case MENU_ID_FMGR_EDITOR_INPUT_METHOD:
            /* This API will create new screen in current group, which is option group */
            EntryInputMethodScreen();            
            break;
    #ifdef __DRM_V02__
        case MENU_ID_FMGR_DRM_OPTION_MUL_ODF_OPEN:
            mmi_fmgri_instance_general_enter_folder(instance);           
            mmi_fmgri_close_option(opt_menu_id, data);
            break;
    #endif /* __DRM_V02__ */
    #ifdef __FS_CARD_SUPPORT__
    #ifndef __MMI_SLIM_FILE_MANAGER__
        case MENU_ID_FMGR_DRIVE_RENAME:
            mmi_fmgri_main_rename_drive(instance);
            mmi_fmgri_close_option(opt_menu_id, data); 			
            break;
    #endif
        case MENU_ID_FMGR_CARD_DETAIL:
            mmi_fmgri_main_entry_card_detail(instance);
            mmi_fmgri_close_option(opt_menu_id, data); 						
            break;
    #endif /* __FS_CARD_SUPPORT__ */
    #ifdef __FMGR_HYPERLINK_SUPPORT__
        case MENU_ID_FMGR_HYPERLINK_APP_FUNC:
            if (!FMGR_FILTER_IS_SET(&(file_info->file_type), FMGR_TYPE_HYPER_LINK))
            {
                break;
            }
            mmi_fmgri_instance_get_hyperlink_info(instance->id, instance->cur_index, &info);

            if (info.lsk_handler)
            {
                buffer = mmi_fmgri_get_and_lock_buffer();
                mmi_ucs2cpy(buffer, instance->file_path);
                mmi_fmgri_query_result_setup(buffer, file_info, instance->app_id);
                info.lsk_handler();
                mmi_fmgri_query_result_clear();
                mmi_fmgri_free_and_unlock_buffer(buffer);
            }
            mmi_fmgri_close_option(opt_menu_id, data);
            break;
    #endif /* __FMGR_HYPERLINK_SUPPORT__ */
    #if defined (__MMI_IMAGE_VIEWER__)
        case MENU_ID_IMGVIEW_OPTION_IMG_VIEW:
            /* Call image viewer CUI to view image */
            fmgr_main_run_imgviewcui(instance);
            break;
    #endif
        default:
            no_match = MMI_TRUE;
            break;
    }

    /* No matched general menu id, use the default hdlr */
    if (no_match == MMI_TRUE)
    {
        buffer = mmi_fmgri_get_and_lock_buffer();
        if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), instance->file_path, file_info, MMI_FALSE) ||
            (srv_fmgr_types_launch_option((WCHAR *)buffer, menu_id) <= 0))
        {
            //FMGR_ASSERT(0);
        }
        mmi_fmgri_free_and_unlock_buffer(buffer);
    }

    OslMfree(file_info);
    return 0;
}

#define MAINL_EDITOR

static void fmgr_main_start_filename_editor(mmi_fmgr_instance_struct *instance, U32 action)
{
#ifdef __FMGR_USE_EDITOR_CUI__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL encoding_base_length = MMI_FALSE;
    U16 string_id, icon_id;
    S32 max_length;
    WCHAR *path, *ext;
    mmi_id editor_id;
#else /* __FMGR_USE_EDITOR_CUI__ */
    extern void fmgr_main_entry_filename_editor(mmi_scrn_essential_struct*);
    U32 user_data;
#endif /* __FMGR_USE_EDITOR_CUI__ */
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __FMGR_USE_EDITOR_CUI__
    path = ext = NULL;
    switch (action)
    {
    #ifdef __FS_CARD_SUPPORT__
    #ifndef __MMI_SLIM_FILE_MANAGER__
        case FMGR_ACTION_RENAME_DRIVE:
            max_length = (SRV_FMGR_DRV_MAX_VOLUME_SIZE - 1);
            string_id = STR_ID_FMGR_CARD_NAME;
            encoding_base_length = MMI_TRUE;
            break;
    #endif
    #endif /* __FS_CARD_SUPPORT__ */
        case FMGR_ACTION_RENAME_FOLDER:
        case FMGR_ACTION_CREATE_FOLDER:
            max_length = SRV_FMGR_PATH_MAX_FILE_NAME_LEN;
            string_id = STR_ID_FMGR_FOLDER_NAME;
            path = (WCHAR*)instance->file_path;
            break;
        case FMGR_ACTION_RENAME_FILE:
            max_length = SRV_FMGR_PATH_MAX_FILE_BASENAME_LEN;
            string_id = STR_GLOBAL_FILENAME;
            path = (WCHAR*)instance->file_path;
            ext = (WCHAR *)fmgr_main_p->ext_name;
            break;
        
        default:
            FMGR_ASSERT(0);
            return;
    }


    mmi_fmgri_instance_get_title_info(instance->id, NULL, &icon_id);
    
    editor_id = cui_filename_editor_create(mmi_fmgri_instance_get_screen_id(instance->id),
                         (WCHAR*)fmgr_main_p->new_file_name,
                         sizeof(fmgr_main_p->new_file_name),
                         max_length, path, ext);
    cui_filename_editor_set_title(editor_id, string_id, icon_id);
    cui_filename_editor_set_parent_data(editor_id, action);
	cui_filename_editor_set_rename_type(editor_id, action);
    cui_filename_editor_set_encoding_base_length(editor_id, encoding_base_length);
    cui_filename_editor_run(editor_id);
    fmgr_main_p->editor_cui_id = editor_id;
#else /* __FMGR_USE_EDITOR_CUI__ */
    user_data = (action << 16) | instance->id;
    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id), 
        SCR_FMGR_FILENAME_EDITOR,
        (FuncPtr)fmgr_main_entry_filename_editor,
        (void*)user_data);
#endif /* __FMGR_USE_EDITOR_CUI__ */
}

#ifndef __FMGR_USE_EDITOR_CUI__
/*****************************************************************************
 * FUNCTION
 *  fmgr_main_entry_filename_editor
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_entry_filename_editor(mmi_scrn_essential_struct* info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    FMGR_FILE_INFO_STRUCT file_info;
    S32 length;
    S32 flag;
    S8 *buffer;
    U16 icon_id, title_str_id;
    U8 instance_id;
    U8 action;
    U32 input_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_TRACE1(TRC_MMI_FMGR_4783A0C3C8D44767A509BC48ABF4DEC5,
        "[MMIFMGR] > Main > fmgr_main_entry_filename_editor > data==0x%08X\n",
        (U32)info->user_data);
    instance_id = (U8)(((U32)info->user_data) & 0xFF);
    action = (U8)((((U32)info->user_data)>>16) & 0xFF);
    instance = mmi_fmgri_get_instance_by_id(instance_id);

    if (!mmi_frm_scrn_enter(
             mmi_fmgri_instance_get_screen_id(instance->id), 
             SCR_FMGR_FILENAME_EDITOR, 
             NULL, (FuncPtr)fmgr_main_entry_filename_editor, 0))
    {
        return;
    }

    if (action == FMGR_ACTION_CREATE_FOLDER)
    {
        flag = FMGR_IS_FOLDER;
    }
    else
    {
        mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info); 
        buffer = mmi_fmgri_get_and_lock_buffer();
        if (mmi_ucs2cmp((PS8)instance->file_path, (PS8)SRV_FMGR_PATH_ROOT)==0)
        {
            mmi_ucs2cpy(buffer, file_info.file_name);
        }
        else
        {
            if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1),
                     instance->file_path, &file_info, MMI_FALSE))
            {
                FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
                mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance->id), SCR_FMGR_FILENAME_EDITOR);
                mmi_fmgri_free_and_unlock_buffer(buffer);
                return;
            }
        }
        /* Create under folder or rename, check folder present or not */
        flag = srv_fmgr_fs_path_exist((WCHAR*)buffer);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        
        if (flag < 0)
        {
            if s(flag == FS_FILE_NOT_FOUND && (file_info.attribute & FS_ATTR_DIR))
            {
                flag = FS_PATH_NOT_FOUND;
            }
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(flag), MMI_EVENT_FAILURE);
            mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance->id), SCR_FMGR_FILENAME_EDITOR);
            return;
        }
    }

#ifdef __FS_CARD_SUPPORT__
#ifndef __MMI_SLIM_FILE_MANAGER__
    if (action == FMGR_ACTION_RENAME_DRIVE)
    {
        length = SRV_FMGR_DRV_MAX_VOLUME_SIZE + 1;
        title_str_id = STR_ID_FMGR_CARD_NAME;
        input_type = IMM_INPUT_TYPE_SENTENCE;
    }
    else
#endif
#endif /* __FS_CARD_SUPPORT__ */
    {
        if (flag == FMGR_IS_FILE)
        {
            length = FMGR_MAX_INPUT_FILE_LEN;
            title_str_id = STR_GLOBAL_FILENAME;
            input_type = IMM_INPUT_TYPE_SENTENCE;
        }
        else
        {
            length = SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1;
            title_str_id = STR_ID_FMGR_FOLDER_NAME;
            input_type = IMM_INPUT_TYPE_SENTENCE;
        }
    }

    if (mmi_ucs2strlen((PS8) fmgr_main_p->new_file_name) >= length)
    {
        memset(&fmgr_main_p->new_file_name[(length - 1) << 1], 0, sizeof(fmgr_main_p->new_file_name) - ((length - 1) << 1));
    }

    mmi_fmgri_instance_get_title_info(instance_id, NULL, &icon_id);

    ShowCategory5Screen(
        title_str_id,
        icon_id,
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        input_type,
        (PU8) fmgr_main_p->new_file_name,
        length,
        mmi_frm_scrn_get_active_gui_buf());

    SetLeftSoftkeyFunction(fmgr_main_entry_editor_option, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_entry_editor_option
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_entry_editor_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct* instance;
    U16 icon_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    instance = mmi_fmgri_get_active_instance();
    mmi_fmgri_instance_get_title_info(instance->id, NULL, &icon_id);
    mmi_fmgri_show_edit_option(mmi_fmgri_instance_get_screen_id(instance->id), 
        MENU_ID_FMGR_EDITOR_OPTION, fmgr_main_options_handler, 
        instance->id, icon_id, fmgri_main_return_to_editor);
}


/*****************************************************************************
 * FUNCTION
 *  fmgri_main_return_to_editor
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgri_main_return_to_editor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    grp_id = mmi_frm_group_get_active_id();
    /* should be a option group */
    mmi_frm_group_close(grp_id);
}
#else /* __FMGR_USE_EDITOR_CUI__ */
void mmi_fmgri_main_handle_editor_event(mmi_fmgr_instance_struct *instance, mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 action;
    MMI_BOOL close_editor;
    cui_filename_editor_result_event_struct *evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(param->evt_id)
    {
        case EVT_ID_CUI_FILENAME_EDITOR_RESULT:
            evt = (cui_filename_editor_result_event_struct*)param;

            close_editor = MMI_TRUE;
            if (evt->result != 0)
            {
                action = (U8)cui_filename_editor_get_parent_data(evt->sender_id);
            
                switch (action)
                {
                    case FMGR_ACTION_CREATE_FOLDER:
                        close_editor = fmgr_main_create_folder_done(instance, action, evt->result, evt->sender_id);
                        break;

                    case FMGR_ACTION_RENAME_FILE:
                    case FMGR_ACTION_RENAME_FOLDER:
                        close_editor = fmgr_main_rename_done(instance, action, evt->result, evt->sender_id);
                        break;

                #ifdef __FS_CARD_SUPPORT__
                #ifndef __MMI_SLIM_FILE_MANAGER__
                    case FMGR_ACTION_RENAME_DRIVE:
                        close_editor = fmgr_main_rename_drive_done(instance, action, evt->result, evt->sender_id);
                        break;
                #endif
                #endif /* __FS_CARD_SUPPORT__ */
                }
            }

            if (close_editor)
            {
                fmgr_main_p->editor_cui_id = 0;
                cui_filename_editor_close(evt->sender_id);
            }
            break;
    }

    return;
}
#endif /* __FMGR_USE_EDITOR_CUI__ */

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_create_folder_done
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL fmgr_main_create_folder_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __FMGR_USE_EDITOR_CUI__
    S32 len;
#endif /* __FMGR_USE_EDITOR_CUI__ */
    S32 fs_ret;
    S8 *ptr;
    S8 *buffer;
    U16 error_str;
    MMI_BOOL close_editor;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    do {
        error_str = 0;
        close_editor = MMI_FALSE;
        buffer = NULL;

    #ifdef __FMGR_USE_EDITOR_CUI__
        if (result < 0)
        {
            error_str = srv_fmgr_fs_error_get_string(result);
            break;
        }
        ptr = fmgr_main_p->new_file_name;
    #else /* __FMGR_USE_EDITOR_CUI__ */
        ptr = srv_fmgr_path_skip_leading_space((WCHAR*)fmgr_main_p->new_file_name);

        if (ptr != fmgr_main_p->new_file_name)
        {
            error_str = FMGR_FS_INVALID_FILENAME_TEXT;
            break;
        }

        len = mmi_ucs2strlen(ptr);

        /* Check new name */
        if (len == 0)
        {
            error_str = STR_GLOBAL_PLEASE_INPUT_THE_FILENAME;
            break;
        }

        if ((ptr[0] == '.') ||
            !srv_fmgr_path_is_filename_valid((const WCHAR*)fmgr_main_p->new_file_name ))
        {
            error_str = FMGR_FS_INVALID_FILENAME_TEXT;
            break;
        }
    #endif /* __FMGR_USE_EDITOR_CUI__ */

        buffer = mmi_fmgri_get_and_lock_buffer();
        mmi_ucs2cpy(buffer, instance->file_path);

        /* Check base folder/drive exist or not */
        if (srv_fmgr_fs_path_exist((WCHAR*)buffer) < 0)
        {
            error_str = FMGR_FS_PATH_NOT_FOUND_TEXT;
            close_editor = MMI_TRUE;
            break;
        }

    #ifndef __FMGR_USE_EDITOR_CUI__
        if (mmi_ucs2strlen((PS8) buffer) + mmi_ucs2strlen(ptr) + 1 >= SRV_FMGR_PATH_MAX_LEN - 10)
        {
            error_str = FMGR_FS_PATH_OVER_LEN_ERROR_TEXT;
            break;
        }
    #endif /* __FMGR_USE_EDITOR_CUI__ */
        mmi_ucs2cat(buffer, ptr);        

        fs_ret = srv_fmgr_fs_create_folder((WCHAR*) buffer);

        if (fs_ret == FS_NO_ERROR)
        {
            /* Success, highlight on this new folder */
            mmi_fmgri_instance_general_set_search_filename(instance, (S8*)srv_fmgr_path_get_filename_ptr((WCHAR*)buffer));
            close_editor = MMI_TRUE;
        }
        else
        {
            /* Fail */
            error_str = srv_fmgr_fs_error_get_string(fs_ret);
        }
        
    } while (0);

    if (buffer)
    {
        mmi_fmgri_free_and_unlock_buffer(buffer);
    }

    if (error_str)
    {
        FMGR2_DisplayPopup(instance, error_str, MMI_EVENT_FAILURE);
    }

    return close_editor;
}


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_rename_done
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL fmgr_main_rename_done(mmi_fmgr_instance_struct *instance, U8 action, S32 result, mmi_id editor_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 error_str;
    MMI_BOOL close_editor;
#ifdef __FMGR_USE_EDITOR_CUI__
    S32 fs_ret;
    S8 *buffer;
#else /* __FMGR_USE_EDITOR_CUI__ */
    FMGR_FILE_INFO_STRUCT file_info;
    S32 fs_ret;
    S8  *ptr;
    S32 len;
    U16 max_len = SRV_FMGR_PATH_MAX_LEN + 1;
    S8  ext_buffer[(SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH];
#endif /* __FMGR_USE_EDITOR_CUI__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __FMGR_USE_EDITOR_CUI__
    do {
        error_str = 0;
        close_editor = MMI_FALSE;
        buffer = NULL;

        /* if file exist due to name not changed, it is success */
        if (result == FS_FILE_EXISTS)
        {
            /* Check the original name */
            buffer = mmi_fmgri_get_and_lock_buffer();
            cui_filename_editor_get_fullpath(editor_id, (WCHAR*)buffer, SRV_FMGR_PATH_BUFFER_SIZE);
            if (!mmi_wcscmp((WCHAR*)buffer, (WCHAR*)fmgr_main_p->old_file_path))
            {
                close_editor = MMI_TRUE;
                break;
            }
        }
        else if (result < 0)
        {
            error_str = srv_fmgr_fs_error_get_string(result);
            break;
        }

        if (!buffer)
        {
            buffer = mmi_fmgri_get_and_lock_buffer();
            cui_filename_editor_get_fullpath(editor_id, (WCHAR*)buffer, SRV_FMGR_PATH_BUFFER_SIZE);
        }

        fs_ret = srv_fmgr_fs_rename((WCHAR *)fmgr_main_p->old_file_path, (WCHAR *)buffer);

        if (fs_ret == 0)
        {
            if (!mmi_wcscmp((WCHAR*)buffer, (WCHAR*)fmgr_main_p->old_file_path))
            {
                close_editor = MMI_TRUE;
                break;
            }
            
            fs_ret = mmi_fmgri_fsdata_instance_get_total_count(instance->id);

            /* Move selection to first */
            mmi_fmgri_instance_general_reset_index(instance);

            /* Search for new name */
            mmi_fmgri_instance_general_set_search_filename(instance, 
                (S8*)srv_fmgr_path_get_filename_ptr((WCHAR*)buffer));

            close_editor = MMI_TRUE;
        }
        else
        {
            /* Fail */
            error_str = srv_fmgr_fs_error_get_string(fs_ret);

            if (fs_ret == FS_ACCESS_DENIED)
            {
                /* Input any name doesn't help, quit editor */
                close_editor = MMI_TRUE;
            }
        }
    } while(0);

    if (buffer)
    {
        mmi_fmgri_free_and_unlock_buffer(buffer);
    }

    if (error_str)
    {
        FMGR2_DisplayPopup(instance, error_str, MMI_EVENT_FAILURE);
    }

    return close_editor;

#else /* __FMGR_USE_EDITOR_CUI__ */

    do {
        error_str = 0;
        close_editor = MMI_FALSE;
        
        if ((fs_ret = srv_fmgr_fs_path_exist((WCHAR*)instance->file_path)) < 0)
        {
            error_str = srv_fmgr_fs_error_get_string(fs_ret);
            close_editor = MMI_TRUE;
            break;
        }

        mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);

        /* Rename file: old name in fmgr_p->old_file_path, new name in fmgr_p->file_path */
        ptr = srv_fmgr_path_skip_leading_space((WCHAR*)fmgr_main_p->new_file_name);
        
        if (ptr != fmgr_main_p->new_file_name)
        {
            error_str = FMGR_FS_INVALID_FILENAME_TEXT;
            break;
        }
        
        len = mmi_ucs2strlen(ptr);
        if (len == 0)
        {
            error_str = STR_GLOBAL_PLEASE_INPUT_THE_FILENAME;
            break;
        }
    	
        if (srv_fmgr_path_is_filename_valid((const WCHAR*)ptr) == MMI_FALSE)
        {
            error_str = FMGR_FS_INVALID_FILENAME_TEXT;
            break;
        }

        if (mmi_ucs2strlen((PS8) instance->file_path) + mmi_ucs2strlen((PS8) ptr) + 1
        #ifdef __MMI_SHOW_FILE_EXT__
            + mmi_ucs2strlen((PS8) fmgr_main_p->ext_name)
        #else /* __MMI_SHOW_FILE_EXT__ */
            + mmi_ucs2strlen((PS8) file_info.file_ext)
        #endif  /* __MMI_SHOW_FILE_EXT__ */
            >= max_len)
        {
            error_str = FMGR_FS_PATH_OVER_LEN_ERROR_TEXT;
            break;
        }

        mmi_ucs2cat((PS8) instance->file_path, (PS8) ptr);

        /* Restore '.' in file name */
        if (!(file_info.attribute & FS_ATTR_DIR))
        {
            ext_buffer[0] = ext_buffer[1] = 0;
        #ifdef __MMI_SHOW_FILE_EXT__
            if (mmi_ucs2strlen((PS8) fmgr_main_p->ext_name) > 0)
            {
                mmi_ucs2cpy((PS8) ext_buffer, (PS8) L".");
                mmi_ucs2cat((PS8)ext_buffer, fmgr_main_p->ext_name);
            }
        #else /* __MMI_SHOW_FILE_EXT__ */ 
            if (mmi_ucs2strlen((PS8) file_info.file_ext) > 0)
            {
                mmi_ucs2cat((PS8) ext_buffer, (PS8) file_info.file_ext);
            }
        #endif /* __MMI_SHOW_FILE_EXT__ */ 
       
            mmi_ucs2cat(instance->file_path, ext_buffer);
        }

        fs_ret = srv_fmgr_fs_rename((WCHAR *)fmgr_main_p->old_file_path, (WCHAR *)instance->file_path);

        if (fs_ret == 0)
        {
            /* Success , notify apps */
            if (FMGR_FILTER_IS_SET(&file_info.file_type, FMGR_TYPE_FOLDER))    
            {
                mmi_ucs2cat(fmgr_main_p->old_file_path, (S8*)L"\\");
                mmi_ucs2cat(instance->file_path, (S8*)L"\\");
            }

            /* Move selection to first */
            mmi_fmgri_instance_general_reset_index(instance);

            /* Search for new name */
            mmi_fmgri_instance_general_set_search_filename(instance, 
            mmi_fmgr_util_extract_filename(instance->file_path));
            close_editor = MMI_TRUE;
        }         
        else
        {
            /* Fail */
            error_str = srv_fmgr_fs_error_get_string(fs_ret);

            if (fs_ret == FS_ACCESS_DENIED)
            {
                /* Input any name doesn't help, quit editor */
                close_editor = MMI_TRUE;
            }
        }
        mmi_fmgri_filepath_go_up_level((PS8)instance->file_path);
    } while(0);

    if (error_str)
    {
        FMGR2_DisplayPopup(instance, error_str, MMI_EVENT_FAILURE);
    }
    return close_editor;

#endif /* __FMGR_USE_EDITOR_CUI__ */
}

#define MAINL_DELETE

mmi_ret mmi_fmgri_main_delete_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_YES:                
                if ((fmgr_main_p->client_action == FMGR_ACTION_DELETE_ALL) ||
                    (fmgr_main_p->client_action == FMGR_ACTION_DELETE_BY_FILTER))
                {
                #ifndef __MMI_SLIM_FILE_MANAGER__
                    fmgr_main_delete_all();
                #endif
                }
            #ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__    
                else if (fmgr_main_p->client_action == FMGR_ACTION_MARK_DELETE)
                {
                    fmgr_main_delete_mark();
                }    
            #endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */
                else  /* Delete single */
                {
                    fmgr_main_delete_single();
                }                               
                mmi_frm_group_close(evt->alert_id);
                break;
            case MMI_ALERT_CNFM_NO:
                /* Close confirm popup only */
                mmi_frm_group_close(evt->alert_id);
                break;
        }
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_delete_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_delete_confirm(mmi_fmgr_instance_struct *instance, U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;
    U8 str[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 20) *  ENCODING_LENGTH]; /* 20 for prefix/postfix string of file name*/
    U8 display_str[(MAX_SUBMENU_CHARACTERS+1) *  ENCODING_LENGTH];   
    S32 result;
    S8 *buffer;
    PS8 ext_name;
    FMGR_FILE_INFO_STRUCT file_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_TRACE2(TRC_MMI_FMGR_47CF7AC87F7543EA9A37B5192D4EBA2C,
        "[MMIFMGR] > Main > fmgr_main_delete_confirm > id=%d, action=%d\n",
        instance->id, action);

    FMGR_ASSERT((action == FMGR_ACTION_DELETE_ALL) ||
        (action == FMGR_ACTION_DELETE_BY_FILTER)||
        (action == FMGR_ACTION_MARK_DELETE) ||
        (action == FMGR_ACTION_DELETE_SINGLE) ||
        (action == FMGR_ACTION_DELETE_FOLDER));

    if ((action == FMGR_ACTION_DELETE_FOLDER) ||
        (action == FMGR_ACTION_DELETE_SINGLE))
    {
        /* Check if current deleting folder/file exist */
        result = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);
        
        if ((result < FS_NO_ERROR) || (mmi_ucs2strlen(file_info.file_name) == 0))
        {
            FMGR2_DisplayPopup(instance, FMGR_FS_PATH_NOT_FOUND_TEXT, MMI_EVENT_FAILURE); 
            return;
        }

        buffer = mmi_fmgri_get_and_lock_buffer();
        if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1),
                  instance->file_path, &file_info, MMI_FALSE))
        {
            FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
            mmi_fmgri_free_and_unlock_buffer(buffer);
            return;
        }

        if ((result = srv_fmgr_fs_path_exist((WCHAR*)buffer)) < 0)
        {
            if (result == FS_FILE_NOT_FOUND && (file_info.attribute & FS_ATTR_DIR))
            {
                result = FS_PATH_NOT_FOUND;
            }
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(result), MMI_EVENT_FAILURE);
            mmi_fmgri_free_and_unlock_buffer(buffer);
            return;
        }
        mmi_fmgri_free_and_unlock_buffer(buffer);
    }
    else
    {
        /* check path exist */
    }
    
    memset(str, 0, sizeof(str));
    memset(display_str, 0, sizeof(display_str));

    if ((action == FMGR_ACTION_DELETE_ALL) ||
        (action == FMGR_ACTION_DELETE_BY_FILTER))
    {
#ifndef __MMI_SLIM_FILE_MANAGER__
        mmi_ucs2cpy((PS8) str, (PS8) get_string(STR_FMGR_DELETE_ALL));
        mmi_ucs2ncpy((S8*)display_str, (S8*)str, MAX_SUBMENU_CHARACTERS);
#endif
    }
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__    
    else if (action == FMGR_ACTION_MARK_DELETE)
    {
        mmi_ucs2cpy((PS8) str, (PS8) get_string(STR_FMGR_MARK_DELETE));
        mmi_ucs2ncpy((S8*)display_str, (S8*)str, MAX_SUBMENU_CHARACTERS);
    }
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */
    else
    {
        /* Delete single , file or folder */
        mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);

    #ifndef __MMI_SHOW_DAF_FILE_EXT__
        if (FMGR_FILTER_IS_SET(&file_info.file_type, FMGR_TYPE_DAF) ||
            FMGR_FILTER_IS_SET(&file_info.file_type, FMGR_TYPE_MP2) )
        {
            ext_name = (PS8)srv_fmgr_path_get_extension_ptr((WCHAR*)file_info.file_name);

            /* Rename file should keep original extension filename in fmgr_p->ext_name
               and append after user input new name */
            if (ext_name != NULL)
            {
                *(ext_name - 2) = 0;
            }
        }
    #endif /* __MMI_SHOW_DAF_FILE_EXT__ */

        mmi_ucs2cpy((PS8) str, (PS8) get_string(STR_GLOBAL_DELETE));
        /* Add a questio mark */

        mmi_ucs2cat((PS8) str, (PS8) L"\n");
        mmi_ucs2cat((PS8) str, (PS8) file_info.file_name);

        if (mmi_ucs2strlen((S8*)str) >= MAX_SUBMENU_CHARACTERS)
        {
            mmi_ucs2ncpy((S8*)display_str, (S8*)str, MAX_SUBMENU_CHARACTERS - 4);
            mmi_ucs2cat((S8*)display_str, (S8*) L"...");
        }
        else
        {
            mmi_ucs2ncpy((S8*)display_str, (S8*)str, MAX_SUBMENU_CHARACTERS);
        }
    }

    mmi_confirm_property_init(&arg, CNFM_TYPE_USER_DEFINE);
    arg.parent_id = mmi_fmgri_instance_get_screen_id(instance->id);
    arg.ctype = CNFM_TYPE_YESNO;
    arg.softkey[0].str = (WCHAR *)GetString(STR_GLOBAL_YES);
    arg.softkey[2].str = (WCHAR *)GetString(STR_GLOBAL_NO);
    arg.callback = (mmi_proc_func)mmi_fmgri_main_delete_confirm_cb;
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    /* To add the "?" string */
    arg.f_auto_question_mark = MMI_TRUE;
#ifdef __MMI_VUI_MEDIAWALL__
    /* Set popup rotation type */
    if (vapp_mediawall_get_direction() == VADP_MEDIAWALL_LANDSCAPE)
    {
        if (mmi_fmgri_instance_get_list_style(instance->id) == FMGR_DISPLAY_TYPE_MATRIX)
        {
            arg.rotation = MMI_FRM_SCREEN_ROTATE_270;
        }
    }
    else
    {
        arg.rotation = MMI_FRM_SCREEN_ROTATE_0;
    }
#endif    
    mmi_confirm_display((WCHAR *)display_str, MMI_EVENT_QUERY, &arg);

    fmgr_main_p->client_id = instance->id;
    fmgr_main_p->client_action = action;

}

mmi_ret mmi_fmgr_async_fs_delete_result_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct* done_evt;
    mmi_fmgr_instance_struct *instance;    
    U8 allow_popup;
#ifndef __MMI_SLIM_FILE_MANAGER__
    U8 action;
#endif
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (param->evt_id)
    {
        case EVT_ID_SRV_FMGR_ASYNC_DONE:

            done_evt = (srv_fmgr_async_done_event_struct*)param;
            FMGR_ASSERT(fmgr_main_p->async_fs_job_id == done_evt->job_id);
            srv_backlight_turn_off();
        #ifndef __MMI_SLIM_FILE_MANAGER__
            action = mmi_fmgri_main_get_async_fs_state();
        #endif
            instance = fmgr_main_get_processing_instance();
            allow_popup = fmgr_main_processing_can_popup(instance);            

            if (done_evt->result == 0)
            {
                /* Success */
                #ifndef __MMI_SLIM_FILE_MANAGER__
				#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
				#endif
                #endif
            }
            else
            {
                /* Fail */
                if (allow_popup)
                {
                    /* Include action aborted and other FS error causes */
                    if (done_evt->result == FS_ABORTED_ERROR)
                    {
                        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(done_evt->result), MMI_EVENT_SUCCESS);
                    }
                    else
                    {
                        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(done_evt->result), MMI_EVENT_FAILURE);
                    }
                }
            }
#ifndef __MMI_SLIM_FILE_MANAGER__
            if (instance)
            {
                if ((action == FMGR_ACTION_DELETE_ALL) ||(action == FMGR_ACTION_DELETE_BY_FILTER))
                {
                    /* Move selection to first */
                    mmi_fmgri_instance_general_reset_index(instance);
                }
            }
#endif
            /* Clean up screen */
            fmgr_main_close_processing();
            break;

        case EVT_ID_SRV_FMGR_ASYNC_ABORTING:
            grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);
            fmgr_main_p->async_fs_aborting = MMI_TRUE;
            /* Refresh processing screen to "Canceling" */
            if ( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
            {
                mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
                mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
            } 
            break;

        default:
            FMGR_ASSERT(0);
    }

    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_delete_single
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_delete_single(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    mmi_fmgr_instance_struct *instance;
    S8* buffer;
    U8  action, instance_id;
    S32 fs_ret;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance_id = fmgr_main_p->client_id;
    fmgr_main_p->client_id = 0;
    action = fmgr_main_p->client_action;
    fmgr_main_p->client_action = FMGR_ACTION_NONE;

    /* Not possible to happen */
    if (!mmi_fmgri_is_instance_id_valid(instance_id))
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }
    
    instance = mmi_fmgri_get_instance_by_id(instance_id);

    if ((fs_ret = srv_fmgr_fs_path_exist((WCHAR*)instance->file_path)) < 0)
    {
        FMGR2_DisplayPopup(instance, FMGR_FS_PATH_NOT_FOUND_TEXT, MMI_EVENT_FAILURE); 
        return;
    }

    fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
        return;
    }    

    buffer = mmi_fmgri_get_and_lock_buffer();

    if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1),
              instance->file_path, &file_info, MMI_FALSE))
    {
        FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        mmi_fmgri_close_options(instance->id);
        return;
    }

    fs_ret = srv_fmgr_async_delete((WCHAR *)buffer,
                     0,
                     mmi_fmgr_async_fs_delete_result_proc,
                     NULL);

    if (fs_ret < 0)
    {
        FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
    }
    else 
    {
        fmgr_main_p->async_fs_job_id = fs_ret;
        fmgr_main_show_processing(instance, action);
    }
    mmi_fmgri_free_and_unlock_buffer(buffer);
}

#ifndef __MMI_SLIM_FILE_MANAGER__
/*****************************************************************************
 * FUNCTION
 *  fmgr_main_delete_all
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_delete_all(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    U8  instance_id, action;
    S32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance_id = fmgr_main_p->client_id;
    fmgr_main_p->client_id = 0;
    action = fmgr_main_p->client_action;
    fmgr_main_p->client_action = FMGR_ACTION_NONE;

    /* Not possible to happen */
    if (!mmi_fmgri_is_instance_id_valid(instance_id))
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }

    instance = mmi_fmgri_get_instance_by_id(instance_id);

    if (srv_fmgr_fs_path_exist((WCHAR*)instance->file_path) < 0)
    {
        /* error on instance path, just remove delete confirm and back, 
           let entry_explorer handle this error */
        mmi_frm_scrn_close_active_id();
        return;
    }

    fs_ret = srv_fmgr_async_delete_all((WCHAR *)instance->file_path,
                     &instance->filter_type,
                     0,
                     mmi_fmgr_async_fs_delete_result_proc,
                     NULL);

    if (fs_ret < 0)
    {
        FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
    }
    else 
    {
        fmgr_main_p->async_fs_job_id = fs_ret;
        fmgr_main_show_processing(instance, action);
    }
}
#endif

#ifdef __FS_SORT_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  fmgr_main_reinit_sort_option
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_reinit_sort_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    U8 temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifndef FMGR_SRV_PART
    ReadValue(NVRAM_EF_FMGR_SORT_OPTION_LID, &temp, DS_BYTE, &error);
    #endif
    if (temp == 0xff)
    {
        mmi_fmgri_fsdata_set_sort_option(FS_SORT_NAME);
    }
    else
    {
        mmi_fmgri_fsdata_set_sort_option((U16)((U16)temp << 5));
    }
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_set_sort
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_set_sort(U16 menu_id, mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 sort_option, new_sort_option = FS_NO_SORT;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (menu_id)
    {
        case MENU_ID_FMGR_SORT_BY_NAME:
        {
            new_sort_option = FS_SORT_NAME;
            break;
        }
        case MENU_ID_FMGR_SORT_BY_TYPE:
        {
            new_sort_option = FS_SORT_TYPE;            
            break;
        }
        case MENU_ID_FMGR_SORT_BY_TIME:
        {
            new_sort_option = FS_SORT_TIME;            
            break;
        }
        case MENU_ID_FMGR_SORT_BY_SIZE:
        {
            new_sort_option = FS_SORT_SIZE;            
            break;
        }
        default:
            FMGR_ASSERT(0);
            break;
    }

    /* If sort_option is not changed, return */
    sort_option = srv_fmgr_sort_get();
    if (sort_option == new_sort_option)
    {
        /* Move selection to first */
        if (instance)
        {
            mmi_fmgri_instance_general_reset_index(instance);
        }
        return;
    }

    srv_fmgr_sort_set(new_sort_option);
    srv_fmgr_filelist_set_setting(mmi_fmgri_fsdata_get_current_file_list_hdl(),
        &(instance->filter_type),
        new_sort_option);
    
    /* Move selection to first */
    if (instance)
    {
        mmi_fmgri_instance_general_reset_index(instance);
    }
}
#endif /* __FS_SORT_SUPPORT__ */

#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
mmi_ret fmgr_main_drive_result_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct* evt;
    mmi_fmgr_instance_struct    *instance;
    U8 allow_popup;
    U16 string_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (param->evt_id)
    {
        case EVT_ID_SRV_FMGR_ASYNC_DONE:

            evt = (srv_fmgr_async_done_event_struct*)param;
            srv_backlight_turn_off();
            instance = fmgr_main_get_processing_instance();
            allow_popup = fmgr_main_processing_can_popup(instance);

            if (evt->result == 0)
            {
                /* Format success */
                if (allow_popup && instance)
                {
                    FMGR2_DisplayPopup(instance, STR_GLOBAL_DONE, MMI_EVENT_SUCCESS);
                }
            }
            else 
            {
                /* Format fail */
                if (evt->result == FS_TIMEOUT)
                {
                    /* If file open => can't format */
                    string_id = srv_fmgr_fs_error_get_string(FS_LOCK_MUTEX_FAIL);
                }
                else
                {
                    string_id = srv_fmgr_fs_error_get_string(evt->result);
                }

                if (allow_popup && instance)
                {
                    FMGR2_DisplayPopup(instance, string_id, MMI_EVENT_FAILURE);
                }
            }

            fmgr_main_close_processing();
            break;

        default:
            FMGR_ASSERT(0);
    }

    return MMI_RET_OK;
}
#endif

#if (!defined __MMI_FMGR_HIDE_FORMAT_DRIVE__) || (!defined __MMI_SLIM_FILE_MANAGER__)
/*****************************************************************************
 * FUNCTION
 *  fmgr_main_drive_action_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_drive_action_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmgr_drive_info_struct drv_info;
    S32 ret;
    mmi_fmgr_instance_struct *instance;
    U8 instance_id, action;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    instance_id = fmgr_main_p->client_id;
    fmgr_main_p->client_id = 0;
    action = fmgr_main_p->client_action;
    fmgr_main_p->client_action = FMGR_ACTION_NONE;

    /* Not possible to happen */
    if (!mmi_fmgri_is_instance_id_valid(instance_id))
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }

    instance = mmi_fmgri_get_instance_by_id(instance_id);

    ret = mmi_fmgri_fsdata_instance_get_drive_info(instance->id, instance->cur_index, &drv_info);
    if (ret < 0)
    {
        FMGR2_DisplayPopup(instance, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }

    switch (action)
    {
    #ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__
        case FMGR_ACTION_FORMAT:
            ret = srv_fmgr_async_format((U8)drv_info.drv_path[0], 0, fmgr_main_drive_result_proc, NULL);
            break;
    #endif
    #ifndef __MMI_SLIM_FILE_MANAGER__
        case FMGR_ACTION_UNMOUNT:
            fmgr_main_start_soft_unmount(instance);
            return;
    #endif
        default:
            return;
    }

    if (ret < 0)
    {
        /* Access Denied */
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(ret), MMI_EVENT_FAILURE);
    }
    else
    {
        fmgr_main_show_processing(instance, action);
    }
    
}
#endif

#if defined(__MMI_FMGR_SUPPORT_SOFT_UNMOUNT__) && !defined(__MMI_SLIM_FILE_MANAGER__)
void fmgr_main_exit_soft_unmount(mmi_scrn_essential_struct* info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 drv_letter;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_prof_stop_tone(SRV_PROF_TONE_WARNING);

    drv_letter = (S8)((U32)info->user_data);
    FMGR_ASSERT(drv_letter);
    srv_fmgr_fs_soft_mount(drv_letter);
}

void fmgr_main_entry_soft_unmount(mmi_scrn_essential_struct* info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 drv_letter;
#ifdef __OTG_ENABLE__
    S8 drv_enum;
#endif
    U16 str_id;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_frm_scrn_enter(info->group_id, info->scrn_id, (FuncPtr)fmgr_main_exit_soft_unmount, NULL, 0))
    {
        return;
    }

    drv_letter = (S8)((U32)info->user_data);
    
    srv_fmgr_fs_soft_unmount(drv_letter);

#ifdef __OTG_ENABLE__
    drv_enum = srv_fmgr_drv_get_type((U8)drv_letter);
    str_id = (drv_enum > SRV_FMGR_DRV_CARD_TYPE) ? STR_ID_FMGR_OTG_REMOVE_PROMPT : STR_ID_FMGR_CARD_REMOVE_PROMPT;
#else /* __OTG_ENABLE__ */
    str_id = STR_ID_FMGR_CARD_REMOVE_PROMPT;
#endif /* __OTG_ENABLE__ */
#ifndef __MMI_WGUI_DISABLE_CSK__
    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
#endif

    ShowCategory165Screen(
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK, 
        0,
        0, 
        (U16*)GetString(str_id), 
        mmi_get_event_based_image(MMI_EVENT_INFO),
        mmi_frm_scrn_get_active_gui_buf());

    srv_prof_play_tone(mmi_get_event_based_sound(MMI_EVENT_INFO), NULL);

    SetLeftSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}

static void fmgr_main_start_soft_unmount(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmgr_drive_info_struct  drv_info;
    S32 ret;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mmi_fmgri_fsdata_instance_get_drive_info(instance->id, instance->cur_index, &drv_info);
    if (ret < 0)
    {
        FMGR2_DisplayPopup(instance, FMGR_FS_DRIVE_NOT_FOUND_TEXT, MMI_EVENT_FAILURE);
        return;
    }
    
    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id),
        SCR_ID_FMGR_CARD_SOFT_UNMOUNT,
        (FuncPtr)fmgr_main_entry_soft_unmount,
        (void*)drv_info.drv_path[0]);
}

#endif


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_entry_detail
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_entry_detail(mmi_scrn_essential_struct* scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *info;
    mmi_fmgr_instance_struct *instance;
    FMGR_FILE_INFO_STRUCT file_info;
    S8 *buffer;
    S32 result;
    U16 iconId;
    U8 instance_id;
#ifdef __DRM_SUPPORT__
    U8 perm = 0;
#endif /* __DRM_SUPPORT__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    instance_id = (U8)((U32)scr_info->user_data);
    instance = mmi_fmgri_get_instance_by_id(instance_id);
    
    if (!mmi_frm_scrn_enter(
               mmi_fmgri_instance_get_screen_id(instance_id), 
               SCR_FMGR_DETAIL,
               NULL,
               (FuncPtr)fmgr_main_entry_detail, MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }
    
    mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);

    buffer = mmi_fmgri_get_and_lock_buffer();
    if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1),
              instance->file_path, &file_info, MMI_FALSE))
    {
        FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
        mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance_id), SCR_FMGR_DETAIL);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return;
    }
    
    if ((mmi_ucs2strlen(buffer) > 3) &&
        ((result = srv_fmgr_fs_path_exist((WCHAR*)buffer)) < FS_NO_ERROR))
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(result), MMI_EVENT_FAILURE); 
        mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance_id), SCR_FMGR_DETAIL);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return;
    }

    info = (PU8) subMenuData;
    mmi_ucs2cpy((PS8) info, (PS8) GetString(STR_ID_FMGR_FILE_DATE));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");
    date_string(&file_info.time, (PU16) & info[mmi_ucs2strlen((PS8) info) << 1], DT_IDLE_SCREEN);
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

	if (!(file_info.attribute & FS_ATTR_DIR))
	{
    mmi_ucs2cat((PS8) info, (PS8) GetString(STR_ID_FMGR_FILE_SIZE));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

    mmi_fmgri_gui_format_size(file_info.file_size, (U16*)info + mmi_ucs2strlen((S8*)info), MAX_SUBMENU_CHARACTERS);    
	}

#ifdef __DRM_SUPPORT__
    mmi_ucs2cat((PS8) info, (PS8) L"\n");
    if (FMGR_FILTER_IS_SET_AUDIO(&file_info.file_type) ||
        FMGR_FILTER_IS_SET_VIDEO(&file_info.file_type))
    {
        perm = DRM_PERMISSION_PLAY;
    }
    else if (FMGR_FILTER_IS_SET_IMAGE(&file_info.file_type))
    {
        perm = DRM_PERMISSION_DISPLAY | DRM_PERMISSION_PRINT;
    }
#ifdef __J2ME__
    else if (FMGR_FILTER_IS_SET(&file_info.file_type, FMGR_TYPE_JAR) ||
        FMGR_FILTER_IS_SET(&file_info.file_type, FMGR_TYPE_JAD))
    {
        perm = DRM_PERMISSION_EXECUTE;
    }
#endif /* __J2ME__ */ 

    if (perm == 0)
    {
        mmi_rmgr_populate_drm_info((U16 *)buffer, DRM_PERMISSION_ALL, info, sizeof(subMenuData));
    }
    else
    {
        mmi_rmgr_populate_drm_info((U16 *)buffer, perm, info, sizeof(subMenuData));
    }
#endif /* __DRM_SUPPORT__ */ 
    mmi_fmgri_free_and_unlock_buffer(buffer);

    mmi_fmgri_instance_get_title_info(instance->id, NULL, &iconId);

    ShowCategory74Screen(
        STR_GLOBAL_DETAILS,
        iconId,
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) subMenuData,
        MAX_SUB_MENUS * MAX_SUB_MENU_SIZE,
        mmi_frm_scrn_get_active_gui_buf());

#ifndef __FMGR_KEY_RULE__
    SetKeyHandler(mmi_frm_scrn_close_active_id, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
#endif /* __FMGR_KEY_RULE__ */
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_entry_copy
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_entry_copy(mmi_fmgr_instance_struct *instance, U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    FMGR_FILTER filter;
    S8 *buffer;
    S32 result;
#if defined(__MMI_FMGR_MULTI_SELECT_SUPPORT__) && !defined(__MMI_SLIM_FILE_MANAGER__)    
    S32 index;
#endif
    U16 icon_id, title_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(action == FMGR_ACTION_COPY ||
        action == FMGR_ACTION_MOVE ||
        action == FMGR_ACTION_MARK_COPY ||
        action == FMGR_ACTION_MARK_MOVE);

    FMGR_TRACE2(TRC_MMI_FMGR_B1EB397EE1E945A5AC9D0D686E552317,
        "[MMIFMGR] > Main > fmgr_main_entry_copy > id=%d, action=%d\n",
        instance->id, action);
    
    if (action == FMGR_ACTION_COPY || action == FMGR_ACTION_MOVE)
    {
        result = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);
        if (result < 0)
        {
            FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(result), MMI_EVENT_FAILURE); 
            return;
        }
        
        buffer = mmi_fmgri_get_and_lock_buffer();

        /* Check if too deep */
        if(!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), instance->file_path, &file_info, MMI_FALSE))
        {
            mmi_fmgri_free_and_unlock_buffer(buffer);
            FMGR_DisplayPopup(FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
            return;
        }

        mmi_ucs2ncpy(fmgr_main_p->old_file_path, buffer, SRV_FMGR_PATH_MAX_LEN);
        mmi_fmgri_free_and_unlock_buffer(buffer);
    }
#if defined(__MMI_FMGR_MULTI_SELECT_SUPPORT__) && !defined(__MMI_SLIM_FILE_MANAGER__)
    else if (action == FMGR_ACTION_MARK_MOVE)
    {
        /* Find final highlight */
        FMGR_ASSERT(fmgr_main_p->ms_id);
        SET_UCS2STR_EMPTY(fmgr_main_p->ms_highlight_filename);
        index = mmi_fmgri_serv_multi_sel_find_non_mark(fmgr_main_p->ms_id, -1);
        if (index >= 0)
        {
            mmi_fmgri_serv_multi_sel_get_file_by_index(fmgr_main_p->ms_id, index, &file_info);
            mmi_ucs2ncpy(fmgr_main_p->ms_highlight_filename, file_info.file_name, SRV_FMGR_PATH_MAX_LEN);
        }
    }
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */

    FMGR_FILTER_INIT(&filter);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_FOLDER);

    fmgr_main_p->client_copy_sel_id = cui_folder_selector_create(
        mmi_fmgri_instance_get_screen_id(instance->id), 
        (WCHAR*)SRV_FMGR_PATH_ROOT, 
        CUI_FOLDER_SELECTOR_STYLE_WRITE, FMGR_IFLAG_INTERNAL|CUI_FOLDER_SELECTOR_OPT_FIXED_PATH_ON);
    
    mmi_fmgr_get_app_title_info(instance->app_id, NULL, &icon_id, NULL);
    title_id = (action == FMGR_ACTION_COPY || action == FMGR_ACTION_MARK_COPY) ? STR_FMGR_COPY_TO : STR_FMGR_MOVE_TO;
    cui_folder_selector_set_title(fmgr_main_p->client_copy_sel_id, title_id, icon_id);
    cui_folder_selector_set_userdata(fmgr_main_p->client_copy_sel_id, action);
    cui_folder_selector_run(fmgr_main_p->client_copy_sel_id);

    /* Select fail, reset file_path */
    if (!fmgr_main_p->client_copy_sel_id)
    {
        return;
    }

    if (action == FMGR_ACTION_COPY || action == FMGR_ACTION_MOVE)
    {
        /* File_path will keep the source_file_path */
        mmi_ucs2cpy((S8*) instance->file_path, (S8*) fmgr_main_p->old_file_path);
    }
    
    fmgr_main_p->client_copy_id = instance->id;
    fmgr_main_p->client_copy_action = action;
}

mmi_ret mmi_fmgr_async_fs_copy_result_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct* done_evt;
    mmi_fmgr_instance_struct    *instance;
    //U8 action;
    U8 allow_popup;
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (param->evt_id)
    {
        case EVT_ID_SRV_FMGR_ASYNC_DONE:

            done_evt = (srv_fmgr_async_done_event_struct*)param;
            FMGR_ASSERT(fmgr_main_p->async_fs_job_id == done_evt->job_id);
            srv_backlight_turn_off();

            //action = mmi_fmgri_main_get_async_fs_state();
            instance = fmgr_main_get_processing_instance();
            allow_popup = fmgr_main_processing_can_popup(instance);

            if (done_evt->result == 0)
            {
                /* Success */
                if (instance)
                {
                    /* Notify copy/move done */
                   mmi_ucs2cat((S8*)instance->file_path, (S8*)fmgr_main_p->new_file_name);
                    srv_fmgr_path_remove_filename((WCHAR*)instance->file_path);
                }

                #ifndef __MMI_SLIM_FILE_MANAGER__
				#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
				#endif
                #endif
            }
            else
            {
                /* Fail */
                if (allow_popup)
                {
                    /* Include action aborted and other FS error causes */
                    if (done_evt->result == FS_ABORTED_ERROR)
                    {
                        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(done_evt->result), MMI_EVENT_SUCCESS);
                    }
                    else
                    {
                        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(done_evt->result), MMI_EVENT_FAILURE);
                    }
                }
            }
            /* Clean up screen */
            fmgr_main_close_processing();
        #ifdef FMGR_TAB_SUPPORT
            fmgr_main_p->destination_tab_id = 0;
        #endif /* FMGR_TAB_SUPPORT */
            break;

        case EVT_ID_SRV_FMGR_ASYNC_ABORTING:
            grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);
            fmgr_main_p->async_fs_aborting = MMI_TRUE;
            /* Refresh processing screen to "Canceling" */
            if ( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
            {
                mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
                mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
            } 
            break;

        default:
            FMGR_ASSERT(0);
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_copy_select_folder_done
 * DESCRIPTION
 *  Callback function for file manager when shared folder selection is finished.
 * PARAMETERS
 *  path            [IN]        User selected path
 *  is_short        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_copy_select_folder_done(mmi_fmgr_instance_struct *instance, cui_folder_selector_result_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    U8 action;
    SRV_FMGR_FILEINFO_HANDLE file_handle;
    S8 *buf;
    S32 fs_ret, result;
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__) 
    S32 pathlen = 0;
#endif
    U32 get_size = 0, get_attr = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_p->client_copy_id = 0;
    fmgr_main_p->client_copy_action = 0;
    FMGR_ASSERT(fmgr_main_p->client_copy_sel_id == evt->sender_id);
    action = (U8)cui_folder_selector_get_userdata(evt->sender_id);

    if (evt->result <= 0)
    {
        goto error_quit;
    }

    fs_ret = cui_folder_selector_get_selected_filepath(evt->sender_id, 
		       NULL,
		       (WCHAR*)fmgr_main_p->old_file_path,
		       ((SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH));

    if (fs_ret < 0)
    {
        if (fs_ret == SRV_FMGR_FILELIST_ERROR_BUSY)
        {
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(FS_DEVICE_BUSY), MMI_EVENT_FAILURE);
        }
        else
        {
            FMGR2_DisplayPopup(instance, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        }
        goto error_quit;
    }

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
    if (action == FMGR_ACTION_MARK_COPY ||action == FMGR_ACTION_MARK_MOVE)
    {
        if (mmi_ucs2cmp((PS8) fmgr_main_p->old_file_path, (PS8) instance->file_path) == 0)
        {
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(FS_FILE_EXISTS), MMI_EVENT_FAILURE);
            goto error_quit;
        }

#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
        if (mmi_fmgri_msa_is_src_folder(fmgr_main_p->ms_id, (PS8) fmgr_main_p->old_file_path))
        {
            FMGR2_DisplayPopup(instance, STR_GLOBAL_FILE_ALREADY_EXISTS, MMI_EVENT_FAILURE);
            goto error_quit;
        }
#endif        
        
        result = fmgr_main_copy_mark(action);
        if (result)
        {
            FMGR2_DisplayPopup(instance, (U16)result, MMI_EVENT_FAILURE);
            goto error_quit;
        }
    }
    else
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */
    if(action == FMGR_ACTION_COPY || action == FMGR_ACTION_MOVE)
    {
        /* file_path = source file path ; old_file_path = destination file path */
        result = srv_fmgr_fs_path_exist((WCHAR*)instance->file_path);
        if (result < FS_NO_ERROR)
        {
            FMGR2_DisplayPopup(instance, FMGR_FS_PATH_NOT_FOUND_TEXT, MMI_EVENT_FAILURE);
            goto error_quit;
        }                            
        
        fs_ret = srv_fmgr_fileinfo_create((WCHAR*)instance->file_path, &file_handle);
        if (fs_ret == 0)
        {
            get_size = srv_fmgr_fileinfo_get_size(file_handle);
            get_attr = srv_fmgr_fileinfo_get_attribute(file_handle);
            srv_fmgr_fileinfo_destroy(file_handle);
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)            
            if (get_attr & FS_ATTR_DIR)
            {
                pathlen = mmi_ucs2strlen(instance->file_path);
                if ((instance->file_path[(pathlen-1)*ENCODING_LENGTH] == '\\') &&
                    (instance->file_path[(pathlen-1)*ENCODING_LENGTH+1] == 0))
                {
                    pathlen--;
                }
                
                if ((mmi_ucs2ncmp(fmgr_main_p->old_file_path, instance->file_path, pathlen) == 0) &&
                    (fmgr_main_p->old_file_path[pathlen*ENCODING_LENGTH] == '\\') &&
                    (fmgr_main_p->old_file_path[pathlen*ENCODING_LENGTH+1] == 0))
                {
                    FMGR2_DisplayPopup(instance, STR_GLOBAL_FILE_ALREADY_EXISTS, MMI_EVENT_FAILURE);
                    goto error_quit;
                }
            }
#endif                            
        }   
        else
        {
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret),MMI_EVENT_FAILURE);
            goto error_quit;
        }

        buf = (S8 *)srv_fmgr_path_get_filename_ptr((WCHAR*)instance->file_path);
        if (mmi_ucs2strlen((PS8) fmgr_main_p->old_file_path) + mmi_ucs2strlen(buf) > SRV_FMGR_PATH_MAX_LEN)
        {
            FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
            goto error_quit;
        }
        
        mmi_ucs2cat((PS8) fmgr_main_p->old_file_path, (PS8)buf);

        if (mmi_ucs2cmp((PS8) fmgr_main_p->old_file_path, (PS8) instance->file_path) == 0)
        {
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(FS_FILE_EXISTS), MMI_EVENT_FAILURE);
            goto error_quit;
        }    

        if (!(get_attr & FS_ATTR_DIR))
        {
            srv_fmgr_path_remove_filename((WCHAR*)fmgr_main_p->old_file_path);
        }
                
        if ((action != FMGR_ACTION_MOVE) || (instance->file_path[0] != fmgr_main_p->old_file_path[0]))
        {
            /* Check free space only when necessary */
            fs_ret = srv_fmgr_drv_check_free_size((U8)fmgr_main_p->old_file_path[0], (U64)get_size);
            if(fs_ret < 0)
            {
                FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret),MMI_EVENT_FAILURE);
                goto error_quit;
            }
        }

        if (action == FMGR_ACTION_MOVE)
        {
            fs_ret = srv_fmgr_async_move((WCHAR *)instance->file_path, 
                            (WCHAR *) fmgr_main_p->old_file_path,
                            0,
                            mmi_fmgr_async_fs_copy_result_proc,
                            NULL);
        }
        else if (action == FMGR_ACTION_COPY)
        {
            fs_ret = srv_fmgr_async_copy((WCHAR *)instance->file_path, 
                            (WCHAR *) fmgr_main_p->old_file_path,
                            0,
                            mmi_fmgr_async_fs_copy_result_proc,
                            NULL);
        }
        else
        {
            FMGR_ASSERT(0);
        }

        if (fs_ret <0 )
        {
			FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
            goto error_quit;
        }
        else
        {
            fmgr_main_p->async_fs_job_id = fs_ret;
        }

        /* Copy source file name */
        buf = (S8*)srv_fmgr_path_get_filename_ptr((WCHAR *)instance->file_path);
        mmi_ucs2ncpy((S8*)fmgr_main_p->new_file_name, (S8*)buf, SRV_FMGR_PATH_MAX_FILE_NAME_LEN);
        srv_fmgr_path_remove_filename((WCHAR*)instance->file_path);
    }

#ifdef FMGR_TAB_SUPPORT
    fmgr_main_p->destination_tab_id = mmi_fmgri_get_query_tab();
#endif /* FMGR_TAB_SUPPORT */

    fmgr_main_show_processing(instance, action);

    cui_folder_selector_close(evt->sender_id);
    fmgr_main_p->client_copy_sel_id = 0;
    return;

error_quit:
    if (instance && (action == FMGR_ACTION_COPY || action == FMGR_ACTION_MOVE))
    {
        srv_fmgr_path_remove_filename((WCHAR*)instance->file_path);
    }
    cui_folder_selector_close(evt->sender_id);
    fmgr_main_p->client_copy_sel_id = 0;
    fmgr_main_p->async_fs_instance_id = 0;
    fmgr_main_p->async_fs_job_id = 0;
    mmi_fmgri_main_set_async_fs_state(FMGR_ACTION_NONE);

    if (evt->result < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(evt->result), MMI_EVENT_FAILURE);
    }
}


#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__

static void fmgr_main_mark_several_close_callback(U32 ms_id, U32 user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 grp_id = 0;
    mmi_fmgr_instance_struct *instance;
    FMGR_FILE_INFO_STRUCT file_info;
    S32 fs_ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	if (fmgr_main_p->ms_id != 0 && fmgr_main_p->ms_caller_instance != NULL)
	{   
		instance = mmi_fmgri_get_instance_by_id((U8)user_data);
        grp_id = mmi_fmgri_instance_get_screen_id(user_data);        
		if (instance && instance == fmgr_main_p->ms_caller_instance && mmi_frm_group_get_active_id() == grp_id)
		{
			fs_ret = mmi_fmgri_serv_multi_sel_get_file_by_index(ms_id,
							 mmi_fmgri_serv_multi_sel_get_index(ms_id), &file_info);
			if (fs_ret >= 0)
			{
				mmi_fmgri_instance_general_set_search_filename(instance, file_info.file_name);
			}
		}

		/* Clean up */
		fmgr_main_p->ms_id = 0;
		fmgr_main_p->action_from_ms = MMI_FALSE;
		fmgr_main_p->ms_caller_instance = NULL;
	}
}

#define MULTI_DELETE

static S32 fmgr_main_mark_delete_find_next(S8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(buffer);
    
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);

    /* Find next delete item */
    FMGR_ASSERT(mmi_fmgri_msa_count(msa_id));
    mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, SRV_FMGR_PATH_MAX_LEN);

    /* Check filepath */
    if(mmi_ucs2strlen(buffer) + mmi_ucs2strlen(mmi_fmgri_msa_top(msa_id)) > SRV_FMGR_PATH_MAX_LEN)
    {
        return FS_PATH_OVER_LEN_ERROR;
    }

    mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));

    return 0;

}

mmi_ret mmi_fmgr_async_fs_delete_mark_result_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct* done_evt;
    mmi_fmgr_instance_struct *instance;
    U8 allow_popup;
    S8* buffer = NULL;
    S32 msa_id, fs_ret;
    U16 display_str_id = 0;
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (param->evt_id)
    {
        case EVT_ID_SRV_FMGR_ASYNC_DONE:

            done_evt = (srv_fmgr_async_done_event_struct*)param;
            FMGR_ASSERT(fmgr_main_p->async_fs_job_id == done_evt->job_id);
            srv_backlight_turn_off();

            if (!fmgr_main_p->ms_id)
            {
                display_str_id = 0;
                instance = NULL;
                allow_popup = 0;
                goto delete_mark_done;
            }

            msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
            instance = fmgr_main_get_processing_instance();
            allow_popup = fmgr_main_processing_can_popup(instance);

            if (done_evt->result == 0)
            {
                /* Success */
                buffer = mmi_fmgri_get_and_lock_buffer();
                mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));
                mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));
                mmi_fmgri_msa_pop(msa_id);

                /* Check done */
                if (!mmi_fmgri_msa_count(msa_id))
                {
                    display_str_id = STR_GLOBAL_DELETED;
                    goto delete_mark_done;
                }

                /* If abort */
                if (fmgr_main_p->async_fs_aborting == MMI_TRUE)
                {
                    display_str_id = FMGR_FS_ABORTED_ERROR_TEXT;
                    goto delete_mark_done;
                }
                
                /* Find next item */
                fs_ret = fmgr_main_mark_delete_find_next(buffer);
                if (fs_ret < 0)
                {
                    display_str_id = srv_fmgr_fs_error_get_string(fs_ret);
                    goto delete_mark_done;
                }

                fs_ret = srv_fmgr_async_delete((WCHAR *)buffer,
                                 0,
                                 mmi_fmgr_async_fs_delete_mark_result_proc,
                                 NULL);

                if (fs_ret < 0)
                {
                    display_str_id = srv_fmgr_fs_error_get_string(fs_ret);
                    goto delete_mark_done;
                }
                else 
                {
                    fmgr_main_p->async_fs_job_id = fs_ret;
                }

                mmi_fmgri_free_and_unlock_buffer(buffer);
                return MMI_RET_OK;
            }
            else
            {
                /* Fail */
                buffer = mmi_fmgri_get_and_lock_buffer();
                mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));
                mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));
                if (srv_fmgr_fs_path_exist((const WCHAR*)buffer) < 0)
                {
                    mmi_fmgri_msa_pop(msa_id);    
                }
                mmi_fmgri_free_and_unlock_buffer(buffer);
				buffer = NULL;
                if (allow_popup)
                {
                    /* Include action aborted and other FS error causes */
                    display_str_id = srv_fmgr_fs_error_get_string(done_evt->result);
                }
            }

            delete_mark_done:

            if (buffer)
            {
                mmi_fmgri_free_and_unlock_buffer(buffer);
            }

            if (allow_popup && display_str_id)
            {
                /* Due to MS will be closed later, and can_popup is checked, use top level popup */
                switch(display_str_id)
                {
                #ifndef __MMI_SLIM_FILE_MANAGER__
                    case FMGR_FS_ABORTED_ERROR_TEXT:
                    case STR_GLOBAL_DELETED:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_SUCCESS);
                        break;
                #else
                    case FMGR_FS_ABORTED_ERROR_TEXT:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_SUCCESS);
                        break;
                    case STR_GLOBAL_DELETED:
                        break;
                #endif
                    default:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_FAILURE);
                        break;
                }
            }
    
            srv_backlight_turn_off();
            fmgr_main_close_processing();

            if (display_str_id == STR_GLOBAL_DELETED)
            {
                if (fmgr_main_p->ms_caller_instance)
                {
                    if (CHECK_UCS2STR_EMPTY(fmgr_main_p->ms_highlight_filename))
                    {
                        mmi_fmgri_instance_general_reset_index(fmgr_main_p->ms_caller_instance);
                    }
                    else
                    {
                        mmi_fmgri_instance_general_set_search_filename(fmgr_main_p->ms_caller_instance, fmgr_main_p->ms_highlight_filename);
                    }
                    fmgr_main_p->ms_caller_instance = NULL;
                }
        
                mmi_fmgri_serv_multi_sel_close(fmgr_main_p->ms_id);
                fmgr_main_p->ms_id = 0;
                fmgr_main_p->action_from_ms = MMI_FALSE;
            }
            else if (fmgr_main_p->ms_id)
            {
                fmgr_main_p->action_from_ms = MMI_FALSE;
                mmi_fmgri_serv_multi_sel_set_mark_array_dirty(fmgr_main_p->ms_id);
            }
    
            break;

        case EVT_ID_SRV_FMGR_ASYNC_ABORTING:
            grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);
            fmgr_main_p->async_fs_aborting = MMI_TRUE;
            /* Refresh processing screen to "Canceling" */
            if ( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
            {
                mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
                mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
            } 
            break;

        default:
            FMGR_ASSERT(0);
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  fmgr_main_delete_mark
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_delete_mark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    S8 *buffer;
    S32 index, fs_ret;
    mmi_fmgr_instance_struct *instance;
    U8 instance_id, action;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance_id = fmgr_main_p->client_id;
    fmgr_main_p->client_id = 0;
    action = fmgr_main_p->client_action;
    fmgr_main_p->client_action = FMGR_ACTION_NONE;

    /* Not possible to happen */
    if (!mmi_fmgri_is_instance_id_valid(instance_id))
    {
        FMGR_DisplayPopup(STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return;
    }

    instance = mmi_fmgri_get_instance_by_id(instance_id);

    buffer = mmi_fmgri_get_and_lock_buffer();

    /* Find final highlight */
#ifndef __MMI_SLIM_FILE_MANAGER__
    FMGR_ASSERT(fmgr_main_p->ms_id);
    SET_UCS2STR_EMPTY(fmgr_main_p->ms_highlight_filename);
    index = mmi_fmgri_serv_multi_sel_find_non_mark(fmgr_main_p->ms_id, -1);
    if (index >= 0)
    {
        mmi_fmgri_serv_multi_sel_get_file_by_index(fmgr_main_p->ms_id, index, &file_info);
        mmi_ucs2ncpy(fmgr_main_p->ms_highlight_filename, file_info.file_name, SRV_FMGR_PATH_MAX_LEN);
    }
#endif

    /* Find first delete */
    fs_ret = fmgr_main_mark_delete_find_next(buffer);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return;
    }

    fmgr_main_p->action_from_ms = MMI_TRUE;
    fs_ret = srv_fmgr_async_delete((WCHAR *)buffer,
                     0,
                     mmi_fmgr_async_fs_delete_mark_result_proc,
                     NULL);

    if (fs_ret < 0)
    {
        FMGR_DisplayPopup(srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
    }
    else 
    {
        fmgr_main_p->async_fs_job_id = fs_ret;
        fmgr_main_show_processing(instance, action);
    }

    mmi_fmgri_free_and_unlock_buffer(buffer);
}

#define MULTI_COPYMOVE

static S32 fmgr_main_mark_copy_find_next(S8* buffer, U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_main_p->ms_id);
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);

    /* Find next item */
    FMGR_ASSERT(mmi_fmgri_msa_count(msa_id));
    mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));

    /* Check filepath */
    if(mmi_ucs2strlen(buffer) + mmi_ucs2strlen(mmi_fmgri_msa_top(msa_id)) > SRV_FMGR_PATH_MAX_LEN)
    {
        return FS_PATH_OVER_LEN_ERROR;
    }
    mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));

    /* Old_file_path = destination file path */
    /* Check if destination over length */
    if(mmi_ucs2strlen(fmgr_main_p->old_file_path) + mmi_ucs2strlen(mmi_fmgri_msa_top(msa_id)) > SRV_FMGR_PATH_MAX_LEN)
    {
        return FS_PATH_OVER_LEN_ERROR;
    }

    return 0;
}

mmi_ret mmi_fmgr_async_fs_copy_mark_result_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct* done_evt;
    mmi_fmgr_instance_struct *instance;   
    U8 action, allow_popup;
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)    
    WCHAR *folder_name = NULL;
    SRV_FMGR_FILEINFO_HANDLE file_hdl;
    S32 str_len = 0;
#endif
    S8* buffer = NULL;
    S32 msa_id, fs_ret;
    U16 display_str_id = 0;
    mmi_id grp_id;    
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (param->evt_id)
    {
        case EVT_ID_SRV_FMGR_ASYNC_DONE:

            done_evt = (srv_fmgr_async_done_event_struct*)param;

            if (!fmgr_main_p->ms_id)
            {
                display_str_id = 0;
                instance = NULL;
                allow_popup = 0;
                action = 0;
                goto copy_mark_done;
            }

            msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
            FMGR_ASSERT(mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE);
            action = mmi_fmgri_main_get_async_fs_state();
            instance = fmgr_main_get_processing_instance();
            allow_popup = fmgr_main_processing_can_popup(instance);

            if (done_evt->result == 0)
            {
                /* Success - remove from msa */
                buffer = mmi_fmgri_get_and_lock_buffer();
                mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));
                mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));
                mmi_fmgri_msa_pop(msa_id);

                /* Check done */
                if (!mmi_fmgri_msa_count(msa_id))
                {
                    display_str_id = STR_GLOBAL_DONE;
                    if (action == FMGR_ACTION_MARK_MOVE)
                    {
                        display_str_id = STR_FMGR_MOVED;
                    }
                    else if (action == FMGR_ACTION_MARK_COPY)
                    {
                        display_str_id = STR_FMGR_COPIED;
                    }
                    goto copy_mark_done;
                }

                /* If abort */
                if (fmgr_main_p->async_fs_aborting == MMI_TRUE)
                {
                    display_str_id = FMGR_FS_ABORTED_ERROR_TEXT;
                    goto copy_mark_done;
                }

                /* Find next item */
                fs_ret = fmgr_main_mark_copy_find_next(buffer, action);
                if (fs_ret)
                {
                    display_str_id = srv_fmgr_fs_error_get_string(fs_ret);
                    goto copy_mark_done;
                }
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
				if (mmi_fmgri_msa_is_src_folder(fmgr_main_p->ms_id, fmgr_main_p->old_file_path))
                {
                    display_str_id = STR_GLOBAL_FILE_ALREADY_EXISTS;
                    goto copy_mark_done;
                }            

                fs_ret = srv_fmgr_fileinfo_create((WCHAR*)buffer, &file_hdl);
                if (fs_ret == 0)
                {
                    if (srv_fmgr_fileinfo_get_attribute(file_hdl) & FS_ATTR_DIR)
                    {
                        /* Concatenate src folder name to dest path */
                        folder_name = srv_fmgr_path_get_filename_ptr((WCHAR *)buffer);

                        str_len = SRV_FMGR_PATH_MAX_LEN - mmi_ucs2strlen(fmgr_main_p->old_file_path);
                        
                        if (str_len >= mmi_ucs2strlen((const CHAR*)folder_name))
                        {
                            mmi_ucs2ncat((CHAR *)fmgr_main_p->old_file_path, (const CHAR *)folder_name, str_len);
                        }
                        else
                        {
                            folder_name = NULL;
                        }
                    }          
                    srv_fmgr_fileinfo_destroy(file_hdl);
                }
#endif                
                
                /* Do next copy/move */
                if (action == FMGR_ACTION_MARK_MOVE)
                {
                    fs_ret = srv_fmgr_async_move((WCHAR *)buffer, 
                                    (WCHAR *) fmgr_main_p->old_file_path,
                                     0,
                                     mmi_fmgr_async_fs_copy_mark_result_proc,
                                     NULL);
                }
                else if (action == FMGR_ACTION_MARK_COPY)
                {
                    fs_ret = srv_fmgr_async_copy((WCHAR *)buffer, 
                                     (WCHAR *) fmgr_main_p->old_file_path,
                                     0,
                                     mmi_fmgr_async_fs_copy_mark_result_proc,
                                     NULL);
                }
                else
                {
                    FMGR_ASSERT(0);
                }

#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
                if (folder_name != NULL)
                {
                    /* Remove folder name from dest path */
                    srv_fmgr_path_remove_filename((WCHAR *)fmgr_main_p->old_file_path);
                }
#endif                
                
                if (fs_ret <0 )
                {
					display_str_id = srv_fmgr_fs_error_get_string(fs_ret);
                    goto copy_mark_done;
                }
                else
                {
                    fmgr_main_p->async_fs_job_id = fs_ret;
                }
	
                mmi_fmgri_free_and_unlock_buffer(buffer);
                return MMI_RET_OK;
            }
            else
            {
                /* Fail */
                if (allow_popup)
                {
                    /* Include action aborted and other FS error causes */
                    display_str_id = srv_fmgr_fs_error_get_string(done_evt->result);
                }
            }

            copy_mark_done:
 
            if (buffer)
            {
                mmi_fmgri_free_and_unlock_buffer(buffer);
            }

            if (allow_popup && display_str_id)
            {
                /* Due to MS will be closed later, and can_popup is checked, use top level popup */
                switch(display_str_id)
                {
                #ifndef __MMI_SLIM_FILE_MANAGER__
                    case FMGR_FS_ABORTED_ERROR_TEXT:
                    case STR_GLOBAL_DONE:
                    case STR_FMGR_MOVED:
                    case STR_FMGR_COPIED:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_SUCCESS);
                #else
                    case FMGR_FS_ABORTED_ERROR_TEXT:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_SUCCESS);
                        break;
                    case STR_GLOBAL_DONE:
                    case STR_FMGR_MOVED:
                    case STR_FMGR_COPIED:
                        break;
                #endif
                        break;
                    default:
                        FMGR_DisplayPopup(display_str_id, MMI_EVENT_FAILURE);
                        break;
                }
            }

            srv_backlight_turn_off();
            fmgr_main_close_processing();

            if (display_str_id == STR_GLOBAL_DONE || 
                display_str_id == STR_FMGR_MOVED ||
                display_str_id == STR_FMGR_COPIED)
            {
                if (fmgr_main_p->ms_caller_instance)
                {
                    if (action == FMGR_ACTION_MARK_MOVE)
                    {
                        if (CHECK_UCS2STR_EMPTY(fmgr_main_p->ms_highlight_filename))
                        {
                            mmi_fmgri_instance_general_reset_index(fmgr_main_p->ms_caller_instance);
                        }
                        else
                        {
                            mmi_fmgri_instance_general_set_search_filename(fmgr_main_p->ms_caller_instance, fmgr_main_p->ms_highlight_filename);
                        }
                    }
                    fmgr_main_p->ms_caller_instance = NULL;
                }
        
                mmi_fmgri_serv_multi_sel_close(fmgr_main_p->ms_id);
                fmgr_main_p->ms_id = 0;
                fmgr_main_p->action_from_ms = MMI_FALSE;
            }
            else if (fmgr_main_p->ms_id)
            {
                fmgr_main_p->action_from_ms = MMI_FALSE;
                mmi_fmgri_serv_multi_sel_set_mark_array_dirty(fmgr_main_p->ms_id);
            }
    
        #ifdef FMGR_TAB_SUPPORT
            fmgr_main_p->destination_tab_id = 0;
        #endif /* FMGR_TAB_SUPPORT */

            break;

        case EVT_ID_SRV_FMGR_ASYNC_ABORTING:
            grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);
            fmgr_main_p->async_fs_aborting = MMI_TRUE;
            /* Refresh processing screen to "Canceling" */
            if ( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
            {
                mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
                mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
            } 
            break;

        default:
            FMGR_ASSERT(0);
    }

    return MMI_RET_OK;
}



/*****************************************************************************
 * FUNCTION
 *  fmgr_main_copy_mark
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 fmgr_main_copy_mark(U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *buffer;
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)    
	WCHAR *folder_name = NULL;
    S32 str_len = 0;
#endif
    U16 err_string;
    S32 fs_ret;    
    U32 file_size = 0;
    SRV_FMGR_FILEINFO_HANDLE file_hdl;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Do copy */
    buffer = mmi_fmgri_get_and_lock_buffer();
    fs_ret = fmgr_main_mark_copy_find_next(buffer, action);
    if (fs_ret < 0)
    {
        err_string = srv_fmgr_fs_error_get_string(fs_ret);
        goto error_exit;
    }

    fs_ret = srv_fmgr_fileinfo_create((WCHAR*)buffer, &file_hdl);
    if (fs_ret == 0)
    {
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)    
        if (srv_fmgr_fileinfo_get_attribute(file_hdl) & FS_ATTR_DIR)
        {
            /* Concatenate src folder name to dest path */
            folder_name = srv_fmgr_path_get_filename_ptr((WCHAR *)buffer);

            str_len = SRV_FMGR_PATH_MAX_LEN - mmi_ucs2strlen(fmgr_main_p->old_file_path);
            
            if (str_len >= mmi_ucs2strlen((const CHAR*)folder_name))
            {
                mmi_ucs2ncat((CHAR *)fmgr_main_p->old_file_path, (const CHAR *)folder_name, str_len);
            }
            else
            {
                folder_name = NULL;
            }
        }
#endif        
        file_size = srv_fmgr_fileinfo_get_size(file_hdl);            
        srv_fmgr_fileinfo_destroy(file_hdl);
    }
    
    if ((action != FMGR_ACTION_MARK_MOVE) || buffer[0] != fmgr_main_p->old_file_path[0])
    {        
        if (fs_ret == 0)
        {            
            fs_ret = srv_fmgr_drv_check_free_size((U8)fmgr_main_p->old_file_path[0], file_size);
            if (fs_ret < 0)
            {
                err_string = srv_fmgr_fs_error_get_string(fs_ret);
                goto error_exit;
            }
        }
    }

    fmgr_main_p->action_from_ms = MMI_TRUE;
    
    if (action == FMGR_ACTION_MARK_MOVE)
    {
        fs_ret = srv_fmgr_async_move((WCHAR *)buffer, 
                         (WCHAR *) fmgr_main_p->old_file_path,
                         0,
                         mmi_fmgr_async_fs_copy_mark_result_proc,
                         NULL);
    }
    else if (action == FMGR_ACTION_MARK_COPY)
    {
        fs_ret = srv_fmgr_async_copy((WCHAR *)buffer, 
                        (WCHAR *) fmgr_main_p->old_file_path,
                        0,
                        mmi_fmgr_async_fs_copy_mark_result_proc,
                        NULL);
    }
    else
    {
        FMGR_ASSERT(0);
    }

#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
    if (folder_name != NULL)
    {
        /* Remove folder name from dest path */
        srv_fmgr_path_remove_filename((WCHAR *)fmgr_main_p->old_file_path);
        folder_name = NULL;        
    }
#endif    
    
    if (fs_ret <0 )
    {
        err_string = srv_fmgr_fs_error_get_string(fs_ret);
        goto error_exit;
    }
    else
    {
        fmgr_main_p->async_fs_job_id = fs_ret;
    }

    mmi_fmgri_free_and_unlock_buffer(buffer);
    return 0;

error_exit:
#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)    
    if (folder_name != NULL)
    {
        /* Remove folder name from dest path */
        srv_fmgr_path_remove_filename((WCHAR *)fmgr_main_p->old_file_path);
        folder_name = NULL; 
    }
#endif    
    mmi_fmgri_free_and_unlock_buffer(buffer);
    return err_string;
    
}


#if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
#define MULTI_PRINT

S32 fmgr_main_mark_print_next()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    srv_fmgr_fileinfo_struct f_info;
    cui_pict_file_info_struct pict_info;
    S32 msa_id, fs_ret, index;
    S8 *buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(fmgr_main_p->ms_id);

    /* Remove previous one */
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
    mmi_fmgri_msa_pop(msa_id);

    buffer = mmi_fmgri_get_and_lock_buffer();
    fs_ret = 0;
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
    memset(&pict_info, 0, sizeof(cui_pict_file_info_struct));

    /* Find next item */
    if (!mmi_fmgri_msa_count(msa_id))
    {
       fs_ret = FS_NO_MORE_FILES;
    }

    mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));

    /* Check filepath */
    if(mmi_ucs2strlen(buffer) + mmi_ucs2strlen(mmi_fmgri_msa_top(msa_id)) >= SRV_FMGR_PATH_MAX_LEN)
    {
        fs_ret = FS_PATH_OVER_LEN_ERROR;
    }
    mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));

    if (fs_ret == 0)
    {
        fs_ret = mmi_fmgr_get_file_info_by_path(buffer, &file_info);
    }

    if (fs_ret < 0)
    {
        cui_pict_print_next_file(fmgr_main_p->ms_pict_cui_id, &pict_info, fs_ret);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return fs_ret;
    }
    else
    {
        index = 1 + fmgr_main_p->ms_total_count - mmi_fmgri_msa_count(msa_id);
        f_info.type = srv_fmgr_types_get_main_type(&file_info.file_type);
        f_info.attribute = file_info.attribute;
        f_info.size = file_info.file_size;
        memcpy(&f_info.datetime, &file_info.time, sizeof(MYTIME));
        pict_info.full_path = (WCHAR *)buffer;
        pict_info.index = index;
        pict_info.info = &f_info;

        cui_pict_print_next_file(fmgr_main_p->ms_pict_cui_id, &pict_info, fs_ret);

        mmi_fmgri_free_and_unlock_buffer(buffer);
    }

    return 0;
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_print_mark
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_print_mark(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables            2                                    */
    /*----------------------------------------------------------------*/
    S32 msa_id, fs_ret, index;
    S8  *buffer;
    mmi_id cui_id;
    FMGR_FILE_INFO_STRUCT file_info;
    srv_fmgr_fileinfo_struct f_info;
    cui_pict_file_info_struct pict_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_main_p->ms_id);
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
    fmgr_main_p->ms_total_count = (U8)mmi_fmgri_msa_count(msa_id);
    buffer = mmi_fmgri_get_and_lock_buffer();

    /* Find next item */
    if (!mmi_fmgri_msa_count(msa_id))
    {
        /* There must be at least one file to print */
        FMGR_ASSERT(0);
    }
    
    mmi_fmgri_serv_multi_sel_get_path(fmgr_main_p->ms_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));

    /* Check filepath */
    if (mmi_ucs2strlen(buffer) + mmi_ucs2strlen(mmi_fmgri_msa_top(msa_id)) >= (SRV_FMGR_PATH_MAX_LEN + 1))
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(FS_PATH_OVER_LEN_ERROR), MMI_EVENT_FAILURE);
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return;
    }
    mmi_ucs2cat(buffer, mmi_fmgri_msa_top(msa_id));

    fs_ret = mmi_fmgr_get_file_info_by_path(buffer, &file_info);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
	 mmi_fmgri_free_and_unlock_buffer(buffer);
        return;
    }

    index = 1 + fmgr_main_p->ms_total_count - mmi_fmgri_msa_count(msa_id);

    f_info.type = srv_fmgr_types_get_main_type(&file_info.file_type);
    f_info.attribute = file_info.attribute;
    f_info.size = file_info.file_size;
    memcpy(&f_info.datetime, &file_info.time, sizeof(MYTIME));

    pict_info.full_path = (WCHAR *)buffer;
    pict_info.index = index;
    pict_info.info = &f_info;

    cui_id = cui_pict_print_launch(mmi_fmgri_instance_get_screen_id(instance->id),
                     MMI_TRUE,
                     fmgr_main_p->ms_total_count,
                     &pict_info);

    fmgr_main_p->ms_pict_cui_id = cui_id;

    mmi_fmgri_free_and_unlock_buffer(buffer);

}

void mmi_fmgr_multi_print_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (fmgr_main_p->ms_id)
    {
        mmi_fmgri_serv_multi_sel_close(fmgr_main_p->ms_id);
        fmgr_main_p->ms_caller_instance = NULL;
        fmgr_main_p->ms_id = 0;
        fmgr_main_p->ms_pict_cui_id = 0;
    }
    mmi_fmgr_close_option_screen();
}

#endif /* #ifndef __MMI_PICT_BRIDGE_MULTI_FILE_PRINT__ */

static void fmgr_main_send_mark(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_main_p->ms_id);

#ifdef __MMI_OPP_SUPPORT__
    mmi_fmgr_bt_multi_send(fmgr_main_p->ms_id);
#endif
}

#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */


#ifdef __FS_CARD_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  fmgr_main_entry_card_detail
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_entry_card_detail(mmi_scrn_essential_struct* scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    fmgr_drive_info_struct drv_info;
    S32 fs_ret;
    U16 buf_drv_name[SRV_FMGR_DRV_MAX_NAME_LEN + 1];
    U64 disk_free_space, disk_total_space;
    U8 *info;
    U16 iconId;
    U8 instance_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance_id = (U8)((U32)scr_info->user_data);
    instance = mmi_fmgri_get_instance_by_id(instance_id);
    
    fs_ret = mmi_fmgri_fsdata_instance_get_drive_info(instance->id, instance->cur_index, &drv_info);
    if (fs_ret < 0)
    {
        mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(instance_id), SCR_FMGR_CARD_DETAIL);
        return;
    }
    ASSERT(drv_info.drv_type == SRV_FMGR_DRV_CARD_TYPE ||
           drv_info.drv_type == SRV_FMGR_DRV_CARD_2_TYPE);
    
    if (!mmi_frm_scrn_enter(
            mmi_fmgri_instance_get_screen_id(instance_id), 
            SCR_FMGR_CARD_DETAIL, 
            NULL, (FuncPtr)fmgr_main_entry_card_detail, MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }

    info = (PU8) subMenuData;

    SET_UCS2STR_EMPTY(buf_drv_name);

    if (srv_fmgr_drv_get_name((U8)drv_info.drv_path[0], (WCHAR *)buf_drv_name, (SRV_FMGR_DRV_MAX_NAME_LEN + 1) * ENCODING_LENGTH) < 0)
    {
        mmi_wcsncpy((U16*)buf_drv_name, (U16*)GetString((U16)STR_FMGR_REM_DEVICE), SRV_FMGR_DRV_MAX_NAME_LEN);
    }
    
    mmi_ucs2cpy((PS8) info, (PS8) GetString(STR_FMGR_CARD_NAME));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

    mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);

    mmi_ucs2cat((PS8) info, (PS8) L"\n");
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

    /* size */
    disk_free_space = 0;
    disk_total_space = 0;
    fs_ret = srv_fmgr_drv_get_size((U8)drv_info.drv_path[0], &disk_total_space, &disk_free_space);

    /* total size */
    mmi_ucs2cat((PS8) info, (PS8) GetString(STR_ID_FMGR_TOTAL_SIZE));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");
	
    mmi_fmgri_gui_format_size(disk_total_space, (U16*)buf_drv_name, SRV_FMGR_DRV_MAX_NAME_LEN);
    mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

    mmi_ucs2cat((PS8) info, (PS8) L"\n");	

    /* free size */
    mmi_ucs2cat((PS8) info, (PS8) GetString(STR_ID_FMGR_FREE_SIZE));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");
	
    mmi_fmgri_gui_format_size(disk_free_space, (U16*)buf_drv_name, SRV_FMGR_DRV_MAX_NAME_LEN);
    mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);   

    mmi_fmgri_instance_get_title_info(instance->id, NULL, &iconId);

    ShowCategory74Screen(
        STR_GLOBAL_DETAILS,
        iconId,
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) subMenuData,
        MAX_SUB_MENUS * MAX_SUB_MENU_SIZE,
        mmi_frm_scrn_get_active_gui_buf());

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}

#endif /* __FS_CARD_SUPPORT__ */

#define ASYNC_OPERATION

static mmi_ret fmgr_main_processing_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __FMGR_KEY_RULE__
    mmi_scenario_evt_struct *evt;
    U32 data;
#endif /* __FMGR_KEY_RULE__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_SCRN_GOBACK:					/* FMGR is active sg */
        case EVT_ID_SCRN_GOBACK_IN_END_KEY:         /* FMGR is active sg */   
        case EVT_ID_SCRN_DELETE_REQ:				/* FMGR is inactive sg */
        case EVT_ID_SCRN_DELETE_REQ_IN_END_KEY:		/* FMGR is inactive sg */         
            if (mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE)
            {
            #ifdef __FMGR_KEY_RULE__
                evt = (mmi_scenario_evt_struct*)param;
                data = (U32)mmi_frm_scrn_get_user_data(evt->targ_group, evt->targ_scrn);
                FMGR_ASSERT(data);

                if ((U8)((data >> 8) & 0xFF))    // if can_cancel
                {
                    fmgr_main_abort_processing();
                    break;
                }
           #endif /* __FMGR_KEY_RULE__ */ 
           #ifdef __DM_LAWMO_SUPPORT__
                fmgr_main_p->post_endkey = MMI_TRUE;
           #endif
                return MMI_RET_ERR;
            }
            break;
        case EVT_ID_SCRN_DEINIT:
            fmgr_main_abort_processing();
            fmgr_main_p->async_fs_instance_id = 0;
            break;
    }
    
    return MMI_RET_OK;
}

static void fmgr_main_entry_processing(mmi_scrn_essential_struct* info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 data;
    U16 string_id;
    U16 icon_id, title_str_id;
    U8  instance_id;
    U8  can_cancel;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

    data = (U32)info->user_data;
    instance_id = (U8)(data & 0xFF);
    can_cancel = (U8)((data>>8) & 0xFF);
    string_id = (U16)((data>>16) & 0xFFFF);
    
    FMGR_TRACE3(TRC_MMI_FMGR_0CA6574A36AB4828B36B3C84D0F28447,   
        "[MMIFMGR] > Main > fmgr_main_entry_processing > data=0x%08X, async_fs_state=%d, async_fs_abort=%d\n",
        data, mmi_fmgri_main_get_async_fs_state(), fmgr_main_p->async_fs_aborting);

    if (!mmi_frm_scrn_enter(
            mmi_fmgri_instance_get_screen_id(instance_id),
            SCR_ID_FMGR_PROCESSING, 
            NULL, (FuncPtr)fmgr_main_entry_processing, MMI_FRM_UNKNOW_SCRN))
    {
        mmi_frm_scrn_set_leave_proc(
            mmi_fmgri_instance_get_screen_id(instance_id),
            SCR_ID_FMGR_PROCESSING, 
            fmgr_main_processing_proc);
        return;
    }

    mmi_frm_scrn_set_leave_proc(
        mmi_fmgri_instance_get_screen_id(instance_id),
        SCR_ID_FMGR_PROCESSING, 
        fmgr_main_processing_proc);

    mmi_fmgri_instance_get_title_info(instance_id, &title_str_id, &icon_id);

    if (fmgr_main_p->async_fs_aborting)
    {
        can_cancel = MMI_FALSE;
        string_id = STR_GLOBAL_CANCELLING;
    }

    ShowCategory66Screen(
        title_str_id,
        icon_id,
        0,
        0,
        (U16)(can_cancel ? STR_GLOBAL_CANCEL : 0),
        0,
        (PU8) GetString(string_id),
        mmi_get_event_based_image(MMI_EVENT_PROGRESS),
        NULL);   
    
    if (can_cancel)
    {
        SetRightSoftkeyFunction(fmgr_main_processing_rsk_hdlr, KEY_EVENT_UP);
        SetKeyDownHandler(fmgr_main_processing_rsk_hdlr, KEY_END);
    }
}

static void fmgr_main_show_processing(mmi_fmgr_instance_struct *instance, U8 new_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 data;   /* = string_id + can_cancel + id */
    U16 string_id;
    U8 can_cancel;
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
    S32 msa_id;
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(mmi_fmgri_main_get_async_fs_state() == FMGR_ACTION_NONE);
    mmi_fmgri_main_set_async_fs_state(new_state);
    fmgr_main_p->async_fs_aborting = MMI_FALSE;
    fmgr_main_p->async_fs_instance_id = instance->id;

    can_cancel = MMI_TRUE;
    string_id = 0;

    switch (new_state)
    {
        case FMGR_ACTION_DELETE_FOLDER:
        case FMGR_ACTION_DELETE_ALL:
        case FMGR_ACTION_DELETE_BY_FILTER:
            string_id = STR_GLOBAL_DELETING;
            break;
        case FMGR_ACTION_DELETE_SINGLE:
            string_id = STR_GLOBAL_DELETING;
            can_cancel = MMI_FALSE;
        break;
    #ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
        case FMGR_ACTION_MARK_DELETE:
            FMGR_ASSERT(fmgr_main_p->ms_id);
            msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_main_p->ms_id);
            if (mmi_fmgri_msa_count(msa_id) == 1)
            {
                can_cancel = MMI_FALSE;
            }
            string_id = STR_GLOBAL_DELETING;
            break;
    #endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */
        case FMGR_ACTION_COPY:
        case FMGR_ACTION_MARK_COPY:
            string_id = STR_GLOBAL_COPYING;
            break;
        case FMGR_ACTION_MOVE:
        case FMGR_ACTION_MARK_MOVE:
            string_id = STR_GLOBAL_MOVING;
            break;
        case FMGR_ACTION_FORMAT:
            string_id = STR_FMGR_FORMATING;
            can_cancel = MMI_FALSE;
            break;
        case FMGR_ACTION_UNMOUNT:
            string_id = STR_FMGR_UNMOUNTING;
            can_cancel = MMI_FALSE;
            break;
    }

    data = (string_id<<16) | (can_cancel<<8) | instance->id;

    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id),
        SCR_ID_FMGR_PROCESSING,
        (FuncPtr)fmgr_main_entry_processing,
        (void*)data);

}

static void fmgr_main_close_processing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE);
    mmi_fmgri_main_set_async_fs_state(FMGR_ACTION_NONE);
    fmgr_main_p->async_fs_job_id = 0;
    fmgr_main_p->async_fs_aborting = MMI_FALSE;

    if (!mmi_fmgri_is_instance_id_valid(fmgr_main_p->async_fs_instance_id))
    {
        return;
    }    
    
#ifdef __DM_LAWMO_SUPPORT__	
    if (fmgr_main_p->post_endkey)
    {
        fmgr_main_p->post_endkey = MMI_FALSE;
        mmi_fmgri_instance_general_close_by_id(fmgr_main_p->async_fs_instance_id);
    }
	else
	{
		mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id), SCR_ID_FMGR_PROCESSING);
	}
#else
	mmi_frm_scrn_close(mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id), SCR_ID_FMGR_PROCESSING);
#endif
    fmgr_main_p->async_fs_instance_id = 0;
}

//mick todo
static void fmgr_main_abort_processing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 data;
    U8  can_cancel;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_TRACE2(TRC_MMI_FMGR_DAA62F1FF92B4DA2B08838DFAF79CF11,   
        "[MMIFMGR] > Main > fmgr_main_abort_processing > async_fs_state=%d, async_fs_abort=%d\n",
        mmi_fmgri_main_get_async_fs_state(), fmgr_main_p->async_fs_aborting);

    if (mmi_fmgri_main_get_async_fs_state() == FMGR_ACTION_NONE)
    {
        return;
    }

    if (fmgr_main_p->async_fs_aborting)
    {
        return;
    }

    if (mmi_fmgri_main_get_async_fs_state() >= FMGR_ACTION_OTHER)
    {
        can_cancel = MMI_TRUE;
    }
    else
    {
        data = (U32)mmi_frm_scrn_get_user_data(mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id), SCR_ID_FMGR_PROCESSING);
        if (data)
        {
            can_cancel = (U8)((data >> 8) & 0xFF);
            if (!can_cancel)
            {
                return;
            }
        }
        else
        {
            can_cancel = MMI_TRUE;
        }
    }

    if (srv_fmgr_async_abort(fmgr_main_p->async_fs_job_id, MMI_FALSE) == MMI_TRUE)
    {
        fmgr_main_p->async_fs_aborting = MMI_TRUE;
    }
    

/*
    switch (mmi_fmgri_main_get_async_fs_state())
    {
        case FMGR_ACTION_DELETE_FOLDER:
        case FMGR_ACTION_DELETE_ALL:
        case FMGR_ACTION_OTHER_DEL_FOLDER:
            FS_Abort(FS_ABORT_XDELETE);
        break;

    default:
        fmt_abort_copy();
        break;
    }*/

}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_processing_rsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void fmgr_main_processing_rsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id grp_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_abort_processing();

    grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);

    /* Refresh processing screen to "Canceling" */
    if ( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
    {
        mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
        mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
    }   
}

static mmi_fmgr_instance_struct* fmgr_main_get_processing_instance(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_TRACE3(TRC_MMI_FMGR_9BD3E70604584EB69C0BEEFB0D8B5F6A,
        "[MMIFMGR] > Main > fmgr_main_get_processing_instance > id=%d, async_fs_state=%d, async_fs_abort=%d\n",
        fmgr_main_p->async_fs_instance_id, mmi_fmgri_main_get_async_fs_state(), fmgr_main_p->async_fs_aborting);
    
    if (mmi_fmgri_is_instance_id_valid(fmgr_main_p->async_fs_instance_id))
    {
        return mmi_fmgri_get_instance_by_id(fmgr_main_p->async_fs_instance_id);
    }
    return NULL;
}

static U8 fmgr_main_processing_can_popup(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id grp_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!instance)
    {
        return MMI_FALSE;
    }

    grp_id = mmi_fmgri_instance_get_screen_id(instance->id);

    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_DATA_CSD, NULL) > 0 &&
         !(mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE))
    {
        return MMI_FALSE;
    }

    return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_fmgri_main_get_async_fs_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_fmgri_main_get_async_fs_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return fmgr_main_p->async_fs_state;
}

/*****************************************************************************
 * FUNCTION
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *****************************************************************************/
void mmi_fmgri_main_set_async_fs_state(U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_main_p->async_fs_state = action;
    fmgr_main_p->async_fs_aborting = MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *****************************************************************************/
void mmi_fmgri_main_clear_async_fs_state(U8 action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(fmgr_main_p->async_fs_state == action);
    FMGR_ASSERT(action >= FMGR_ACTION_OTHER);
    fmgr_main_p->async_fs_state = FMGR_ACTION_NONE;
}

/*****************************************************************************
 * FUNCTION
 *  fmgr_main_op_abort_processing_hdlr
 * DESCRIPTION
 *  operation abort processing message handler
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmgr_main_op_abort_processing_hdlr(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE &&
        !fmgr_main_p->async_fs_aborting)
    {
        fmgr_main_p->async_fs_aborting = MMI_TRUE;

        grp_id = mmi_fmgri_instance_get_screen_id(fmgr_main_p->async_fs_instance_id);

        if( mmi_frm_scrn_get_state(grp_id, SCR_ID_FMGR_PROCESSING) & MMI_SCENARIO_STATE_ACTIVE)
        {
            srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
        
            mmi_frm_scrn_enter(grp_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, (FuncPtr)mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);
            mmi_frm_scrn_close(grp_id, SCR_ID_FMGR_GENERAL_DUMMY);
        }   
    }

}


#ifdef __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__


static void fmgr_main_start_phone_lock_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id cui_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(mmi_fmgri_is_instance_id_valid(fmgr_main_p->client_id));

    cui_id = cui_verify_create(mmi_fmgri_instance_get_screen_id(fmgr_main_p->client_id), CUI_VERIFY_TYPE_PHONE_PASSWORD);
    cui_verify_run(cui_id);


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}

#endif /* if __MMI_FMGR_FORMAT_WITH_PHONE_LOCK_CONFIRM__ */


#ifdef __OP12__

static void fmgr_main_memory_detail_rsk_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct    *instance;
    WCHAR                       path_buf[10];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /****** use active API, RSK handler ******/
    instance = mmi_fmgri_get_active_instance();
    
    kal_wsprintf(path_buf, "%d", STR_GLOBAL_MEMORY_STATUS);
    mmi_fmgri_instance_general_set_search_filename(instance, (S8*)path_buf);
    
    mmi_frm_scrn_close_active_id();
}

static void fmgr_main_entry_memory_detail(mmi_scrn_essential_struct* scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    SRV_FMGR_DRVLIST_HANDLE drvlist_hdl;
    S32 fs_ret, i;
    U16 buf_drv_name[SRV_FMGR_DRV_MAX_NAME_LEN + 1];
    U64 disk_free_space, disk_total_space;
    S8 *info;
    U16 iconId;
    U8 instance_id;
    WCHAR *colon;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance_id = (U8)((U32)scr_info->user_data);
    instance = mmi_fmgri_get_instance_by_id(instance_id);

    if (!mmi_frm_scrn_enter(
            mmi_fmgri_instance_get_screen_id(instance_id),
            SCR_FMGR_DETAIL,
            NULL, (FuncPtr)fmgr_main_entry_memory_detail, 0))
    {
        return;
    }

    info = (S8*) subMenuData;
    SET_UCS2STR_EMPTY(info);

    drvlist_hdl = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);

    for (i = 0; i < srv_fmgr_drivelist_count(drvlist_hdl); i++)
    {
        if (srv_fmgr_drv_get_name((U8)srv_fmgr_drivelist_get_drv_letter(drvlist_hdl, i),
            (WCHAR *)buf_drv_name,
            (SRV_FMGR_DRV_MAX_NAME_LEN + 1) * ENCODING_LENGTH) < 0)
        {
            /* Can't get name, use drive type as display name */
            mmi_wcsncpy((U16*)buf_drv_name,
                (U16*)GetString(srv_fmgr_drv_get_string(srv_fmgr_drivelist_get_drv_letter(drvlist_hdl, i))),
                SRV_FMGR_DRV_MAX_NAME_LEN);
        }

        mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);
        colon = (WCHAR*)GetString(STR_ID_FMGR_FILE_SIZE);
        while(*(colon+1)) colon++;
        mmi_ucs2cat((PS8) info, (PS8) colon);
        mmi_ucs2cat((PS8) info, (PS8) L"\n");

        /* Size */
        disk_free_space = 0;
        disk_total_space = 0;
        fs_ret = srv_fmgr_drv_get_size((U8)srv_fmgr_drivelist_get_drv_letter(drvlist_hdl, i), &disk_total_space, &disk_free_space);
        if (fs_ret < 0)
        {
            FMGR_ASSERT(0);
        }

        /* Free/total size */
        mmi_fmgri_gui_format_size(disk_free_space, (U16*)buf_drv_name, SRV_FMGR_DRV_MAX_NAME_LEN);
        mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);
        mmi_ucs2cat((PS8) info, (PS8) L"/");
        mmi_fmgri_gui_format_size(disk_total_space, (U16*)buf_drv_name, SRV_FMGR_DRV_MAX_NAME_LEN);
        mmi_ucs2cat((PS8) info, (PS8) buf_drv_name);

        mmi_ucs2cat((PS8) info, (PS8) L"\n\n");	
    }

    srv_fmgr_drivelist_destroy(drvlist_hdl);

    mmi_fmgri_instance_get_title_info(instance->id, NULL, &iconId);

    ShowCategory74Screen(
        STR_GLOBAL_MEMORY_STATUS,
        iconId,
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) subMenuData,
        MAX_SUB_MENUS * MAX_SUB_MENU_SIZE,
        mmi_frm_scrn_get_active_gui_buf());

    SetRightSoftkeyFunction(fmgr_main_memory_detail_rsk_handler, KEY_EVENT_UP);

}

void mmi_fmgr_display_memory_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /****** use active API ******/
    instance = mmi_fmgri_get_active_instance();

    mmi_frm_scrn_first_enter(
        mmi_fmgri_instance_get_screen_id(instance->id),
        SCR_FMGR_DETAIL,
        (FuncPtr)fmgr_main_entry_memory_detail,
        (void*)instance->id);
}
#endif /* __OP12__ */

#endif /* defined (__MMI_FILE_MANAGER__) */

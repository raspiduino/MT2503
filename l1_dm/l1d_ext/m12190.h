/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 *
 * Filename:
 * ---------
 *   m12190.h
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   Setup RF
 *
 * Author:
 * -------
 * -------
 *
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *******************************************************************************/


#ifndef  _M12190_H_
#define  _M12190_H_
/*---------------------------------------------------------------------------*/

/*...................................*/
// for the following IS_CHIP_* compile option
#include "l1d_cid.h"

#if defined(L1_SIM) || IS_CHIP_MT6268T || IS_CHIP_MT6268T_DMAC
#include "tool.h"
#else
#define  HW_WRITE(ptr,data)      (*(ptr) = (data))
#define  HW_READ(ptr)            (*(ptr))
#define  LET_SIM_TIME_RUN_A_BIT()
#endif

/*...................................*/

#ifndef _L1D_DATA_H_
#define  PWRRES_BIT              3
#define  PWRRES                  (1<<PWRRES_BIT)
#endif

#define  GAINLOSS( n )           ((signed char)((n)*PWRRES))
#define  TABLE_END               -1

/*...................................*/

#define  IS_CONTINUOUS_RX_SLOT() ((l1d_rf.rx_slots&CONTISLOTMASK[l1d_rf.cur_slot])==CONTISLOTMASK[l1d_rf.cur_slot])
#define  IS_CONTINUOUS_TX_SLOT() ((l1d_rf.tx_slots&CONTISLOTMASK[l1d_rf.cur_slot])==CONTISLOTMASK[l1d_rf.cur_slot])
#define  IS_1ST_RX_SLOT()        ((l1d_rf.rx_slots&FIRSTSLOTMASK[l1d_rf.cur_slot])==(1<<l1d_rf.cur_slot))
#define  IS_1ST_TX_SLOT()        ((l1d_rf.tx_slots&FIRSTSLOTMASK[l1d_rf.cur_slot])==(1<<l1d_rf.cur_slot))
#if IS_RF_VCO_PARTIAL_DOO_ON || IS_RF_VCO_DOO_OFF
#define  IS_2_TX_CWIN()          ((l1d_rf.tx_slots==5)||(l1d_rf.tx_slots==9)||(l1d_rf.tx_slots==10)||(l1d_rf.tx_slots==11)||(l1d_rf.tx_slots==13))
                                 /*       T_T_                  T__T                  _T_T                  TT_T                   T_TT        */
   #if IS_RF_MT6162 && IS_RF_VCO_PARTIAL_DOO_ON
#define  IS_2ND_RX_SLOT_EXIST()  ((l1d_rf.rx_slots==5)||(l1d_rf.rx_slots==9)||(l1d_rf.rx_slots==10)||(l1d_rf.rx_slots==11)||(l1d_rf.rx_slots==13))
                                 /*       R_R_                  R__R                  _R_R                  RR_R                   R_RR        */
   #endif
#endif

/*...................................*/

#if IS_DCXO_SUPPORT_CHIP && IS_AFC_EVENT_SUPPORT_CHIP
#define IS_USE_AFC()             (l1d_rf.is_afc_event_enable)
#define IS_AFC_TRIGGER_BSI()     (l1d_rf.is_afc_trigger_bsi)
#elif IS_DCXO_SUPPORT_CHIP
#define IS_USE_AFC()             (0)
#define IS_AFC_TRIGGER_BSI()     (0)
#else
#define IS_USE_AFC()             (1)
#define IS_AFC_TRIGGER_BSI()     (0)
#endif

#if IS_BBTXRX_CHIP_DESIGN_VER_2
#define IS_AUTO_CAL_IN_PROCESS() (L1D_RF_RXDCOC_Check() || L1D_RF_TXIQMM_Check())
#else
#define IS_AUTO_CAL_IN_PROCESS() (0)
#endif

#ifndef l1_types_public_h
typedef enum
{
   FrequencyBand400,
   FrequencyBand850,
   FrequencyBand900,
   FrequencyBand1800,
   FrequencyBand1900,

   FrequencyBandCount

} FrequencyBand;
#endif

/*...................................*/

typedef struct
{
   unsigned short data[16];   /* for closed-loop AUXADC/BSI TXPC  */
} sTXPC_ADCDATA;

typedef struct
{
   unsigned short data[8];    /* for closed-loop BSI TXPC         */
} sTXPC_TEMPDATA;

typedef struct
{
   char           is_calibrated;
   sTXPC_ADCDATA  adc[FrequencyBandCount];
   short          temperature;
   sTXPC_TEMPDATA temp[FrequencyBandCount];
} sTXPC_L1CAL;

typedef struct
{
   unsigned short data[8];    /* for temperature ADC */
} sTEMPERATURE_ADC_L1CAL;

#if IS_TX_POWER_CONTROL_SUPPORT
#define TXPC_SLOT_MAX            4
#define TXPC_MAX_OFFSET_PWR      4     /* Max compensation: 4 dBm */
#define TXPC_DB_NUM              8     /* Must be 2^n             */
#define TXPC_DB_RES              12
#define TXPC_DB_ROUNDING         (1<<(TXPC_DB_RES-1))
#define TXPC_DB_MAX_OFFSET       ((TXPC_MAX_OFFSET_PWR<<TXPC_DB_RES)/2) /* DB offset: (1<<TXPC_DB_RES) == 2dB */
#define TXPC_RD_ADC_RES          6
#define TXPC_RD_ADC_ROUNDING     (1<<(TXPC_RD_ADC_RES-1))
#define AUXADC_DAT_RES           12
#define AUXADC_DAT_MASK          ((1<<AUXADC_DAT_RES) - 1)
#define AUXADC_VALUE_MAX         ((1<<AUXADC_DAT_RES) - 1)
#define TXPC_WEIGHT_CAL          2     /* For calibration   */
#define TXPC_WEIGHT_UPDATE       4     /* For normal update */
#define TEMP_IDX_DEFAULT         2     /* Default index of TXTEMP_DATA for 20 oC */
#define TEMP_VALUE_DEFAULT       20    /* Default temperature: 20 oC */


   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
#define TXPC_CL_DET_RES          12    /* the detetor resolution */
   #endif

   #if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
#define TXPC_OL_UPDATE_PERIOD    2//200   /* 200 L1 frames     */
   #endif

   #if IS_CHIP_MT6256 || IS_EDGE_SAIC_CHIP_MT6270A_AND_LATTER_VERSION
      #if IS_CHIP_MT6256
#define TXPC_RF_TEMP_CW          138
#define TXPC_BB_PGA_GAIN_MAX     7
      #endif
#define TXPC_AUXADC_VDET_PORT    6
#define TXPC_ADC_THRES_G         2
#define TXPC_ADC_THRES_E         4
#define TXPC_RF_TEMP_RES         12
   #endif

   #if IS_RF_MT6162
#define TXPC_RF_ADC_SLOPE        32    /* 1 dB power change = 32 steps of ADC change        */
#define TXPC_RF_PA_GAIN_SLOPE    32    /* 1 dB power change = 32 steps of OH PA gain change */
   #endif

typedef enum
{                                /* Sampling       */
   TXPC_NO_CONTROL_TYPE,         /* (Do nothing)   */
   TXPC_AUXADC_CLOSED_TYPE,      /* AUXADC (Vdet)  */
   TXPC_BSI_CLOSED_TYPE,         /* BSI_RD (Pdet)  */
   TXPC_AUXADC_OPEN_TYPE,        /* AUXADC (Temp.) */
   TXPC_BSI_OPEN_TYPE            /* RF Temperature */
} TXPC_TYPE;

typedef enum
{                                /* Calibration    DB Update & Compensation        */
   TXPC_SAMPLE_MODE,             /* N              N, Only output sampling results */
   TXPC_NORMAL_MODE,             /* N              Y                               */
   TXPC_META_MODE,               /* Y              N                               */
   TXPC_TRANS_TO_META_MODE,      /* N              N                               */
   TXPC_TRANS_TO_NORMAL_MODE     /* N              N                               */
} TXPC_MODE;

typedef struct
{
            short    adc;        /* info_idx=0, record the themister read-back value */
            short    idx;        /* info_idx=1, record the region index (0~7) of current temperature */
            short    value;      /* info_idx=2, record the temperature (degree) calculated from the themister read-back value */
} sTXPC_TEMP_INFO;

typedef struct
{
            short    power_idx_right;              /* Setup stage only */
            short    power_dac_right;              /* Setup stage only */
            short    power_dac_left;               /* Setup stage only */
            short    power_dac_target;             /* Setup stage only */

   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
   unsigned char     is_dtx_detected;              /* Passed to COMPUTE in runQ1 */
            short    adc_interval[TXPC_SLOT_MAX];  /* Passed to COMPUTE in runQ1 */
            short    target_adc[TXPC_SLOT_MAX];    /* Passed to COMPUTE in runQ1. Target Vdet or Pdet ADC value */
            short    power_idx[TXPC_SLOT_MAX];     /* For calibration only */
   #endif
} sTXPC_SETUP;

   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
typedef struct
{                                                  /* Update in Run Q 1 */
   unsigned char     tx_slots;                     /* win.last_tx_slots. [7:0]:TX slots mask    */
      #if IS_EPSK_TX_SUPPORT
   unsigned char     tx_mod_type;                  /* win.last_tx_mod_type */ // 29 latter
      #endif
   unsigned char     tx_setting_change;            /* [3:0] 1: TX slot 0-3 power chang, 0: no change. If power changes, final computed ratio is divided by 2 to avoid the problem that contiguous slot power diff is not 2 dBm */
            char     rf_band;                      /* Computed from win.last_rtx_arfcn */
            short    arfcn;                        /* win.last_rtx_arfcn   */
            short    adc_interval[TXPC_SLOT_MAX];
            short    target_adc[TXPC_SLOT_MAX];    /* Target power. TXPC_AUXADC_CLOSED_MODE: Vdet, TXPC_BSI_CLOSED_MODE: Pdet */
            short    power_idx[TXPC_SLOT_MAX];     /* For traditional calibration only */
            long     rdbk_adc[TXPC_SLOT_MAX];      /* Readback power from AUXADC or RF(BSI). Resolution enhanced before storing. Fed into alpha filter */
} sTXPC_CL_COMPUTE;

typedef struct
{
   unsigned short    outdate;                            /* The larger this number is, the more likely this DB entry is to be cleared. */
            short    arfcn;                              /* Applied ARFCN */
            short    dac_offset_ratio_G[TXPC_SLOT_MAX];  /* APC DAC offset ratio, if target power is changed, apply half of the DB value due to incorrect ratio exchange between different PCL */
      #if IS_EPSK_TX_SUPPORT
            short    dac_offset_ratio_E[TXPC_SLOT_MAX];  /* APC DAC offset ratio, valide value range: min:(-1)<<14, max: 1<<14 */
      #endif
} sTXPC_CL_DB_DATA;

typedef struct
{
   sTXPC_CL_DB_DATA  data[TXPC_DB_NUM];
} sTXPC_CL_DB;
   #endif /* IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT */

   #if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
typedef struct
{
   short             temperature;
   short             update_coutdown;              /* Update event is triggered when this value is zero */
} sTXPC_OL_DB;
   #endif /* IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT */

typedef struct
{
   sTXPC_TEMP_INFO   temp_info;                    /* Temperature info for both closed & open loop */
   sTXPC_SETUP       setup;                        /* For TX setup recorded in  L1D_SetupTxAPC & L1D_SetupTxAPC2 */

   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
   sTXPC_CL_COMPUTE  cl_compute;                   /* For TXPC computation in L1D_TXPC_Update1 & L1D_TXPC_Update2 before updating DB */
   sTXPC_CL_DB       cl_db;                        /* Database of TX power compensation */
   #endif
   #if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
   sTXPC_OL_DB       ol_db;
   #endif
} sTXPC;

typedef struct
{
   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
   short             subband_compensation;
   short             temperature_compensation;
   #endif
   #if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
   short             ratio;                        /* record the compensation ratio */
   #endif
} sTXPC_TRACE;

extern       char       closed_loop_txpc_type;
extern const char       open_loop_txpc_type;
extern       char       is_txpc_calibrated;

   #if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
extern sTXPC_ADCDATA*   TXADC_Data[FrequencyBandCount];
extern sTXPC_TEMPDATA*  TXTEMP_Data[FrequencyBandCount];
      #if IS_EPSK_TX_SUPPORT
extern sTXPC_ADCDATA*   TXADC_Data_EPSK[FrequencyBandCount];
extern sTXPC_TEMPDATA*  TXTEMP_Data_EPSK[FrequencyBandCount];
      #endif
   #endif   /* IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT */

   #if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
extern short            ref_temperature;
   #endif
#endif      /* IS_TX_POWER_CONTROL_SUPPORT */

/*...................................*/

#define  RF_RX                   0
#define  RF_TX                   1
#define  RF_TX_8G                2

/*...................................*/


/* BB -> RF structure, can not use RF complie option */

typedef  struct
{
   char           cwin_idx;
   char           band;
   signed char    rtxwin_idx;
   char           is_init;
   char           is_nvram_data_ready;
   char           cur_slot;
   char           cur_slot_n;
   char           rx_slots;
   char           tx_slots;
   char           tx_mod_type;
   unsigned short tx_mod_type2;
   char           modidx;
   char           change;
   char           bb_tx_autocal;
   char           bat_volt;
   char           bat_temp;
   char           old_band;
   unsigned short apc_dc_offset;
   unsigned short AFC_data;
   unsigned long  RFN_data;
   unsigned long  IFN_data;
   unsigned long  AGC_data;
   char           inj;
   char           next_inj;
   char           d2c_txiqswap;
   char           d2c_txiqconfig;
   char           egsm_disable;
   unsigned long  Uncalibrated_LID_Flag;
   unsigned short gpio_modeswitch;
   unsigned char  handle_tx_dcm;
#if IS_DCXO_SUPPORT_CHIP && IS_AFC_EVENT_SUPPORT_CHIP
   unsigned char  is_afc_event_enable;
   unsigned char  is_afc_trigger_bsi;
#endif
#if IS_OBB_DETECTION_SUPPORT
   signed short   if_change;
   signed int     obb_arfcn;
#endif
#if IS_FHC_SUPPORT
   char           fhc_proc;
   signed short   fhc_high_apc_dcoffset;
   unsigned char  fhc_vbias[4];
   unsigned char  fhc_is_low_pcl[4];
#endif
#if IS_BBTXRX_CHIP_DESIGN_VER_2
   signed short   rx_dc_i;
   signed short   rx_dc_q;
   signed short   cal_band;
   char           is_rf_rxdcoc_support;
   char           is_rf_txiqmm_support;
#endif
#if IS_TX_POWER_CONTROL_SUPPORT
   TXPC_MODE      txpc_mode;
   TXPC_TYPE      txpc_type;
   sTXPC          txpc;
   sTXPC_TRACE    txpc_trc;
   char           is_txpc_in_meta;
#endif
#if IS_W_CANCELLATION_SUPPORT
   char           if_state;
#endif
#if IS_HEADROOM_DETECTION_SUPPORT ||       \
    IS_INBAND_BLOCKER_DETECTION_SUPPORT || \
    IS_OUTBAND_BLOCKER_DETECTION_SUPPORT
   char           blk_flag;
#endif
#if IS_TEMP_COMP_TC_GAIN_SUPPORT
   #if IS_RF_MT6250RF || IS_RF_MT6260RF
   short          thermo_adc_code;        /* range: 0 ~ 63 (6-bits) */
   short          thermo_adc_code_offset; /* in form of S8.8        */
   #endif
   #if IS_KCAL_COMP_TC_GAIN_SUPPORT
   short          k_cal;                  /* range: 0~ 1023 (10-bits) */
   short          k_cal_comp;             /* in form of S8.8          */
                                          /* k_cal_comp = (k_cal)/(k_cal_nom) */
   #endif
#endif

#if IS_32K_CRYSTAL_REMOVAL_SUPPORT
   char           dcxo_lpm;
   char           is_lock_dcxo;
#endif
#if IS_DECREASE_RF_TX_MAX_POWER_SUPPORT
   unsigned char  tx_power_decrement;
#endif
#if IS_WIFI_ADAPTIVE_POWER_CONTROL_SUPPORT
   char           wifi_low_pwr_flag;
   char           rx_power_flag;
#endif
#if IS_TDMA_TWO_STAGE_RF_POWERON_SUPPORT
   unsigned char  is_power_on_stage_1;
   unsigned char  is_power_on_stage_2;
   unsigned short power_on_stage2_enter;
   unsigned short power_on_stage2_leave;
#endif
#if IS_NORMAL_MODE_CAPID_CAL_SUPPORT
   char	          capid_cal_en;
#endif
#if IS_DCS_NB_WB_SWITCH_SUPPORT
   int            arfcn;
#endif
}  sRFSETTING;

extern sRFSETTING l1d_rf;

/* RF only structure */

typedef  struct
{
   int            arfcn;
#if IS_EPSK_TX_SUPPORT || IS_RF_MT6162
   unsigned char  tx_power[4];
#endif
#if IS_DYNAMIC_MACRO_SUPPORT
   char           is_wakeup;     //for reset dynamic digital block
#endif
#if IS_RF_MT6256RF
   unsigned char  r_cal;         //for BT R calibration
   #if IS_EPSK_TX_SUPPORT
   unsigned char  is_alt_bb_gain;//for indication of using BB PGA gain 4~7
   unsigned short tx_power_sel;  //for TX power selection
   #endif
#endif
#if IS_FHC_SUPPORT
   #if IS_EPSK_TX_GAIN_CONTROL_SUPPORT
   unsigned short fhc_PGA_gain;  /* for MT6256 and OH EPSK APC DAC */
   #endif
#endif
#if IS_RF_VCO_PARTIAL_DOO_ON || IS_RF_VCO_DOO_OFF || IS_WIFI_ADAPTIVE_POWER_CONTROL_SUPPORT
   char           dedicated_flag;
#endif
#if IS_RF_VCO_PARTIAL_DOO_ON || IS_RF_VCO_DOO_OFF
   char           rx_pm_flag;
   char           tx_1st_cwin_idx;
#endif
#if IS_RF_MT6162
   char           is_2g_on;             /* for 3G to check if 2G is on and decide if doing RF_Power_On or RF_Power_Off */
   char           lpfcap;
   char           is_rx_cal;
   char           is_tx_cal;
   char           is_isotpol;           /* On the near-integer channel, we should set it to 1 */
   char           is_integer;           /* On the      integer channel, we should set it to 1 */
   char           is_fhc;               /* for the RX LNA path loss calibration use */
   unsigned char  mt6162_rfid;
   unsigned char  is_fix_rf1828;        /* indicate if Vrf18 and Vrf28 should be always turned on */
   unsigned long  rx_dc_offset;
   #if IS_RF_RX_DCOC_SUPPORT
   signed short   rx_dac_to_voltage_i;  /* stored in S(4,4) */
   signed short   rx_dac_to_voltage_q;  /* stored in S(4,4) */
   signed short   rx_dc_offset_i[4][4]; /* [Band][G_Biquad] */
   signed short   rx_dc_offset_q[4][4]; /* [Band][G_Biquad] */
   #endif
   #if IS_RF_TX_CALIBRATION_SUPPORT
   signed short   tx_gain_error[4][4];  /* the   gain error is related to band and gain_RF (3,4,5,6) */
   signed short   tx_phase_error[4][4]; /* the  phase error is related to band and gain_RF (3,4,5,6) */
   signed short   tx_dc_bb_i[4];        /* the bb dc offset is related to band only                  */
   signed short   tx_dc_bb_q[4];        /* the bb dc offset is related to band only                  */
   signed short   tx_dc_rf_i[4][4];     /* the rf dc offset is related to band and gain_RF (3,4,5,6) */
   signed short   tx_dc_rf_q[4][4];     /* the rf dc offset is related to band and gain_RF (3,4,5,6) */
   #endif
#endif
#if IS_TX_POWER_CONTROL_SUPPORT
   #if IS_RF_MT6162
   unsigned short real_read_back[TXPC_SLOT_MAX];
   unsigned short compensated_read_back[TXPC_SLOT_MAX];
   unsigned short tx_gain_setting[TXPC_SLOT_MAX];
   #elif IS_RF_MT6256RF
      #if IS_EPSK_TX_SUPPORT
   unsigned short tx_gain_setting[TXPC_SLOT_MAX];
      #endif
   #endif
#endif
#if IS_DCS_NB_WB_SWITCH_SUPPORT
   unsigned char  is_dcs_nb_wb_switch_on;
#endif
#if IS_DCS_TX_NOTCH_SWITCH_SUPPORT
   unsigned char  is_tx_notch_switch_on;
#endif
}  sRFSETTING2;

extern sRFSETTING2 l1d_rf2;

/*...................................*/

typedef  struct
{
   unsigned short  ctrl;
   unsigned long   data;

} sSDATAINITDATA;

/*...................................*/

typedef  struct
{
   int  max_gain;
   int  min_gain;

} sL1DGAINRANGE;

/*...................................*/

typedef  struct
{
   short pos_gain;
   short A;
   long  setting;

} sL1DAGCDATA;

/*...................................*/

#define  PLTABLE_SIZE            13

typedef  struct
{
   short        max_arfcn;
   signed char  gain_offset;

} sAGCGAINOFFSET;

extern sAGCGAINOFFSET* AGC_PATHLOSS_TABLE[FrequencyBandCount];

/*...................................*/

typedef  struct
{
   signed char  gain_offset_middle;
   signed char  gain_offset_low;

} sLNAGAINOFFSET;

extern sLNAGAINOFFSET* LNA_PATHLOSS_TABLE[FrequencyBandCount];

/*...................................*/

typedef struct
{
   sLNAGAINOFFSET     lnaPathLoss[FrequencyBandCount][PLTABLE_SIZE];
} sLNAPATHLOSS_L1CAL;

/*...................................*/

#define PROFILE_NUM              16
#define ARFCN_SECTION_NUM        12
#define WEIGHT(n)                ((unsigned short)((n)*(1<<14)))

typedef  struct
{
   unsigned char  point[2][16];

} sRAMPAREADATA;

typedef  struct
{
   signed short   max_arfcn;
   unsigned short mid_level;
   unsigned short hi_weight;
   unsigned short low_weight;

} sARFCN_SECTION;

typedef  struct
{
   signed   long  lowest_power;
   unsigned short power[16];
   sRAMPAREADATA  ramp[ PROFILE_NUM ];
   sARFCN_SECTION arfcn_weight[ ARFCN_SECTION_NUM ];
   unsigned short battery_compensate[3/*volt*/][3/*temp*/];
} sRAMPDATA;

typedef  struct
{
   signed   long  lowest_power;
   unsigned short power[16];
   sRAMPAREADATA  ramp;
} sRAMPDATA_DEFAULT;

extern sRAMPDATA* RampData[FrequencyBandCount];
#if IS_EPSK_TX_SUPPORT
extern sRAMPDATA* RampData_EPSK[FrequencyBandCount];
#endif

extern const sRAMPDATA_DEFAULT RampData_Default;
#if IS_EPSK_TX_SUPPORT
extern const sRAMPDATA_DEFAULT RampData_Default_EPSK;
#endif
/*...................................*/

typedef struct
{
   unsigned char bbtx_common_mode_voltage;
   unsigned char bbtx_gain;
   unsigned char bbtx_calrcsel;
   unsigned char bbtx_trimI;        // need to set
   unsigned char bbtx_trimQ;        // need to set
   unsigned char bbtx_dccoarseI;    // need to set
   unsigned char bbtx_dccoarseQ;    // need to set
   unsigned char bbtx_offsetI;      // need to set
   unsigned char bbtx_offsetQ;      // need to set
   unsigned char bbtx_isCalibrated; // need to set
   int           apc_bat_low_voltage;
   int           apc_bat_high_voltage;
   int           apc_bat_low_temperature;
   int           apc_bat_high_temperature;
   unsigned char bbtx_common_mode_voltage_h;
   unsigned char bbtx_gain_h;
   unsigned char bbtx_calrcsel_h;
   unsigned char bbtx_trimI_h;
   unsigned char bbtx_trimQ_h;
   unsigned char bbtx_dccoarseI_h;
   unsigned char bbtx_dccoarseQ_h;
   unsigned char bbtx_offsetI_h;
   unsigned char bbtx_offsetQ_h;
   unsigned char bbtx_phsel;
   unsigned char bbtx_phsel_h;
   unsigned char bbrx_gsm850_gsm900_swap;
   unsigned char bbrx_dcs1800_pcs1900_swap;
} sBBTXParameters;

extern sBBTXParameters BBTXParameters;

/*...................................*/

typedef unsigned char sMIDRAMPDATA[16];
extern sMIDRAMPDATA*  InterRampData[FrequencyBandCount];

#if IS_EPSK_TX_SUPPORT
extern sMIDRAMPDATA*  GSM850_EPSK_InterRampData[4];
extern sMIDRAMPDATA*  GSM_EPSK_InterRampData[4];
extern sMIDRAMPDATA*  DCS_EPSK_InterRampData[4];
extern sMIDRAMPDATA*  PCS_EPSK_InterRampData[4];
extern sMIDRAMPDATA** EPSK_InterRampData[5];
#endif

/*...................................*/

#if IS_VCXO_LC_SUPPORT
#define XO_SlopeArea_Num         33
#else
#define XO_SlopeArea_Num         4
#endif

typedef  struct
{
   long   min_freq;
   short  min_dac;
// long   inv_slope;
}  XO_SLOPE_AREA_DATA;

extern const XO_SLOPE_AREA_DATA  XO_SlopeAreaData_RO[XO_SlopeArea_Num];
extern XO_SLOPE_AREA_DATA  XO_SlopeAreaData[XO_SlopeArea_Num];
#if IS_VCXO_LC_SUPPORT
extern XO_SLOPE_AREA_DATA  XO_SlopeAreaData_ori[XO_SlopeArea_Num];
#endif
/*...................................*/

#define XO_SET_FLAG(flag,mask)   ((flag)|=(mask))
#define XO_CHECK_FLAG(flag,mask) ((flag)&(mask))

#define XO_LC_DISABLED           0x00
#define XO_LC_ENABLED            0x01
#define XO_LC_INIT_FAIL          0x02

extern unsigned char XO_LC_Flags;

typedef struct
{
   unsigned int         curr_idx;
   XO_SLOPE_AREA_DATA  *first_element;
   XO_SLOPE_AREA_DATA  *last_element;
}  XO_LC_PARAMS;

/*...................................*/

extern long XO_CapID;

/*...................................*/

extern signed short pdata_gmsk;
extern signed short pdata_8psk;

/*...................................*/

typedef struct
{
   unsigned long icorrection;
   unsigned long qcorrection;
} skyip2coef;

typedef struct
{
   unsigned long ipol;
   unsigned long qpol;
} sky117ip2pol;

typedef struct
{
   unsigned long acode;
   unsigned long amcode;
} mt6139ip2coef;

typedef struct
{
   signed short  w_re;
   signed short  w_im;
} w_coef;

typedef struct
{
   unsigned char map[16];
} gain_rf_map;

typedef union
{
   struct
   {
      skyip2coef   data[5/*band*/];
   } skyip2; //for sky74045
   struct
   {
      skyip2coef   data[5/*band*/];
      sky117ip2pol pol[5/*band*/];
   } sky117ip2;
   struct
   {
      mt6139ip2coef data[5/*band*/];
      unsigned long rxamcalmode;
   } mt6139ip2;
   struct
   {
      unsigned char fixgain_enable;
   } sky74137; //for sky74137
   struct
   {  // borrowed for mpll_fh chip, should not have rf rx_coff
      unsigned char  fixed_mpll_clk;
      unsigned short mpll_freq_idx;
      unsigned char  fixed_spll_clk;
      unsigned short spll_freq_idx;
   } mpll_fh;
   struct
   {  // reserved for mpll_fh
      unsigned char  fixed_mpll_clk;
      unsigned short mpll_freq_idx;
      w_coef         w_data[19];
   } mt6256_51rf;
   struct
   {  // reserved for mpll_fh
      unsigned char  fixed_mpll_clk;
      unsigned short mpll_freq_idx;
      unsigned short is_md2g_log_on;
   } md2g_log; // for chip support md2g logger
   struct
   {  // reserved for mpll_fh
      unsigned char  fixed_mpll_clk;
      unsigned short mpll_freq_idx;
      unsigned short is_md2g_log_on;
      gain_rf_map    gain_rf_table[4/*band*/];
   } mt6162_gain_rf;
} sRxip2;

typedef struct
{
   unsigned long word6_4_0;
   unsigned long word6_5_0;
   unsigned long word6_6_0;
   unsigned long word6_7_0;
   unsigned long bvmode;
   unsigned long c3mode;
   unsigned long wordC3;
} b5ptxcoef;

typedef struct
{
   short         pcl_index;
   unsigned char pa_vbias;
} pa_vbias;

typedef struct
{
   pa_vbias GSM850_pa_vbias[8];
   pa_vbias GSM900_pa_vbias[8];
   pa_vbias DCS1800_pa_vbias[8];
   pa_vbias PCS1900_pa_vbias[8];
} mt6140tx_pa_vbias;

typedef struct
{
   pa_vbias GSM850_pa_vbias[8];
   pa_vbias GSM900_pa_vbias[8];
   pa_vbias DCS1800_pa_vbias[8];
   pa_vbias PCS1900_pa_vbias[8];
} mt6162tx_pa_vbias;

typedef struct
{
   pa_vbias GSM850_pa_vbias[8];
   pa_vbias GSM900_pa_vbias[8];
   pa_vbias DCS1800_pa_vbias[8];
   pa_vbias PCS1900_pa_vbias[8];
} mt6256tx_pa_vbias;

typedef struct
{
   unsigned char REFDET_SLOPE_SKEW;
   unsigned char AM_FB_DAC;
} ad6546txcoef;

typedef struct
{
   signed char MID_GAMA_THRESHOLD;
   signed char LOW_GAMA_THRESHOLD;
   signed char MID_DELTA_SLOPE_SKEW;
   signed char LOW_DELTA_SLOPE_SKEW;
   signed char MID_DELTA_APC_CAP;
   signed char LOW_DELTA_APC_CAP;
} ad6546tx_reg8_highband_delta;

typedef union  //  Vito For Register8
{  struct
   {
      unsigned int Address           : 7;
      unsigned int POLAR_APC_CAP     : 5;
      unsigned int VGA_SLOPE         : 4;
      unsigned int REFDET_SLOPE_SKEW : 4;
      unsigned int AM_FB_DAC         : 4;
      unsigned int reserved          : 8;
   } AM_LOOP;
   unsigned int RegData;
} ad6546tx_reg8;

typedef union
{
   struct
   {
      b5ptxcoef data;
   } b5ptx;
   struct
   {
      mt6140tx_pa_vbias data;
   } mt6140tx;
   struct
   {
      unsigned char ref_temp;
      unsigned char LB_GMSK_TX_PGA_GC;
      unsigned char HB_GMSK_TX_PGA_GC;
      char isDCXO;
   } CMOSEDGEtx;
   struct
   {
      ad6546txcoef  CalData[4];
      unsigned long Reg8_default[4];
      ad6546tx_reg8_highband_delta AMLoopDelta;
   } ad6546tx;
   struct
   {
      mt6162tx_pa_vbias data;
   } mt6162tx;
   struct
   {
      mt6256tx_pa_vbias data;
   } mt6256tx;
/* struct
   {
      unsigned long dummy;
   } sTXdummy;
 */
} sTxepsk;

typedef struct
{
   sRxip2  rx;
   sTxepsk tx;
} sRFSpecialCoef;

typedef struct
{
   unsigned short stage;
   unsigned short flag;
   unsigned short ADD;
   unsigned short delay_ADD;
   unsigned short event_timing;
   unsigned short ADD_pair;
   unsigned long  DATA_pair;
} sBSIread;

typedef struct
{    signed short gain_bb_dac;
   unsigned short gain_bb_inverse;
} sTX_GAIN_BB_MAPPING;

extern  sRFSpecialCoef RFSpecialCoef;

/*...................................*/

typedef enum
{
   FMC_CAP_ID,
   FMC_TRX_OFFSET,
   FMC_TX_IQ,
   FMC_OE_ITEM,
   FMC_W_COEF,
   FMC_TX_PC,
   FMC_TX_PC_TEMP,
   FMC_DTS_GAIN_CMB,
   FMC_UTS_BAND_CMB
} FAC_CAL_ITEM;

#define FMC_NULL_SETTING      0x0
#define FMC_CAPABLE           0x1
#define FMC_MANDATORY         0x2

/*...................................*/

extern const unsigned char   CONTISLOTMASK[5];
extern const unsigned char   FIRSTSLOTMASK[5];

/*.............................................*/
#ifdef  __UMTS_RAT__
/* under construction !*/
/* under construction !*/
#endif

/*.............................................*/

#if IS_RF_MT6162
extern unsigned char  TX_GAINRF_MAPPING[4][16];
extern signed   short BBGAIN_DECODE_TABLE[14][2];
extern unsigned long  read_back;
extern unsigned long  TX_GAIN_READ_ADDRESS[5];
#endif

/*.............................................*/

#ifdef __MTK_TARGET__
   #ifdef NVRAM_NOT_PRESENT
#define IS_NVRAM_DATA_READY() (1)
   #else
#define IS_NVRAM_DATA_READY() (l1d_rf.is_nvram_data_ready==1)
   #endif
#else
#define IS_NVRAM_DATA_READY() (1)
#endif
/*.............................................*/

/* inteface to set BFE setting from calibration data rather than GCM */
void  L1D_GCMachine_Stop( void );
short L1D_GCMachine_Done( void );
int   L1D_CheckIfMetaMode( void );

void  L1D_RF_Init( void );
void  L1D_RF_Init_FIR( void );
void  L1D_RF_Init_BPI( void );

#if IS_65NM_CHIP_BSI_BPI_PWN
void  L1D_RF_Init_BSI_BPI( void );
#endif

void  L1D_RF_PowerOn( void );
void  L1D_RF_PowerOff( void );
void  L1D_RF_WindowOn( void );
void  L1D_RF_WindowOff( void );
void  L1D_RF_SetWakeUpFlag( void );
void  L1D_RF_ClearWakeUpFlag( void );
void  L1D_RF_Set_PowerOn( unsigned char is_stage1, unsigned char is_stage2 );

unsigned char L1D_RF_Get_PowerOn_Stage( unsigned char stage_idx );
unsigned char L1D_Check_SW_SecVersion( void );

#if IS_RF_AD6548 || IS_RF_AD6546
void  L1D_RF_CAP_Set( void );
void  L1D_RF_CAP_Clear( void );
#endif

#if IS_RF_MT6256RF || IS_RF_MT6251RF || IS_RF_MT6255RF || IS_RF_MT6250RF || IS_RF_MT6260RF || IS_RF_MT6261RF
unsigned short L1D_RF_ARFCN_CH_to_TxFreq( int rf_band, int arfcn );
unsigned short L1D_RF_ARFCN_CH_to_RxFreq( int rf_band, int arfcn );
#endif

#if IS_RF_MT6256RF
   #if IS_EPSK_TX_SUPPORT
void L1D_Setup_BB_TxPower( unsigned short reversed_PGA_gain, unsigned char alt_bb_gain );
   #endif
unsigned long  L1D_RF_GetSData_ST2( void );
unsigned char  L1D_RF_Get_BT_Rcal( void );
#endif

void  L1D_RF_GetRxPLLSetting( int rf_band, int arfcn, long *rfN, long *ifN );
void  L1D_RF_GetTxPLLSetting( int rf_band, int arfcn, long *rfN, long *ifN );
int   L1D_RF_GetGainSetting( int rf_band, int arfcn, int request_gain, long *gain_setting );

#if IS_RF_MTKSOC1 || IS_RF_MTKSOC1T
void  L1D_RF_GetRxPLL_HB_FractionPart( int *Nfrac, int arfcn, int arfcn_base );
void  L1D_RF_Band1800_FrequecyFractionPartCompensation( int arfcn, int *Nfrac, short arfcn1, short arfcn2, short arfcn3, short arfcn4, short arfcn5, short arfcn6 );
void  L1D_RF_GetRX_SX_CAL_FBX_Setting( int arfcn, int rf_band, long *cw27, short sx_cal_dmd_t );
void  L1D_RF_GetTX_SX_CAL_FBX_Setting( int arfcn, int rf_band, long *cw27, short sx_cal_dmd_t, short OPLL_DIV4O5_DIV4 );
void  L1D_SetTxIQSwap_NO_PCS1900( void );
#endif

#if IS_RF_MTKSOC1T
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
   #if IS_RF_MTKSOC1_A2 || IS_RF_MTKSOC1_A3 || IS_RF_MTKSOC1_A4
/* under construction !*/
/* under construction !*/
   #else
/* under construction !*/
   #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if IS_RF_MT6256RF || IS_RF_MT6251RF || IS_RF_MT6255RF || IS_RF_MT6250RF || IS_RF_MT6260RF || IS_RF_MT6261RF
#define SYNTH_SCALE              5
#define DCXO_FREQ                (26*SYNTH_SCALE)
#define DLIF                     (65*SYNTH_SCALE)   //65=13*5
#define DLIF_SCALE               384                //384=96*4
#endif

void  L1D_RF_SetFixGainEnable( unsigned char enable );
void  L1D_RF_SetPathLossTable( int rf_band, void *table );
void  L1D_RF_SetLnaPathLossTable( sLNAPATHLOSS_L1CAL *table );
void  L1D_RF_GetLnaPathLossTable( sLNAPATHLOSS_L1CAL *table );
void  L1D_RF_CheckFHC( char is_fhc );

// Update AFC DAC by BSI 3-wire
void  L1D_RF_UpdateAFCDac( unsigned short afc_data );

#if IS_32K_CRYSTAL_REMOVAL_SUPPORT || IS_NORMAL_MODE_CAPID_CAL_SUPPORT
void L1D_RF_IMM_Set_CapID( long capid );
#endif

#if IS_FHC_SUPPORT
/*
short L1D_RF_GetAFCDacTRxOffset( int rf_band );
 */
void  L1D_RF_GetAFCDacTRxOffset( short *afcdactrxoffset );
/*
void  L1D_RF_SetAFCDacTRxOffset( int rf_band, short afcdactrxoffset );
 */
void  L1D_RF_SetAFCDacTRxOffset( short *afcdactrxoffset );

#endif

void  L1D_RF_GetPGAGain( unsigned short tx_power );

void  L1D_RF_SetRampTable( int rf_band, void *table );
void  L1D_RF_InitRampTable( int rf_band );

#if IS_EPSK_TX_SUPPORT
void  L1D_RF_SetRampTableEPSK( int rf_band, void *table );
void  L1D_RF_InitRampTableEPSK( int rf_band );
void  L1D_RF_EPSK_SetInterSlotRampTable( int rf_band, int _8G_mode, void *table );
short L1D_RF_SetInterslotPowerLevel( int rf_band, int arfcn, short mod_type );
#endif

#if IS_RF_CMOSEDGE
/* under construction !*/
#endif

void  L1D_RF_SetInterSlotRampTable( int rf_band, void *table );
void  L1D_RF_SetCrystalAFCData( void *table );
void  L1D_RF_SetCrystalCap( int cap_no );
void  L1D_RF_SetCrystalCap_Value( int cap_no );
void  L1D_RF_SetCrystalDac( short dacValue );
void  L1D_RF_SetCrystalDac_Value( short dacValue );
int   L1D_RF_GetCrystalCapRange( void );
int   L1D_RF_GetWCalMode( void );
void  L1D_RF_SetRFSpecialCoef( void *table );
unsigned long  L1D_RF_GetID( void );
unsigned short L1D_RF_GetCalSets( FAC_CAL_ITEM item );
unsigned long  L1D_GetBandSupport( void );
unsigned short L1D_Get_EPSK_TX_Support( void );
unsigned short L1D_GetPsEpskTxStatus( void );
unsigned short L1D_Get_TCVCXO_Support( void );
#if IS_BSI_V2_SUPPORT
unsigned long L1D_RF_TX_BSI_ENA( unsigned short win );
#endif
#if IS_BPI_V2_SUPPORT
unsigned long L1D_RF_TX_BPI_ENA( unsigned short win );
#endif
void  L1D_RF_SetImmediateBSI( unsigned long bsidata );
void  L1D_RF_GetImmediateBSI( unsigned long bsi_addr, unsigned long *bsi_data );
void  L1D_RF_TXIQ_Dynamic_Swap( void );
void  L1D_BFE_SetTxIQSwap( void );
void  L1D_BFE_SET_TxIQSwapRegister( int is_swap );
void  L1D_BFE_GET_RxRegisters( void *set );
void  L1D_BFE_SET_RxRegisters( void *set );
void  L1D_BFE_GET_TxRegisters( void *set );
void  L1D_BFE_SET_TxRegisters( void *set );

#define HW_READ_BFERXSET(  _set )   L1D_BFE_GET_RxRegisters( &_set )
#define HW_WRITE_BFERXSET( _set )   L1D_BFE_SET_RxRegisters( &_set )
#define HW_READ_BFETXSET(  _set )   L1D_BFE_GET_TxRegisters( &_set )
#define HW_WRITE_BFETXSET( _set )   L1D_BFE_SET_TxRegisters( &_set )

#if IS_TDMA_BSI_READBACK_SUPPORT
/*BSI read flag*/
#define BSI_GET_READBACK_DATA       0x1
#define BSI_READBACK_DATA_ERROR     0x2
#define BSI_READBACK_ENABLE         0x4
#define BSI_READ_INDICATE_ADDR(add) { BSIread.ADD = add; }

typedef  enum
{
   BSI_READ_STOP,
   BSI_READ_START,
   BSI_READ_DELAY,
   BSI_READ_DELAY_THEN_START

}  BSI_READ_STATUS;

extern sBSIread BSIread;
void  L1D_RF_Readback_BSI_Set_Event( void* data );
void  L1D_RF_Readback_BSI_Set_Address( void* data );
void  L1D_RF_Readback_BSI_GetData( unsigned short ADD, unsigned long *DATA );
#endif

#if IS_RF_MT6251RF
void  L1D_RF_OBB_trace_setting( void );
#endif

unsigned long L1D_RF_SetTX_BSI_CW( short qb_st2, short timing_bound );

#define FOUR_POINT_FOUR_SUBBAND          0  // 4-point W cal.,  4 subbands
#define ZERO_POINT_SIXTEEN_SUBBAND       1  // 0-point W cal., 16 subbands
#define ONE_POINT_SIXTEEN_SUBBAND        2  // 1-point W cal., 16 subbands
#define FOUR_POINT_SIXTEEN_SUBBAND       3  // 4-point W cal., 16 subbands
#define EIGHT_POINT_SIXTEEN_SUBBAND      4  // 8-point W cal., 16 subbands
#define SIXTEEN_POINT_SIXTEEN_SUBBAND    5  //16-point W cal., 16 subbands

#if IS_W_CANCELLATION_SUPPORT
   #if IS_RF_MT6256RF || IS_RF_MT6251RF || IS_RF_MT6255RF || IS_RF_MT6250RF || IS_RF_MT6260RF  || IS_RF_MT6261RF
unsigned short  L1D_RF_FindGainStep( unsigned long gain_setting, FrequencyBand rf_band );
   #endif
#endif

#if IS_RF_MT6261RF
void L1D_RF_SR2_GetGainSetting( long agc_data, unsigned long *gain_setting );
#endif

#define SC_DEDICATED            0x0001
#define SC_ACCESS               0x0002
#define SC_DEDICATED_2TX        0x0004
#define SC_NON_IDLE             ( SC_DEDICATED | SC_ACCESS | SC_DEDICATED_2TX )

void  L1D_RF_Access_Dedicated_Mode_Start( char mode_flag );
void  L1D_RF_Access_Dedicated_Mode_End( char mode_flag );
void  L1D_RF_Check_RTX_PM( unsigned char rx_slots, int pm_count, char tx_cwin_idx, unsigned short is_fsi_win );
void  L1D_RF_SetStandbyMode( void );

short L1D_RF_SetTxPowerLevel( int rf_band, int arfcn, short power_dbm, short mod_type );
short L1D_RF_GetRxPathLoss( int rf_band, int arfcn, short request_gain );
void  L1D_RF_SetTxPower( short *tx_power );
void  L1D_RF_NotifyBatteryVoltage( int micro_volt );
void  L1D_RF_NotifyBatteryTemperature( int mili_degree );
void  L1D_RF_NotifyRFTemperature( int temp_adc );
unsigned char L1D_RF_IS_GetRFTemperatureFromADC( void );

void  L1D_RF_ResetSData_StopFSIWinOff( int idx );
void  L1D_RF_SetSData_FSIWinOff( int idx );
void  L1D_RF_SetPData_PR( void );
void  L1D_RF_SetPData_PT( void );
void  L1D_RF_SetPData_PR2M( void );
void  L1D_RF_SetPData_PT2M( void );
void  L1D_RF_SetSData_SR1( void );
void  L1D_RF_SetSData_SR2( void );
void  L1D_RF_SetSData_SR3( void );
void  L1D_RF_SetSData_ST1( void );
void  L1D_RF_SetSData_ST2( void );
void  L1D_RF_SetSData_ST3( void );

#if IS_BSI_SX0_SUPPORT
void  L1D_RF_SetSData_SR0( void );
void  L1D_RF_SetSData_ST0( void );
#endif

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION
void  L1D_RF_SetSData_ST2B( void );
void  L1D_RF_SetSData_ST2M( void );
void  L1D_RF_Set_FB_FIR( void );
/*
void  L1D_RF_init_FIR_SwitchNB( int wider );
 */
void  L1D_RF_TXIQ_Dynamic_Config( void );
void  L1D_BFE_SetTxIQ_Config( void );
#endif

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION || IS_CHIP_MT6225_AND_LATTER_VERSION
void  L1D_RF_init_FIR_SwitchNB( int wider );
#endif

#if IS_TX_POWER_CONTROL_SUPPORT
void  L1D_RF_Init_TXPC_Data( void );
void  L1D_RF_TXPC_Get_Temp_ADC( sTEMPERATURE_ADC_L1CAL *buff );
void  L1D_RF_TXPC_Set_Temp_ADC( sTEMPERATURE_ADC_L1CAL *temp_adc );
void  L1D_RF_TXPC_RecordParam( unsigned char scenario, const sRAMPDATA* band, unsigned short weight, short temp_idx, char is_rollback, short target_dac );
short L1D_RF_TXPC_RecUpdateAPCDAC( const short dac_ori, unsigned char rf_band, short arfcn, short slot, char is_EPSK );
short L1D_RF_TXPC_ComputeVAPC_DAC( const short dac_ori, short ratio, short dac_diff );

   #if IS_EPSK_TX_SUPPORT
      #if IS_RF_MT6256RF
short L1D_RF_TXPC_ComputePGA_GAIN( const short gain_ori, short slot, short ratio, short gain_diff );
      #elif IS_RF_MT6162
short L1D_RF_TXPC_Compute_OH_PA_GAIN( const short dac_ori, short ratio );
      #endif
   #endif
#endif

#if IS_TXPC_CL_AUXADC_SUPPORT
void  L1D_RF_TXPC_CL_AUXADC_PowerOn( void );
void  L1D_RF_TXPC_CL_AUXADC_PowerOff( void );
#endif

#if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
void  L1D_TXPC_CL_RecordPowerIndex( short index, short slot );
void  L1D_RF_TXPC_CL_GetAllADC( sTXPC_L1CAL *buff, char is_EPSK );
void  L1D_RF_TXPC_CL_GetAllTEMP( sTXPC_L1CAL *buff, char is_EPSK );
void  L1D_RF_TXPC_CL_GetSubband( int rf_band, unsigned short *buff, char is_EPSK );
void  L1D_RF_TXPC_CL_SetAllCalADC( sTXPC_L1CAL *cal_adc, char is_EPSK );
void  L1D_RF_TXPC_CL_SetAllCalTEMP( sTXPC_L1CAL *cal_adc, char is_EPSK );
void  L1D_RF_TXPC_CL_BackUpSubband( int rf_band, char is_EPSK );
void  L1D_RF_TXPC_CL_RestoreSubband( void );
void  L1D_RF_TXPC_CL_BackupAllCalADC( void );
void  L1D_RF_TXPC_CL_RestoreAllCalADC( void );
void  L1D_RF_TXPC_CL_Read_RF_Power( long *sample_array, unsigned char tx_slot, unsigned char mod_type );
void  L1D_RF_TXPC_CL_Update_TXADC_Subband_Data( unsigned short read_back_data, short arfcn, char rf_band, unsigned char mod_type );
unsigned short L1D_RF_TXPC_CL_GetDetReadBack( unsigned char is_compensated, unsigned short slot_idx );
unsigned short L1D_RF_TXPC_CL_GetOneADC( int rf_band, int power_in_dBm, char is_EPSK );
unsigned char  L1D_RF_TXPC_CL_Check_OHGMSK( void );
short L1D_TXPC_CL_Detector_Subband_Compensation( unsigned char mod_type );
short L1D_TXPC_CL_Detector_Temperature_Compensation( unsigned char mod_type );
#endif

#if IS_TX_POWER_CONTROL_SUPPORT
short L1D_RF_TXPC_GetTxGainSetting( unsigned char is_gain_rf, unsigned char slot_idx );
short L1D_RF_TXPC_GetTemperatureInfo( unsigned char info_idx );
short L1D_RF_TXPC_CheckTransitionMode( void );
unsigned char  L1D_RF_TXPC_IS_CAL( void );
   #if IS_RF_MT6162 || IS_RF_MT6256RF
void  L1D_RF_GetRFTemperatureIdxAndValue( short temp_dac );
   #endif
   #if IS_CHIP_MT6256
unsigned short L1D_RF_TXPC_GetTemperatureInfoFromBSI( void );
   #endif
#endif

#if IS_TXPC_CL_AUXADC_SUPPORT
#define L1D_RF_TXPC_CL_AUXADC_POWERON()   L1D_RF_TXPC_CL_AUXADC_PowerOn()
#define L1D_RF_TXPC_CL_AUXADC_POWEROFF()  L1D_RF_TXPC_CL_AUXADC_PowerOff()
#else
#define L1D_RF_TXPC_CL_AUXADC_POWERON()   {;}
#define L1D_RF_TXPC_CL_AUXADC_POWEROFF()  {;}
#endif /* IS_TXPC_CL_AUXADC_SUPPORT */

#if IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT
#define L1D_RF_TXPC_CL_RECORD_PWR_IDX( index, slot )                                               \
{  L1D_TXPC_CL_RecordPowerIndex( index, slot );                                                    \
}

#define L1D_RF_TXPC_CL_GET_ALL_ADC( buff, is_EPSK )                                                \
{  L1D_RF_TXPC_CL_GetAllADC( buff, is_EPSK );                                                      \
}

#define L1D_RF_TXPC_CL_GET_ALL_TEMP( buff, is_EPSK )                                               \
{  L1D_RF_TXPC_CL_GetAllTEMP( buff, is_EPSK );                                                     \
}

#define L1D_RF_TXPC_CL_GET_SUBBAND( rf_band, buff, is_EPSK )                                                \
{  L1D_RF_TXPC_CL_GetSubband( rf_band, buff, is_EPSK );                                                     \
}

#define L1D_RF_TXPC_CL_SET_ALL_CAL_ADC( cal, is_EPSK )                                             \
{  L1D_RF_TXPC_CL_SetAllCalADC( cal, is_EPSK );                                                    \
}

#define L1D_RF_TXPC_CL_SET_ALL_CAL_TEMP( cal, is_EPSK )                                            \
{  L1D_RF_TXPC_CL_SetAllCalTEMP( cal, is_EPSK );                                                   \
}

#else
#define L1D_RF_TXPC_CL_RECORD_PWR_IDX( index, slot )                                               {;}
#define L1D_RF_TXPC_CL_GET_ALL_ADC( buff, is_EPSK )                                                {;}
#define L1D_RF_TXPC_CL_GET_ALL_TEMP( buff, is_EPSK )                                               {;}
#define L1D_RF_TXPC_CL_GET_SUBBAND( buff, is_EPSK )                                                {;}
#define L1D_RF_TXPC_CL_SET_ALL_CAL_ADC( cal, is_EPSK )                                             {;}
#define L1D_RF_TXPC_CL_SET_ALL_CAL_TEMP( cal, is_EPSK )                                            {;}
#endif /* IS_TXPC_CL_AUXADC_SUPPORT || IS_TXPC_CL_BSI_SUPPORT */

#if IS_TXPC_OL_BSI_SUPPORT || IS_TXPC_OL_AUXADC_SUPPORT
#define L1D_RF_TXPC_OL_GET_TEMPERATURE( buff )                                                     \
{  (buff)->temperature = ref_temperature;                                                          \
}

#define L1D_RF_TXPC_OL_SET_CAL_TEMPERATURE( cal )                                                  \
{  ref_temperature = (cal)->temperature;                                                           \
}
#else
#define L1D_RF_TXPC_OL_GET_TEMPERATURE( buff )                                                     {;}
#define L1D_RF_TXPC_OL_SET_CAL_TEMPERATURE( cal )                                                  {;}
#endif

#if IS_TX_POWER_CONTROL_SUPPORT
#define L1D_RF_INIT_TXPC_DATA()                                                                    \
{  L1D_RF_Init_TXPC_Data();                                                                        \
}

#define L1D_RF_TXPC_GET_FLAG( buff )                                                               \
{  (buff)->is_calibrated = is_txpc_calibrated;                                                     \
}

#define L1D_RF_TXPC_GET_TEMP_ADC( buff )                                                           \
{  L1D_RF_TXPC_Get_Temp_ADC( buff );                                                               \
}

#define L1D_RF_TXPC_SET_CAL_FLAG( cal )                                                            \
{  is_txpc_calibrated |= (cal)->is_calibrated;                                                     \
}

#define L1D_RF_TXPC_SET_TEMP_ADC( temp_adc )                                                       \
{  L1D_RF_TXPC_Set_Temp_ADC( temp_adc );                                                           \
}

#define L1D_RF_TXPC_GET_L1_SETTING( buff, is_EPSK )                                                \
{  L1D_RF_TXPC_GET_FLAG( buff );                                                                   \
   L1D_RF_TXPC_CL_GET_ALL_ADC( buff, is_EPSK );                                                    \
   L1D_RF_TXPC_OL_GET_TEMPERATURE( buff );                                                         \
   L1D_RF_TXPC_CL_GET_ALL_TEMP( buff, is_EPSK );                                                   \
}

#define L1D_RF_TXPC_SET_CAL( cal, is_EPSK )                                                        \
{  L1D_RF_TXPC_SET_CAL_FLAG( cal );                                                                \
   L1D_RF_TXPC_CL_SET_ALL_CAL_ADC( cal, is_EPSK );                                                 \
   L1D_RF_TXPC_OL_SET_CAL_TEMPERATURE( cal );                                                      \
   L1D_RF_TXPC_CL_SET_ALL_CAL_TEMP( cal, is_EPSK );                                                \
   L1D_RF_INIT_TXPC_DATA();                                                                        \
}

#define L1D_RF_TXPC_RECORD_PARAM( scenario, band, weight, temp_idx, is_rollback, target_dac )      \
{  L1D_RF_TXPC_RecordParam( scenario, band, weight, temp_idx, is_rollback, target_dac );           \
}

#define L1D_RF_TXPC_REC_UPDATE_APCDAC( dac_ori, rf_band, arfcn, slot, is_EPSK )                    \
(  L1D_RF_TXPC_RecUpdateAPCDAC( dac_ori, rf_band, arfcn, slot, is_EPSK )   )

   #if IS_EPSK_TX_SUPPORT
      #if IS_RF_MT6256RF
#define L1D_RF_TXPC_COMPUTE_DAC_EPSK( dac_ori, slot, ratio, dac_diff )                             \
(  L1D_RF_TXPC_ComputePGA_GAIN( dac_ori, slot, ratio, dac_diff )  )
      #elif IS_RF_MT6162
#define L1D_RF_TXPC_COMPUTE_DAC_EPSK( dac_ori, slot, ratio, dac_diff )                             \
(  L1D_RF_TXPC_Compute_OH_PA_GAIN( dac_ori, ratio )  )
      #else
#define L1D_RF_TXPC_COMPUTE_DAC_EPSK( dac_ori, slot, ratio, dac_diff )                             \
(  L1D_RF_TXPC_ComputeVAPC_DAC( dac_ori, ratio, dac_diff )  )
      #endif
   #endif /* IS_EPSK_TX_SUPPORT */
#else
#define L1D_RF_INIT_TXPC_DATA()                                                                    {;}
#define L1D_RF_TXPC_GET_FLAG( buff )                                                               {;}
#define L1D_RF_TXPC_SET_CAL_FLAG( cal )                                                            {;}
#define L1D_RF_TXPC_GET_TEMP_ADC( buff )                                                           {;}
#define L1D_RF_TXPC_SET_TEMP_ADC( temp_adc )                                                       {;}
#define L1D_RF_TXPC_GET_L1_SETTING( buff, is_EPSK )                                                {;}
#define L1D_RF_TXPC_SET_CAL( cal, is_EPSK )                                                        {;}
#define L1D_RF_TXPC_RECORD_PARAM( scenario, band, weight, temp_idx, is_rollback, target_dac )      {;}
#define L1D_RF_TXPC_REC_UPDATE_APCDAC( dac_ori, rf_band, arfcn, slot, is_EPSK )                    (dac_ori)
#endif /* IS_TX_POWER_CONTROL_SUPPORT */

/*===============================================================================*/
/* for RF Tool Customization Support                                                       */
/*===============================================================================*/
void  L1D_RF_CAPID_Update( void );
void  L1D_RF_Custom_BBTXParameter_Update( void );
void  L1D_RF_Custom_Table_Update( void );
void  L1D_RF_CLK_Buffer_Variable_Reset( void );
void  L1D_RF_Custom_Table_Update_V2_No_Check( void );

/*.............................................*/

void  L1D_PowerOn_BSI( void );
void  L1D_AFCDAC_On( void );
void  L1D_AFCDAC_Off( void );
void  L1D_BeforeSleep( void );
void  L1D_AfterSleep( void );
unsigned long  L1D_RF_GetITC_PCL(void);
unsigned short L1D_RF_GetTxPAVBias_TxITC( unsigned short lb_cw_high_idx, unsigned short hb_cw_high_idx );
short L1D_RF_GetTxPAVBias(void);

/*.............................................*/

#define IMMMASK_AFC              0x01
#define IMMMASK_BSI              0x02
#define IMMMASK_BPI              0x04
#define IMMMASK_ALL              (IMMMASK_AFC|IMMMASK_BSI|IMMMASK_BPI)

void  WAIT_TIME_QB( short time_qb );
void  IMM_MODE_BEGIN( unsigned short imm_mask );
void  IMM_MODE_END( void );
void  IMM_SEND_BPI( unsigned short data );
void  IMM_SEND_BSI( unsigned short ctrl, unsigned long data );
void  IMM_RECEIVE_BSI( unsigned short ADD_Ctrl, unsigned long ADD, unsigned short DATA_Ctrl, unsigned long *DATA );
void  IMM_UPDATE_BSI_BEGIN( void );
void  IMM_UPDATE_BSI_END( void );

/*===============================================================================*/
/*    BSI codeword marco                                                         */
/*===============================================================================*/
#if IS_CHIP_MT6256 || IS_CHIP_MT6251 || IS_CHIP_MT6255 || IS_CHIP_MT6250 || IS_CHIP_MT6260 || IS_CHIP_MT6261
#define BSI_CW( addr, data )     ((unsigned long)((((addr)&0xFF)<<20)|((data)&0xFFFFF))) //CW length: 28bit, addr part: 8bit, data part: 20bit
#endif

/*===============================================================================*/
/*    BSI read back                                                              */
/*===============================================================================*/
#define SCTRL_IMOD_RX_MAIN       (0x0103+(2<<4)+(2<<6))    /* 13/4Mhz, long enable negative pulse */
#define SCTRL_IMOD_RX_SEND       (0x000B+(2<<4)+(2<<6))    /* 13/4Mhz,                            */

/*===============================================================================*/
/*    AFC linear compensation mechanism                                          */
/*===============================================================================*/
void             XO_LC_Initialize( void );
void             XO_LC_TuneAFCTable( signed int Ratio_ind );
signed short int XO_LC_CalculateNewDacNBSB( signed int Current_Freq, signed short int Servingstarted );
signed int       XO_LC_InitialPhiFactor( signed short int DacValue );
signed int       XO_LC_GetCurrentPhi_est( void );

/*===============================================================================*/
/* for TX power rollback                                                         */
/*===============================================================================*/

typedef  struct
{
   signed char rollback_2t; /* Rollback (2t/F2I_Resolution) dB when 2 TX slots */
   signed char rollback_3t; /* Rollback (3t/F2I_Resolution) dB when 3 TX slots */
   signed char rollback_4t; /* Rollback (4t/F2I_Resolution) dB when 4 TX slots */
   signed char rollback_5t; /* Rollback (5t/F2I_Resolution) dB when 5 TX slots */
} sTX_POWER_ROLLBACK;

#if IS_GPRS
short L1D_RF_PowerRollback( short power_dbm, int rf_band, unsigned short weight, short mod_type);
void L1D_RF_SetTxPowerRollbackData( int rf_band, void *table );

#define F2I_Resolution           8     //float to interger resolution
#define GMSK_LB_MAX_POWER        33
#define GMSK_HB_MAX_POWER        30
#define EPSK_LB_MAX_POWER        27
#define EPSK_HB_MAX_POWER        26

extern sTX_POWER_ROLLBACK* tx_power_rollback_gmsk[FrequencyBandCount];

   #if IS_EGPRS
void L1D_RF_SetTxPowerRollbackData_EPSK( int rf_band, void *table );

extern sTX_POWER_ROLLBACK* tx_power_rollback_epsk[FrequencyBandCount];
   #endif

#endif
// end :TX power rollback

/*===============================================================================*/
/* for 32K Crystal Removal                                                       */
/*===============================================================================*/
#if IS_32K_CRYSTAL_REMOVAL_SUPPORT
#define DCXO_NONE    0x0
#define DCXO_LPM     0x1
#define DCXO_FPM     0x2

char L1D_RF_Check_32K_XO_Status( void );
void L1D_RF_SetCLoadFreqOffset( int* freq_offset );
void L1D_RF_GetCLoadFreqOffset( int* buff );
void L1D_RF_GetAfcDacFreqOffset( int* freq_offset );
void L1D_RF_GetDFCFreqOffset( int* freq_offset );
void L1D_RF_Set_DCXO_LPM_Divider( unsigned int dcxo_frac );
void L1D_RF_Set_DCXO_FPM_Divider( unsigned int dcxo_frac );
#endif

unsigned short L1D_RF_Check_DCXO_LPM( void );
void L1D_RF_Set_DCXO_Power_Mode( char mode );

/*===============================================================================*/
/* dynamic Tx freq. error compensation over temperature                          */
/*===============================================================================*/
#if IS_BAND_COMP_TC_GAIN_SUPPORT
   #if IS_RF_MT6260RF
#define TC_GAIN_RES                 7                              /* DFM_VCO_TC_GAIN[6:0] is composed by 7 bits */
#define TC_GAIN_CW_LSB              13                             /* DFM_VCO_TC_GAIN[6:0] is located at CW4[0]+CW57[18:13] */
#define TC_GAIN_CW                  BSI_CW(0x39, POR_CW57&0xFE000) /* CW57, from m12196.c RF POR w/o DFM_XO_CAFC[12:0] */
   #elif IS_RF_MT6250RF
#define TC_GAIN_RES                 6                              /* DFM_VCO_TC_GAIN[5:0] is composed by 6 bits */
#define TC_GAIN_CW_LSB              13                             /* DFM_VCO_TC_GAIN[5:0] is located at CW57[18:13] */
#define TC_GAIN_CW                  BSI_CW(0x39, POR_CW57&0xFE000) /* CW57, from m12196.c RF POR w/o DFM_XO_CAFC[12:0] */
   #elif IS_RF_MT6256RF || IS_RF_MT6255RF
#define TC_GAIN_RES                 5                      /* DFM_VCO_TC_GAIN[4:0] is composed by 5 bits */
#define TC_GAIN_CW_LSB              4                      /* DFM_VCO_TC_GAIN[4:0] is located at CW63[8:4] */
#define TC_GAIN_CW                  BSI_CW(0x3F, 0x8BC86)  /* CW63, from m12196.c RF POR */
   #endif
#define TC_GAIN_MASK                ((0x1<<TC_GAIN_RES)-1)
#define TC_GAIN_CW_MASK             (TC_GAIN_MASK<<TC_GAIN_CW_LSB)  /* DFM_VCO_TC_GAIN[(TC_GAIN_RES-1):0] */

unsigned long L1D_RF_Get_TC_Gain_CW( void );

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
   #if IS_TEMP_COMP_TC_GAIN_SUPPORT

/* A decimal presentation of an integer */
#define DEC_FORM_RES                8              /* DEC_FORM_RES should be larger than 2 */
#define DEC_FORM(n)                 (((int)(n))<<DEC_FORM_RES)
#define DEC_FORM_INV(n)             ((n)>>DEC_FORM_RES)

      #if IS_RF_MT6260RF
#define TC_GAIN_LOW_TEMP            DEC_FORM(-20)  /* unit: Celsius degree */
#define TC_GAIN_NORMAL_TEMP         DEC_FORM(25)   /* any two value of LOW_TEMP, NORMAL_TEMP, and HIGH_TEMP can not be the same. */
#define TC_GAIN_HIGH_TEMP           DEC_FORM(65)   /* it will make tcGainSlope be infinite and make error. */
      #elif IS_RF_MT6250RF
#define TC_GAIN_LOW_TEMP            DEC_FORM(-20)  /* unit: Celsius degree */
#define TC_GAIN_NORMAL_TEMP         DEC_FORM(25)   /* any two value of LOW_TEMP, NORMAL_TEMP, and HIGH_TEMP can not be the same. */
#define TC_GAIN_HIGH_TEMP           DEC_FORM(85)   /* it will make tcGainSlope be infinite and make error. */
      #else
#define TC_GAIN_LOW_TEMP            DEC_FORM(-20)  /* unit: Celsius degree */
#define TC_GAIN_NORMAL_TEMP         DEC_FORM(25)   /* any two value of LOW_TEMP, NORMAL_TEMP, and HIGH_TEMP can not be the same. */
#define TC_GAIN_HIGH_TEMP           DEC_FORM(65)   /* it will make tcGainSlope be infinite and make error. */
      #endif
#define TC_GAIN_SLOPE(x1,x2,y1,y2)  (short)( DEC_FORM(DEC_FORM((y2)-(y1))) / ((x2)-(x1)) )  /* Get slope from (x1,y1) to (x2,y2) */

typedef enum
{
   LOW_TEMP_IND,     /* low temperature index    */
   NORMAL_TEMP_IND,  /* normal temperature index */
   HIGH_TEMP_IND,    /* high temperature index   */

   TEMP_SECTION_NUM
} TC_GAIN_TEMP_SECTION;

      #if IS_RF_MT6250RF || IS_RF_MT6260RF
/* RF Temperature Sensor ADC is located at EFUE_HW_RES0[25:20] */

         #if IS_RF_MT6260RF
#define EFUE_TEMP_CODE_RES       7      /* MT6260RF */
         #else 
#define EFUE_TEMP_CODE_RES       6      /* MT6250RF */
         #endif
#define EFUE_TEMP_CODE_LSB      20
#define EFUE_TEMP_CODE_MASK     ((0x1<<EFUE_TEMP_CODE_RES)-1)
#define EFUE_TEMP_CODE_CW_MASK  (EFUE_TEMP_CODE_MASK<<EFUE_TEMP_CODE_LSB)

void L1D_RF_THADC_Set_Code_Offset( void );
void L1D_RF_THADC_KCAL_Init( void );
      #endif
     
      #if IS_KCAL_COMP_TC_GAIN_SUPPORT
void L1D_RF_KCAL_Get_Kcal_Comp_Value( void );
      #endif

   #endif  /* IS_TEMP_COMP_TC_GAIN_SUPPORT */

#endif  /* IS_BAND_COMP_TC_GAIN_SUPPORT */

/*===============================================================================*/
/* HRD/IBB/OBB detection                                                         */
/*===============================================================================*/
/* Define flags for l1d_rf.blk_flag */
#define  HRD_FOUND                  0x01
#define  IBB_FOUND                  0x02
#define  LB_OBB_FOUND               0x04
#define  HB_OBB_FOUND               0x08

/*===============================================================================*/
/* for BT Co_clock Support                                                       */
/*===============================================================================*/
#if IS_CHIP_MT6223
unsigned short L1D_BT_Co_Clock_EINT_Setting( void );
#endif

#if IS_CHIP_MT6223 || IS_CHIP_MT6225 || IS_CHIP_MT6238
   #ifdef __CUST_NEW__   /*support driving tool*/
extern const char gpio_bt_co_clock_pin;
#define BT_Co_Clock_GPIO_PORT    gpio_bt_co_clock_pin
   #else
#define BT_Co_Clock_GPIO_PORT    0xff      /*user must define this value for BT co-clock solution*/
   #endif

#define SET_GPIO_MODE            0

   #if IS_CHIP_MT6225
#define SET_EINT_MODE            3 ///for MT6225
   #elif IS_CHIP_MT6238
#define SET_EINT_MODE            1 ///for MT6235/38/39
   #else
#define SET_EINT_MODE            L1D_BT_Co_Clock_EINT_Setting()
   #endif
#endif

/*===============================================================================*/
/* BFE registers transformation for META tool                                    */
/*===============================================================================*/
#if IS_BBTXRX_CHIP_DESIGN_VER_2
signed char DC_OFFSET_TO_OFFSET( signed char off, signed char coarse );
signed char OFFSET_TO_DC_OFFSET( signed char off );
signed char OFFSET_TO_DC_COARSE( signed char off );
signed char TRIM_IQ_TO_GAIN_COMP( signed char trimi, signed char trimq );
signed char TRIM_IQ_TO_GAIN_SEL( signed char trimi, signed char trimq );
signed char GAIN_COMP_TO_TRIMI( signed char iqgain_sel, signed char gain_comp );
signed char GAIN_COMP_TO_TRIMQ( signed char iqgain_sel, signed char gain_comp );
signed char PHASE_COMP_TO_PHSEL_I( signed char phase_sel );
signed char PHASE_COMP_TO_PHSEL_Q( signed char phase_sel );
signed char PHSEL_IQ_TO_PHASE_COMP( signed char phseli, signed char phselq );

void L1D_BFE_SET_TX_CON( int idx, void *_set );
#endif
/*===============================================================================*/

/*===============================================================================*/
/* for PMU Control                                                               */
/*===============================================================================*/
void L1D_PMU_VRF18Setting( char vrf18on );
void L1D_PMU_VRF28Setting( char vrf28on );
/*===============================================================================*/

void L1D_ABB_Set_ADCMUX_DLPad( void );
unsigned char L1D_Check_BPI_Data( void );

/*===============================================================================*/
/* for OthelloH                                                                  */
/*===============================================================================*/
#define RX_LNA_0              0
#define RX_TEST_DISABLE       1
#define PLL_TYPE2_SWITCH      2
#define PLL_TYPE1_SWITCH      3

#if IS_RF_MT6162
#define RF_MT6162_ID_REV0_0A  0x01
#define RF_MT6162_ID_REV0_0B  0x02
#define RF_MT6162_ID_REV0_1A  0xFE
#define RF_MT6162_ID_REV0_1B  0xFD
#define RF_MT6162_ID_REV1_0   0x03
   #if IS_RF_RX_DCOC_WITH_PRECISION_IMPROVEMENT
#define ALPHA_FILTER_COEFF    3
#define ALPHA_FILTER_SCALE    3   /* ALPHA_FILTER_SCALE should not smaller than 1 */
   #else
#define ALPHA_FILTER_COEFF    1
#define ALPHA_FILTER_SCALE    0
   #endif /* IS_RF_RX_DCOC_WITH_PRECISION_IMPROVEMENT */
#endif

#if IS_BBTXRX_CHIP_DESIGN_VER_2
void  L1D_RF_Calibration_Start( void );
void  L1D_RF_IMM_SEND_BSI( char type );
void  L1D_RF_GetData( unsigned long data, char idx );
void  L1D_RF_Get_RXDCOffset( FrequencyBand band, signed short idx );
void  L1D_RF_Update_DCoffset( unsigned char slot, FrequencyBand band, unsigned long gain_setting );
void  L1D_RF_RXDCOC_Start( void );
void  L1D_RF_RXDCOC_End( void );
char  L1D_RF_RXDCOC_Check( void );
int   L1D_RF_SetRXDelayInTXIQMM( int tq_cnt );
int   L1D_RF_SetTXDelayInTXIQMM( int tq_cnt );
void  L1D_RF_TXIQMM_Start( char tx_cal );
void  L1D_RF_TXIQMM_End( void );
char  L1D_RF_TXIQMM_Check( void );
void  L1D_RF_Get_TXIQMM_Results_DCBB( short dc_i_1, short dc_i_2, short dc_q_1, short dc_q_2 );
void  L1D_RF_Get_TXIQMM_Results( short g, short phi, short dc_i, short dc_q, unsigned char idx );
void  L1D_RF_Set_BULON( void );
void  L1D_RF_Recover_BULON( void );
#endif

#if IS_RF_MT6162
char  L1D_RF_Get6162Version( void );
char  L1D_RF_CheckDMPower( void );
unsigned long L1D_RF_GetClockControl( void );
unsigned long L1D_RF_SetTxGainWrite( unsigned short mod_type, char slot_idx, signed short tx_power, FrequencyBand rf_band );
void  L1D_RF_BASEBAND_FILTER_CAL( void );
void  L1D_RF_TX_GAINSTEP_CAL( void );
   #if IS_RF_RX_DCOC_SUPPORT
void  L1D_RF_RXDCOffset_Init( void );
   #endif /* IS_RF_RX_DCOC_SUPPORT */
   #if IS_RF_TX_CALIBRATION_SUPPORT
void  L1D_RF_TXIQMM_Init( void );
void  L1D_RF_SetEPSKTxIQ( signed short slot_idx, unsigned long tx_gain_write );
   #endif /* IS_RF_TX_CALIBRATION_SUPPORT */
#endif /* IS_RF_MT6162 */

/*===============================================================================*/
/* MPLL frequency hopping free run switch                                        */
/*===============================================================================*/
extern int L1D_FH_Is_MPLL_Free_Run_On( void );

#if IS_DCXO_SUPPORT_CHIP
   #if IS_RF_MT6162 && defined(AFC_VCXO)
void  L1D_RF_IMM_SEND_DCXO_BSI( unsigned short afc_dac );
   #endif
void  L1D_DCXO_WAKEUP_RESEND( void );
#endif
unsigned char L1D_RF_IS_MT6162_DCXO( void );
unsigned char L1D_PMU_IS_FIX_VRF1828SETTING( void );

/*===============================================================================*/
/* For RF TX Max Power Decrement                                                 */
/*===============================================================================*/
#if IS_DECREASE_RF_TX_MAX_POWER_SUPPORT
#define IS_RF_TX_MAX_POWER_DECREASED()       (l1d_rf.tx_power_decrement>0)
#else
#define IS_RF_TX_MAX_POWER_DECREASED()       (0)
#endif

/*===============================================================================*/
/* For WiFi adaptive power control                                               */
/*===============================================================================*/
#if IS_WIFI_ADAPTIVE_POWER_CONTROL_SUPPORT
#define DEGRADE_PWR_THRES_ORI                -100
#define DEGRADE_PWR_THRES_HYS                -97
short L1D_GET_RX_PWR_THRES_ORI( void );
short L1D_GET_RX_PWR_THRES_HYS( void );
#endif

/*===============================================================================*/
/* IS_SET_TX_BSI_CW_NEEDED                                                       */
/*===============================================================================*/
#if IS_SET_TX_BSI_CW_NEEDED
   #if IS_CHIP_MT6250 || IS_CHIP_MT6260 || IS_CHIP_MT6261
#define  QB_TX_BUF_TS_STEP            5  //each step of TX_BUF_TS is  5us (~5QB)
   #elif IS_CHIP_MT6256_S00 || IS_CHIP_MT6256 || IS_CHIP_MT6251 || IS_CHIP_MT6255
#define  QB_TX_BUF_TS_STEP           11  //each step of TX_BUF_TS is 10us (~11QB)
   #else
#error "Please check QB_TX_BUF_TS_STEP for the new chip." 
   #endif
#endif

/*===============================================================================*/
/* RF CW POR value                                                               */
/*===============================================================================*/

/*MT6261RF*/ #if IS_RF_MT6261RF
/*MT6261RF*/ #define  POR_CW0       0x0444E /* For DYN_EN           */ //TXPE , 0306
/*MT6261RF*/ #define  POR_CW1       0xA0000 /* For SX               */
/*MT6261RF*/ #define  POR_CW2       0x02000 /* For MODE             */
/*MT6261RF*/ #define  POR_CW12      0x4460E /* For ISO              */
/*MT6261RF*/ #define  POR_CW56      0x0000F /* For CapID            */
/*MT6261RF*/ #define  POR_CW57      0x11000 /* For AFC DAC          */
/*MT6261RF*/ #define  POR_CW63      0x00750 /* For DCXO FPM         */
/*MT6261RF*/ #define  POR_CW96      0xFA3B0 /* For Gain Setting     */
/*MT6261RF*/ #define  POR_CW98      0xAE88A /* For Gain Setting     */
/*MT6261RF*/ #define  POR_CW128     0xF2944 /* For TX_BUF_TS        */
/*MT6261RF*/ #define  POR_CW133     0x80000 /* For DFM_FILTER_RST   */
/*MT6261RF*/ #endif

/*MT6260RF*/ #if IS_RF_MT6260RF
/*MT6260RF*/ #define  POR_CW0       0x072A4 /* For DYN_EN           */
/*MT6260RF*/ #define  POR_CW4       0xD46A8 /* For VCO TC Gain      *///20130103,Update for OBB ,Ori 0x546A8
/*MT6260RF*/ #define  POR_CW12      0x44215 /* For ISO              */
/*MT6260RF*/ #define  POR_CW56      0x00080 /* For CapID            */
/*MT6260RF*/ #define  POR_CW57      0x39000 /* For AFC DAC          */
/*MT6260RF*/ #define  POR_CW63      0x70750 /* For DCXO FPM         */
/*MT6260RF*/ #define  POR_CW96      0xF9238 /* For Gain Setting     */
/*MT6260RF*/ #define  POR_CW105     0x1B47C /* For DET_MODE_SEL     */
/*MT6260RF*/ #define  POR_CW128     0xF2944 /* For TX_BUF_TS        */
/*MT6260RF*/ #define  POR_CW133     0x80000 /* For DFM_FILTER_RST   */
/*MT6260RF*/ #endif

/*MT6250RF*/ #if IS_RF_MT6250RF
/*MT6250RF*/ #define  POR_CW0       0x0A2A4
/*MT6250RF*/ #define  POR_CW1       0xA0000
/*MT6250RF*/ #define  POR_CW4       0x556A8 /* for GSM900 band */
/*MT6250RF*/ #define  POR_CW12      0x4821D
/*MT6250RF*/ #define  POR_CW13      0x00100
/*MT6250RF*/ #define  POR_CW14      0x01C4D
/*MT6250RF*/ #define  POR_CW56      0x00080
/*MT6250RF*/ #define  POR_CW57      0x39000
/*MT6250RF*/ #define  POR_CW96      0xF2422
/*MT6250RF*/ #define  POR_CW105     0x1E03C /* need to change CW105 setting in m12196.c if CW105 is modified. */
/*MT6250RF*/ #define  POR_CW128     0xFA944
/*MT6250RF*/ #define  POR_CW133     0x80000
/*MT6250RF*/ #endif

/*===============================================================================*/
/* Switch IF Threshold Setting                                                   */
/*===============================================================================*/
#if IS_OBB_DETECTION_SUPPORT
#define  OBB_POWER_THR                  (-840)  //-105*PWRRES
#define  OBB_C_VALUE_THR1                 128   //16*8
   #if IS_CHIP_MT6251 || IS_CHIP_MT6255
#define  OBB_C_VALUE_THR2                 128   //16*8
   #else
#define  OBB_C_VALUE_THR2                 640   //80*8
   #endif
#define  OBB_C_RATIO_THR1                  16   //THR4
#define  OBB_W_THR                      16384   //2048*8
#define  OBB_C_RATIO_THR2                   2   //THR6
#endif

#if defined(L1_SIM) || IS_COSIM_ON_L1SIM_SUPPORT
#define  IS_BSI_IMM_SEND_COMPLETE       (0x1)
#else
   #if IS_CHIP_MT6260 || IS_CHIP_MT6261
#define  IS_BSI_IMM_SEND_COMPLETE       ((HW_READ(BSI_CON)&0x80000000)>>31)
   #else
#define  IS_BSI_IMM_SEND_COMPLETE       (0x1)
   #endif
#endif

/*===============================================================================*/
/* for the DCS-TD co-existence support                                           */
/*===============================================================================*/
#if IS_DCS_NB_WB_SWITCH_SUPPORT
   #if IS_CHIP_MT6261
/* the frequency range of DCS narrow band is 1805~1850MHz, and the ARFCN is from 512 to 736 */
#define  DCS_NB_ARFCN                     736
   #else
#define  DCS_NB_ARFCN                     636   
   #endif
void L1D_RF_Init_DCS_NB_WB_Switch( void );
char L1D_RF_IS_DCS_NB_WB_Switch( void );
char L1D_RF_IS_DCS_Change_to_NB( void );
#endif

#if IS_DCS_TX_NOTCH_SWITCH_SUPPORT
char L1D_RF_IS_TDD_GSM_TX_Overlap( void );
void L1D_RF_Init_TX_Notch_Switch( void );
char L1D_RF_IS_DCS_Change_to_TX_Notch( void );

   #if IS_CHIP_MT6261
#define DT_coexist_readback_pin            48
   #else
#error "Please check the readback GPIO for the new chip." 
   #endif
#endif

/*===============================================================================*/
#endif


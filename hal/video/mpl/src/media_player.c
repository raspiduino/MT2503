/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2007
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   test_media_player.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "drv_features_video.h"
#if defined(__VIDEO_ARCHI_V2__)
//#include "kal_release.h"
//#include "med_global.h"

#include "media_player.h"

/* Audio */
#include "L1audio.h"

#include "aud_main.h"
/* Video */
#include "Video_types_v2.h"
//#include "video_render_component_v2.h"
#include "video_decoder_component_v2.h"
//#include "video_decoder_il_if_v2.h"
#include "video_decscheduler_component_v2.h"
#include "video_buffer_management_v2.h"
//#include "video_decoder_demuxer_if_v2.h"
//#include "video_comm_idp_if.h"

#include "visual_comm.h"

/* LCD */
#include "lcd_if.h"

#include "media_enum.h"

//#include "custom_sw_video.h"



/*
#include "drv_features.h"
#ifdef DRV_IDP_OLD_DESIGN 
#include "imgproc.h"
#include "resizer.h"
#include "imgdma.h"
#include "img_comm.h"
#include "Image_effect.h"
#endif
#include "img_common_enum.h"
*/
#include "Image_effect_struct.h"

#include "media_player_prot.h"
#include "kal_public_defs.h"
#include "kal_general_types.h"
#include "kal_public_api.h"

#include "mpl_common.h" // the common defition for MPL

#include "kal_trace.h"
#include "app_ltlcom.h"
#include "video_memory_usage_v2.h"
#include "video_codec_mem_v2.h"
#include "H264SwDecMem.h"
#include "video_codec_mem_custom_v2.h"
#include "lcd_sw_inc.h"
#include "MP4SwDecMem.h"
#include "va2_video_renderer_mem_req.h"
#include "video_comm_v2.h"
#include "va2_comp_video_renderer.h"
#include "video_comm_component_v2.h"
#include "stack_config.h"
#include "stack_msgs.h"
//#include "kal_active_module.h"
#include "stack_ltlcom.h"
#include "stack_common.h"
#include "hal_custom_video.h"
#include "vcodec_v2_trc.h"
#include "mpl_utility.h"

#define MPLY_ASSERT(exp) if(!(exp)) {ASSERT(0);}
#define media_player_alloc_ext_mem(client, size) (((media_player_client_t*)client)->mem_alloc_func(client, size, MED_MEM_NONCACHE, __FILE__, __LINE__))
#define media_player_free_ext_mem(client, p) (((media_player_client_t*)client)->mem_free_func(client, p, MED_MEM_NONCACHE, __FILE__, __LINE__))
#define media_player_aud_alloc_ext_mem(client, size) (((media_player_client_t*)client)->mem_alloc_func(client, size, MED_MEM_AUD_RINGBUFF, __FILE__, __LINE__))
#define media_player_aud_free_ext_mem(client, p) (((media_player_client_t*)client)->mem_free_func(client, p, MED_MEM_AUD_RINGBUFF, __FILE__, __LINE__))

/***************************************************************************** 
 * Private Function
 *****************************************************************************/
media_player_cntx_struct *media_player_cntx_p;
kal_eventgrpid media_player_comp_eg;
kal_mutexid media_player_mutex;

/*****************************************************************************
* FUNCTION
*  media_player_init
* DESCRIPTION
*  This function is to initialize media player when boot up
* PARAMETERS
*  void 
* RETURNS
*  void
*****************************************************************************/
kal_bool media_player_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    
    media_player_comp_eg = kal_create_event_group("Player Component State");        
    media_player_mutex = kal_create_mutex("Player mutex");
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_update_play_time
 * DESCRIPTION
 *  The function is to update play time
 *  playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_update_play_time(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint64 play_time = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (self->state == MPLY_STATE_PREPARED)
    {
        /* Don't need to update */
    }
    /* When player is playing, update play time from clock if there is video track. */
    else if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {
        self->scheduler_handle->pfnGetParameter(VIDEO_PARAM_CURR_TIME, &play_time);
        self->current_time = MEDIA_PLAYER_COMPTIME_TO_TIME(play_time);
    }
    else if (self->mhdl_handle)
    {
        self->current_time = self->mhdl_handle->GetCurrentTime(self->mhdl_handle);                
    }

    if (self->total_duration != 0 && self->current_time > self->total_duration)
    {
        self->current_time = self->total_duration;
    }
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_if_ignore_underflow
 * DESCRIPTION
 *  The function is to query if ignore underflow
 *  playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static kal_bool media_player_ignore_underflow(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_int64 diff;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (MPLY_IS_FLAG_SET(MPLY_FLAG_LIVE_STREAM) &&
        self->aud_stream.duration != 0)
    {        
        media_player_update_play_time(&self->itf);
        diff = self->aud_stream.duration - self->current_time;

        if (diff <= MPLY_LIVE_STREAM_IGNORE_UNDERFLOW)
        {
            return KAL_TRUE;
        }
    }
    
    return KAL_FALSE;           
}

/*****************************************************************************
 * FUNCTION
 *  media_player_audio_event_hdlr
 * DESCRIPTION
 *  This function is audio event handler
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_audio_event_hdlr(void *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_vid_media_player_aud_event_ind_struct *msg_p;
    Media_Event event;
    media_player_cntx_struct *self;
    kal_bool ignore;
    kal_uint8 msg_p_event;
    kal_uint32 session_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  

    msg_p = (media_vid_media_player_aud_event_ind_struct*)param;
    self = (media_player_cntx_struct *) msg_p->user_data;    
    msg_p_event = msg_p->event;
    session_id = msg_p->session_id;
    free_ctrl_buffer(param);

    
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_AUDIO_EVENT_HDLR, msg_p_event, session_id, self->aud_session_id, self->state);
    if (session_id != self->aud_session_id)
    {
        return;
    }
    
    if (self->mhdl_handle)
    {
        event = self->mhdl_handle->Process(self->mhdl_handle, (Media_Event)msg_p_event);
    }
    else
    {
        return;
    }

    if (self->state != MPLY_STATE_PLAYING &&
        self->state != MPLY_STATE_VID_PLAY_FINISH)
    {
        return;        
    }
    
    if (event == MEDIA_DATA_REQUEST || event == MEDIA_BUFFER_UNDERFLOW)
    {     
        MPLY_UNSET_FLAG(MPLY_FLAG_AUD_BUFF_FULL);

        /* Notify session to ask provider to read audio frame */
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_DATA_REQUEST, 0);
            
        if (self->audio_queue != NULL)
        {
            media_player_consume_audio_queue(&self->itf);

            self->mhdl_handle->FinishWriteData(self->mhdl_handle);
            
            if (self->audio_queue == NULL &&
                self->aud_stream_status == MPLY_AUD_STREAM_END)
            {
                kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
                self->mhdl_handle->DataFinished(self->mhdl_handle); 
            }
            return;
        }
        
        if (self->aud_stream_status == MPLY_AUD_STREAM_END)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
            self->mhdl_handle->DataFinished(self->mhdl_handle);
            return;
        }        
           
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_AUD_UNDERFLOW);
        if (event == MEDIA_BUFFER_UNDERFLOW)
        {
            ignore = media_player_ignore_underflow(&self->itf);
            if (ignore)
            {
                kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
                self->mhdl_handle->DataFinished(self->mhdl_handle);

                /* NOTICE: The action will make buffer release out of order */
                self->aud_stream_status = MPLY_AUD_STREAM_END;
                return;
            }
            
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_UNDERFLOW, 0);
        }               
    }
    else if (event == MEDIA_END)
    {   
        if (self->state == MPLY_STATE_PLAYING)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_AUD_PLAY_FINISH);
            self->state = MPLY_STATE_AUD_PLAY_FINISH;

            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
            {
                /* Notify media session to call player_stop() */
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
            }
        }
        else if (self->state == MPLY_STATE_VID_PLAY_FINISH)
        {
            /* Notify media session to call player_stop() */
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
        }            
    }
    else if (event == MEDIA_ERROR || event == MEDIA_DECODER_UNSUPPORT)
    {
        /* Notify media session to call player_stop() */
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
    }
    else if (event == MEDIA_STOP_TIME_UP)
    {
        /* Notify media session to call player_stop() */
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_STOP_TIME_REACHED, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  media_player_reset_recover
 * DESCRIPTION
 *  The function is to reset recover
 * PARAMETERS
 *  arg         [IN]        not used
 * RETURNS
 *  void
 *****************************************************************************/
void media_player_reset_recover(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = (media_player_cntx_struct*) arg;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_RESET_RECOVER, MPLY_IS_FLAG_SET(MPLY_FLAG_SKIP_NON_I_FRAME));

    /* if I is not yet found, don't reset recover */
    if (MPLY_IS_FLAG_SET(MPLY_FLAG_SKIP_NON_I_FRAME))
    {
        mpl_start_timer(
            MPL_PLAYER_RECOVER_TIMER, 
            MPLY_RESET_RECOVER_ELAPSE, 
            media_player_reset_recover, 
            self);
        return; /* DON'T REMOVE. */
    }   
    
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_RECOVER_RESET0, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  media_player_start_avsync
 * DESCRIPTION
 *  This function is to start av sync
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_start_avsync(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_bool clock_enable = KAL_TRUE;
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Ask clock to start to do AV sync. Must put after Media_A2V_SetFreq() */
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_CLOCK_ENABLE, &clock_enable);
    self->decoder_handle->pfnSetParameter(VIDEO_PARAM_BUFFERING_DONE, NULL);
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_RECOVER_RESET0, NULL);
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_RECOVER_RESET1, NULL);
    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_process_video_queue
 * DESCRIPTION
 *  This function is video process buffer event handler
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_process_video_queue(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MPLY_IS_FLAG_SET(MPLY_FLAG_VID_BUFF_FULL))
    {
        return;
    }
    
    if (self->video_queue != NULL)
    {
        media_player_consume_video_queue(&self->itf);
    }
    
    if (self->video_queue == NULL &&
        self->vid_stream_status == MPLY_VID_STREAM_END_WAIT_NOTIFY)
    {
        media_player_deliver_vid_eof_buffer(&self->itf);        
    }
}


/*****************************************************************************
 * FUNCTION
 *  media_player_video_buffer_req_hdlr
 * DESCRIPTION
 *  This function is video process buffer event handler
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_video_buffer_req_hdlr(void *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = media_player_cntx_p;
    media_vid_mply_vid_buf_req_struct *msg_p;
    kal_uint32 session_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_p = (media_vid_mply_vid_buf_req_struct*)param;
    session_id = msg_p->session_id;
    free_ctrl_buffer(param);
    
    kal_take_mutex(media_player_mutex);
    
    if (self == NULL)
    {
        kal_give_mutex(media_player_mutex);
        return;
    }
    
    /*********************************************
     * Check validity
     *********************************************/
    if (session_id != self->vid_session_id)
    {
        kal_give_mutex(media_player_mutex);
        return;
    }
    
    media_player_process_video_queue(&self->itf);
    
    kal_give_mutex(media_player_mutex);
}

/*****************************************************************************
 * FUNCTION
 *  media_player_video_set_renderer_bypass
 * DESCRIPTION
 *  This function is video process buffer event handler
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_disable_renderer_bypass(media_player_cntx_struct *self)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    kal_bool bypass = KAL_FALSE;
    kal_uint32 event_group;
    VIDEO_COMPONENT_TYPE_T *render_handle = self->render_handle;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set renderer bypass mode false */
    /* Change render state to stop */
    render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_STOP);
    /* Wait until the state transition is done */  
    kal_retrieve_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_RENDER_COMPLETE, KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
    render_handle->pfnSetParameter(VIDEO_PARAM_RENDERER_BYPASS, (void*) &bypass);
    /* Change render state to run */
    render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_RUN);
    /* Wait until the state transition is done */  
    kal_retrieve_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_RENDER_COMPLETE, KAL_OR_CONSUME, &event_group, KAL_SUSPEND);

}

/*****************************************************************************
 * FUNCTION
 *  media_player_recover_event_hdlr
 * DESCRIPTION
 *  The function is to handle video recover event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_recover_event_hdlr(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint64 diff;
    kal_uint32 format_index;
    media_codec_type_t codec_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   

    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
            
    media_player_update_play_time(&self->itf);

    if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0)
    {   
        /* reset flag */
        self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I);

        codec_type = self->vid_stream.dec_config.codec;
        format_index = mpl_get_vid_custom_format_index(codec_type);
        diff = mply_custom_get_cust((mply_custom_format_enum)format_index, 2);
        if (diff != 0)
        {
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_RECOVER_JUMP_TO_I, 0); 
        }
    }
    else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
    {  
        /* reset flag */
        self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO);
        
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_RECOVER_STOP_AUDIO, 0);
    }
      
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_video_event_hdlr
 * DESCRIPTION
 *  This function is video event handler
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_video_event_hdlr(void *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_vid_media_player_vid_event_ind_struct *msg_p;
    media_player_cntx_struct *self = media_player_cntx_p;
    kal_uint32 evt;
    media_error_t ret;
    kal_uint32 event;
    kal_uint32 session_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    msg_p = (media_vid_media_player_vid_event_ind_struct*)param;
    event = msg_p->event;
    session_id = msg_p->session_id;
    free_ctrl_buffer(param);

    if (self == NULL)
    {
        return;
    }
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VIDEO_EVENT_HDLR, event, self->comp_event, session_id, self->vid_session_id, self->state);
    
    /*********************************************
     * Check validity
     *********************************************/
    if (session_id != self->vid_session_id)
    {
        if (event == MPLY_EVT_DECODER_COMPLETE ||
            event == MPLY_EVT_SCHEDULER_COMPLETE)
        {
            /* Don't need to check session id */
        }
        else
        {
            /* The event is out of date */
            return;
        }
    }

    /*********************************************
     * Error Handing
     *********************************************/
    if (event == MPLY_EVT_DECODER_ERROR)
    {
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_VIDEO_PLAY_ERROR, 0);
        return;
    }
    if (event == MPLY_EVT_RENDER_ERROR)
    {
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_VIDEO_PLAY_ERROR, MED_E_INVALID_RESOLUTION);
        return;
    }
    else if (event == MPLY_EVT_DECODER_RESOLUTION_NOT_SUPPORT) 
    {
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_VIDEO_DECODER_NOT_SUPPORT, 0);
        return;        
    }

    if (self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
    {
        /* Don't need to handle any valid event anymore */
        return;
    }
    
    /*********************************************
     * Modify Stream Status
     *********************************************/    
    if (event == MPLY_EVT_DECODER_COMPLETE)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_COMPLETE);
        self->vid_stream_status = MPLY_VID_STREAM_COMPLETE;
    }
    else if (event == MPLY_EVT_SCHEDULER_COMPLETE)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_PLAY_FINISH);
        self->vid_stream_status = MPLY_VID_STREAM_PLAY_FINISH;
    }
    
    /*********************************************
     * Normal Event Handing
     *********************************************/
    self->comp_event |= event;

    evt = MPLY_EVT_CLOCK_START | MPLY_EVT_SCHEDULER_COMPLETE;
    /*
    if (self->comp_event & MPLY_EVT_CLOCK_EXPECTED_BUF_NUM_RDY)
    {
        media_player_disable_renderer_bypass(self);
    }
    */

    if (self->state == MPLY_STATE_BUFFERING)
    {
        if ((self->comp_event & MPLY_EVT_SCHEDULER_COMPLETE) != 0)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_BUFFERED);
            self->state = MPLY_STATE_VID_BUFFERED;

            if (!self->audio_config.play_audio ||
                self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->aud_stream_status == MPLY_AUD_STREAM_END ||
                !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
            {
                /* Notify media session to call player_stop() */
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
            }
            self->comp_event = 0;
        }
        else if ((self->comp_event & MPLY_EVT_CLOCK_EXPECTED_BUF_NUM_RDY) != 0 ||
            ((self->comp_event & MPLY_EVT_DECODER_COMPLETE) != 0 &&
             (self->comp_event & evt) != 0))
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_BUFFERED);
            self->state = MPLY_STATE_VID_BUFFERED;

            if (!self->audio_config.play_audio)
            {   
                media_player_start_avsync(&self->itf);
                 
                kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PLAYING);
                self->state = MPLY_STATE_PLAYING;               
            }
            else if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                     self->aud_stream_status == MPLY_AUD_STREAM_END ||
                     !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
            {        
                ret = media_player_play_dummy_audio(&self->itf);
                if (ret < 0)
                {
                    self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
                    return;
                }                
            }

            self->comp_event = 0;
        }        
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO);
        }
    }
    else if (self->state == MPLY_STATE_VID_BUFFERED)
    {
        /* video frame has been consumed. Change state back to BUFFERING */
        if (event == MPLY_EVT_SCHEDULER_COMPLETE)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_BUFFERING);
            self->state = MPLY_STATE_BUFFERING;
        }
    }
    else if (self->state == MPLY_STATE_AUD_BUFFERED)
    {
        /* clock_expected || (decoder_complete && (clock_start || scheduler complete))*/
        if ((self->comp_event & MPLY_EVT_CLOCK_EXPECTED_BUF_NUM_RDY) != 0 ||
            ((self->comp_event & MPLY_EVT_DECODER_COMPLETE) != 0 &&
             (self->comp_event & evt) != 0))
        {         
            ret = media_player_play_audio(&self->itf);            
            if (ret < 0)
            {
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
                return;
            }
            self->comp_event = 0;
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO);
        }
    }
    else if (self->state == MPLY_STATE_SEEKING)
    {
        /* clock_expected || (decoder_complete && (clock_start || scheduler complete))*/
        if ((self->comp_event & MPLY_EVT_CLOCK_EXPECTED_BUF_NUM_RDY) != 0 ||
            ((self->comp_event & MPLY_EVT_DECODER_COMPLETE) != 0 &&
             (self->comp_event & evt) != 0))
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_SEEK_DONE);
            self->state = MPLY_STATE_SEEK_DONE;
            self->comp_event = 0;
            
        #ifdef __CONTOUR_IMPROVEMENT_SUPPORT__
            /* Get prediction time */
            self->decoder_handle->pfnGetParameter(VIDEO_PARAM_QUERY_PREDICATION_TIME, &self->predict_time);
        #endif /* __CONTOUR_IMPROVEMENT_SUPPORT__ */
        
            /* Notify media session to call player_stop() */
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_STARTED, 0);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
        {
            /* Ignore */
            self->comp_event &= (~MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO);
        }
    }
    else if (self->state == MPLY_STATE_PLAYING)
    {
        if ((self->comp_event & MPLY_EVT_SCHEDULER_COMPLETE) != 0)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_PLAY_FINISH);
            self->state = MPLY_STATE_VID_PLAY_FINISH;

            if (!self->audio_config.play_audio)
            {
                /* Notify media session to call player_stop() */
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
            }
        }
        else if ((self->comp_event & MPLY_EVT_CLOCK_STOP) != 0)
        {
            /* Notify media session to call player_stop() */
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_STOP_TIME_REACHED, 0);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0 ||
                 (self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
        {
            media_player_recover_event_hdlr(&self->itf);
        }
    }
    else if (self->state == MPLY_STATE_AUD_PLAY_FINISH)
    {
        if ((self->comp_event & MPLY_EVT_SCHEDULER_COMPLETE) != 0)
        {
            /* Notify media session to call player_stop() */
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
        }
        else if ((self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I) != 0 ||
                 (self->comp_event & MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO) != 0)
        {
            media_player_recover_event_hdlr(&self->itf);
        }
    } 
}


/*****************************************************************************
 * FUNCTION
 *  media_player_decoder_callback
 * DESCRIPTION
 *  The function is decoder callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_ERROR_TYPE_T media_player_decoder_callback(
                            VIDEO_EVENT_TYPE_T event, 
                            kal_uint32 data1, 
                            kal_uint32 data2, 
                            void* data_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    media_player_cntx_struct *self = media_player_cntx_p;
    VIDEO_ERROR_TYPE_T error = VIDEO_ERROR_NONE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self == NULL)
    {
        return error;
    }    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_DECODER_CALLBACK, event, data1, self->state);
    if(event == VIDEO_EVENT_COMPLETE)
    {
        if(data1 == VIDEO_COMMAND_STATESET)
        {
            kal_set_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_DECODER_COMPLETE, KAL_OR);		
        }
        else if(data1 == VIDEO_COMMAND_NOTIFY)
        {
            media_player_video_event_callback(MPLY_EVT_DECODER_COMPLETE);
        }
    }
    else if (event == VIDEO_EVENT_INPUT_EMPTY)
    {
        if (!MPLY_IS_FLAG_SET(MPLY_FLAG_VID_BUFF_REQ_HANDING))
        {
            /* Send one msg to MED. */
            MPLY_SET_FLAG(MPLY_FLAG_VID_BUFF_REQ_HANDING);                
            media_player_video_buffer_req_callback();  
        }
    }
    else if (event == VIDEO_EVENT_FLUSH_DONE)
    {
        MPLY_ASSERT(MPLY_IS_FLAG_SET(MPLY_FLAG_WAIT_FLUSH_FRAME));
        MPLY_ASSERT(self->video_written_queue == NULL);
        kal_set_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_DECODER_FLUSH_FRAME_DONE, KAL_OR);
    }
    else if(event == VIDEO_EVENT_WAIT_BUFFER)
    {
        media_player_video_event_callback(MPLY_EVT_DECODER_WAIT_BUFFER);        
    }
    else if(event == VIDEO_EVENT_ERROR)
    { 
        media_player_video_event_callback(MPLY_EVT_DECODER_ERROR);  
    }    	
    else if (event == VIDEO_EVENT_RESOLUTION_NOT_SUPPORT)
    {
        /* Avoid decoder to make MED queue full */
        if (!MPLY_IS_FLAG_SET(MPLY_FLAG_DECODE_UNSUPPORT_RES))
        {
            media_player_video_event_callback(MPLY_EVT_DECODER_RESOLUTION_NOT_SUPPORT);  
            MPLY_SET_FLAG(MPLY_FLAG_DECODE_UNSUPPORT_RES);
        }
    }    
  
    return error;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_scheduler_callback
 * DESCRIPTION
 *  The function is scheduler callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_ERROR_TYPE_T media_player_scheduler_callback(
                            VIDEO_EVENT_TYPE_T event, 
                            kal_uint32 data1, 
                            kal_uint32 data2, 
                            void* data_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct *self = media_player_cntx_p;
    VIDEO_ERROR_TYPE_T error = VIDEO_ERROR_NONE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self == NULL)
    {
        return error;
    }
       
    if(event == VIDEO_EVENT_COMPLETE)
    {
        if(data1 == VIDEO_COMMAND_STATESET)
        {
            kal_set_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_SCHEDULER_COMPLETE, KAL_OR);		
        }
        else if(data1 == VIDEO_COMMAND_NOTIFY)
        {
            media_player_video_event_callback(MPLY_EVT_SCHEDULER_COMPLETE);
        }
    }
    else if (event == VIDEO_EVENT_STOP)
    {
        media_player_video_event_callback(MPLY_EVT_CLOCK_STOP);
    }
    else if (event == VIDEO_EVENT_EXPECTED_BUF_NUM_RDY)
    {
        media_player_video_event_callback(MPLY_EVT_CLOCK_EXPECTED_BUF_NUM_RDY);
    }
    else if(event == VIDEO_EVENT_RECOVER0)
    {
        media_player_video_event_callback(MPLY_EVT_SCHEDULER_RECOVER_JUMP_TO_I);
    }
    else if(event == VIDEO_EVENT_RECOVER1)
    {
        media_player_video_event_callback(MPLY_EVT_SCHEDULER_RECOVER_STOP_AUDIO);
    }

    return error;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_render_callback
 * DESCRIPTION
 *  The function is render callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_ERROR_TYPE_T media_player_render_callback(
                            VIDEO_EVENT_TYPE_T event, 
                            kal_uint32 data1, 
                            kal_uint32 data2, 
                            void* data_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct *self = media_player_cntx_p;
    VIDEO_ERROR_TYPE_T error = VIDEO_ERROR_NONE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (self == NULL)
    {        
        return error;
    }
    
    if(event == VIDEO_EVENT_COMPLETE)
    {
        kal_set_eg_events(media_player_comp_eg, MEDIA_PLAYER_EG_RENDER_COMPLETE, KAL_OR);		
    }
    else if(event == VIDEO_EVENT_ERROR)
    {
        /* Avoid HISR to make MED queue full */
        if (!MPLY_IS_FLAG_SET(MPLY_FLAG_RENDER_ERROR_HANDLING))
        {
            media_player_video_event_callback(MPLY_EVT_RENDER_ERROR); 
            MPLY_SET_FLAG(MPLY_FLAG_RENDER_ERROR_HANDLING);
        }
    }
    return error;
}

   
/*****************************************************************************
 * FUNCTION
 *  media_player_release_media_data
 * DESCRIPTION
 *  The function is to fill decoder init parameter
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_release_media_data(struct media_data_t* md)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    media_player_cntx_struct *self = media_player_cntx_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self == NULL)
    {
        return;
    }

    /* Only release media_data_t. Don't release data in media_data_t */
    media_player_free_ext_mem(self->client, (void **)&md);
}


/*****************************************************************************
 * FUNCTION
 *  media_player_fill_decoder_buffer
 * DESCRIPTION
 *  The function is to prepare buffer for decoder component
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_fill_decoder_buffer(
                media_player_t* mp, 
                VIDEO_BUFFERHEADER_TYPE_T *buffer_header, 
                media_data_t* media_data,
                kal_bool init_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Reset buffer header first */
    kal_mem_set(buffer_header, 0, sizeof(VIDEO_BUFFERHEADER_TYPE_T));
    
    buffer_header->pu1Buffer = media_data->data;
    buffer_header->u4BuffSize = media_data->size;
    buffer_header->u8TimeStamp = media_data->display_time * 1000;    
    buffer_header->u4OutputPort = 0;
    buffer_header->u4InputPort = 0; 
    
    if (media_data->specific_info != NULL)
    {
        /* Assign rv_specific_info_t to RM_DECODER_INPUT_PARAM_T | H264_DECODER_INPUT_PARAM_T*/
        buffer_header->pPrivateData = (void *)media_data->specific_info;
    }
    if (media_data->flags & MEDIA_DATA_FLAG_KEY_FRAME)
    {
        buffer_header->eFlags |= VIDEO_BUFFERFLAG_SYNCFRAME;
    }
    
    if (init_param)
    {
        buffer_header->eFlags |= VIDEO_BUFFERFLAG_PARAMETERSET;
    }
    else if(self->state != MPLY_STATE_SEEKING)
    {
        buffer_header->eFlags |= VIDEO_BUFFERFLAG_NONE;
    }
    else
    {
        if (MPLY_IS_FLAG_SET(MPLY_FLAG_SEEK_TIME_REACHED))
        {
            buffer_header->eFlags |= VIDEO_BUFFERFLAG_NONE;
        }
        else
        {
            if (media_data->display_time < self->audio_start_time)
            {
                buffer_header->eFlags |= VIDEO_BUFFERFLAG_DECODEONLY;
            }
            else
            {
                buffer_header->eFlags |= VIDEO_BUFFERFLAG_STARTTIME;
                MPLY_SET_FLAG(MPLY_FLAG_SEEK_TIME_REACHED);
            }
        }
    }  
}


/*****************************************************************************
 * FUNCTION
 *  media_player_init_comp_param
 * DESCRIPTION
 *  The function is to init comp parameter
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_init_comp_param(media_player_t* mp)
{  
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    VIDEO_COMPONENT_TYPE_T *dec_handle = self->decoder_handle;
    VIDEO_COMPONENT_TYPE_T *sche_handle = self->scheduler_handle;
    media_video_info_t *info_p;
    media_data_t *media_data;    
    VIDEO_BUFFERHEADER_TYPE_T decoder_buffer;
    media_codec_type_t codec_type;   
    kal_uint8* init_data = NULL;
    kal_uint32 data_size = 0, format_index;
    void *private_data = NULL;
    kal_uint64 tolerance;
#ifdef MP4_DECODE     
    media_video_mpeg4_dec_config_t *mp4_config;
#endif
#ifdef H264_DECODE
    media_video_h264_dec_config_t *h264_config;
#endif
#ifdef __RM_DEC_SUPPORT__
    media_rv_dec_config_t *rv_config;
#endif    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Scheduler parameter */
    codec_type = self->vid_stream.dec_config.codec;
    format_index = mpl_get_vid_custom_format_index(codec_type);

    tolerance = mply_custom_get_cust((mply_custom_format_enum)format_index, 0);
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, (kal_uint32)tolerance, __LINE__);
    tolerance = MEDIA_PLAYER_TIME_TO_COMPTIME(tolerance);   
    sche_handle->pfnSetParameter(VIDEO_PARAM_AVSYNC_TOLERANCE0, &tolerance);
    
    tolerance = mply_custom_get_cust((mply_custom_format_enum)format_index, 1);
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, (kal_uint32)tolerance, __LINE__);
    tolerance = MEDIA_PLAYER_TIME_TO_COMPTIME(tolerance);
    sche_handle->pfnSetParameter(VIDEO_PARAM_AVSYNC_TOLERANCE1, &tolerance);

    /* Decoder parameter */
    info_p = &(self->vid_stream.info.video);
    dec_handle->pfnSetParameter(VIDEO_PARAM_FRAMERATE, &info_p->fps);
    dec_handle->pfnSetParameter(VIDEO_PARAM_BITRATE, &info_p->avg_bitrate);
    
    if (self->elapse_ticks != 0 && self->sleep_ticks != 0) 
    {
        self->decoder_handle->pfnSetParameter(
            VIDEO_PARAM_ELAPSE_TICKS_BEFORE_SLEEP, &self->elapse_ticks);
        self->decoder_handle->pfnSetParameter(
            VIDEO_PARAM_SLEEP_TICKS, &self->sleep_ticks);
    }

    switch (codec_type)
    {
    #ifdef MP4_DECODE  
        case MEDIA_CODEC_VID_MPEG4:
            mp4_config = &(self->vid_stream.dec_config.u.mpeg4);
            init_data = mp4_config->pu1VOS;
            data_size = mp4_config->u4VOSSize;
            private_data = NULL;
            break;    
        case MEDIA_CODEC_VID_H263:            
            return MED_S_OK; /* H263 don't need init param */
    #endif /* MP4_DECODE */      
    #ifdef H264_DECODE        
        case MEDIA_CODEC_VID_H264:
            h264_config = &(self->vid_stream.dec_config.u.h264);
            init_data = h264_config->pu1Buffer;
            data_size = h264_config->u4BuffSize;    
            private_data = h264_config->pPrivateData;            
            break;
    #endif /* H264_DECODE */
    #ifdef __RM_DEC_SUPPORT__        
        case MEDIA_CODEC_VID_RV_8:
        case MEDIA_CODEC_VID_RV_9:
        case MEDIA_CODEC_VID_RV_10: 
            rv_config = &(self->vid_stream.dec_config.u.rv);
            init_data = rv_config->prp_data;
            data_size = rv_config->prp_size;  
            private_data = NULL;
            break;
    #endif /* __RM_DEC_SUPPORT__ */
    #ifdef MJPG_DECODE
        case MEDIA_CODEC_VID_MJPG:
            return MED_S_OK; /* MJPG don't need init param */
    #endif
        default:
            MPLY_ASSERT(0);
            break;
    }

    if (init_data == NULL || data_size == 0)
    {
        return MED_S_OK; /* AVI don't need init param */
    }
    
    /* Allocate media_queue to save the media data */
    media_data = media_player_alloc_ext_mem(self->client, sizeof(media_data_t));
    if (media_data == NULL) 
    {
        MPLY_ASSERT(0);
        return MED_E_OUT_OF_MEMORY;
    }
    kal_mem_set(media_data, 0, sizeof(media_data_t));
    
    media_data->data = init_data;
    media_data->size = data_size;
    media_data->release = media_player_release_media_data;    
    media_data->specific_info = private_data;
    
    media_player_fill_decoder_buffer(mp, &decoder_buffer, media_data, KAL_TRUE);
    dec_handle->pfnEmptyThisBuffer(&decoder_buffer);
                    
    media_player_add_to_queue(&self->video_written_queue, media_data);
    self->vid_queue_num ++;
    
    return MED_S_OK;
}

/*****************************************************************************
 * FUNCTION
 *  media_player_codec_type_to_decoder_type
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_DECODER_SCENARIO_T media_player_media_scenario_to_decoder_scenario(
                mpl_scenario_enum media_scenario)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VIDEO_DECODER_SCENARIO_T scenario = VIDEO_SCENARIO_UNKNOWN;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (media_scenario)
    {
        case MPL_DECODER:
            scenario = VIDEO_SCENARIO_PLAYER;
            break;
        case MPL_QVGA:
            scenario = VIDEO_SCENARIO_QVGA;
            break;
        case MPL_PREVIEW:
            scenario = VIDEO_SCENARIO_PREVIEW;
            break;
        case MPL_CIF:
            scenario = VIDEO_SCENARIO_CIF;
            break;
        default:
            /* decoder does not support. Provider should fill it out */
            MPLY_ASSERT(0);
    }   
    return scenario;
}

/*****************************************************************************
 * FUNCTION
 *  media_player_codec_type_to_decoder_type
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_DECODER_CODEC_T media_player_codec_type_to_decoder_type(
                media_codec_type_t codec_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VIDEO_DECODER_CODEC_T type = VIDEO_CODEC_UNKNOWN;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (codec_type)
    {
        case MEDIA_CODEC_VID_RV_9:
        case MEDIA_CODEC_VID_RV_10:  
            type = VIDEO_CODEC_RV9_10;
            break;
        case MEDIA_CODEC_VID_MPEG4:
            type = VIDEO_CODEC_MPEG4;
            break;
        case MEDIA_CODEC_VID_H263:
            type = VIDEO_CODEC_H263;
            break;
        case MEDIA_CODEC_VID_H264:  
            type = VIDEO_CODEC_H264;
            break;
        case MEDIA_CODEC_VID_MJPG:
            type = VIDEO_CODEC_MJPEG;
            break;
        default:
            /* decoder does not support. Provider should fill it out */
            MPLY_ASSERT(0);
    }   
    return type;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_put_bits
 * DESCRIPTION
 *  The function is copy from mp4_parser_audio.c
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_put_bits(kal_uint8* in, kal_uint32* bitcnt, kal_uint32 data, kal_uint32 data_length)
{
    kal_uint32 t, count;

    MPLY_ASSERT(data_length>0 && data_length<=16);

    t = *bitcnt;

    if ((t & 0x7) == 0)
        in[t>>3] = 0;

    if ((t & 0x7) + data_length <= 8)
        in[(t>>3)] |= (data << (8-((t&0x7) + data_length)));
    else
    {
        count = (t&7) + data_length;
        in[(t>>3)] |= (data >> (data_length - 8 + (t&7)));
        count -= 8;

        if(count > 8) {
            in[(t>>3)+1] = (unsigned char)((data >> (count-8))&0xFF);
            in[(t>>3)+2] = (unsigned char)((data << (16-count))&0xFF);
        } else {
            in[(t>>3)+1] = (unsigned char)((data << (8-count))&0xFF);
        }
    }
    *bitcnt += data_length;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_gen_adts_header
 * DESCRIPTION
 *  The function is to add a audio stream to the player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_gen_adts_header(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint8 *h = self->adts_header;
    kal_uint32 bit_count; 
    kal_uint16 channel_number;
    kal_uint32 rate;
    kal_uint32 rate_table[] =
    { 96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000};
    kal_int32 rate_index;    
    kal_int32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Find sampling rate index */
    rate = self->aud_stream.info.audio.sample_rate;
    rate_index = -1;
    for (i = 0; i < sizeof(rate_table)/sizeof(rate_table[0]) ; i ++)
    {
        if (rate_table[i] == rate)
        {
            rate_index = i;
            break;
        }
    }

    channel_number = self->aud_stream.info.audio.channels;

    bit_count = 0;
    /* adts_fixed_header */
    media_player_put_bits(h, &bit_count, 0xFFF, 12); /* syncword */
    media_player_put_bits(h, &bit_count, 0, 1);      /* ID */
    media_player_put_bits(h, &bit_count, 0, 2);      /* Layer */
    media_player_put_bits(h, &bit_count, 1, 1);      /* Protection absent */
    media_player_put_bits(h, &bit_count, 1, 2);      /* Profile */
    media_player_put_bits(h, &bit_count, rate_index, 4); /* sample_frequency_index */
    media_player_put_bits(h, &bit_count, 0, 1);      /* private_bit */
    media_player_put_bits(h, &bit_count, channel_number, 3); /* Channel_configuration */
    media_player_put_bits(h, &bit_count, 1, 1);      /* original_copy */
    media_player_put_bits(h, &bit_count, 0, 1);      /* Home */

    /* adts_variable_header */
    media_player_put_bits(h, &bit_count, 0, 1);      /* copy_identification_bit */
    media_player_put_bits(h, &bit_count, 0, 1);      /* copy_identification_byte */
    media_player_put_bits(h, &bit_count, MEDIA_PLAYER_ADTS_HEADER_LEN, 13); /* length */
    media_player_put_bits(h, &bit_count, 0x7FF, 11); /* buffer_fullness */
    media_player_put_bits(h, &bit_count, 0, 2);      /* no_raw_data_blocks_in_frame */

    MPLY_ASSERT(bit_count == MEDIA_PLAYER_ADTS_HEADER_LEN * 8);  
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_update_adts_header
 * DESCRIPTION
 *  The function is to update adts header
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_update_adts_header(media_player_t* mp, kal_uint32 buf_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint8 *h = self->adts_header;
    kal_uint32 bit_count = 30;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    media_player_put_bits(h, &bit_count, MEDIA_PLAYER_ADTS_HEADER_LEN + buf_len, 13); 
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_enter_comp_state
 * DESCRIPTION
 *  The function is to enter component state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_enter_comp_state(media_player_t* mp, VIDEO_STATE_TYPE_T state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 event_group;
    kal_bool forward_order = KAL_TRUE;
    kal_bool block_render = KAL_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (state)
    {        
        case VIDEO_STATE_STOP:        
        case VIDEO_STATE_IDLE:
        case VIDEO_STATE_CLOSE:    
            forward_order = KAL_TRUE;
            break;
        case VIDEO_STATE_RUN:
            forward_order = KAL_FALSE;
            if (MPLY_IS_FLAG_SET(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED))
            {
                block_render = KAL_TRUE;
            }
            break;
        default:
            break;
    }
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_ENTER_COMP_STATE, block_render, state, self->state);
    
    if (forward_order)
    {
        /* Change component state */        
        self->decoder_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);

        self->scheduler_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);

        if (!block_render)
        {
            self->render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);
        }
    }
    else
    {  
        if (!block_render)
        {
            self->render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);
        }
        
        self->scheduler_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);
        
        self->decoder_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, state);
    }

    /* Wait until the state transition is done */
    kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_DECODER_COMPLETE | MEDIA_PLAYER_EG_DECODER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
    if((event_group & MEDIA_PLAYER_EG_DECODER_ERROR) !=0)
    {
        return MED_E_FAIL;
    }
    
    kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_SCHEDULER_COMPLETE | MEDIA_PLAYER_EG_SCHEDULER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
    if((event_group & MEDIA_PLAYER_EG_SCHEDULER_ERROR) !=0)
    {
        return MED_E_FAIL;
    }

    if (!block_render)
    {
        kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_RENDER_COMPLETE | MEDIA_PLAYER_EG_RENDER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
        if((event_group & MEDIA_PLAYER_EG_RENDER_ERROR) != 0)
        {
            return MED_E_FAIL;
        }
    }
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_init_video_comp
 * DESCRIPTION
 *  The function is to initialize video component
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_init_video_comp(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);    
    media_error_t ret;
    media_codec_type_t codec_type;
    VIDEO_DECODER_CODEC_T decoder_type;
    VIDEO_DECODER_SCENARIO_T eScenario;
    kal_uint32 u4MemSize = 0;
    VA2_VIDEO_RENDERER_TYPE_T eRendererType = VIDEO_RENDERER_VIDEO_PLAYBACK;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Hardware buffer */
    /*
    self->intmem_start_address = (kal_uint32) med_alloc_int_mem(MAX_VID_DEC_INT_MEM_SIZE);
    if (self->intmem_start_address == NULL)
    {
        return MED_E_FAIL;
    }
    */

    switch (self->media_scenario)
    {
        case MPL_DECODER:
            u4MemSize = VIDEO_V2_DEC_EXT_MEMORY;
            eRendererType = VIDEO_RENDERER_VIDEO_PLAYBACK;
            break;
        case MPL_QVGA:
            u4MemSize = VIDEO_V2_QVGA_DEC_EXT_MEMORY;
            eRendererType = VIDEO_RENDERER_VIDEO_PLAYBACK;
            break;
        case MPL_PREVIEW:
            u4MemSize = VIDEO_V2_PREVIEW_DEC_EXT_MEMORY;
            eRendererType = VIDEO_RENDERER_VIDEO_THUMBNAIL;
            break;
        case MPL_CIF:
            u4MemSize = VIDEO_V2_CIF_DEC_EXT_MEMORY;
            eRendererType = VIDEO_RENDERER_VIDEO_PLAYBACK;
            break;            
        default:
            MPLY_ASSERT(0);
            break;
    }

    self->extmem_start_address = (kal_uint32) media_player_alloc_ext_mem(self->client, u4MemSize);
    if (self->extmem_start_address == NULL)
    {
        //med_free_int_mem((void **)&self->intmem_start_address);
        //self->intmem_start_address = NULL;
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, self->extmem_start_address, __LINE__);
        return MED_E_FAIL;
    }
    
    self->ext_handle = VideoInitExtBuffer(self->extmem_start_address, u4MemSize, VIDEO_SCENARIO_DECODE);
    self->int_handle = VideoInitIntBuffer(self->intmem_start_address, 0, VIDEO_SCENARIO_DECODE);

    codec_type = self->vid_stream.dec_config.codec;
    decoder_type = media_player_codec_type_to_decoder_type(codec_type);
    eScenario = media_player_media_scenario_to_decoder_scenario(self->media_scenario);
    
    /* decoder handle */
    self->decoder_handle = GetVideoDecoderHandle(decoder_type, eScenario, self->ext_handle, self->int_handle);
    MPLY_ASSERT(self->decoder_handle != NULL); 

    self->decoder_callback.pfnEventHandler = media_player_decoder_callback;
    self->decoder_handle->pfnSetCallbacks(&self->decoder_callback);

    /* scheduler handle */
    //self->scheduler_handle = GetVideoSchedulerHandle(VIDEO_SCHEDULER_COMM, self->ext_handle);
    self->scheduler_handle = GetVideoDecSchedulerHandle(VIDEO_SCHEDULER_COMM, self->ext_handle);
    MPLY_ASSERT(self->scheduler_handle != NULL);   
    
    self->scheduler_callback.pfnEventHandler = media_player_scheduler_callback;
    self->scheduler_handle->pfnSetCallbacks(&self->scheduler_callback);

    /* render handle */
    self->render_handle = GetVideoRendererHandle(eRendererType, self->ext_handle, self->int_handle);
    MPLY_ASSERT(self->render_handle != NULL);    

    self->render_callback.pfnEventHandler = media_player_render_callback;
    self->render_handle->pfnSetCallbacks(&self->render_callback);

    /* Setup tunnel */    
    VideoConfigComp(
                self->decoder_handle, 
                KAL_TRUE, 
                VIDEO_PORT_VIDEO_DATA, 
                media_player_decoder_fill_this_buffer);
    VideoSetupTunnel(self->decoder_handle, self->scheduler_handle, VIDEO_PORT_VIDEO_DATA);
    VideoSetupTunnel(self->scheduler_handle, self->render_handle, VIDEO_PORT_VIDEO_DATA);
 
    ret = media_player_enter_comp_state(mp, VIDEO_STATE_IDLE);
    if (ret < 0)
    {
        return ret;
    }

    media_player_init_comp_param(mp);
    return MED_S_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_release_video_comp
 * DESCRIPTION
 *  The function is to release video component
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_release_video_comp(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Chage state to close */
    media_player_enter_comp_state(mp, VIDEO_STATE_CLOSE);
    
    /* Release component handle */
    ReleaseVideoDecoderHandle(self->decoder_handle);

    ReleaseVideoDecSchedulerHandle(self->scheduler_handle);

    ReleaseVideoRendererHandle(self->render_handle);

    
    VideoDeInitExtBuffer(self->ext_handle);
    VideoDeInitIntBuffer(self->int_handle, VIDEO_SCENARIO_DECODE); 
    self->ext_handle = NULL;
    self->int_handle = NULL;
    
    /* Release memory */
    /*
    if (self->intmem_start_address)
    {
        med_free_int_mem((void **)&self->intmem_start_address);
        self->intmem_start_address = NULL;
    }
    */
    
    if (self->extmem_start_address)
    {
        media_player_free_ext_mem(self->client, (void **)&self->extmem_start_address);
        self->extmem_start_address = NULL;
    }

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_init_audio
 * DESCRIPTION
 *  The function is to init audio
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_init_audio(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
#if defined(__COOK_DECODE__)
    Media_COOK_Param cook_param;
    media_ra_dec_config_t *ra_dec_p;
#endif    
    media_audio_info_t *audio_info_p;
    Media_VM_PCM_Param vpFormat;
    Media_PCM_Stream_Param sFormat;
    kal_bool report_error;
    kal_uint64 tolerance;
    kal_uint32 format_index;
    media_codec_type_t codec_type;
    kal_uint32 buffer_size = MPLY_AUD_RING_BUFFER_SIZE;
#ifdef DAF_DECODE    
    Media_Ext_DAF_strm daf_strm;
#endif    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_INIT_AUDIO, self->state);

    MPLY_ASSERT(self->audio_config.play_audio);
    MPLY_ASSERT(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH));
    MPLY_ASSERT(self->mhdl_handle == NULL);
   
    switch (self->aud_format)
    {
#if defined(AAC_DECODE)
    case MEDIA_FORMAT_AAC:
    case MEDIA_FORMAT_AAC_PLUS:    
        /* insist av-sync */
        if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
        {
            tolerance = 0;
        }
        else
        {
            codec_type = self->vid_stream.dec_config.codec;
            format_index = mpl_get_vid_custom_format_index(codec_type);
            tolerance = mply_custom_get_cust((mply_custom_format_enum)format_index, 1);
        }
        report_error = (tolerance == 0) ? KAL_TRUE : KAL_FALSE;
        self->mhdl_handle = AAC_Open(media_player_audio_event_callback, NULL, (void *)report_error);

        break;
#endif /*AAC_DECODE*/    
#if defined(__COOK_DECODE__)
    case MEDIA_FORMAT_COOK:
        ra_dec_p = &(self->aud_stream.dec_config.u.ra);
        cook_param.nSamples = ra_dec_p->nSamples;
        cook_param.nChannels = ra_dec_p->usNumChannels;
        cook_param.nRegions = ra_dec_p->nRegions;
        cook_param.nFrameBits = ra_dec_p->ulBitsPerFrame;
        cook_param.sampRate = ra_dec_p->ulSampleRate;
        cook_param.cplStart = ra_dec_p->cplStart;
        cook_param.cplQbits = ra_dec_p->cplQBits;
        
        self->mhdl_handle = COOK_Open(media_player_audio_event_callback, NULL, &cook_param);
        break;
#endif /* __COOK_DECODE__ */ 

#ifdef AMR_DECODE    
    case MEDIA_FORMAT_AMR:
#ifdef AMRWB_DECODE        
    case MEDIA_FORMAT_AMR_WB:
#endif /* AMRWB_DECODE */        
        vpFormat.mediaType = self->aud_format;
        vpFormat.vmParam = (kal_uint32)MEDIA_VMP_AS_RINGTONE;       
        self->mhdl_handle = AMR_Open(media_player_audio_event_callback, NULL, &vpFormat);

        /* Set buffer size */
        buffer_size = MPLY_AMR_RING_BUFFER_SIZE;
        break;
#endif /* AMR_DECODE */            
#if defined(BSAC_DECODE)
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* BSAC_DECODE */
#ifdef DAF_DECODE    
    case MEDIA_FORMAT_DAF:
#ifdef MUSICAM_DECODE
    case MED_TYPE_MUSICAM:
#endif     
        daf_strm.channel_num = self->aud_stream.info.audio.channels;
        daf_strm.sample_rate = self->aud_stream.info.audio.sample_rate;
        self->mhdl_handle = DAF_Open(media_player_audio_event_callback, NULL, &daf_strm);
        //self->mhdl_handle = DAF_Open(media_player_audio_event_callback, NULL, NULL);
        break;
#endif
#if defined(WAV_CODEC)
    case MEDIA_FORMAT_PCM_8K:
        audio_info_p = &self->aud_stream.info.audio;
        sFormat.isStereo = (audio_info_p->channels == 2) ? KAL_TRUE : KAL_FALSE;
        sFormat.bitPerSample = audio_info_p->bits_per_sample;
        sFormat.sampleFreq = audio_info_p->sample_rate;
        sFormat.forceVoice = KAL_FALSE;
        self->mhdl_handle = PCM_Strm_Open(media_player_audio_event_callback, &sFormat);        
        break;
#endif        
    default:
        MPLY_ASSERT(0);
        break;
    }          

    MPLY_ASSERT(self->mhdl_handle != NULL);
    MPLY_UNSET_FLAG(MPLY_FLAG_IS_DUMMY_AUDIO);
    self->mhdl_handle->SetUserData(self->mhdl_handle, self);
    self->aud_frame_num = 0;
    self->audio_buf = media_player_aud_alloc_ext_mem(self->client, buffer_size << 1);
    MPLY_ASSERT(self->audio_buf != NULL); 
    
    /* Prepare audio ring buffer */
    self->mhdl_handle->SetBuffer(
            self->mhdl_handle, 
            self->audio_buf,
            buffer_size << 1);
    MPLY_UNSET_FLAG(MPLY_FLAG_AUD_BUFF_FULL);
    
    if (self->vol_level != MEDIA_PLAYER_VOL_LEVEL_NOT_USED)
    {
        self->mhdl_handle->SetLevel(self->mhdl_handle, self->vol_level);
    }

    self->mhdl_handle->SetStartTime(self->mhdl_handle, self->audio_start_time);
    if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX && self->stop_time != 0)
    {
        self->mhdl_handle->SetStopTime(self->mhdl_handle, self->stop_time);
    }

    audio_info_p = &self->aud_stream.info.audio;
    
#ifdef __VE_BES_TS_SUPPORT__
    if (self->play_speed != 100)
    {
        aud_stretch_set_speed(self->play_speed); 
    }
#endif /* __VE_BES_TS_SUPPORT__ */    

    /* SW video and loudness can't work smoothly */
    AudioPP_DisableBesSound();
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_init_dummy_audio
 * DESCRIPTION
 *  The function is to init dummy audio
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_get_silence_info(
            media_player_t* mp, 
            Media_Format *aud_format, 
            kal_uint16 *channel_no, 
            kal_uint32 *sampling_rate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_audio_info_t *audio_info_p = &self->aud_stream.info.audio;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
        self->aud_format == MEDIA_FORMAT_AMR ||
        audio_info_p->channels == 0)
    {
        *aud_format = MEDIA_FORMAT_AMR;
        *channel_no = 1;
        *sampling_rate = MEDIA_PLAYER_AMR_SAMPLING_RATE;
        return MED_S_OK;
    }

    switch (self->aud_format)
    {
    #ifdef AMRWB_DECODE    
        case MEDIA_FORMAT_AMR_WB:    
            *aud_format = MEDIA_FORMAT_AMR_WB;
            *channel_no = 1;
            *sampling_rate = MEDIA_PLAYER_AMRWB_SAMPLING_RATE;
            break;
    #endif /* AMRWB_DECODE */
    #if defined(WAV_CODEC)
        case MEDIA_FORMAT_PCM_8K:
            *aud_format = MEDIA_FORMAT_AAC;            
            *channel_no = audio_info_p->channels;
            *sampling_rate = audio_info_p->sample_rate;
            break; 
    #endif  /* WAV_CODEC */      
    #if defined(DAF_DECODE)        
        case MEDIA_FORMAT_DAF:
    #ifdef MUSICAM_DECODE
        case MED_TYPE_MUSICAM:
    #endif /* MUSICAM_DECODE */    
            *aud_format = MEDIA_FORMAT_AAC;            
            *channel_no = audio_info_p->channels;
            *sampling_rate = audio_info_p->sample_rate;
            break; 
    #endif /* DAF_DECODE */            
        default:
            *aud_format = self->aud_format;
            *channel_no = audio_info_p->channels;
            *sampling_rate = audio_info_p->sample_rate;
            break;
    }
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_init_dummy_audio
 * DESCRIPTION
 *  The function is to init dummy audio
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_init_dummy_audio(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    void *param = NULL;
    Media_Format aud_format;
    kal_uint16 audio_channel_no;
    kal_uint32 audio_sample_rate;
    kal_uint32 audio_buf_len;
    kal_uint8 *audio_buf_p;
    
    Media_Status status;
    Media_VM_PCM_Param vpFormat;
    kal_uint32 frame_len;
    kal_uint8 *silence_frame_p;
    kal_uint32 header_len = 0;
    kal_uint8 *silence_header_p = NULL;
#if defined(__COOK_DECODE__)
    Media_COOK_Param cook_param = {0};
    media_ra_dec_config_t *ra_dec_p;
#endif
    kal_uint32 buffer_size = MPLY_AUD_RING_BUFFER_SIZE;
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_INIT_DUMMY_AUDIO, self->state);

    MPLY_ASSERT(self->audio_config.play_audio);
    
#if defined(__BTMTK__) && defined(__VE_BT_A2DP_SUPPORT__) 
    aud_bt_a2dp_close_codec_ind();
#endif

    /* close normal audio handle */
    if (self->mhdl_handle != NULL)
    {
        /* Close aud_stretch before close audio_handle */
    #ifdef __VE_BES_TS_SUPPORT__
        aud_stretch_close();
    #endif  
        AudioPP_EnableBesSound();

        self->mhdl_handle->Close(self->mhdl_handle);
        self->mhdl_handle = NULL;

        /* free audio ring buffer */
        if (self->audio_buf != NULL)
        {
            media_player_aud_free_ext_mem(self->client, (void**)&self->audio_buf);
            self->audio_buf = NULL;
        }       
    }

    /* Get silence info */
    media_player_get_silence_info(mp, &aud_format, &audio_channel_no, &audio_sample_rate);
  
    
    /* Silence header */
    status = Media_GetFileHeaderLength(
                aud_format, audio_channel_no, audio_sample_rate, 1, &header_len);

    if (status != MEDIA_SUCCESS)
    {    
        MPLY_ASSERT(0);
        return MED_E_FAIL;
    } 

    if (header_len > 0)
    {
        silence_header_p = (kal_uint8*) media_player_alloc_ext_mem(self->client, header_len);
        
        MPLY_ASSERT(silence_header_p != NULL);
        status = Media_GetFileHeaderPattern(
                    aud_format, audio_channel_no, audio_sample_rate, 1, silence_header_p);
        MPLY_ASSERT(status == MEDIA_SUCCESS);
    }   
    
    /* Silence pattern */ 
    status = Media_GetSilenceLength(
                aud_format, audio_channel_no, audio_sample_rate, 1, &frame_len);

    if (status != MEDIA_SUCCESS)
    {   
        media_player_free_ext_mem(self->client, (void **)&silence_header_p);
        MPLY_ASSERT(0);
        return MED_E_FAIL;
    }
    
    silence_frame_p = (kal_uint8*) media_player_alloc_ext_mem(self->client, frame_len);
    MPLY_ASSERT(silence_frame_p != NULL);
    status = Media_GetSilencePattern(
                aud_format, audio_channel_no, audio_sample_rate, 1 , silence_frame_p);

    if (status != MEDIA_SUCCESS)
    {
        media_player_free_ext_mem(self->client, (void **)&silence_header_p);
        media_player_free_ext_mem(self->client, (void **)&silence_frame_p);
        MPLY_ASSERT(0);
        return MED_E_FAIL;
    }                            

    switch (aud_format)
    {
    #ifdef AMR_DECODE    
        case MEDIA_FORMAT_AMR: 
    #ifdef AMRWB_DECODE        
        case MEDIA_FORMAT_AMR_WB:
    #endif /* AMRWB_DECODE */        
            vpFormat.mediaType = aud_format;
            vpFormat.vmParam = (kal_uint32)MEDIA_VMP_AS_RINGTONE;
            param = &vpFormat;        
            self->mhdl_handle = AMR_Open(media_player_audio_dummy_callback, NULL, param);

            /* Set buffer size */
            buffer_size = MPLY_AMR_RING_BUFFER_SIZE;
            break;
    #endif /*AMR_DECODE*/
    #if defined(AAC_DECODE)            
        case MEDIA_FORMAT_AAC:
        case MEDIA_FORMAT_AAC_PLUS:    
            self->mhdl_handle = AAC_Open(media_player_audio_dummy_callback, NULL, NULL);
            break;
    #endif /*AAC_DECODE*/    
    #if defined(__COOK_DECODE__)
        case MEDIA_FORMAT_COOK:
            ra_dec_p = &(self->aud_stream.dec_config.u.ra);
            cook_param.nSamples = ra_dec_p->nSamples;
            cook_param.nChannels = ra_dec_p->usNumChannels;
            cook_param.nRegions = ra_dec_p->nRegions;
            cook_param.nFrameBits = ra_dec_p->ulBitsPerFrame;
            cook_param.sampRate = ra_dec_p->ulSampleRate;
            cook_param.cplStart = ra_dec_p->cplStart;
            cook_param.cplQbits = ra_dec_p->cplQBits;
        
            self->mhdl_handle = COOK_Open(media_player_audio_dummy_callback, NULL, &cook_param);
            break;
    #endif /* __COOK_DECODE__ */  
    #if defined(BSAC_DECODE)
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* BSAC_DECODE */        
        default:
            MPLY_ASSERT(0);
            break;
    }

    MPLY_ASSERT(self->mhdl_handle != NULL);
    MPLY_SET_FLAG(MPLY_FLAG_IS_DUMMY_AUDIO);

    self->audio_buf = media_player_aud_alloc_ext_mem(self->client, buffer_size << 1);
    MPLY_ASSERT(self->audio_buf != NULL); 
    
    /* Initialize audio buffer */
    self->mhdl_handle->SetBuffer(
            self->mhdl_handle, 
            self->audio_buf,
            buffer_size << 1);    
  
    self->mhdl_handle->GetWriteBuffer(
        self->mhdl_handle, 
        &audio_buf_p, 
        &audio_buf_len);

    /* Put silence header to audio buffer */
    if (silence_header_p != NULL && header_len > 0)
    {
        kal_mem_cpy(audio_buf_p, silence_header_p, header_len);

        self->mhdl_handle->WriteDataDone(self->mhdl_handle, header_len);

        self->mhdl_handle->GetWriteBuffer(
            self->mhdl_handle, 
            &audio_buf_p, 
            &audio_buf_len);

        media_player_free_ext_mem(self->client, (void **)&silence_header_p);
    }
    
    /* Put silence frame to audio buffer */
    kal_mem_cpy(audio_buf_p, silence_frame_p, frame_len); 

    self->mhdl_handle->WriteDataDone(self->mhdl_handle, frame_len);
    self->mhdl_handle->FinishWriteData(self->mhdl_handle); 
    
    media_player_free_ext_mem(self->client, (void **)&silence_frame_p);

    /* To mute audio in case of noise, set analog gain to 0 */
    aud_melody_set_output_volume(0, 0);

    /* SW video and loudness can't work smoothly */
    AudioPP_DisableBesSound();
    
    return MED_S_OK;    

}


/*****************************************************************************
 * FUNCTION
 *  media_player_play_dummy_audio
 * DESCRIPTION
 *  The function is to play dummy audio
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_play_dummy_audio(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    Media_Status aud_ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_PLAY_DUMMY_AUDIO, self->state);
    media_player_init_dummy_audio(&self->itf);

    media_player_start_avsync(&self->itf);
                            
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_PLAY, __LINE__);
    aud_ret = self->mhdl_handle->Play(self->mhdl_handle);    

    if (aud_ret != MEDIA_SUCCESS)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, aud_ret, __LINE__);
        return MED_E_FAIL;
    }
    /* Change state to AUD_PLAY_FINISHED directly */
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_AUD_PLAY_FINISH);
    self->state = MPLY_STATE_AUD_PLAY_FINISH;

    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
    self->mhdl_handle->DataFinished(self->mhdl_handle);
    
    return MED_S_OK;
}



/*****************************************************************************
 * FUNCTION
 *  media_player_play_audio
 * DESCRIPTION
 *  The function is to play audio
 *  playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_play_audio(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    Media_Status aud_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Ask clock to start to do AV sync */
    if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {
        media_player_start_avsync(&self->itf);
    }
    
#if defined(__BTMTK__) && defined(__VE_BT_A2DP_SUPPORT__)          
    aud_bt_a2dp_open_codec(self->aud_format);                        
#endif

    if (self->audio_queue == NULL && 
        self->aud_stream_status == MPLY_AUD_STREAM_END)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
        self->mhdl_handle->DataFinished(self->mhdl_handle);
    }

    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_PLAY, __LINE__);
    aud_ret = self->mhdl_handle->Play(self->mhdl_handle);

    if (aud_ret != MEDIA_SUCCESS)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, aud_ret, __LINE__);
        return MED_E_FAIL;
    }
    
    if (self->audio_queue == NULL && 
        self->aud_stream_status == MPLY_AUD_STREAM_END)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
        self->mhdl_handle->DataFinished(self->mhdl_handle);
    }

    if (self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_PLAY_FINISH);
        self->state = MPLY_STATE_VID_PLAY_FINISH;
    }
    else
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PLAYING);
        self->state = MPLY_STATE_PLAYING;
    }

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_add_to_queue
 * DESCRIPTION
 *  The function is to add media data to media queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_add_to_queue(media_data_t **queue, media_data_t* node)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_data_t *head;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (*queue == NULL)
    {
        *queue = node;
        node->next = node;
    }
    else
    {
        head = (*queue)->next;
        (*queue)->next = node;
        node->next = head;
        (*queue) = node;
    }
}


/*****************************************************************************
 * FUNCTION
 *  media_player_remove_from_queue
 * DESCRIPTION
 *  The function is to remove queue head 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void media_player_remove_from_queue(media_data_t **queue, media_data_t* node)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_data_t *head;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    head = (*queue)->next;  

    /* Only allow to review queue's head */
    MPLY_ASSERT(head == node);    
    if (head == *queue)
    {
        *queue = NULL;
    }
    else
    {
        (*queue)->next = head->next;
    }
}


/*****************************************************************************
 * FUNCTION
 *  media_player_reset_queue
 * DESCRIPTION
 *  The function is to reset queue 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void media_player_reset_queue(media_player_t* mp, media_player_queue_type_enum queue_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_data_t *head;
    media_data_t **queue_ptr_addr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (queue_type)
    {
        case MPLY_QUEUE_AUDIO:
            queue_ptr_addr = &self->audio_queue;
            break;
        case MPLY_QUEUE_VIDEO:
            queue_ptr_addr = &self->video_queue;
            break;
        case MPLY_QUEUE_VIDEO_WRITTEN:
            queue_ptr_addr = &self->video_written_queue;
            break;
        default:
            break;
    }    
    
    while (*queue_ptr_addr != NULL)
    {
        head = (*queue_ptr_addr)->next;
                        
        media_player_remove_from_queue(queue_ptr_addr, head);
        head->release(head);                
    }

}


/*****************************************************************************
 * FUNCTION
 *  media_player_check_and_fill_silence
 * DESCRIPTION
 *  This function is to fill silence
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  MED_S_OK: if consume
 *****************************************************************************/
static media_error_t media_player_check_and_fill_silence(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_audio_info_t *audio_info_p = &self->aud_stream.info.audio;
    kal_bool fill_silence = KAL_FALSE;
    media_data_t *head;
    Media_Format aud_format;
    kal_uint16 audio_channel_no;
    kal_uint32 audio_sample_rate;
    kal_uint32 frame_len = 0;
    kal_uint8 silence_frame[39];    
    media_error_t ret;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (self->aud_time_diff != 0 && audio_info_p->channels != 0 &&
        self->adts_written_size == 0 && self->aud_written_size == 0)
    {
        /* Streaming */
        if (MPLY_IS_FLAG_SET(MPLY_FLAG_LIVE_STREAM))
        {
            fill_silence = KAL_TRUE;
        }
        /* Local playback in the beggining of the file */
        else if (self->audio_last_time == 0 && self->aud_frame_num == 0)
        {
            fill_silence = KAL_TRUE;
        }
    }

    /* Fill silence: streaming or local playback in the begin of the file */
    if (fill_silence)
    {
        head = self->audio_queue->next;
        while (head->display_time > self->audio_last_time &&
               head->display_time - self->audio_last_time >= self->aud_time_diff * 2)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_AUTO_FILE_SILENCE,
                (kal_uint32)head->display_time, (kal_uint32)self->audio_last_time, (kal_uint32)self->aud_time_diff);
            /* Initialize when enter the while loop for the first time */
            if (frame_len == 0)
            {
                /* Get silence info */
                media_player_get_silence_info(mp, &aud_format, &audio_channel_no, &audio_sample_rate);
                /* Silence pattern */ 
                Media_GetSilenceLength(
                    aud_format, audio_channel_no, audio_sample_rate, 0, &frame_len);
                MPLY_ASSERT(frame_len <= 39);
                Media_GetSilencePattern(
                    aud_format, audio_channel_no, audio_sample_rate, 0 , silence_frame);
            }

            ret = media_player_write_to_audio_buffer(
                        &self->itf, 
                        silence_frame,
                        frame_len,
                        &self->silence_written_size);
            if (ret < 0)
            {
                MPLY_SET_FLAG(MPLY_FLAG_AUD_BUFF_FULL);
                return MED_S_OK;
            }
            self->silence_written_size = 0;
            self->audio_last_time += self->aud_time_diff;
            self->aud_frame_num ++; /* Would wrap around */
        }
    }
    return MED_S_OK;
}

/*****************************************************************************
 * FUNCTION
 *  media_player_consume_audio_queue
 * DESCRIPTION
 *  This function is consume audio queue
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  MED_S_OK: if consume
 *****************************************************************************/
static media_error_t media_player_consume_audio_queue(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;
    kal_bool need_adts = KAL_FALSE;
    media_data_t *head;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MPLY_ASSERT(self->audio_queue != NULL);
    
    if (self->aud_format == MEDIA_FORMAT_AAC || self->aud_format == MEDIA_FORMAT_AAC_PLUS)
    {
        need_adts = KAL_TRUE;
    }
    
    while (self->audio_queue != NULL)
    {
        head = self->audio_queue->next;

        /* Fill silence frame */
        media_player_check_and_fill_silence(mp);

        /* Fill adts header */
        if (need_adts && !(head->flags & MEDIA_DATA_FLAG_WITH_ADTS_HEADER))
        {
            if (self->adts_written_size == 0)
            {
                media_player_update_adts_header(mp, head->size);
            }

            if (self->adts_written_size != MEDIA_PLAYER_ADTS_HEADER_LEN)
            {
                ret = media_player_write_to_audio_buffer(
                        &self->itf, 
                        self->adts_header,
                        MEDIA_PLAYER_ADTS_HEADER_LEN,
                        &self->adts_written_size);
                if (ret < 0)
                {
                    MPLY_SET_FLAG(MPLY_FLAG_AUD_BUFF_FULL);
                    break;
                }
            }
        }        
        /* Fill audio frame */        
        ret = media_player_write_to_audio_buffer(
                    &self->itf, 
                    head->data,
                    head->size,
                    &self->aud_written_size);
        if (ret < 0)
        {
            MPLY_SET_FLAG(MPLY_FLAG_AUD_BUFF_FULL);         
            break;
        }
        
        /* Reset for the next audio frame */
        self->adts_written_size = 0;
        self->aud_written_size = 0;        
        /* Release the buffer */                
        media_player_remove_from_queue(&self->audio_queue, head);
        self->aud_frame_size -= head->size;
        self->aud_frame_num ++; /* Would wrap around */
        self->audio_last_time = head->decode_time;
        head->release(head);
        self->aud_queue_num --;
    }
    
    return MED_S_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_consume_video_queue
 * DESCRIPTION
 *  This function is consume video queue
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  MED_S_OK: if consume
 *****************************************************************************/
static media_error_t media_player_consume_video_queue(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_data_t *head;
    VIDEO_ERROR_TYPE_T error;
    VIDEO_BUFFERHEADER_TYPE_T decoder_buffer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MPLY_ASSERT(self->video_queue != NULL);
    
    while (self->video_queue != NULL)
    {
        head = self->video_queue->next;

        media_player_fill_decoder_buffer(mp, &decoder_buffer, head, KAL_FALSE);
        
        error = self->decoder_handle->pfnEmptyThisBuffer(&decoder_buffer);
        kal_trace(TRACE_GROUP_1, VID_TRC_MEDIA_PLAYER_EMPTY_THIS_BUFFER, 
                    error, (kal_uint32)head->display_time, decoder_buffer.eFlags);          
        if(error == VIDEO_ERROR_NONE)
        {            
            media_player_remove_from_queue(&self->video_queue, head);
            media_player_add_to_queue(&self->video_written_queue, head);  

            /* Update max_empty_time */
            //self->max_empty_time = head->decode_time;
            self->max_empty_time = head->display_time;
        }
        else if (error == VIDEO_ERROR_BUFF_FULL)
        {            
            MPLY_SET_FLAG(MPLY_FLAG_VID_BUFF_FULL);
            break;                    
        }

    } 

    /* Unset flag */
    MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_REQ_HANDING);
    return MED_S_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_process_audio_queue
 * DESCRIPTION
 *  The function is to process audio queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_process_audio_queue(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;
    kal_bool processed = KAL_FALSE;
    kal_uint32 data_count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MPLY_ASSERT(self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX);
    
    if (self->audio_queue != NULL)
    {
        media_player_consume_audio_queue(&self->itf);
        self->mhdl_handle->FinishWriteData(self->mhdl_handle);
        processed = KAL_TRUE;
    }

    if (self->mhdl_handle != NULL)
    {
        /* Buffer size (unit: byte) in audio ring buffer */
        data_count = self->mhdl_handle->GetDataCount(self->mhdl_handle);
    }
    
    if (!(MPLY_IS_FLAG_SET(MPLY_FLAG_AUD_BUFF_FULL) || 
          self->aud_stream_status == MPLY_AUD_STREAM_END ||
          self->aud_frame_num >= self->aud_ready_frame_num ||
          data_count >= (MPLY_AUD_BUFFER_START_TO_PLAY << 1)))
    {
        return MED_S_OK;
    }
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_AUTO_PROCESS_BUFF,    
        MPLY_IS_FLAG_SET(MPLY_FLAG_AUD_BUFF_FULL), 
        self->aud_stream_status,
        self->aud_frame_num,
        self->aud_ready_frame_num,
        data_count
        );
      
    if (self->state == MPLY_STATE_BUFFERING)
    {
        if (processed)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_AUD_BUFFERED);
            self->state = MPLY_STATE_AUD_BUFFERED;
            
            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->vid_stream_status == MPLY_VID_STREAM_COMPLETE ||
                self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
            {
                ret = media_player_play_audio(&self->itf);            
                if (ret < 0)
                {
                    return MED_E_FAIL;
                }            
            }
        }
        else
        {
            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
            {
                return MED_S_TERMINATED;
            }
        }
    }
    else if (self->state == MPLY_STATE_VID_BUFFERED)
    {
        if (processed)
        {
            ret = media_player_play_audio(&self->itf);
        }
        else
        {
            /* audio_queue == NULL & aud_stream_status == END */
            ret = media_player_play_dummy_audio(&self->itf);
        }
        
        if (ret < 0)
        {
            return MED_E_FAIL;
        }       
    }
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_write_to_audio_buffer
 * DESCRIPTION
 *  The function is to write to audio buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_write_to_audio_buffer(
                        media_player_t* mp, 
                        kal_uint8 *data,
                        kal_uint32 data_len,
                        kal_uint32 *written_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 buf_len;
    kal_uint8 *buf_p;
    kal_int32 remain_size;
    kal_int32 cnt = 2;
    media_error_t ret = MED_E_FAIL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Write from the end of audio buffer and then write from the start of audio buffer */
    while (cnt--)
    {
        self->mhdl_handle->GetWriteBuffer(self->mhdl_handle, &buf_p, &buf_len); 
        if (buf_len == 0)
        {
            /* Return FAIL if entry here at the first loop */
            return ret;
        }

        if (*written_size == 0)
        {
            if (data_len <= buf_len)
            {
                kal_mem_cpy(buf_p, data, data_len);
                self->mhdl_handle->WriteDataDone(self->mhdl_handle, data_len); 
                *written_size = data_len;
                return MED_S_OK;
            }
            else
            {
                kal_mem_cpy(buf_p, data, buf_len);
                self->mhdl_handle->WriteDataDone(self->mhdl_handle, buf_len);
                *written_size = buf_len;
                ret = MED_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            remain_size = data_len - *written_size;
            if (remain_size <= buf_len)
            {
                kal_mem_cpy(buf_p, &data[*written_size], remain_size);
                self->mhdl_handle->WriteDataDone(self->mhdl_handle, remain_size); 
                *written_size += remain_size;
                return MED_S_OK;
            }
            else
            {
                kal_mem_cpy(buf_p, &data[*written_size], buf_len);
                self->mhdl_handle->WriteDataDone(self->mhdl_handle, buf_len);
                *written_size += buf_len;
                ret = MED_E_OUT_OF_MEMORY;
            }
        }
    }
    
    return ret;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_validate_packet
 * DESCRIPTION
 *  The function is to validate packet
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_validate_packet(
                        media_player_t* mp, 
                        kal_uint32 stream_index, 
                        media_data_t* media_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Drop the packet */
    if (stream_index == self->vid_stream_index)
    {
        kal_take_mutex(media_player_mutex);
        if (self->vid_stream_status != MPLY_VID_STREAM_NONE)
        {
            media_data->release(media_data);
            kal_give_mutex(media_player_mutex);
            return MED_S_FALSE;
        }
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
        if (MPLY_IS_FLAG_SET(MPLY_FLAG_SKIP_NON_I_FRAME))
        {
            if ((media_data->flags & MEDIA_DATA_FLAG_KEY_FRAME) &&
                media_data->decode_time >= self->key_frame_time)
            {
                MPLY_UNSET_FLAG(MPLY_FLAG_SKIP_NON_I_FRAME);
            }
            else
            {
                MPLY_ASSERT(media_data->decode_time < self->key_frame_time);
            
                media_data->release(media_data);
                kal_give_mutex(media_player_mutex);
                return MED_S_FALSE;
            }
        }
        kal_give_mutex(media_player_mutex);
    }
    else if (stream_index == self->aud_stream_index)
    {
        if (self->aud_stream_status == MPLY_AUD_STREAM_END)
        {
            media_data->release(media_data);
            return MED_S_FALSE;
        }
        
        /* When player is at SEEKING, we don't know if play audio */
        if (self->state != MPLY_STATE_SEEKING &&
            self->state != MPLY_STATE_SEEK_DONE)
        {
            if (!self->audio_config.play_audio ||
                !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
            {
                media_data->release(media_data);
                return MED_S_FALSE;
            }
        }      

        if (media_data->decode_time < self->audio_start_time)
        {
            media_data->release(media_data);
            return MED_S_FALSE;
        }        
    }

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_set_render_param
 * DESCRIPTION
 *  The function is to init render param
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_set_render_param(media_player_t* mp, media_player_render_param_type_enum param_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    VIDEO_COMPONENT_TYPE_T *rh = self->render_handle;
    media_player_video_config_t *cfg = &self->video_config;
    VA2_FRAME_SIZE_T display_size;
    kal_bool bypass, trigger_lcd, disable_dc;
    va2_video_renderer_dst_fb_t display_fb;
    va2_video_renderer_post_process_config_t ipp;
    VA2_VIDEO_RENDERER_COLOR_FORMAT_T color_fmt;
    va2_video_renderer_rotate_flip_t rot;
    VA2_VIDEO_RENDERER_RENDER_MODE_T mode;  
    va2_video_renderer_display_surface_t surface;
    kal_uint32 frame_period, fps;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    bypass = KAL_FALSE;
    self->render_handle->pfnSetParameter(VIDEO_PARAM_RENDERER_BYPASS, (void*) &bypass);
    
    display_size.u4_width = cfg->display_width;
    display_size.u4_height = cfg->display_height;
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DST_FB_SIZE, (void*) &display_size);
    rh->pfnSetParameter(VIDEO_CONFIG_RENDERER_RESIZE_DST_SIZE, (void*) &display_size);

    display_fb.u2_index = 0;
    display_fb.r_fb_addr.u4_fb_addr_plane0 = (kal_uint32)cfg->image_buffer_p;
    display_fb.r_fb_addr.u4_fb_addr_plane1 = 0;
    display_fb.r_fb_addr.u4_fb_addr_plane2 = 0; 
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DST_FB_ADDR, (void*) &display_fb);

    ipp.b_brightness = KAL_TRUE;
    ipp.b_contrast = KAL_TRUE;
    ipp.u1_brightness = cfg->brightness;
    ipp.u1_contrast = cfg->contrast;
    rh->pfnSetParameter(VIDEO_CONFIG_RENDERER_POST_PROCESS, (void*) &ipp);

    fps = self->vid_stream.info.video.fps;
    frame_period = (fps == 0) ? 0xFFFFFFFF: (100000 / fps);
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_SOURCE_FRAME_PERIOD, (void*) &frame_period);
    
    disable_dc = (cfg->force_lcd_hw_trigger) ? KAL_TRUE : KAL_FALSE;
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DISABLE_DC_MODE, (void*) &disable_dc);
    
#ifdef __CONTOUR_IMPROVEMENT_SUPPORT__
    /* Set prediction time */
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DECODE_TIME, (void*)&self->predict_time);
#endif /* __CONTOUR_IMPROVEMENT_SUPPORT__ */

    

    switch (cfg->image_data_format)
    {
        case IMG_COLOR_FMT_RGB565: 
            color_fmt = VIDEO_RENDERER_COLOR_RGB565;
            break;
        case IMG_COLOR_FMT_PACKET_YUYV422:    
            color_fmt = VIDEO_RENDERER_COLOR_PACKED_UYVY422;
            break;      
        default:
            color_fmt = VIDEO_RENDERER_COLOR_RGB565;          
    }
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DST_COLOR_FORMAT, (void*) &color_fmt);


    /* Seek mode */
    if (param_type == MEDIA_PLAYER_RENDER_GET_FRAME)
    {
        rot.u2_cw_rotate_angle = 0;
    }
    /* Play mode */
    else
    {
        switch (cfg->idp_rotate)
        {
            case 0:
                rot.u2_cw_rotate_angle = 0;
                break;
            case 90:
                rot.u2_cw_rotate_angle = 90;
                break;
            case 180:
                rot.u2_cw_rotate_angle = 180;
                break;
            case 270:
                rot.u2_cw_rotate_angle = 270;
                break;
            default:
                ASSERT(0);
        }
    }

    rot.b_flip = KAL_FALSE;
    rh->pfnSetParameter(VIDEO_CONFIG_RENDERER_ROTATE_FLIP, (void*) &rot);

    switch (cfg->frame_mode)
    {
        case MED_VID_FRAME_STRETCH:
            mode = VIDEO_RENDERER_RENDER_MODE_STRETCH_TO_WINDOW;
            break;
        case MED_VID_FRAME_FIT_OUTSIDE:
            mode = VIDEO_RENDERER_RENDER_MODE_TOUCH_WINDOW_FROM_OUTSIDE;
            break;
        case MED_VID_FRAME_FIT_INSIDE:
            mode = VIDEO_RENDERER_RENDER_MODE_TOUCH_WINDOW_FROM_INSIDE;
            break;
        default:
            mode = VIDEO_RENDERER_RENDER_MODE_STRETCH_TO_WINDOW;
            ASSERT(0);
    }
    rh->pfnSetParameter(VIDEO_PARAM_RENDERER_SEMI_AUTO_RENDER_MODE, (void*) &mode);

    color_fmt = VIDEO_RENDERER_COLOR_YUV420;
    rh->pfnSetParameter(VIDEO_CONFIG_RENDERER_SRC_COLOR_FORMAT, (void*) &color_fmt);

    if (param_type == MEDIA_PLAYER_RENDER_PLAY_VISIBLE)
    {
        trigger_lcd = KAL_TRUE;
        rh->pfnSetParameter(VIDEO_PARAM_RENDERER_TRIGGER_DISPLAY, (void*) &trigger_lcd);

        surface.dspl_element_handle = cfg->layer_element;
        surface.dspl_ctx_handle = cfg->blt_ctx;
        surface.dspl_dev_handle = cfg->blt_dev;

        rh->pfnSetParameter(VIDEO_PARAM_RENDERER_DISPLAY_SURFACE, (void*) &surface);
    }
    else
    {
        trigger_lcd = KAL_FALSE;
        rh->pfnSetParameter(VIDEO_PARAM_RENDERER_TRIGGER_DISPLAY, (void*) &trigger_lcd);
    }
}


/*****************************************************************************
 * FUNCTION
 *  media_player_update_frame_to_memory
 * DESCRIPTION
 *  The function is to stop a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_update_frame_to_memory(media_player_t* mp, media_player_frame_enum frame)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    VIDEO_ERROR_TYPE_T error;
    kal_uint32 dummy_addr;
    kal_bool keep = KAL_FALSE;
    kal_bool visual_paused;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    visual_paused = MPLY_IS_FLAG_SET(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED)? KAL_TRUE : KAL_FALSE;
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_UPDATE_FRAME_TO_MEMORY, visual_paused, self->state);

    /* MMI released the layer, so don't update frame to MMI layer */
    if (visual_paused)
    {
        return MED_S_OK;
    }
    
    switch (frame)
    {
        case MEDIA_PLAYER_PREV_FRAME: 
            keep = KAL_TRUE;
            break;
        case MEDIA_PLAYER_CURR_FRAME:
            keep = KAL_FALSE;
            break;        
        default:
            break;
    }

    media_player_set_render_param(mp, MEDIA_PLAYER_RENDER_GET_FRAME);
    
    error = self->render_handle->pfnSetParameter(VIDEO_PARAM_RENDERER_KEEP_CURR_PTR,(void*) &keep);

    /* The second parameter is useless. Render will copy frame to lcd_buffer1 directly */
    error = self->render_handle->pfnGetParameter(VIDEO_PARAM_RENDERER_RENDER_DISPLAY_BUFFER, (void*) &dummy_addr);
    if (error != VIDEO_ERROR_NONE)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, error, __LINE__);
        return MED_E_OVER_LIMIT;
    }
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_get_accurate_play_speed
 * DESCRIPTION
 *  Get the accurate play speed according to audio format.
 * PARAMETERS
 *  org_speed       [IN]        original play speed
 * RETURNS
 *  Accurate play speed
 *****************************************************************************/
kal_uint16 media_player_get_accurate_play_speed(media_player_t* mp, kal_uint16 org_speed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_int16 speed;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    speed = org_speed;    

    if (self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX) 
    {
        switch (self->aud_format)
        {
        case MEDIA_FORMAT_AAC:
            if (org_speed >= 125 && org_speed <= 130)
            {
                speed = 128;
            }
            break;
        case MEDIA_FORMAT_AMR:
            if (org_speed >= 125 && org_speed <= 130)
            {
                speed = 125;
            }
            break;
        }    
    }
    
    if (org_speed >= 75 && org_speed <= 80)
    {
        speed =  80;
    }
    else if (org_speed >= 150 && org_speed <= 160)
    {
        speed = 160;
    }
 
    return speed;
}

/*****************************************************************************
 * FUNCTION
 *  media_player_audio_dummy_callback
 * DESCRIPTION
 *  This function is audio dummy event callback function
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_audio_dummy_callback(MHdl *handle, Media_Event event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
}

/*****************************************************************************
 * FUNCTION
 *  media_player_audio_event_callback
 * DESCRIPTION
 *  This function is audio event callback function
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_audio_event_callback(MHdl *handle, Media_Event event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_vid_media_player_aud_event_ind_struct *ind_p = NULL;
    media_player_cntx_struct *self;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    handle->GetUserData(handle, (void **)&self);
    
    ind_p = (media_vid_media_player_aud_event_ind_struct*)
        get_ctrl_buffer(sizeof(media_vid_media_player_aud_event_ind_struct));

    ind_p->user_data = self;
    ind_p->event = event;
    ind_p->session_id = self->aud_session_id;

    mpl_send_async_context_ilm(MOD_MED, media_player_audio_event_hdlr, (void*)ind_p);
}


/*****************************************************************************
 * FUNCTION
 *  media_player_video_event_callback
 * DESCRIPTION
 *  This function is video event callback function
 * PARAMETERS
 *  event       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_video_event_callback(media_player_comp_evt_enum event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_vid_media_player_vid_event_ind_struct *ind_p = NULL;
    media_player_cntx_struct *self = media_player_cntx_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    ind_p = (media_vid_media_player_vid_event_ind_struct*)
        get_ctrl_buffer(sizeof(media_vid_media_player_vid_event_ind_struct));

    ind_p->event = event; 
    ind_p->session_id = self->vid_session_id;

    mpl_send_async_context_ilm(MOD_MED, media_player_video_event_hdlr, (void*)ind_p);
    
}

/*****************************************************************************
 * FUNCTION
 *  media_player_video_buffer_req_callback
 * DESCRIPTION
 *  This function is video buffer req callbck
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_video_buffer_req_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_vid_mply_vid_buf_req_struct *ind_p = NULL;
    media_player_cntx_struct *self = media_player_cntx_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    /* Send a message to MED */
    ind_p = (media_vid_mply_vid_buf_req_struct*)
        get_ctrl_buffer(sizeof(media_vid_mply_vid_buf_req_struct));

    ind_p->session_id = self->vid_session_id;

    mpl_send_async_context_ilm(MOD_MED, media_player_video_buffer_req_hdlr, (void*)ind_p);
}

/*****************************************************************************
 * FUNCTION
 *  media_player_decoder_fill_this_buffer
 * DESCRIPTION
 *  This function is video process buffer callback
 * PARAMETERS
 *  event       [IN]       media event 
 * RETURNS
 *  void
 *****************************************************************************/
static VIDEO_ERROR_TYPE_T media_player_decoder_fill_this_buffer(
                                VIDEO_BUFFERHEADER_TYPE_T *buf_header)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct *self = media_player_cntx_p;
    media_data_t *head;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    kal_take_mutex(media_player_mutex);
    
    if (self == NULL)
    {
        kal_give_mutex(media_player_mutex);
        return VIDEO_ERROR_NONE;
    }

    /* There is no buffer to release */
    if (buf_header->eFlags == VIDEO_BUFFERFLAG_EOF)
    {
        kal_give_mutex(media_player_mutex);
        return VIDEO_ERROR_NONE;        
    }    
    
    MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_FULL);

    if (self->video_written_queue == NULL)
    {
        kal_give_mutex(media_player_mutex);
        return VIDEO_ERROR_NONE;
    }
    /* Release buffer */    
    head = self->video_written_queue->next;

    if (buf_header->pu1Buffer != head->data)
    {        
        MPLY_ASSERT(0);
        kal_give_mutex(media_player_mutex);
        return VIDEO_ERROR_NONE;
    }
    
    kal_trace(TRACE_GROUP_1, VID_TRC_MEDIA_PLAYER_PROC_MAX_TIME, 
        (kal_uint32) head->display_time, (kal_uint32) self->max_empty_time);

    media_player_remove_from_queue(&self->video_written_queue, head);
    head->release(head);
    self->vid_queue_num --;
    
    kal_give_mutex(media_player_mutex);
    return VIDEO_ERROR_NONE;
}

/***************************************************************************** 
 * Exported Function
 *****************************************************************************/
 
 /*****************************************************************************
 * FUNCTION
 *  media_player_open
 * DESCRIPTION
 *  The function is to open a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_open(media_player_t* mp, mpl_scenario_enum media_scenario, med_mode_enum media_mode, kal_bool fgSeekable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    if (self->state != MPLY_STATE_CLOSED)
    {
        return MED_E_WRONG_STATE;

    }   

    self->audio_queue = NULL;
    self->video_queue = NULL;
    self->video_written_queue = NULL;  
    self->aud_queue_num = self->vid_queue_num = 0;
    self->aud_frame_num = self->aud_frame_size = 0;    
    self->vid_stream_index = MEDIA_PLAYER_INVALID_INDEX;
    self->aud_stream_index = MEDIA_PLAYER_INVALID_INDEX;
    self->vol_level = MEDIA_PLAYER_VOL_LEVEL_NOT_USED;    
    self->elapse_ticks = self->sleep_ticks = 0;
    self->stop_time = 0;
    MPLY_UNSET_FLAG(MPLY_FLAG_SUPPORT_TIME_STRETCH);
    MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_FULL);
    
    self->media_scenario= media_scenario;
    self->media_mode = media_mode;
    self->fgSeekable = fgSeekable;
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_OPENED);
    self->state = MPLY_STATE_OPENED;
    return MED_S_OK;       
}


/*****************************************************************************
 * FUNCTION
 *  media_player_add_video_stream
 * DESCRIPTION
 *  The function is to add a video stream to the player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_add_video_stream(media_player_t* mp, media_stream_t* stream, kal_uint32* stream_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint16 width, height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_ADD_VIDEO_STREAM, self->state);

    if (self->state != MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }
    
    *stream_index = self->vid_stream_index = stream->index;
    self->vid_stream = *stream;


    /* Assign media player context */
    media_player_cntx_p = self;
        
    width = self->vid_stream.info.video.width;
    height = self->vid_stream.info.video.height;
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_RESOLUTION, width, height);
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_add_audio_stream
 * DESCRIPTION
 *  The function is to add a audio stream to the player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_add_audio_stream(media_player_t* mp, media_stream_t* stream, kal_uint32* stream_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_codec_type_t codec_type;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_ADD_AUDIO_STREAM, self->state);
    if (self->state != MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }
    
    *stream_index = self->aud_stream_index = stream->index;
    self->aud_stream = *stream;


    codec_type = self->aud_stream.dec_config.codec;
    self->aud_format = (Media_Format)mpl_get_media_format_from_codec_type((kal_uint16)codec_type);
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_AUD_FORMAT, self->aud_format);

    self->aud_ready_frame_num =  Media_GetPlaybackPrebufferFrameNum(self->aud_format);
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, self->aud_ready_frame_num, __LINE__);
    if (self->aud_format == MEDIA_FORMAT_AAC ||
        self->aud_format == MEDIA_FORMAT_AAC_PLUS)
    {
        media_player_gen_adts_header(mp);
    }    
  
    return MED_S_OK;
}
 

/*****************************************************************************
 * FUNCTION
 *  media_player_prepare
 * DESCRIPTION
 *  The function is to prepare a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_prepare(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;
    kal_uint32 aud_dur = 0, vid_dur = 0;
    media_audio_info_t *audio_info_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_PREPARE, self->state, self->vid_stream_index, self->aud_stream_index);
    if (self->state != MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }

    /* No track */
    if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX &&
        self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX)
    {
        return MED_E_FAIL;
    }

    /* Initialize component */
    if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {      
        ret = media_player_init_video_comp(mp);
        if (ret < 0)
        {
            return ret;
        }
    }    

    /* Initialize AV sync parameter */
    if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX)
    {
        Media_A2V_SetFreq(MEDIA_PLAYER_AMR_SAMPLING_RATE);
    }
    else
    {
        audio_info_p = &self->aud_stream.info.audio;
        Media_A2V_SetFreq(audio_info_p->sample_rate);
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_SAMPLE_FREQ, 
            audio_info_p->sample_rate, audio_info_p->channels);

        if (self->media_mode != MED_MODE_STREAM)
        {
            self->aud_format_supported = Media_IsFormatSupported(
                self->aud_format, audio_info_p->channels, audio_info_p->sample_rate);
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, self->aud_format_supported, __LINE__);
        }
    }
    
    /*Assign total duration */
    self->total_duration = 0;
    if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {        
        vid_dur = self->vid_stream.duration;
        if (vid_dur > self->total_duration)
        {
            self->total_duration = vid_dur;
        }
    }
    if (self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {        
        aud_dur = self->aud_stream.duration;
        if (aud_dur > self->total_duration)
        {
            self->total_duration = aud_dur;
        }
    }
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_DURATION, aud_dur, vid_dur, self->total_duration); 
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PREPARED);
    self->state = MPLY_STATE_PREPARED;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_set_video_config
 * DESCRIPTION
 *  The function is to set video configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_set_video_config(
                        media_player_t* mp, 
                        kal_uint32 stream_index, 
                        media_player_video_config_t* video_config)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }

    
    self->video_config = *video_config;
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_get_video_config
 * DESCRIPTION
 *  The function is to get video configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_get_video_config(media_player_t* mp, kal_uint32 stream_index, media_player_video_config_t* video_config)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }
    *video_config = self->video_config;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_set_audio_config
 * DESCRIPTION
 *  The function is to set audio configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_set_audio_config(
                        media_player_t* mp, 
                        kal_uint32 stream_index, 
                        media_player_audio_config_t* audio_config)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }
        
    self->audio_config = *audio_config;

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_get_audio_config
 * DESCRIPTION
 *  The function is to get audio configuration
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_get_audio_config(media_player_t* mp, kal_uint32 stream_index, media_player_audio_config_t* audio_config)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }
    *audio_config = self->audio_config;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_set_param
 * DESCRIPTION
 *  The function is to set parameter which could be dynamically changed during
 *  playing.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_set_param(media_player_t* mp, media_player_param_t *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 event_group;
    va2_video_renderer_post_process_config_t ipp;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_SET_PARAM, param->type, self->state);
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }

    if (param->type == MEDIA_PLAYER_PARAM_TYPE_VOLUME)
    {
        if (self->mhdl_handle != NULL)
        {
            self->mhdl_handle->SetLevel(self->mhdl_handle, param->val.volume);
        }
        self->vol_level = param->val.volume;
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_STOP_TIME)
    {
        self->stop_time = param->val.time;
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_AUD_TIME_DIFF)
    {
        self->aud_time_diff = param->val.aud_time_diff;
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, self->aud_time_diff, __LINE__);
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_SLEEP_TIME)
    {
        if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
        {
            return MED_S_OK;
        }
        
        /* Store parameter to set again when component enters idle state */
        self->elapse_ticks = param->val.sleep_time.elapse_ticks;
        self->sleep_ticks = param->val.sleep_time.sleep_ticks;
        
        self->decoder_handle->pfnSetParameter(
            VIDEO_PARAM_ELAPSE_TICKS_BEFORE_SLEEP, &self->elapse_ticks);
        self->decoder_handle->pfnSetParameter(
            VIDEO_PARAM_SLEEP_TICKS, &self->sleep_ticks);        
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_UPDATE_VID_DURATION)
    {
        /* Update vid duration for corrupted video stream as the last video frame's timestamp */
        if (self->video_queue != NULL)
        {
            self->vid_stream.duration = self->video_queue->display_time;
        }
        else if (self->max_empty_time != -1)
        {
            self->vid_stream.duration = self->max_empty_time;
        }
        else
        {
            self->vid_stream.duration = 0;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_STOP_DECODER)
    {
        /* Change decoder state */        
        self->decoder_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_STOP);
        /* Wait until the state transition is done */
        kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_DECODER_COMPLETE | MEDIA_PLAYER_EG_DECODER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
        if((event_group & MEDIA_PLAYER_EG_DECODER_ERROR) !=0)
        {
            return MED_E_FAIL;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_RUN_DECODER)
    {
        /* Change decoder state */        
        self->decoder_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_RUN);
        /* Wait until the state transition is done */
        kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_DECODER_COMPLETE | MEDIA_PLAYER_EG_DECODER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
        if((event_group & MEDIA_PLAYER_EG_DECODER_ERROR) !=0)
        {
            return MED_E_FAIL;
        }
        self->decoder_handle->pfnSetParameter(VIDEO_PARAM_BUFFERING_DONE, NULL);                
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_BRIGHTNESS)
    {    
        if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
        {
            return MED_S_OK;
        }
        ipp.b_brightness = KAL_TRUE;
        ipp.b_contrast = KAL_FALSE;
        ipp.u1_brightness = param->val.brightness;        
        self->render_handle->pfnSetParameter(VIDEO_CONFIG_RENDERER_POST_PROCESS, (void*) &ipp);

        /* Save */
        self->video_config.brightness = param->val.brightness;
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_CONTRAST)
    {
        if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
        {
            return MED_S_OK;
        }
        ipp.b_brightness = KAL_FALSE;
        ipp.b_contrast = KAL_TRUE;
        ipp.u1_contrast = param->val.contrast;
        self->render_handle->pfnSetParameter(VIDEO_CONFIG_RENDERER_POST_PROCESS, (void*) &ipp);

        /* Save */
        self->video_config.contrast = param->val.contrast;
    }
    
    return MED_S_OK;
}



/*****************************************************************************
 * FUNCTION
 *  media_player_get_buffer_status
 * DESCRIPTION
 *  The function is to get buffer status
 *  playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_get_buffer_status(media_player_t* mp, kal_uint32 stream_index, media_stream_buffer_status_t* buffer_status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 data_count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED || self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }

    /* Only support audio buffer status */
    if (stream_index == self->vid_stream_index)
    {
        return MED_E_FAIL;
    }

    if (self->mhdl_handle != NULL)
    {
        /* Buffer size (unit: byte) in audio ring buffer */
        data_count = self->mhdl_handle->GetDataCount(self->mhdl_handle);
    }
    
    buffer_status->used_bytes = data_count;
    buffer_status->free_bytes = (MPLY_AUD_RING_BUFFER_SIZE <<1) - data_count;

    /* Not support */
    buffer_status->duration = 0;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_get_param
 * DESCRIPTION
 *  The function is to get parameter which changes dynamically during
 *  playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_get_param(media_player_t* mp, media_player_param_t *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_video_info_t *info_ptr;
    VIDEO_ERROR_TYPE_T error;
    VIDEO_QUERY_FRAME_SIZE_TYPE_T frame_size = {0};
    media_error_t ret;
    media_time_t max_time;
    media_player_frame_enum frame_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED)
    {
        return MED_E_WRONG_STATE;
    }

    if (param->type == MEDIA_PLAYER_PARAM_TYPE_PLAY_TIME)
    {
        media_player_update_play_time(mp);
        param->val.time = self->current_time;
        
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CUR_TIME, (kal_uint32)param->val.time);
    }    
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_PLAY_SPEED)
    {
        param->val.play_speed = self->play_speed;
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_MAX_VID_FRAME_TIME)
    {
        if (self->video_queue)
        {    
            //param->val.time = self->video_queue->decode_time;
            param->val.time = self->video_queue->display_time;
        }
        else
        {
            param->val.time = (self->max_empty_time == -1) ? 0 : self->max_empty_time;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_AUD_BUFFER_SIZE)
    { 
        param->val.aud_buffer.size = self->aud_frame_size;
        /* audio ring buffer size */
        param->val.aud_buffer.ring_size = (MPLY_AUD_BUFFER_START_TO_PLAY << 1);
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_AUD_BUFFER_NUM)
    { 
        param->val.aud_buffer.size = self->aud_queue_num;
        param->val.aud_buffer.ring_size = self->aud_ready_frame_num;
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_AUD_BUFFER_TIME)
    {
        media_player_update_play_time(mp);
        
        if (self->audio_queue)
        {    
            max_time = self->audio_queue->decode_time;
        }
        else
        {
            max_time = self->audio_last_time;
        }

        if (max_time > self->current_time)
        {
            param->val.time = max_time - self->current_time;
        }
        else
        {
            param->val.time = 0;
        }        
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_VIDEO_RESOLUTION)
    { 
        info_ptr = &(self->vid_stream.info.video);

        /* Update video resolution from decoder */
        if (info_ptr->width == 0 || info_ptr->height == 0)
        {
            error = self->decoder_handle->pfnGetParameter(VIDEO_PARAM_QUERY_RESOLUTION, &frame_size);
            if (error == VIDEO_ERROR_NONE)
            {
                info_ptr->width = frame_size.u4Width;
                info_ptr->height = frame_size.u4Height;
            }

        }        
        param->val.video_size.width = info_ptr->width;
        param->val.video_size.height = info_ptr->height;
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_RESOLUTION, info_ptr->width, info_ptr->height);
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_DUMMY_AUD_PLAYING)
    {
        if (self->mhdl_handle != NULL && MPLY_IS_FLAG_SET(MPLY_FLAG_IS_DUMMY_AUDIO))
        {
            param->val.playing = KAL_TRUE;
        }
        else
        {
            param->val.playing = KAL_FALSE;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_AUD_PLAYING)
    {
        if (self->state == MPLY_STATE_PREPARED ||
            self->state == MPLY_STATE_SEEKING ||
            self->state == MPLY_STATE_SEEK_DONE)
        {
            param->val.playing = KAL_FALSE;
        }
        else if (self->audio_config.play_audio == KAL_FALSE)
        {
            param->val.playing = KAL_FALSE;
        }
        else
        {
            param->val.playing = KAL_TRUE;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_NEED_AUD_FRAME)
    {
        if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
            !self->audio_config.play_audio ||
            !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
        {   
            param->val.need_aud_frame = KAL_FALSE;
        }
        else
        {
            param->val.need_aud_frame = KAL_TRUE;
        }
    }
    else if (param->type == MEDIA_PLAYER_PARAM_TYPE_FRAME)
    {
        if (MPLY_IS_FLAG_SET(MPLY_FLAG_VID_USE_CUR_FRAME))
        {
            frame_type = MEDIA_PLAYER_CURR_FRAME;
        }
        else
        {
            frame_type = MEDIA_PLAYER_PREV_FRAME;
        }
        ret = media_player_update_frame_to_memory(mp, frame_type);
        if (ret < 0)
        {
            return ret;
        }
    }
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_seek
 * DESCRIPTION
 *  The function is to seek a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_seek(media_player_t* mp, media_player_start_params_t* params)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint64 clock_time;
    kal_bool bypass;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_SEEK, (kal_uint32)params->audio_start_time, self->state);
  
    /* Pure-Audio */
    if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
    {           
        self->current_time = params->audio_start_time;
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CUR_TIME, (kal_uint32)self->current_time);

        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_SEEK_DONE);
        self->state = MPLY_STATE_SEEK_DONE;
        return MED_S_OK;
    }   
    
    /* Save parameter */
    self->get_frame = params->get_frame;

    /* Initilize paramter */
    MPLY_UNSET_FLAG(MPLY_FLAG_SKIP_NON_I_FRAME);
    
    /* Flush buffer */ 
    if (params->flush_buffer)
    {
        MPLY_UNSET_FLAG(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED);
    
        media_player_enter_comp_state(mp, VIDEO_STATE_IDLE);
        self->max_empty_time = -1;    

        media_player_reset_queue(mp, MPLY_QUEUE_VIDEO_WRITTEN);
        media_player_reset_queue(mp, MPLY_QUEUE_VIDEO);    
        self->vid_queue_num = 0;
        MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_FULL);

        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_NONE);
        self->vid_stream_status = MPLY_VID_STREAM_NONE;

        self->vid_life_cycle_id ++;      
        media_player_init_comp_param(mp);
    }
    else
    {
        /* Component does not callback again. So do it by myself */
        if (self->vid_stream_status == MPLY_VID_STREAM_COMPLETE)
        {
            self->comp_event |= MPLY_EVT_DECODER_COMPLETE;
        }
        else if (self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
        {
            self->comp_event |= MPLY_EVT_SCHEDULER_COMPLETE;

            self->current_time = params->audio_start_time;
            MPLY_UNSET_FLAG(MPLY_FLAG_VID_USE_CUR_FRAME);

            return MED_S_OK;
        }
    }
    
    media_player_reset_queue(mp, MPLY_QUEUE_AUDIO);
    self->aud_written_size = 0;
    self->adts_written_size = 0;
    self->silence_written_size = 0;
    self->aud_queue_num = 0;
    self->aud_frame_size = 0;
    self->aud_frame_num = 0;
    
    self->aud_stream_status = MPLY_AUD_STREAM_NONE;        

    /* Set audio start time to clock */
    clock_time = MEDIA_PLAYER_TIME_TO_COMPTIME(params->audio_start_time);
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_AV_TIMEBASE, &clock_time);
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_START_TIME, &clock_time);
  
    self->current_time = params->audio_start_time;
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CUR_TIME, (kal_uint32)self->current_time);

    bypass = KAL_TRUE;
    self->render_handle->pfnSetParameter(VIDEO_PARAM_RENDERER_BYPASS, (void*) &bypass);
    
    /* Change component state to RUN */
    media_player_enter_comp_state(mp, VIDEO_STATE_RUN);     

    MPLY_UNSET_FLAG(MPLY_FLAG_SEEK_TIME_REACHED);

    /* Disable sleep before seek */
    visual_disable_sleep();   

    if (!params->flush_buffer)
    {
        media_player_process_video_queue(mp);
    }
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_SEEKING);
    self->state = MPLY_STATE_SEEKING; 
    
    return MED_S_ASYNC;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_play
 * DESCRIPTION
 *  The function is to play a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_play(media_player_t* mp, media_player_start_params_t* params)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint64 clock_time;
    media_error_t ret; 
    kal_bool audio_enable;  
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_PLAY, 
        (kal_uint32)params->audio_start_time, 
        self->state, 
        self->vid_stream_status, 
        params->play_speed, 
        MPLY_IS_FLAG_SET(MPLY_FLAG_VID_BUFF_FULL));

    /* Initilize paramter */
    MPLY_UNSET_FLAG(MPLY_FLAG_SKIP_NON_I_FRAME);
    self->stop_time = params->stop_time;
    
    if (params->live_stream)
    {
        MPLY_SET_FLAG(MPLY_FLAG_LIVE_STREAM);
    }
    else
    {
        MPLY_UNSET_FLAG(MPLY_FLAG_LIVE_STREAM);
    }
    self->play_speed = media_player_get_accurate_play_speed(mp, params->play_speed);
#ifdef __VE_BES_TS_SUPPORT__      
    if (self->play_speed <= 160 && self->play_speed >= 50 && AudioPP_TS_IsSupport(self->aud_format, NULL))
    {
        MPLY_SET_FLAG(MPLY_FLAG_SUPPORT_TIME_STRETCH);
    }
    else
    {
        MPLY_UNSET_FLAG(MPLY_FLAG_SUPPORT_TIME_STRETCH);
    }    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH), __LINE__);
#endif /* __VE_BES_TS_SUPPORT__ */    

#if defined(__BTMTK__) && defined(__VE_BT_A2DP_SUPPORT__) 
    if (params->close_bt_codec)
    {
        aud_bt_a2dp_close_codec_for_open();
    }
#endif /* defined(__BTMTK__) && defined(__VE_BT_A2DP_SUPPORT__) */

    /* Force not to play audio */
    if (self->media_mode != MED_MODE_STREAM)
    {
        if (!self->aud_format_supported)
        {
            self->audio_config.play_audio = KAL_FALSE;
        }
    }

    /* Pure-Audio */
    if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX)
    {    
        if (!(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
        {
            return MED_E_FAIL;
        }
        if (!self->audio_config.play_audio)
        {
            return MED_E_FAIL;
        }
       
        aud_get_active_device_path_by_mode(self->audio_config.audio_path, aud_melody_set_output_device);
        
        ret = media_player_init_audio(mp);

        /* Disable sleep when playing */
        visual_disable_sleep();
        
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_BUFFERING);
        self->state = MPLY_STATE_BUFFERING; 

        /* process audio queue */        
        ret = media_player_process_audio_queue(mp);
        if (ret < 0)
        {
            /* Reset parameter */
            media_player_stop(mp);
        }
        return ret;
    }   
  
    
    /* Set audio start time to clock */
    clock_time = MEDIA_PLAYER_TIME_TO_COMPTIME(params->audio_start_time);
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_AV_TIMEBASE, &clock_time);
    if (self->fgSeekable)
    {
        self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_START_TIME, &clock_time);
    }

    if (params->stop_time != 0)
    {
        clock_time = MEDIA_PLAYER_TIME_TO_COMPTIME(params->stop_time);
        self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_STOP_TIME, &clock_time);
    }

    /* Enable audio or not */
    if (self->audio_config.play_audio)
    {
        audio_enable = KAL_TRUE;
        self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_AUDIO_ON, &audio_enable);
    }
    else
    {
        audio_enable = KAL_FALSE;
        self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_AUDIO_ON, &audio_enable);
    }

    if (self->video_config.display_device == MED_DISPLAY_NONE)
    {
        media_player_set_render_param(mp, MEDIA_PLAYER_RENDER_PLAY_INVISIBLE);
    }
    else
    {        
        media_player_set_render_param(mp, MEDIA_PLAYER_RENDER_PLAY_VISIBLE);
    }
    
    /* Video */
    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_PLAY_SPEED, &self->play_speed);

    media_player_enter_comp_state(mp, VIDEO_STATE_RUN);
    
    /* Audio */
    if (self->audio_config.play_audio)
    {        
        aud_get_active_device_path_by_mode(self->audio_config.audio_path, aud_melody_set_output_device);

        if (self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX &&
            (self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
        {
            ret = media_player_init_audio(mp);
        }
    }

    /* Disable sleep when playing */
    visual_disable_sleep();
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_BUFFERING);
    self->state = MPLY_STATE_BUFFERING;
    
    if (self->vid_stream_status == MPLY_VID_STREAM_COMPLETE)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_BUFFERED);
        self->state = MPLY_STATE_VID_BUFFERED;

        if (!self->audio_config.play_audio)
        {
            media_player_start_avsync(&self->itf);
            
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PLAYING);
            self->state = MPLY_STATE_PLAYING;
            return MED_S_OK;
        }
        else if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                 !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)) ||
                 (self->audio_queue == NULL && self->aud_stream_status == MPLY_AUD_STREAM_END))
        {   
            ret = media_player_play_dummy_audio(&self->itf);
            if (ret < 0)
            {
                /* Reset parameter */
                media_player_stop(mp);
                return MED_E_FAIL;
            }
        }
    }
    else if (self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
    {
        if (self->aud_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
            !self->audio_config.play_audio ||
            !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)) ||
            (self->audio_queue == NULL && self->aud_stream_status == MPLY_AUD_STREAM_END))
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_VID_PLAY_FINISH);
            self->state = MPLY_STATE_VID_PLAY_FINISH;
            return MED_S_TERMINATED;
        }
    }
    else
    {
        media_player_process_video_queue(mp);
    }

    if (self->audio_config.play_audio &&
        self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX &&
        (self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
    {
        ret = media_player_process_audio_queue(mp);
        if (ret < 0)
        {
            /* Reset parameter */
            media_player_stop(mp);
            return MED_E_FAIL;
        }  
    }
    
    return MED_S_OK;
}

/*****************************************************************************
 * FUNCTION
 *  media_player_start
 * DESCRIPTION
 *  The function is to start a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_start(media_player_t* mp, media_player_start_params_t* params)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret = MED_S_OK; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (self->state != MPLY_STATE_PREPARED &&
        self->state != MPLY_STATE_SEEK_DONE)
    {
        return MED_E_WRONG_STATE;
    }

    /* change component state to STOP first */
    if (self->state == MPLY_STATE_SEEK_DONE)
    {
        if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
        {
            /* Stop video component */
            media_player_enter_comp_state(mp, VIDEO_STATE_STOP);

            /* Stop timer */
            mpl_stop_timer(MPL_PLAYER_RECOVER_TIMER);        
            self->vid_session_id ++;        
        }       
    }    

    /* Save audio start time */
    self->audio_last_time = self->audio_start_time = params->audio_start_time;

    /* Local mp4: start play with fixed audio frame num */
    if (!params->live_stream)
    {
        self->aud_ready_frame_num = MPLY_AUD_FRAME_NUM_START_TO_PLAY;        
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VAL, self->aud_ready_frame_num, __LINE__);
    }
    
    if (params->start_mode == MEDIA_PLAYER_SEEK_MODE)
    {
        ret = media_player_seek(mp, params);         
    }
    else if (params->start_mode == MEDIA_PLAYER_PLAY_MODE)
    {        
        ret = media_player_play(mp, params);
    }
  
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_stop
 * DESCRIPTION
 *  The function is to stop
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_stop(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_bool clock_enable = KAL_FALSE;
    kal_uint64 play_time;
    kal_bool update_clock_time = KAL_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STOP, self->state);
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED)
    {
        return MED_E_WRONG_STATE;
    }

    
    if (self->state == MPLY_STATE_PLAYING ||
        self->state == MPLY_STATE_AUD_PLAY_FINISH ||
        self->state == MPLY_STATE_VID_PLAY_FINISH)
    {
        if (self->mhdl_handle)
        {
            self->mhdl_handle->Stop(self->mhdl_handle);            
            self->aud_session_id ++;

            /* (1) If dummy audio, use clock time
               (2) If audio plays finish and there is visual track, use clock time */
            if (!MPLY_IS_FLAG_SET(MPLY_FLAG_IS_DUMMY_AUDIO) &&
                !(self->state == MPLY_STATE_AUD_PLAY_FINISH &&
                  self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX))
            {
                self->current_time = self->mhdl_handle->GetCurrentTime(self->mhdl_handle);
                kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CUR_TIME, (kal_uint32)self->current_time);
                update_clock_time = KAL_FALSE;
            }

            /* Close aud_stretch before close audio_handle */
        #ifdef __VE_BES_TS_SUPPORT__
            aud_stretch_close();
        #endif
            AudioPP_EnableBesSound();
        
            self->mhdl_handle->Close(self->mhdl_handle);
            self->mhdl_handle = NULL;

            /* free audio ring buffer */
            if (self->audio_buf != NULL)
            {
                media_player_aud_free_ext_mem(self->client, (void**)&self->audio_buf);
                self->audio_buf = NULL;
            }            
        }
    }
    else if (self->state == MPLY_STATE_BUFFERING ||
             self->state == MPLY_STATE_VID_BUFFERED ||
             self->state == MPLY_STATE_AUD_BUFFERED)
    {
        if (self->mhdl_handle)
        {
            /* Close aud_stretch before close audio_handle */
        #ifdef __VE_BES_TS_SUPPORT__
            aud_stretch_close();
        #endif
            AudioPP_EnableBesSound();
        
            self->mhdl_handle->Close(self->mhdl_handle);
            self->mhdl_handle = NULL;

            /* free audio ring buffer */
            if (self->audio_buf != NULL)
            {
                media_player_aud_free_ext_mem(self->client, (void**)&self->audio_buf);
                self->audio_buf = NULL;
            }           
        }
    }

    if (self->aud_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {    
        media_player_reset_queue(mp, MPLY_QUEUE_AUDIO);
        self->aud_written_size = 0;
        self->adts_written_size = 0;
        self->silence_written_size = 0;
        self->aud_queue_num = 0;
        self->aud_frame_size = 0;
        self->aud_frame_num = 0;
        
        self->aud_stream_status = MPLY_AUD_STREAM_NONE;
    }

    if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
    {
        /* Need to set clock enable as false before change clock state to STOP */
        self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_CLOCK_ENABLE, &clock_enable);

        /* Stop video component */
        media_player_enter_comp_state(mp, VIDEO_STATE_STOP);

        /* Stop timer */
        mpl_stop_timer(MPL_PLAYER_RECOVER_TIMER);

        MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_REQ_HANDING);
        MPLY_UNSET_FLAG(MPLY_FLAG_RENDER_ERROR_HANDLING);
        MPLY_UNSET_FLAG(MPLY_FLAG_DECODE_UNSUPPORT_RES);
        
        self->vid_session_id ++;

        if (update_clock_time)
        {
            /* Update current time */
            self->scheduler_handle->pfnGetParameter(VIDEO_PARAM_CURR_TIME, &play_time);
            self->current_time = MEDIA_PLAYER_COMPTIME_TO_TIME(play_time);
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CUR_TIME, (kal_uint32)self->current_time);
        }
   
        /* Copy frame to layer */
        if (self->state == MPLY_STATE_SEEK_DONE)        
        {
            MPLY_SET_FLAG(MPLY_FLAG_VID_USE_CUR_FRAME);
        }
        else if (self->state != MPLY_STATE_SEEKING)        
        {
            MPLY_UNSET_FLAG(MPLY_FLAG_VID_USE_CUR_FRAME);
        }

    }

    /* Enable sleep */
    visual_enable_sleep();
    
    self->comp_event = 0;
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PREPARED);
    self->state = MPLY_STATE_PREPARED;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_pause_visual_update
 * DESCRIPTION
 *  The function is to pause visual update
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_pause_visual_update(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 event_group;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_PAUSE_VISUAL_UPDATE, self->state);

    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED ||
        self->state == MPLY_STATE_SEEKING || 
        self->state == MPLY_STATE_SEEK_DONE)
    {
        return MED_E_WRONG_STATE;
    }

    /* Change render state to stop */
    self->render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_STOP);

    MPLY_UNSET_FLAG(MPLY_FLAG_VID_USE_CUR_FRAME);

    
    /* Wait until the state transition is done */  
    kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_RENDER_COMPLETE | MEDIA_PLAYER_EG_RENDER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
    if((event_group & MEDIA_PLAYER_EG_RENDER_ERROR) != 0)
    {
        return MED_E_FAIL;
    }

    MPLY_SET_FLAG(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED);

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_resume_visual_update
 * DESCRIPTION
 *  The function is to stop visual update
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_resume_visual_update(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_uint32 event_group;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_RESUME_VISUAL_UPDATE, self->state);

    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED ||
        self->state == MPLY_STATE_SEEKING || 
        self->state == MPLY_STATE_SEEK_DONE)
    {
        return MED_E_WRONG_STATE;
    }

    if (!MPLY_IS_FLAG_SET(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED))
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, MED_E_WRONG_STATE, __LINE__);
        return MED_E_WRONG_STATE;
    }

    if (self->video_config.display_device == MED_DISPLAY_NONE)
    {
        media_player_set_render_param(mp, MEDIA_PLAYER_RENDER_PLAY_INVISIBLE);
    }
    else
    {        
        media_player_set_render_param(mp, MEDIA_PLAYER_RENDER_PLAY_VISIBLE);
    }
    
    /* Change render state to run */
    self->render_handle->pfnSendCommand(VIDEO_COMMAND_STATESET, VIDEO_STATE_RUN);
    
    /* Wait until the state transition is done */  
    kal_retrieve_eg_events(media_player_comp_eg, (MEDIA_PLAYER_EG_RENDER_COMPLETE | MEDIA_PLAYER_EG_RENDER_ERROR), KAL_OR_CONSUME, &event_group, KAL_SUSPEND);
    if((event_group & MEDIA_PLAYER_EG_RENDER_ERROR) != 0)
    {
        return MED_E_FAIL;
    }

    MPLY_UNSET_FLAG(MPLY_FLAG_VID_VISUAL_UPDATE_PAUSED);
    
    return MED_S_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_stop_visual_update
 * DESCRIPTION
 *  The function is to stop visual update
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_stop_visual_update(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    kal_bool clock_enable = KAL_FALSE;
    media_error_t ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STOP_VISUAL_UPDATE, self->state);

    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED ||
        self->state == MPLY_STATE_SEEKING || 
        self->state == MPLY_STATE_SEEK_DONE)
    {
        return MED_E_WRONG_STATE;
    }

    self->scheduler_handle->pfnSetParameter(VIDEO_PARAM_CLOCK_ENABLE, &clock_enable);

    /* Stop video component */
    media_player_enter_comp_state(mp, VIDEO_STATE_STOP);
    self->vid_session_id ++;
    media_player_release_video_comp(mp);

    /* Stop timer */
    mpl_stop_timer(MPL_PLAYER_RECOVER_TIMER);    

    media_player_reset_queue(mp, MPLY_QUEUE_VIDEO_WRITTEN);
    media_player_reset_queue(mp, MPLY_QUEUE_VIDEO);    
    self->vid_life_cycle_id ++;
    self->vid_queue_num = 0;
    MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_FULL);

    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_NONE);
    self->vid_stream_status = MPLY_VID_STREAM_NONE;

    /* Set as pure-audio */
    self->vid_stream_index = MEDIA_PLAYER_INVALID_INDEX;    
    
    if (self->state == MPLY_STATE_VID_BUFFERED)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_BUFFERING);
        self->state = MPLY_STATE_BUFFERING;
    }
    else if (self->state == MPLY_STATE_AUD_BUFFERED)
    {
        ret = media_player_play_audio(&self->itf);            
        if (ret < 0)
        {
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
            return MED_S_OK;
        }
    }
    else if (self->state == MPLY_STATE_VID_PLAY_FINISH)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_PLAYING);
        self->state = MPLY_STATE_PLAYING;
    }
    else if (self->state == MPLY_STATE_AUD_PLAY_FINISH)
    {
        /* Notify media session to call player_stop() */
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
    }
    return MED_S_OK;    
}


/*****************************************************************************
 * FUNCTION
 *  media_player_deliver_video
 * DESCRIPTION
 *  The function is to deliver video to media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_deliver_video(
                        media_player_t* mp, 
                        media_data_t* media_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   

    kal_take_mutex(media_player_mutex);
    media_player_add_to_queue(&self->video_queue, media_data);
    self->vid_queue_num ++;
    
    if (MPLY_IS_FLAG_SET(MPLY_FLAG_VID_BUFF_FULL))
    {
        kal_give_mutex(media_player_mutex);
        return MED_S_OK;
    }

    media_player_consume_video_queue(mp);

    kal_give_mutex(media_player_mutex);
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_correct_audio_info
 * DESCRIPTION
 *  The function is to deliver audio to media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_correct_audio_info(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_audio_info_t *audio_info_p = &self->aud_stream.info.audio;
    kal_uint32 buf_len;
    kal_bool need_adts = KAL_FALSE;
    kal_uint8 *buf;
    Media_Status status;
    kal_uint32 channels, sampling_rate;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CORRECT_AUDIO_INFO, self->aud_frame_num);
    /* Don't correct in these cases */
    if (self->audio_queue == NULL || self->aud_frame_num != 0)
    {
        return MED_E_FAIL;
    }

    if ((self->aud_format == MEDIA_FORMAT_AAC || 
         self->aud_format == MEDIA_FORMAT_AAC_PLUS) &&
         !(self->audio_queue->flags & MEDIA_DATA_FLAG_WITH_ADTS_HEADER))
    {
        need_adts = KAL_TRUE;
    }   
    
    if (need_adts)
    {
        ASSERT(self->adts_written_size == 0);        
        media_player_update_adts_header(mp, self->audio_queue->size);        

        buf_len = self->audio_queue->size + MEDIA_PLAYER_ADTS_HEADER_LEN;
        buf = media_player_alloc_ext_mem(self->client, buf_len);
        if (buf == NULL) 
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, buf, __LINE__);
            return MED_E_OUT_OF_MEMORY;
        }
        
        kal_mem_cpy(buf, self->adts_header, MEDIA_PLAYER_ADTS_HEADER_LEN);
        kal_mem_cpy(&buf[MEDIA_PLAYER_ADTS_HEADER_LEN], self->audio_queue->data, self->audio_queue->size);
    }
    else
    {
        buf_len = self->audio_queue->size;
        buf = self->audio_queue->data;
    }            
    
    status = Media_GetSilenceFormat(
                self->aud_format, &channels, &sampling_rate, buf, buf_len);
    if (status == MEDIA_SUCCESS)
    {
        audio_info_p->sample_rate = sampling_rate;
        audio_info_p->channels = channels;
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_SAMPLE_FREQ, 
            audio_info_p->sample_rate, audio_info_p->channels);
    }
    else
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, status, __LINE__);
    }

    if (need_adts)
    {
        media_player_free_ext_mem(self->client, (void**)&buf);
    }

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_deliver_audio
 * DESCRIPTION
 *  The function is to deliver audio to media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_deliver_audio(
                        media_player_t* mp,
                        media_data_t* media_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;
    media_audio_info_t *audio_info_p = &self->aud_stream.info.audio;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (self->aud_stream_status != MPLY_AUD_STREAM_RECEIVED)
    {
        self->aud_stream_status = MPLY_AUD_STREAM_RECEIVED;
    }
    
    media_player_add_to_queue(&self->audio_queue, media_data);
    self->aud_frame_size += media_data->size;
    self->aud_queue_num ++;
    
		if (audio_info_p->sample_rate == 0 || audio_info_p->channels == 0)
    {
        /* Correct sampling rate & fre-num */
        media_player_correct_audio_info(&self->itf);
    }
    
    /* queue audio buffer in player when seeking */
    if (self->state == MPLY_STATE_SEEKING || self->state == MPLY_STATE_SEEK_DONE)
    {
        if (self->aud_queue_num >= self->aud_ready_frame_num || 
            self->aud_frame_size >= (MPLY_AUD_BUFFER_START_TO_PLAY << 1))
        {
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_FRAME_READY, 0);
        }
        return MED_S_OK;
    }
    
    if (MPLY_IS_FLAG_SET(MPLY_FLAG_AUD_BUFF_FULL))
    {
        return MED_S_OK;
    }

    ret = media_player_process_audio_queue(mp);
    if (ret < 0)
    {
        self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
    }  
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_deliver
 * DESCRIPTION
 *  The function is to deliver packet to media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_deliver(
                        media_player_t* mp, 
                        kal_uint32 stream_index, 
                        media_data_t* media_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_GROUP_1, VID_TRC_MEDIA_PLAYER_DELIVER, 
        stream_index, 
        (kal_uint32) media_data->decode_time,
        (kal_uint32) media_data->display_time,
        (kal_uint32) media_data->size,
        (kal_uint32) self->audio_start_time, 
        (kal_uint32) self->max_empty_time, 
        self->aud_queue_num, self->vid_queue_num,
        self->state);
    /* For pure audio streaming. state is at PREPARED state after seek() */
    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED)
    {
        return MED_E_WRONG_STATE;
    }
    
    
    /* Check if drop the packet */
    ret = media_player_validate_packet(mp, stream_index, media_data);
    if (ret == MED_S_FALSE)
    {
        return ret;
    }
    
    /* Video */    
    if (stream_index == self->vid_stream_index)
    {        
        ret = media_player_deliver_video(mp, media_data);
    }
    /* Audio */
    else if (stream_index == self->aud_stream_index)
    {   
        ret = media_player_deliver_audio(mp, media_data);
    }
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_deliver_eof_buffer
 * DESCRIPTION
 *  The function is to deliver eof buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_deliver_vid_eof_buffer(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    VIDEO_BUFFERHEADER_TYPE_T buffer_header = {0};
    VIDEO_ERROR_TYPE_T error;
    media_time_t vid_duration;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_GROUP_1, VID_TRC_MEDIA_PLAYER_DELIVER_VID_EOF_BUFFER, 
        (kal_uint32) self->max_empty_time, self->state);
    
    /* Send EOF buffer to decoder component */       
    buffer_header.eFlags = VIDEO_BUFFERFLAG_EOF;
    vid_duration = self->vid_stream.duration; 
    if (self->max_empty_time == -1)
    {
        buffer_header.u8TimeStamp = MEDIA_PLAYER_TIME_TO_COMPTIME(self->audio_start_time);
    }
    else
    {
        buffer_header.u8TimeStamp = MEDIA_PLAYER_TIME_TO_COMPTIME(vid_duration);
    }
    error = self->decoder_handle->pfnEmptyThisBuffer(&buffer_header);
    if(error == VIDEO_ERROR_NONE)
    {    
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_END_NOTIFIED);
        self->vid_stream_status = MPLY_VID_STREAM_END_NOTIFIED;
    }
    else if (error == VIDEO_ERROR_BUFF_FULL)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_FAIL, error, __LINE__);
        /* Do nothing */
    }

    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_notify_audio_eos
 * DESCRIPTION
 *  The function is to notify end of stream
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_notify_audio_eos(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    media_error_t ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (self->state == MPLY_STATE_BUFFERING)
    {
        if (self->aud_stream_status == MPLY_AUD_STREAM_NONE)
        {
            /* Nothing can't play. Send Media End to session */
            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
            {
                /* Notify media session to call player_stop() */
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
                return MED_S_OK; /* CANNOT REMOVE */
            }
        }
        else if (self->aud_stream_status == MPLY_AUD_STREAM_RECEIVED)
        {
            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->vid_stream_status == MPLY_VID_STREAM_COMPLETE ||
                self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
            {
                /* Must put before play_audio */
                self->aud_stream_status = MPLY_AUD_STREAM_END;
    
                ret = media_player_play_audio(&self->itf);            
                if (ret < 0)
                {
                    self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
                    return MED_S_OK;
                }               
            }
            else
            {
                kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_AUD_BUFFERED);
                self->state = MPLY_STATE_AUD_BUFFERED;
            }
        }        
    }
    else if (self->state == MPLY_STATE_VID_BUFFERED)
    {    
        if (self->aud_stream_status == MPLY_AUD_STREAM_NONE)
        {
            /* Nothing can't play. Send Media End to session */
            if (self->vid_stream_index == MEDIA_PLAYER_INVALID_INDEX ||
                self->vid_stream_status == MPLY_VID_STREAM_PLAY_FINISH)
            {
                /* Notify media session to call player_stop() */
                self->client->on_event(self->client, MEDIA_PLAYER_EVENT_END_OF_MEDIA, 0);
                return MED_S_OK; /* CANNOT REMOVE */
            }
        
            ret = media_player_play_dummy_audio(&self->itf);            
        }
        else
        {
            /* Must put before play_audio */
            self->aud_stream_status = MPLY_AUD_STREAM_END;

            ret = media_player_play_audio(&self->itf);            
        }

        if (ret < 0)
        {
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_PLAY_ERROR, 0);
            return MED_S_OK;
        }        
    }
    else if (self->state == MPLY_STATE_PLAYING ||
             self->state == MPLY_STATE_VID_PLAY_FINISH)
    {
        if (self->audio_queue == NULL && self->mhdl_handle)
        {
            kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CALL_AUD_DATA_FINISH, __LINE__);
            self->mhdl_handle->DataFinished(self->mhdl_handle);
        }
    }
    
    self->aud_stream_status = MPLY_AUD_STREAM_END;
       
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_notify_eof
 * DESCRIPTION
 *  The function is to notify end of stream
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_notify_eos(media_player_t* mp, kal_uint32 stream_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_NOTIFY_EOS, stream_index, self->vid_stream_status, (kal_uint32) self->max_empty_time, self->state);

    if (self->state == MPLY_STATE_CLOSED ||
        self->state == MPLY_STATE_OPENED ||
        self->state == MPLY_STATE_PREPARED)
    {
        return MED_E_WRONG_STATE;
    }    

    if (stream_index == self->vid_stream_index)
    {
        /* Ignore the duplicated notification */
        if (self->vid_stream_status != MPLY_VID_STREAM_NONE)
        {
            return MED_S_OK;
        }
        
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_VID_STREAM_STATUS, self->vid_stream_status, MPLY_VID_STREAM_END_WAIT_NOTIFY);
        self->vid_stream_status = MPLY_VID_STREAM_END_WAIT_NOTIFY;

        if (MPLY_IS_FLAG_SET(MPLY_FLAG_VID_BUFF_FULL))
        {
            return MED_S_OK;
        }

        /* Notify: Video */
        if (self->video_queue == NULL)
        {
            media_player_deliver_vid_eof_buffer(mp);
        }
    }
    else if (stream_index == self->aud_stream_index)
    {    
        /* Ignore the duplicated notification */
        if (self->aud_stream_status == MPLY_AUD_STREAM_END)
        {
            return MED_S_OK;
        }

        /* When player is at SEEKING, we don't know if play audio */
        if (self->state != MPLY_STATE_SEEKING &&
            self->state != MPLY_STATE_SEEK_DONE)
        {
            /* If not play audio, drop the notification */
            if (!self->audio_config.play_audio ||
                !(self->play_speed == 100 || MPLY_IS_FLAG_SET(MPLY_FLAG_SUPPORT_TIME_STRETCH)))
            {
                return MED_S_OK;
            }
        }
        else if (self->state == MPLY_STATE_SEEK_DONE)
        {
            self->client->on_event(self->client, MEDIA_PLAYER_EVENT_AUDIO_FRAME_READY, 0);
        }
        
        media_player_notify_audio_eos(mp);                      
    }    
    
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_close
 * DESCRIPTION
 *  The function is to close a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static media_error_t media_player_close(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_CLOSE, self->state);
    if (self->state == MPLY_STATE_OPENED)
    {
        kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_CLOSED);
        self->state = MPLY_STATE_CLOSED;
    }
    else if (self->state == MPLY_STATE_PREPARED)
    {    
        if (self->vid_stream_index != MEDIA_PLAYER_INVALID_INDEX)
        {
            media_player_release_video_comp(mp);
        }       
    }
    else
    {
        MPLY_ASSERT(0);
    } 

    /* Reset queue */
    media_player_reset_queue(mp, MPLY_QUEUE_VIDEO_WRITTEN);
    media_player_reset_queue(mp, MPLY_QUEUE_VIDEO);    
    media_player_reset_queue(mp, MPLY_QUEUE_AUDIO);

    self->vid_life_cycle_id ++;
    self->vid_queue_num = 0;
    MPLY_UNSET_FLAG(MPLY_FLAG_VID_BUFF_FULL);
    
    self->aud_written_size = 0;
    self->adts_written_size = 0;
    self->silence_written_size = 0;    
    self->aud_queue_num = 0;
    self->aud_frame_size = 0;    
    self->aud_frame_num = 0;
    
    kal_trace(TRACE_FUNC, VID_TRC_MEDIA_PLAYER_STATE, self->state, MPLY_STATE_CLOSED);
    self->state = MPLY_STATE_CLOSED;
    return MED_S_OK;
}


/*****************************************************************************
 * FUNCTION
 *  media_player_destroy
 * DESCRIPTION
 *  The function is to destroy a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void media_player_destroy(media_player_t* mp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_player_cntx_struct* self = SELF(mp, media_player_cntx_struct, itf);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Reset context */
    if (self == media_player_cntx_p)
    {
        media_player_cntx_p = NULL;
    }
    
    MPLY_ASSERT(self->state == MPLY_STATE_CLOSED);

    media_player_free_ext_mem(self->client, (void**)&self);
    
}


/*****************************************************************************
 * FUNCTION
 *  construct_media_player
 * DESCRIPTION
 *  The function is to construct a media player
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
media_player_t* construct_media_player(media_player_client_t* client)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    media_player_cntx_struct* mp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mp = (media_player_cntx_struct *)media_player_alloc_ext_mem(client, sizeof(media_player_cntx_struct)); 
    if (!mp)
    {
        return NULL;
    }
    
    /* Initialize the context structure */
    kal_mem_set(mp, 0, sizeof(media_player_cntx_struct));
        
    /* Assign exported function pointer */
    mp->itf.open = media_player_open;
    mp->itf.add_video_stream = media_player_add_video_stream;
    mp->itf.add_audio_stream = media_player_add_audio_stream;
    mp->itf.prepare = media_player_prepare;    
    mp->itf.set_video_config = media_player_set_video_config;   
    mp->itf.set_audio_config = media_player_set_audio_config;
    mp->itf.get_param = media_player_get_param;  
    mp->itf.set_param = media_player_set_param; 
    mp->itf.get_buffer_status = media_player_get_buffer_status;
    mp->itf.start = media_player_start;
    mp->itf.stop = media_player_stop;
    mp->itf.pause_visual_update = media_player_pause_visual_update;
    mp->itf.resume_visual_update = media_player_resume_visual_update;
    mp->itf.release_visual = media_player_stop_visual_update; 
    mp->itf.jump_to_i_frame = media_player_do_recover;
    mp->itf.deliver = media_player_deliver;
    mp->itf.notify_eos = media_player_notify_eos;
    mp->itf.close = media_player_close;
    mp->itf.destroy = media_player_destroy;

    /* assign client function */
    mp->client = client;

    // may not use
    mp->itf.get_video_config = media_player_get_video_config;
    mp->itf.get_audio_config = media_player_get_audio_config;  

    mp->state = MPLY_STATE_CLOSED;

    return &mp->itf;
}
#endif /* defined(__VIDEO_ARCHI_V2__) */
